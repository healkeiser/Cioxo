
class Agent(PackedPrim):
    """
    hou.Agent
    
    An agent primitive.
    
    See Crowd Agents for more information.
    
    
    """
    
    def setClipTimes(times):
        """
        setClipTimes(times)
        
        Sets the current times for the agent's animation clips.
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable.
        
        
        times
        A float sequence.
        
        
        """
        pass
        
    
    def layers(self):
        """
        layers(self) -> tuple of hou.AgentLayer
        
        Returns all of the layers that are available. This is equivalent to
        definition().layers().
        
        """
        pass
        
    
    def setDefinition(definition):
        """
        setDefinition(definition)
        
        Changes the agent's definition. If the new definition's rig has a
        different number of transforms, the agent's current transforms will
        be reset. The agent's current clips will be reset if the new
        definition does not contain clips with the same names.
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable.
        
        
        definition
        A hou.AgentDefinition.
        
        
        """
        pass
        
    
    def collisionLayer():
        """
        collisionLayer(self) -> hou.AgentLayer
        
        Returns the current collision layer of the agent.
        
        
        """
        pass
        
    
    def setWorldTransform(xform, index):
        """
        setWorldTransform(xform, index)
        
        Sets the current world space transform of an agent primitive's bone.
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable.
        
        
        xform
        A hou.Matrix4.
        
        index
        Index of a transform in the agent's rig.
        
        
        """
        pass
        
    
    def clipWeights():
        """None"""
        pass
        
    
    def rig(self):
        """
        rig(self) -> hou.AgentRig
        
        Returns the agent's rig. This is equivalent to definition().rig().
        
        """
        pass
        
    
    def setClips(clips):
        """
        setClips(clips)
        
        Sets the agent's current animation clips.
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable.
        
        
        clips
        A hou.AgentClip sequence.
        
        
        """
        pass
        
    
    def setCollisionLayer(layer):
        """
        setCollisionLayer(layer)
        
        Sets the agent's current collision layer.
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable.
        
        
        layer
        A hou.AgentLayer.
        
        
        """
        pass
        
    
    def setLocalTransform(xform, index):
        """
        setLocalTransform(xform, index)
        
        Sets the current local space transform of an agent primitive's bone.
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable.
        
        
        xform
        A hou.Matrix4.
        
        index
        Index of a transform in the agent's rig.
        
        
        """
        pass
        
    
    def localTransform(transform):
        """
        localTransform(self, transform) -> hou.Matrix4
        
        Returns the current local space transform of an agent primitive's
        bone.
        
        
        transform
        Index of a transform in the agent's rig.
        
        
        """
        pass
        
    
    def clipCatalog(self):
        """
        clipCatalog(self) -> tuple of hou.AgentClip
        
        Returns all of the animation clips that are available. This is
        equivalent to definition().clips().
        
        """
        pass
        
    
    def clipTimes():
        """
        clipWeights(self) -> tuple of float
        
        Returns the blend weights for the agent's animation clips.
        
        
        """
        pass
        
    
    def shapeLibrary(self):
        """
        shapeLibrary(self) -> hou.AgentShapeLibrary
        
        Returns the agent's shape library. This is equivalent to
        definition().shapeLibrary().
        
        """
        pass
        
    
    def worldTransform(transform):
        """
        worldTransform(self, transform) -> hou.Matrix4
        
        Returns the current world space transform of an agent primitive's
        bone.
        
        
        transform
        Index of a transform in the agent's rig.
        
        
        """
        pass
        
    
    def setCurrentLayer(layer):
        """
        setCurrentLayer(layer)
        
        Sets the agent's current display layer.
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable.
        
        
        layer
        A hou.AgentLayer.
        
        
        """
        pass
        
    
    def clips():
        """
        clips(self) -> tuple of hou.AgentClip
        
        Returns the agent's current animation clips.
        
        
        """
        pass
        
    
    def setClipWeights(weights):
        """
        setClipWeights(weights)
        
        Sets the blend weights for the agent's animation clips.
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable.
        
        
        weights
        A float sequence.
        
        
        """
        pass
        
    
    def definition():
        """
        definition(self) -> hou.AgentDefinition
        
        Returns the shared agent definition.
        
        
        """
        pass
        
    
    def currentLayer():
        """
        currentLayer(self) -> hou.AgentLayer
        
        Returns the current display layer of the agent.
        
        
        """
        pass
        

class AgentClip(object):
    """
    hou.AgentClip
    
    An agent's animation clip.
    
    See Crowd Animation Clips for more information.
    
    
    """
    
    def sampleCount():
        """
        sampleCount(self) -> int
        
        Returns the number of samples in the clip.
        
        
        """
        pass
        
    
    def setLocalTransforms(sample, xforms):
        """
        setLocalTransforms(self, sample, xforms)
        
        Edits the local transforms for a sample in the clip.
        
        Raises hou.GeometryPermissionError if the clip is not modifiable.
        
        
        sample
        Index of a sample in the clip.
        
        xforms
        A sequence of hou.Matrix4, with a local space transform for each
        joint in the rig. Raises hou.InvalidSize if the length does not
        match hou.AgentRig.transformCount.
        
        
        """
        pass
        
    
    def freeze():
        """
        freeze(self) -> hou.AgentClip
        
        Creates a modifiable copy of the clip. The copy will not be marked
        as an external reference.
        
        
        """
        pass
        
    
    def sample(time, channel_name):
        """
        sample(self, time, channel_name) -> float
        
        
        time
        The time (in seconds) to evaluate the clip at.
        
        channel_name
        Name of a channel in the clip. See hou.AgentClip.channelNames.
        
        Evaluates the clip at the given time and returns the value of the
        specified channel. For sampling the clip's transforms, use
        hou.AgentClip.sampleLocal or hou.AgentClip.sampleWorld.
        
        
        """
        pass
        
    
    def sampleWorld(time, transform):
        """
        sampleWorld(self, time, transform) -> hou.Matrix4
        
        
        time
        The time (in seconds) to evaluate the clip at.
        
        transform
        Index of a transform in the agent's rig.
        
        Evaluates the clip at the given time and returns the world
        transform.
        
        
        """
        pass
        
    
    def isExternalReference(self):
        """
        isExternalReference(self) -> bool
        
        Returns a bool indicating whether the clip references a file on
        disk.
        
        """
        pass
        
    
    def sampleLocal(time, transform):
        """
        sampleLocal(self, time, transform) -> hou.Matrix4
        
        
        time
        The time (in seconds) to evaluate the clip at.
        
        transform
        Index of a transform in the agent's rig.
        
        Evaluates the clip at the given time and returns the local
        transform.
        
        
        """
        pass
        
    
    def fileName(expanded, =, False):
        """
        fileName(self, expanded = False) -> str
        
        If the clip is an external reference, returns the path to the file
        on disk.
        
        
        expanded
        Specifies whether to expand any variables in the path, such as
        $HIP.
        
        
        """
        pass
        
    
    def worldTransforms(sample):
        """
        worldTransforms(self, sample) -> tuple of hou.Matrix4
        
        Returns the world space transforms for the specified sample. The
        number of entries matches hou.AgentRig.transformCount.
        
        
        sample
        Index of a sample in the clip.
        
        
        """
        pass
        
    
    def addChannel(name, samples):
        """
        addChannel(self, name, samples)
        
        Creates an additional channel in the clip. If a channel already
        exists with the same name, the previous samples will be overwritten.
        
        Raises hou.GeometryPermissionError if the clip is not modifiable.
        
        
        name
        The name of the channel.
        
        `samples
        A float sequence containing the channel's data. Raises
        hou.InvalidSize if the length does not match
        hou.AgentClip.sampleCount.
        
        
        """
        pass
        
    
    def name():
        """
        name(self) -> str
        
        Returns the name of the clip.
        
        
        """
        pass
        
    
    def data(binary, worldspace, =, False):
        """
        data(self, binary, worldspace = False) -> str
        
        Returns the clip data in ASCII or binary.
        
        
        binary
        Specifies whether the clip data should be saved in ASCII (.clip)
        or binary (.bclip) format.
        
        worldspace
        Specifies whether the transform channels should be saved in
        local or world space.
        
        
        """
        pass
        
    
    def channelNames():
        """
        channelNames(self) -> tuple of str
        
        Returns the names of the additional (non-transform) channels in the
        clip. These channels can be sampled with hou.AgentClip.sample.
        
        
        """
        pass
        
    
    def localTransforms(sample):
        """
        localTransforms(self, sample) -> tuple of hou.Matrix4
        
        Returns the local space transforms for the specified sample. The
        number of entries matches hou.AgentRig.transformCount.
        
        
        sample
        Index of a sample in the clip.
        
        
        """
        pass
        
    
    def length():
        """
        length(self) -> float
        
        Returns the length (in seconds) of the clip.
        
        
        """
        pass
        
    
    def sampleRate():
        """
        sampleRate(self) -> float
        
        Returns the sample rate of the clip.
        
        
        """
        pass
        

def AgentClip_swigregister():
    """None"""
    pass
    

class AgentDefinition(object):
    """
    hou.AgentDefinition
    
    The shared data for an agent primitive.
    
    An agent definition includes a rig, shape library, layers, and clips,
    and can be shared between agent primitives. See Agent Primitives for
    more information.
    
    Since an agent definition is shared between copies of an agent primitive
    (such as agents in an upstream SOP's geometry), the definition returned
    by hou.Agent.definition is read-only. The hou.AgentDefinition.freeze
    method can be used to create a modifiable copy of an agent definition.
    
    RELATED
    
    * hou.crowds.findAgentDefinitions
    
    
    """
    
    def removeClip(name):
        """
        removeClip(self, name)
        
        Removes a clip from the agent definition.
        
        Raises hou.GeometryPermissionError if the agent definition is not
        modifiable.
        
        
        name
        The name of the clip to remove.
        
        
        """
        pass
        
    
    def addClip(clip):
        """
        addClip(self, clip)
        
        Adds a clip to the agent definition.
        
        Raises hou.GeometryPermissionError if the agent definition is not
        modifiable.
        
        Raises hou.OperationFailed if the clip is associated with a
        different rig.
        
        
        clip
        A hou.AgentClip.
        
        
        """
        pass
        
    
    def freeze(new_shapelib, =, None):
        """
        freeze(self, new_shapelib = None) -> hou.AgentDefinition
        
        Creates a modifiable copy of the agent definition. Use
        hou.Agent.setDefinition to change one or more agents to use the new
        agent definition.
        
        
        new_shapelib
        If specified, the copied agent definition and its layers will
        reference the new shape library.
        
        
        """
        pass
        
    
    def findTransformGroup(name):
        """
        findTransformGroup(self, name) -> hou.AgentTransformGroup
        
        Finds the transform group with the specified name, or None if no
        such group exists.
        
        
        """
        pass
        
    
    def removeLayer(name):
        """
        removeLayer(self, name)
        
        Removes a layer from the agent definition.
        
        Raises hou.GeometryPermissionError if the agent definition is not
        modifiable.
        
        
        name
        The name of the layer to remove.
        
        
        """
        pass
        
    
    def rig():
        """
        rig(self) -> hou.AgentRig
        
        Returns the agent definition's rig.
        
        
        """
        pass
        
    
    def layers():
        """
        layers(self) -> tuple of hou.AgentLayer
        
        Returns a list of the layers in the agent definition.
        
        
        """
        pass
        
    
    def transformGroups():
        """
        transformGroups(self) -> tuple of hou.AgentTransformGroup
        
        Returns a list of the transform groups in the agent definition.
        
        
        """
        pass
        
    
    def findLayer(name):
        """
        findLayer(self, name) -> hou.AgentLayer
        
        Finds the layer with the specified name, or None if no such layer
        exists.
        
        
        """
        pass
        
    
    def findClip(name):
        """
        findClip(self, name) -> hou.AgentClip
        
        Finds the clip with the specified name, or None if no such clip
        exists.
        
        
        """
        pass
        
    
    def removeTransformGroup(name):
        """
        removeTransformGroup(self, name)
        
        Removes a transform group from the agent definition.
        
        Raises hou.GeometryPermissionError if the agent definition is not
        modifiable.
        
        
        name
        The name of the transform group to remove.
        
        
        """
        pass
        
    
    def shapeLibrary():
        """
        shapeLibrary(self) -> hou.AgentShapeLibrary
        
        Returns the agent definition's shape library.
        
        
        """
        pass
        
    
    def clips():
        """
        clips(self) -> tuple of hou.AgentClip
        
        Returns a list of the clips in the agent definition.
        
        
        """
        pass
        
    
    def addTransformGroup(group):
        """
        addTransformGroup(self, group)
        
        Adds a transform group to the agent definition.
        
        Raises hou.GeometryPermissionError if the agent definition is not
        modifiable.
        
        Raises hou.OperationFailed if the group is associated with a
        different rig.
        
        
        group
        A hou.AgentTransformGroup.
        
        
        """
        pass
        
    
    def addLayer(layer):
        """
        addLayer(self, layer)
        
        Adds a layer to the agent definition.
        
        Raises hou.GeometryPermissionError if the agent definition is not
        modifiable.
        
        Raises hou.OperationFailed if the layer is associated with a
        different rig or shape library.
        
        
        layer
        A hou.AgentLayer.
        
        
        """
        pass
        

def AgentDefinition_swigregister():
    """None"""
    pass
    

class AgentLayer(object):
    """
    hou.AgentLayer
    
    An agent's layer.
    
    See Agent Layers for more information.
    
    
    """
    
    def asJSON():
        """
        asJSON(self) -> str
        
        Returns a string containing the JSON that represents the layer.
        
        
        """
        pass
        
    
    def fileName(expanded, =, False):
        """
        fileName(self, expanded = False) -> str
        
        If the layer is an external reference, returns the path to the file
        on disk.
        
        
        expanded
        Specifies whether to expand any variables in the path, such as
        $HIP.
        
        
        """
        pass
        
    
    def staticBindings():
        """
        staticBindings(self) -> tuple of hou.AgentShapeBinding
        
        Returns the shape bindings in the layer which reference static
        shapes.
        
        
        """
        pass
        
    
    def isExternalReference(self):
        """
        isExternalReference(self) -> bool
        
        Returns a bool indicating whether the layer references a file on
        disk.
        
        """
        pass
        
    
    def deformingBindings():
        """
        deformingBindings(self) -> tuple of hou.AgentShapeBinding
        
        Returns the shape bindings in the layer which reference deforming
        shapes.
        
        
        """
        pass
        
    
    def bindings(transform, =, None):
        """
        bindings(self, transform = None) -> tuple of hou.AgentShapeBinding
        
        Returns the list of shape bindings in the layer.
        
        
        transform
        Index of a transform in the agent's rig. If specified, only the
        shape bindings attached to the specified transform will be
        returned.
        
        
        """
        pass
        
    
    def name():
        """
        name(self) -> str
        
        Returns the name of the layer.
        
        
        """
        pass
        

def AgentLayer_swigregister():
    """None"""
    pass
    

class AgentRig(object):
    """
    hou.AgentRig
    
    The rig of an agent primitive.
    
    See Crowd Agents for more information.
    
    
    """
    
    def transformName(transform):
        """
        transformName(self, transform) -> str
        
        Returns the name of the specified transform.
        
        
        transform
        Index of a transform in the rig.
        
        
        """
        pass
        
    
    def findTransform(transform_name):
        """
        findTransform(self, transform_name) -> int
        
        Returns the index of the transform with the given name, or -1 if the
        transform name is invalid.
        
        
        transform_name
        Name of a transform in the rig.
        
        
        """
        pass
        
    
    def fileName(expanded, =, False):
        """
        fileName(self, expanded = False) -> str
        
        If the rig is an external reference, returns the path to the file on
        disk.
        
        
        expanded
        Specifies whether to expand any variables in the path, such as
        $HIP.
        
        
        """
        pass
        
    
    def isExternalReference(self):
        """
        isExternalReference(self) -> bool
        
        Returns a bool indicating whether the rig references a file on disk.
        
        """
        pass
        
    
    def parentIndex(transform):
        """
        parentIndex(self, transform) -> int
        
        Returns the parent of the specified transform, or -1 if the
        transform is a root of the transform hierarchy.
        
        
        transform
        Index of a transform in the rig.
        
        
        """
        pass
        
    
    def name():
        """
        name(self) -> str
        
        Returns the name or filename of the rig.
        
        
        """
        pass
        
    
    def asJSON():
        """
        asJSON(self) -> str
        
        Returns a string containing the JSON that represents the rig.
        
        
        """
        pass
        
    
    def transformCount():
        """
        transformCount(self) -> int
        
        Returns the number of transforms in the rig.
        
        
        """
        pass
        
    
    def childIndices(transform):
        """
        childIndices(self, transform) -> tuple of int
        
        Returns the children of the specified transform.
        
        
        transform
        Index of a transform in the rig.
        
        
        """
        pass
        

def AgentRig_swigregister():
    """None"""
    pass
    

class AgentShape(object):
    """
    hou.AgentShape
    
    An agent's shape.
    
    See Crowd Agents for more information.
    
    
    """
    
    def geometry():
        """
        geometry(self) -> hou.Geometry
        
        Returns the shape's geometry.
        
        
        """
        pass
        
    
    def uniqueId():
        """
        uniqueId(self) -> int
        
        Returns the shape's globally unique id.
        
        
        """
        pass
        
    
    def name():
        """
        name(self) -> str
        
        Returns the shape's name, which is unique within a shape library.
        
        
        """
        pass
        

class AgentShapeBinding(object):
    """
    hou.AgentShapeBinding
    
    A shape binding in an agent's layer.
    
    A shape binding attaches a shape from the agent's shape library to a
    transform in the agent's rig. See Agent Layers for more information.
    
    
    """
    
    def transformId():
        """
        transformId(self) -> int
        
        Returns the index of the transform in the agent's rig that the shape
        is attached to.
        
        
        """
        pass
        
    
    def isAttachedToTransform(self):
        """
        isAttachedToTransform(self) -> bool
        
        Returns whether the shape is attached to a transform in the agent's
        rig.
        
        """
        pass
        
    
    def shapeId():
        """
        shapeId(self) -> int
        
        Returns the unique id of the shape. This is equivalent to
        shape().uniqueId().
        
        
        """
        pass
        
    
    def boundsScale():
        """
        boundsScale(self) -> float
        
        Returns the scale factor for the shape's bounding box.
        
        
        """
        pass
        
    
    def isDeforming():
        """
        isDeforming(self) -> bool
        
        Returns whether the shape is static or deforming.
        
        
        """
        pass
        
    
    def shape():
        """
        shape(self) -> hou.AgentShape
        
        Returns the referenced shape.
        
        
        """
        pass
        
    
    def shapeName():
        """
        shapeName(self) -> str
        
        Returns the name of the shape. This is equivalent to shape().name().
        
        
        """
        pass
        
    
    def deformer():
        """
        deformer(self) -> hou.AgentShapeDeformer
        
        Returns the deformer used for the shape, or None if the shape
        binding is static.
        
        
        """
        pass
        

def AgentShapeBinding_swigregister():
    """None"""
    pass
    

class AgentShapeDeformer(object):
    """
    hou.AgentShapeDeformer
    
    A deformer for agent shapes.
    
    Agent shape deformers are used to provide different deformation methods
    for shapes, such as linear skinning or dual quaternion skinning. Each
    shape binding can specify the deformer that should be used. The
    hou.crowds.shapeDeformers method provides a list of the available
    deformers.
    
    
    """
    
    def name():
        """
        name(self) -> str
        
        Returns the unique name for the deformer.
        
        
        """
        pass
        

def AgentShapeDeformer_swigregister():
    """None"""
    pass
    

class AgentShapeLibrary(object):
    """
    hou.AgentShapeLibrary
    
    The shape library of an agent primitive.
    
    See Crowd Agents for more information.
    
    
    """
    
    def freeze(keep_external_ref, =, False):
        """
        freeze(self, keep_external_ref = False) -> hou.AgentShapeLibrary
        
        Creates a modifiable copy of the shape library.
        
        
        keep_external_ref
        If the original shape library referenced a file on disk,
        specifies whether the new shape library should be marked as
        _including_ the original library. In this situation, saving out
        the new shape library will only write out shapes that were not
        included from the original library, along with the path to the
        included shape library. Otherwise, saving out the new shape
        library will produce a standalone library containing all of the
        shapes.
        
        
        """
        pass
        
    
    def isExternalReference(self):
        """
        isExternalReference(self) -> bool
        
        Returns a bool indicating whether the shape library references a
        file on disk.
        
        """
        pass
        
    
    def fileName(expanded, =, False):
        """
        fileName(self, expanded = False) -> str
        
        If the shape library is an external reference, returns the path to
        the file on disk.
        
        
        expanded
        Specifies whether to expand any variables in the path, such as
        $HIP.
        
        
        """
        pass
        
    
    def data():
        """
        data(self) -> hou.Geometry
        
        Returns the geometry representation of the shape library, which can
        be saved to disk.
        
        
        """
        pass
        
    
    def name():
        """
        name(self) -> str
        
        Returns the name or filename of the shape library.
        
        
        """
        pass
        
    
    def addShape(name, geometry):
        """
        addShape(self, name, geometry) -> hou.AgentShape
        
        Adds a new shape to the shape library.
        
        Raises hou.GeometryPermissionError if the shape library is not
        modifiable.
        
        
        name
        The name for the new shape.
        
        geometry
        A hou.Geometry containing the shape's geometry.
        
        
        """
        pass
        
    
    def shapes():
        """
        shapes(self) -> tuple of hou.AgentShape
        
        Returns a list of all shapes in the shape library.
        
        
        """
        pass
        
    
    def findShape(shape_name):
        """
        findShape(self, shape_name) -> hou.AgentShape
        
        Finds the shape with the specified name, or None if no such shape
        exists.
        
        
        """
        pass
        

def AgentShapeLibrary_swigregister():
    """None"""
    pass
    

def AgentShape_swigregister():
    """None"""
    pass
    

class AgentTransformGroup(object):
    """
    hou.AgentTransformGroup
    
    A group of transforms in an agent's rig.
    
    See Crowd Agents for more information.
    
    
    """
    
    def asJSON():
        """
        asJSON(self) -> str
        
        Returns a string containing the JSON representation of the group.
        
        
        """
        pass
        
    
    def transformIndices():
        """
        transformIndices(self) -> tuple of int
        
        Returns a list containing the index of each transform in the group.
        
        
        """
        pass
        
    
    def fileName(expanded, =, False):
        """
        fileName(self, expanded = False) -> str
        
        If the transform group is an external reference, returns the path to
        the file on disk.
        
        
        expanded
        Specifies whether to expand any variables in the path, such as
        $HIP.
        
        
        """
        pass
        
    
    def weights():
        """
        weights(self) -> tuple of float
        
        Returns a list containing the weight of each transform in the group.
        
        
        """
        pass
        
    
    def isExternalReference(self):
        """
        isExternalReference(self) -> bool
        
        Returns a bool indicating whether the transform group references a
        file on disk.
        
        """
        pass
        
    
    def name():
        """
        name(self) -> str
        
        Returns the name of the transform group.
        
        
        """
        pass
        

def AgentTransformGroup_swigregister():
    """None"""
    pass
    

def Agent_swigregister():
    """None"""
    pass
    

class AssetBrowser(PathBasedPaneTab):
    """None"""
    
    def storeSyncSessionKey():
        """None"""
        pass
        
    
    def installRequiredDefinitionsForNodeTypeName():
        """None"""
        pass
        
    
    def reload():
        """None"""
        pass
        
    
    def storeUpdateSessionKey():
        """None"""
        pass
        
    
    def updateAssetDownloadFraction():
        """None"""
        pass
        

def AssetBrowser_swigregister():
    """None"""
    pass
    

class Attrib(object):
    """
    hou.Attrib
    
    This class stores information about a Geometry attribute.
    
    An attribute describes extra data you can attach to different elements
    of geometry. The attribute values are the individual instances of that
    data, and for each attribute there is exactly one attribute value per
    geometry element. For example, if you look at the points in Houdini's
    geometry spreadsheet, the point numbers are listed down the side, the
    point attributes are listed across the top, and the point attribute
    values are contained in the table.
    
    The attribute specifies which elements store the attribute values:
    points, primitives, or vertices. An attribute can also be global (also
    known as a detail attribute), in which case there is one instance of the
    attribute value in the geometry.
    
    The attribute also specifies the data type of the attribute values.
    
    To look up existing attributes, use hou.Geometry.findPointAttrib,
    hou.Geometry.findPrimAttrib, hou.Geometry.findVertexAttrib, and
    hou.Geometry.findGlobalAttrib. To add a new attribute, use
    hou.Geometry.addAttrib.
    
    
    NOTE
    Point positions are stored in a point attribute named P and point
    weights are stored in Pw. See hou.Point.position and
    hou.Point.weight for more information.
    
    
    """
    
    def optionType(name):
        """
        optionType(self, name) -> hou.fieldType enum value
        
        Return a hou.fieldType enumerated value that describes the type of
        data stored in an option. Returns hou.fieldType.NoSuchField if no
        field exists with that name.
        
        
        """
        pass
        
    
    def option():
        """None"""
        pass
        
    
    def removeOption(name):
        """
        removeOption(self, name)
        
        Remove an entry in the dictionary of options. See hou.Attrib.options
        for more information.
        
        Raises hou.OperationFailed if there is no entry in the dictionary
        with this name.
        
        
        """
        pass
        
    
    def dataType():
        """
        dataType(self) -> hou.attribData enum value
        
        Return the attribute's data type (int, float or string).
        
        The size of the attribute also determines the format of the
        attribute values. For example, if the data type is int and the size
        is 3, the attribute value will be a tuple of 3 ints. If the size was
        1, the attribute value would simply be an int.
        
        Note that a string attribute's size must be 1.
        
        
        """
        pass
        
    
    def isTransformedAsNormal():
        """
        isTransformedAsNormal(self) -> bool
        
        Return whether attribute values in the geometry are automatically
        transformed as a normal when Houdini transforms (e.g. rotates) the
        geometry.
        
        For more information, see the hou.Geometry.addAttrib, in the
        transform_as_normal parameter documentation.
        
        
        """
        pass
        
    
    def defaultValue():
        """
        defaultValue(self) -> int or float or str or tuple
        
        Return the attribute's default value. Returns a single
        int/float/string for attributes of size 1 and a tuple of values for
        attributes with more than one component.
        
        This method is useful when duplicating an attribute. See
        hou.Geometry.addAttrib for an example.
        
        
        """
        pass
        
    
    def strings():
        """
        strings(self) -> tuple of str
        
        Return the string table for this attribute. If the attribute is not
        a string, returns an empty tuple.
        
        A string attribute does not store each string value inside the
        attribute element (i.e. point, primitive, etc.). Instead, the unique
        string attribute values are stored in a table inside the attribute,
        and each attribute value stores an index to that string.
        
        For example, suppose this attribute stores strings on points. If all
        points have the attribute value "foo" then the string table will be
        just ("foo",) and each point will store the index 0. When you set
        some points' values to "bar", Houdini adds sets the string table to
        ("foo", "bar") and sets stores the index 1 in those points. When you
        set one of those points back to "foo", Houdini leaves the string
        table unchanged and stores the index 0 in that point.
        
        When using string attribute values, this implementation is hidden
        from you, and you get and set those attributes as strings. This
        method is provided only in case you need access to the string table.
        
        
        """
        pass
        
    
    def size():
        """
        size(self) -> int
        
        Return the number of data components in the attribute value. See
        hou.Attrib.dataType for more information.
        
        
        """
        pass
        
    
    def name():
        """
        name(self) -> str
        
        Return the attribute's name. Each attribute in the geometry has a
        unique name.
        
        
        """
        pass
        
    
    def geometry():
        """
        geometry(self) -> hou.Geometry
        
        Return the Geometry object containing this attribute.
        
        
        """
        pass
        
    
    def setSize():
        """
        setSize(self)
        
        Sets the number of data components in the attribute value. See
        hou.Attrib.dataType for more information.
        
        
        """
        pass
        
    
    def setOption(name, value, type_hint, =, hou.fieldType::NoSuchField):
        """
        setOption(self, name, value, type_hint = hou.fieldType::NoSuchField)
        
        Set an entry in the dictionary of options. See hou.Attrib.options
        for more information.
        
        
        name
        The name of the option to set.
        
        value
        An integer, float, string, hou.Vector2, hou.Vector3,
        hou.Vector4, hou.Quaternion, hou.Matrix3, hou.matrix4, or
        sequence of numbers.
        
        type_hint
        Used to determine the exact hou.fieldType desired when the
        specified value type is not enough to unambiguously determine
        it.
        
        
        """
        pass
        
    
    def indexPairPropertyTables():
        """
        indexPairPropertyTables(self) -> tuple of hou.IndexPairPropertyTable
        
        Return the property tables for this attribute. If the attribute is
        not an index pair, returns an empty tuple.
        
        
        """
        pass
        
    
    def qualifier():
        """
        qualifier(self) -> str
        
        Return the attribute's type qualifier. The qualifier is a
        description of the data contained in the attribute. An empty string
        is returned if the attribute has no numeric representation or if the
        attribute is the pseudo Pw point attribute.
        
        
        """
        pass
        
    
    def options(name):
        """
        option(self, name) -> bool, int, float, str, hou.Vector2, hou.Vector3,
        hou.Vector4, hou.Quaternion, hou.Matrix3, hou.Matrix4, tuple of int, or
        tuple of float
        
        Return the value of an individual option, on None if no such option
        exists.
        
        See also hou.Attrib.options, hou.Attrib.setOption and
        hou.Attrib.removeOption.
        
        
        """
        pass
        
    
    def boostAnyDefaultValue():
        """None"""
        pass
        
    
    def isArrayType():
        """
        isArrayType(self) -> bool
        
        Return True if the attribute is a type that contains array data
        (i.e. Float Array, Integer Array, String Array) and False otherwise.
        
        
        """
        pass
        
    
    def destroy():
        """
        destroy(self)
        
        Remove this attribute from the geometry. You would typically call
        this method from the code of a Python-defined SOP.
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable.
        
        Raises hou.OperationFailed if you try to destroy the P or Pw point
        attributes.
        
        
        """
        pass
        
    
    def isTransformedAsVector():
        """None"""
        pass
        
    
    def type():
        """
        type(self) -> hou.attribType enum value
        
        Return the type of attribute (point, primitive, vertex, or global).
        
        
        """
        pass
        

def Attrib_swigregister():
    """None"""
    pass
    

class BaseKeyframe(object):
    """
    hou.BaseKeyframe
    
    Abstract base class for all keyframe class.
    
    REPLACES
    
    * chkey
    
    * chkeyls
    
    * chkey
    
    * chround
    
    * chsraw()
    
    * lock()
    
    * opscript
    
    
    """
    
    def isExpressionSet():
        """
        isExpressionSet(self) -> bool
        
        Returns whether the keyframe's expression is set.
        
        See setExpression() and expression().
        
        
        """
        pass
        
    
    def frame():
        """
        frame(self) -> double
        
        Returns the keyframe's frame number.
        
        This function raises hou.KeyframeValueNotSet if the frame or time
        has not been set.
        
        See setFrame() and setTime().
        
        
        """
        pass
        
    
    def expressionLanguage():
        """
        expressionLanguage(self) -> hou.exprLanguage enum value
        
        Returns the keyframe's expression's language.
        
        This function raises hou.KeyframeValueNotSet if an expression
        language has not ben set.
        
        See setExpression(), and isExpressionLanguageSet().
        
        
        """
        pass
        
    
    def evaluatedType():
        """
        evaluatedType(self) -> hou.parmData enum value
        
        Returns the type that the keyframe evaluates to.
        
        
        """
        pass
        
    
    def setTime(time):
        """
        setTime(self, time)
        
        Sets the keyframe's time in seconds. Using the number of frames per
        second (hou.fps), setting the time also sets the frame number. For
        example, with an fps of 24, then setting the time to 2 seconds will
        set the frame number to 49.
        
        See time().
        
        
        """
        pass
        
    
    def setExpression(expression, language=None):
        """
        setExpression(self, expression, language=None)
        
        Sets the keyframe's expression and language.
        
        This function raises hou.TypeError if language is not a value from
        hou.exprLanguage.
        
        See expression(), expressionLanguage(), isExpressionSet(),
        isExpressionLanguageSet().
        
        
        """
        pass
        
    
    def setFrame(frame):
        """
        setFrame(self, frame)
        
        Sets the keyframe's frame number. Using the number of frames per
        second (hou.fps), setting the frame number also sets the time. For
        example, with an fps of 24, then setting the frame number to 49 will
        set the time to 2 seconds.
        
        See frame().
        
        
        """
        pass
        
    
    def asCode(brief=False, save_keys_in_frames=False, function_name=None):
        """
        asCode(self, brief=False, save_keys_in_frames=False, function_name=None)
        -> str
        
        Returns a script of Python statements that can be executed to create
        the keyframe. To run the script, use either Python's exec or
        execfile functions.
        
        
        brief
        When <brief> is True, the output script omits commands for
        setting unused values, slopes and accelerations. This parameter
        only applies to non-string keyframes. The value of <brief> must
        be either True or False.
        
        save_keys_in_frames
        When <save_keys_in_frames> is True, asCode outputs commands for
        setting channel and key times in samples (frames) instead of
        seconds. The value of <save_keys_in_frames> must be either True
        or False.
        
        function_name
        If <function_name> is specified, then the output script is
        wrapped in a Python function definition with the given name.
        <function_name> must be a non-zero length string consisting of
        only alphanumeric and underscore characters. Any invalid
        characters are internally converted to underscores.
        
        The function returns a reference to the newly created keyframe
        object.
        
        Here is an example of saving the output to a file and then loading
        it back into Houdini:
        
        > # Get a reference to the target keyframe.
        > tx_parm = hou.parm("/obj/geo1/tx")
        > key = tx_parm.keyframes()[0]
        >
        > # Execute asCode and write the output script to file.
        > script = key.asCode()
        > f = open("create_key.py", "w")
        > f.write(script)
        > f.close()
        >
        > # Execute the script.  The new keyframe will be stored
        > # in the 'hou_keyframe' variable.
        > execfile("create_key.py")
        >
        > # Commit the keyframe back into the node parameter.
        > tx_parm.setKeyframe(hou_keyframe)
        
        Here is an example of saving the output into a function and then
        calling it in Houdini:
        
        > # Get a reference to the target keyframe.
        > tx_parm = hou.Node("/obj/geo1").Parm("tx")
        > key = tx_parm.keyframes()[0]
        >
        > # Execute asCode and write the function definition to file.
        > func = key.asCode(function_name="createKeyframe")
        > f = open("keylib.py", "w")
        > f.write(func)
        > f.close()
        >
        > # Call the function definition.
        > import keylib
        > hou_keyframe = keylib.createKeyframe()
        >
        > # Commit the keyframe back into the node parameter.
        > tx_parm.setKeyframe(hou_keyframe)
        
        """
        pass
        
    
    def isTimeSet():
        """
        isTimeSet(self) -> bool
        
        Returns whether the keyframe's time is set.
        
        See setTime() and time().
        
        
        """
        pass
        
    
    def time():
        """
        time(self) -> double
        
        Returns the keyframe's time in seconds.
        
        This function raises hou.KeyframeValueNotSet if the time or frame
        has not been set.
        
        See setTime() and setFrame().
        
        
        """
        pass
        
    
    def expression():
        """
        expression(self) -> str
        
        Returns the keyframe's expression. For example, in cases where the
        keyframe has had two values set the interpolating function is
        returned e.g. "bezier()", "spline()" etc.
        
        This function raises hou.KeyframeValueNotSet if an expression has
        not been set.
        
        See setExpression() and isExpressionSet().
        
        
        """
        pass
        
    
    def isExpressionLanguageSet():
        """
        isExpressionLanguageSet(self) -> bool
        
        Returns whether the keyframe expression's language is set.
        
        See setExpression() and expressionLanguage().
        
        
        """
        pass
        

def BaseKeyframe_swigregister():
    """None"""
    pass
    

class BoundingBox(object):
    """
    hou.BoundingBox
    
    An axis-aligned 3D rectangular region.
    
    For example, a bounding box might describe a piece of geometry's minimum
    and maximum values on each of the coordinate axes. See
    hou.Geometry.boundingBox for an example of a function that returns a
    bounding box.
    
    
    """
    
    def almostEqual():
        """None"""
        pass
        
    
    def isValid():
        """
        isValid(self) -> bool
        
        Returns whether this bounding box is valid.
        
        
        """
        pass
        
    
    def enlargeToContain(point_or_bbox):
        """
        enlargeToContain(self, point_or_bbox)
        
        Enlarge the bounding box to contain the given element. The element
        may be a sequence of 3 floats (such as a hou.Vector3) describing a
        position or another bounding box. If this box does not need to grow
        because it already completely contains the element, it won't be
        modified.
        
        
        """
        pass
        
    
    def sizevec():
        """
        sizevec(self) -> hou.Vector3
        
        Return a vector describing the size of the box in each of the x, y,
        and z axes.
        
        This method can be implemented as follows:
        
        > def sizevec(self):
        >     return self.maxvec() - self.minvec()
        
        """
        pass
        
    
    def setTo(bounds_sequence):
        """
        setTo(self, bounds_sequence)
        
        Given a sequence of (xmin, ymin, zmin, xmax, ymax, zmax) values, set
        the position of the bounding box.
        
        Raises hou.InvalidSize if the tuple does not contain six elements.
        
        
        """
        pass
        
    
    def isAlmostEqual(bbox, tolerance=0.00001):
        """
        isAlmostEqual(self, bbox, tolerance=0.00001) -> bool
        
        Returns whether this bounding box is equal to another, subject to
        numerical tolerances.
        
        
        """
        pass
        
    
    def minvec():
        """
        minvec(self) -> hou.Vector3
        
        Return a vector describing the corner of the box with the smallest
        x, y, and z values.
        
        
        """
        pass
        
    
    def center():
        """
        center(self) -> hou.Vector3
        
        Return the position of the center of the bounding box.
        
        This method can be implemented as follows:
        
        > def sizevec(self):
        >     return (self.minvec() + self.maxvec()) * 0.5
        
        """
        pass
        
    
    def _asVoidPointer():
        """None"""
        pass
        
    
    def contains(point):
        """
        contains(self, point)
        
        Given a sequence of 3 floats (such as a hou.Vector3) describing a
        position, return whether the position is inside the box.
        
        
        """
        pass
        
    
    def maxvec():
        """
        maxvec(self) -> hou.Vector3
        
        Return a vector describing the corner of the box with the largest x,
        y, and z values.
        
        
        """
        pass
        

def BoundingBox_swigregister():
    """None"""
    pass
    

class BoundingRect(object):
    """
    hou.BoundingRect
    
    An axis-aligned 2D rectangular region.
    
    A bounding rectangle can describe the size and location of a node in a
    network, or the visible area or a network editor pane.
    
    
    """
    
    def intersects(rect):
        """
        intersects(self, rect) -> bool
        
        Given a hou.BoundingRect object, return whether that rectangle
        partially or fully overlaps the one described by this object.
        
        > >>> unitrect = hou.BoundingRect(0, 0, 1, 1)
        > >>> unitrect.intersects(hou.BoundingRect(0.5, 0.5, 1.0, 1.0))
        > True
        > >>> unitrect.intersects(hou.BoundingRect(0.5, 0.5, 1.5, 1.5))
        > True
        > >>> unitrect.intersects(hou.BoundingRect(1.5, 1.5, 2.5, 2.5))
        > False
        
        """
        pass
        
    
    def max():
        """
        max(self) -> hou.Vector2
        
        Return a vector describing the corner of the rectangle with the
        largest x and y values.
        
        
        """
        pass
        
    
    def enlargeToContain(point_or_rect):
        """
        enlargeToContain(self, point_or_rect)
        
        Enlarge the bounding rectangle to contain the given element. The
        element may be a sequence of 2 floats (such as a hou.Vector2)
        describing a position or another bounding rectangle. If this
        rectangle does not need to grow because it already completely
        contains the element, it won't be modified.
        
        > >>> unitrect = hou.BoundingRect(0, 0, 1, 1)
        > >>> unitrect.enlargeToContain((2, 0.5))
        > >>> unitrect
        > <hou.BoundingRect [0, 0, 2, 1]>
        > >>> unitrect = hou.BoundingRect(0, 0, 1, 1)
        > >>> unitrect.enlargeToContain(hou.BoundingRect(0.5, 0.5, 2, 1.5))
        > >>> unitrect
        > <hou.BoundingRect [0, 0, 2, 1.5]>
        
        """
        pass
        
    
    def setTo(bounds_sequence):
        """
        setTo(self, bounds_sequence)
        
        Given a sequence of (xmin, ymin, xmax, ymax) values, set the
        position of the bounding rectangle.
        
        Raises hou.InvalidSize if the tuple does not contain four elements.
        
        
        """
        pass
        
    
    def isAlmostEqual(rect, tolerance=0.00001):
        """
        isAlmostEqual(self, rect, tolerance=0.00001) -> bool
        
        Returns whether this bounding rectangle is equal to another, subject
        to numerical tolerances.
        
        > >>> unitrect = hou.BoundingRect(0, 0, 1, 1)
        > >>> subrect = hou.BoundingRect(0.001, 0.001, 0.999, 1.001)
        > >>> unitrect.isAlmostEqual(subrect)
        > False
        > >>> unitrect.isAlmostEqual(subrect, 0.01)
        > True
        
        """
        pass
        
    
    def size():
        """
        size(self) -> hou.Vector2
        
        Return a vector describing the size of the rectangle in each of the
        x and y axes.
        
        This method can be implemented as follows:
        
        > def size(self):
        >     return self.max() - self.min()
        
        """
        pass
        
    
    def scale(scale):
        """
        scale(self, scale)
        
        Scales this rectangle by the amount specified in the two float tuple
        or hou.Vector2 passed as the scale parameter. Note that scaling the
        rectangle by a negative value will result in an invlalid rectangle
        where the lower left corner is above or to the right of the upper
        right corner.
        
        > >>> rect = hou.BoundingRect(1, 1, 2, 2)
        > >>> rect.scale(hou.Vector2(2, 3))
        > >>> rect
        > <hou.BoundingRect [2, 3, 4, 6]>
        > >>> rect.scale((-1, -1))
        > >>> rect
        > <hou.BoundingRect [-2, -3, -4, -6]>
        > >>> rect.isValid()
        > False
        
        """
        pass
        
    
    def center():
        """
        center(self) -> hou.Vector2
        
        Return the position of the center of the bounding rectangle.
        
        This method can be implemented as follows:
        
        > def center(self):
        >     return (self.min() + self.max()) * 0.5
        
        """
        pass
        
    
    def min():
        """
        min(self) -> hou.Vector2
        
        Return a vector describing the corner of the rectangle with the
        smallest x and y values.
        
        
        """
        pass
        
    
    def getOffsetToAvoid(bounds, direction, =, None):
        """
        getOffsetToAvoid(self, bounds, direction = None) -> hou.Vector2
        
        Return a vector describing the minimum distance this rectangle must
        be translated to avoid any overlap with the bounds rectangle. If
        direction is provided as a hou.Vector2, it indicates the specific
        direction the returned offset should be. If the rectangles do not
        overlap, the result will be hou.Vector2(0.0, 0.0).
        
        > >>> unitrect = hou.BoundingRect(0, 0, 1, 1)
        > >>> subrect = hou.BoundingRect(0.2, 0.4, 0.8, 0.6)
        > >>> unitrect.getOffsetToAvoid(subrect)
        > <hou.Vector2 [0, 0.6]>
        > >>> unitrect.getOffsetToAvoid(subrect, hou.Vector2(1.0, 0.0))
        > <hou.Vector2 [0.8, 0]>
        > >>> unitrect.getOffsetToAvoid(subrect, hou.Vector2(1.0, 1.0))
        > <hou.Vector2 [0.6, 0.6]>
        
        """
        pass
        
    
    def _asVoidPointer():
        """None"""
        pass
        
    
    def contains(rect):
        """
        contains(self, rect) -> bool
        
        Given a hou.BoundingRect object, return whether that rectangle is
        inside the one described by this object.
        
        > >>> unitrect = hou.BoundingRect(0, 0, 1, 1)
        > >>> unitrect.contains(hou.BoundingRect(0.5, 0.5, 1.0, 1.0))
        > True
        > >>> unitrect.contains(hou.BoundingRect(0.5, 0.5, 1.5, 1.5))
        > False
        
        """
        pass
        
    
    def closestPoint(point):
        """
        closestPoint(self, point) -> hou.Vector2
        
        Given a sequence of 2 floats (such as a hou.Vector2) describing a
        position, return the position inside the rectangle that is closest
        to the provided point.
        
        > >>> unitrect = hou.BoundingRect(0, 0, 1, 1)
        > >>> unitrect.closestPoint((0.5, 0.5))
        > <hou.Vector2 [0.5, 0.5]>
        > >>> unitrect.closestPoint((100, 0.5))
        > <hou.Vector2 [1.0, 0.5]>
        > >>> unitrect.closestPoint((-10, -5))
        > <hou.Vector2 [0, 0]>
        
        """
        pass
        
    
    def intersect(rect):
        """
        intersect(self, rect)
        
        Given a hou.BoundingRect object, updates the rectangle in this
        object to be the region where the two rectangles overlap.
        
        > >>> rect = hou.BoundingRect(0, 0, 1, 1)
        > >>> rect.intersect(hou.BoundingRect(0.5, 0.5, 1.5, 1.5))
        > >>> rect
        > <hou.BoundingRect [0.5, 0.5, 1, 1]>
        
        """
        pass
        
    
    def isValid():
        """
        isValid(self) -> bool
        
        Returns whether this bounding rectangle is valid, indicating it has
        been initialized in any way.
        
        > >>> hou.BoundingRect().isValid()
        > False
        > >>> hou.BoundingRect(0, 0, 0, 0).isValid()
        > True
        > >>> hou.BoundingRect(0, 0, 0, 0).isValid()
        > True
        
        """
        pass
        
    
    def expand(offset):
        """
        expand(self, offset)
        
        Moves the edges of the rectangle away from its center by the
        distances specified in the two float tuple or hou.Vector2 passed as
        the offset parameter. The offset is applied to both sides of the
        rectangle so actually changes the width and height of the rectangle
        by twice the passed in values.
        
        Negative values can be passed into the offset to shrink the
        rectangle, but shrinking the rectangle by more than its current size
        will result in an invliad rectangle.
        
        > >>> rect = hou.BoundingRect(1, 1, 2, 2)
        > >>> rect.expand((1, 1))
        > >>> rect
        > <hou.BoundingRect [0, 0, 3, 3]>
        > >>> rect.expand((0, -2))
        > >>> rect
        > <hou.BoundingRect [0, 2, 3, 1]>
        > >>> rect.isValid()
        > False
        
        """
        pass
        
    
    def translate(offset):
        """
        translate(self, offset)
        
        Moves this rectangle by the amount specified in the two float tuple
        or hou.Vector2 passed as the offset parameter.
        
        > >>> rect = hou.BoundingRect(1, 1, 2, 2)
        > >>> rect.translate(hou.Vector2(1, -1))
        > >>> rect
        > <hou.BoundingRect [2, 0, 3, 1]>
        
        """
        pass
        

def BoundingRect_swigregister():
    """None"""
    pass
    

class Bundle(object):
    """
    hou.NodeBundle
    
    A named set of nodes whose contents can be from different networks. A
    bundle's contents may be fixed or may be determined from a pattern, and
    the contents may be filtered by node type.
    
    Unlike node groups, the nodes in a bundle may be from different node
    networks. For example, the same bundle may contain /obj/geo1 and
    /obj/subnet1/geo2. Node groups are primarily used to organize and
    display very large networks, while node bundles are normally used to
    track which objects are lit by a light, which objects are visible in a
    scene, etc.
    
    There are two types of node bundles: regular and smart. You can add and
    remove individual nodes to and from a regular bundle. The nodes in a
    smart bundle, on the other hand, are determined from a pattern stored in
    the bundle. As nodes matching the pattern are created or deleted in
    Houdini, the contents of the bundle will update automatically. You can
    use hou.NodeBundle.pattern to determine if the bundle is a smart bundle
    or a regular one.
    
    When a node matches the pattern in a smart bundle, that node and its
    children will be added to the bundle. For example, if the pattern in
    "/obj/*" and /obj/box_object1 is a geometry object, all the nodes inside
    /obj/box_object1 will be added to the bundle, recursively. Carets (^) in
    the pattern can be used to remove nodes; for example, "/obj/*
    ^/obj/geo1" will match everything in /obj except for /obj/geo1.
    
    A bundle may also have a filter to specify what types of nodes may be in
    the bundle. See hou.nodeTypeFilter for the possible filters. If you try
    to add a node to a regular bundle but the node does not match the
    filter, Houdini will fail to add the node. For smart bundles, the filter
    is applied after doing any pattern matching. For example, if the pattern
    is "/obj/*" and the filter is hou.nodeTypeFilter.Obj, the bundle will
    contain only the objects in /obj, without any SOPs, etc. inside them.
    Because the pattern is applied recursively, however, any objects inside
    object subnets will also be in the bundle.
    
    To specify a bundle in a node parameter that expects a list of nodes,
    prefix the bundle name with @. For example, you can enter @bundle1 in
    the light mask parameter of an object so it is lit by the nodes inside
    the bundle named bundle1.
    
    You can view and edit node bundles in Houdini's Bundle List pane. Use
    hou.nodeBundle_ and hou.nodeBundles to access existing node bundles, and
    hou.addNodeBundle to create a new bundle.
    
    
    """
    
    def setPattern(pattern_or_none):
        """
        setPattern(self, pattern_or_none)
        
        Change the pattern of this bundle.
        
        Setting the pattern to None changes the bundle into a regular
        bundle. In this case, the bundle's contents are unchanged, but
        Houdini will no longer do pattern matching to determine the bundle's
        contents.
        
        If the pattern is a string, the bundle becomes a smart bundle and
        its contents immediately change to match the pattern. The bundle's
        contents will update as nodes are created and deleted in Houdini.
        
        See hou.NodeBundle.pattern and the class documentation for more
        information.
        
        
        """
        pass
        
    
    def addNode(node):
        """
        addNode(self, node)
        
        Add a node to the bundle.
        
        Raises hou.OperationFailed if this bundle is a smart bundle, since
        the contents of smart bundles are automatically determined by their
        pattern.
        
        
        """
        pass
        
    
    def setSelected(on, clear_all_selected=false):
        """
        setSelected(self, on, clear_all_selected=false)
        
        Select this bundle in the bundle list pane. If clear_all_selected is
        True, only this bundle will remain selected. Otherwise, this bundle
        will be added to the existing selection.
        
        
        """
        pass
        
    
    def convertToSmartBundle():
        """
        convertToSmartBundle(self)
        
        Convert the bundle into a smart bundle. A regular expression is
        constructed from the contents of the bundle and then set as the
        bundle pattern.
        
        Do nothing if the bundle is already a smart bundle.
        
        
        """
        pass
        
    
    def setName(name):
        """
        setName(self, name)
        
        Change the name of the bundle.
        
        Raises hou.OperationFailed if the name contains non-alphanumeric
        characters other than _, or if a bundle with that name already
        exists.
        
        
        """
        pass
        
    
    def containsNode(node):
        """
        containsNode(self, node) -> bool
        
        Return True if the node is in the bundle and False otherwise. node
        must be a hou.Node object.
        
        This method is a shortcut for node in bundle.nodes(). For bundles
        with many nodes, this method will be slightly faster.
        
        
        """
        pass
        
    
    def setFilter(node_type_filter):
        """
        setFilter(self, node_type_filter)
        
        Set this bundle's filter to a hou.nodeTypeFilter enumerated value.
        Use hou.nodeTypeFilter.NoFilter to clear the filter.
        
        See hou.NodeBundle.filter and the class documentation for more
        information.
        
        
        """
        pass
        
    
    def name():
        """
        name(self) -> str
        
        Return the name of the bundle.
        
        
        """
        pass
        
    
    def removeNode(node):
        """
        removeNode(self, node)
        
        Remove a node from the bundle.
        
        Raises hou.OperationFailed if this bundle is a smart bundle, since
        the contents of smart bundles are automatically determined by their
        pattern.
        
        
        """
        pass
        
    
    def pattern():
        """
        pattern(self) -> str or None
        
        Return None if this bundle is a regular bundle, or a string pattern
        if the bundle is a smart bundle.
        
        See the class documentation for more information on smart bundles.
        Note that if a node matches the pattern, all its subchildren will be
        in the bundle, as long as they match the filter. For example, if the
        pattern is "/obj/*" and the filter is hou.nodeTypeFilter.NoFilter,
        the bundle will contain all nodes under /obj, recursively.
        
        
        """
        pass
        
    
    def clear():
        """
        clear(self)
        
        Remove all nodes from the bundle.
        
        Raises hou.OperationFailed if this bundle is a smart bundle, since
        the contents of smart bundles are automatically determined by their
        pattern.
        
        
        """
        pass
        
    
    def findBestFilter():
        """
        findBestFilter(self) -> hou.nodeTypeFilter enum value
        
        Return the most restrictive bundle filter that matches all the nodes
        in the bundle.
        
        See hou.nodeTypeFilter for the possible filters.
        hou.nodeTypeFilter.NoFilter is a special value to indicate that
        there is no filtering.
        
        
        """
        pass
        
    
    def filter():
        """
        filter(self) -> hou.nodeTypeFilter enum value
        
        Return the bundle's filter. For smart bundles, the filter is applied
        after matching nodes to the pattern, and nodes whose types do not
        match the filter are removed from the bundle.
        
        See hou.nodeTypeFilter for the possible filters.
        hou.nodeTypeFilter.NoFilter is a special value to indicate that
        there is no filtering.
        
        See the class documentation for more information about filtering.
        
        
        """
        pass
        
    
    def isSelected():
        """
        isSelected(self) -> bool
        
        Return True if the bundle is selected in the bundle list pane and
        False otherwise.
        
        
        """
        pass
        
    
    def convertToNormalBundle():
        """
        convertToNormalBundle(self)
        
        Convert the bundle into a normal bundle. The smart bundle pattern is
        removed.
        
        Do nothing if the bundle is already a normal bundle.
        
        
        """
        pass
        
    
    def destroy():
        """
        destroy(self)
        
        Remove this bundle.
        
        
        """
        pass
        
    
    def nodes():
        """
        nodes(self) -> tuple of hou.Node
        
        Return a tuple of the nodes in this bundle.
        
        
        """
        pass
        

def Bundle_swigregister():
    """None"""
    pass
    

class ButtonParmTemplate(ParmTemplate):
    """
    hou.ButtonParmTemplate
    
    Describes a parameter tuple containing a button.
    
    
    """

def ButtonParmTemplate_swigregister():
    """None"""
    pass
    

class ChannelEditorPane(PaneTab):
    """
    hou.ChannelEditorPane
    
    REPLACES
    
    * chanlist
    
    * chaneditor
    
    
    """
    
    def colorsCallback():
        """
        colorsCallback(self) -> string
        
        Return the active channel colors callback name.
        
        
        """
        pass
        
    
    def channelListSplitFraction():
        """
        channelListSplitFraction(self) -> double
        
        Return the width of the embedded channel list as fraction (0-1
        value) of the pane's width.
        
        
        """
        pass
        
    
    def templateFilter():
        """
        templateFilter(self) -> string
        
        Return the filter pattern for which channels are templated.
        
        
        """
        pass
        
    
    def unregisterColorsCallback(callback_name):
        """
        unregisterColorsCallback(self, callback_name) -> bool
        
        Unregister a callback by name. It also resets the active callback if
        the callback to remove was the active one. Return True if the
        callback was successfully removed. Return False if the callback name
        was invalid.
        
        
        """
        pass
        
    
    def setDisplayFilter(filter):
        """
        setDisplayFilter(self, filter)
        
        Set the filter pattern for which channels are displayed. The channel
        name is used to match against the pattern.
        
        
        """
        pass
        
    
    def colorsCallbacks():
        """
        colorsCallbacks(self) -> tuple of string
        
        Return the list of registered channel colors callback.
        
        
        """
        pass
        
    
    def displayFilter():
        """
        displayFilter(self) -> string
        
        Return the filter pattern for which channels are displayed.
        
        
        """
        pass
        
    
    def setChannelListSplitFraction(value):
        """
        setChannelListSplitFraction(self, value)
        
        Set the width of the embedded channel list as fraction (0-1 value)
        of the pane's width.
        
        
        """
        pass
        
    
    def graph():
        """
        graph(self) -> hou.ChannelGraph
        
        Return the channel graph for this pane.
        
        
        """
        pass
        
    
    def editorMode():
        """
        editorMode(self) -> hou.channelEditorMode enum value
        
        Return the animation editor mode.
        
        
        """
        pass
        
    
    def setEditorMode(mode):
        """
        setEditorMode(self, mode)
        
        Set the animation editor mode.
        
        
        """
        pass
        
    
    def registerColorsCallback(callback_name, callback_object):
        """
        registerColorsCallback(self, callback_name, callback_object ) -> bool
        
        Registers a callback to generate custom channel colors based on the
        node and parameter names.
        
        
        callback_name
        A name for the custom color scheme. You can use this to remove
        the callback with the unregisterColorsCallback method.
        
        callback_object
        A Python object with a getChannelColor method. For example:
        
        >
        > class MyChannelColors(object):
        >     def getChannelColor(self, node_path, channel_name):
        >         return 0, 0, 0
        
        The node argument is the path to the node (for example,
        /obj/table). The parm argument is the internal name of the
        channel (for example, tx). The method must return a 3-tuple
        representing normalized (0-1, not 0-255) red, green, and blue
        values. If the method returns (0, 0, 0) Houdini uses the default
        channel color.
        
        You should register the callback in a session-independent startup
        script. When you register the callback, Houdini will call it once
        with empty string arguments to make sure it returns a triple. Your
        getChannelColor() method needs to handle this case.
        
        The following example object uses the custom color tint of a node to
        color its channels:
        
        >
        > import hou
        >
        > class NodeColors:
        >     '''
        >     Use hue variants of a node's color for parameter names
        >     ending in x, y or z.
        >     '''
        >
        >     def getChannelColor(self, node_path, channel_name):
        >         # Handle the empty string case
        >         if not node_path:
        >             return 0, 0, 0
        >
        >         # Get a Node object from the path
        >         n = hou.node(node_path)
        >         # Get the node's color as a hou.Color object
        >         color = n.color()
        >         # Get the color's HSV values as a triple
        >         hue, sat, val = n.color().hsv()
        >
        >         # If the color is gray, use the default
        >         if not sat:
        >             return 0, 0, 0
        >
        >         # Hue-shift the node color for X, Y, and Z channels:
        >         if channel_name.endswith("x"):
        >             color.setHSV(hue - 50, sat * 2, val * 1.2)
        >         elif channel_name.endswith("y"):
        >             color.setHSV(hue, sat * 2, val * 1.2)
        >         elif channel_name.endswith("z"):
        >             color.setHSV(hue + 50, sat * 2, val * 1.2)
        >
        >         # Return the color as normalized (r, g, b)
        >         return color.rgb()
        
        """
        pass
        
    
    def setTemplateFilter(filter):
        """
        setTemplateFilter(self, filter)
        
        Set the filter pattern for which channels are templated. The channel
        name is used to match against the pattern.
        
        
        """
        pass
        
    
    def setColorsCallback(callback_name):
        """
        setColorsCallback(self, callback_name) -> bool
        
        Set the active channel colors callback name. If the callback name is
        invalid, the active callback will be reset to default. Return True
        if the callback was successfully changed. Return False if the
        callback name was invalid.
        
        
        """
        pass
        

def ChannelEditorPane_swigregister():
    """None"""
    pass
    

class ChannelGraph(object):
    """
    hou.ChannelGraph
    
    REPLACES
    
    * chaneditor
    
    
    """
    
    def selectedKeyframes():
        """
        selectedKeyframes(self) -> dictionary of (, tuple of hou.BaseKeyframe)
        pairs
        
        Returns a dictionary of (hou.Parm, keyframes) which are currently
        selected in the playbar. TIP: Here is an example of how to scale the
        selected key values by 2:
        
        > keyframes = hou.playbar.selectedKeyframes()
        > for parm in keyframes.keys():
        >     for key in keyframes[parm]:
        >         key.setValue(2 * key.value())
        >         parm.setKeyframe(key)
        
        """
        pass
        

def ChannelGraph_swigregister():
    """None"""
    pass
    

class ChopNode(Node):
    """
    hou.ChopNode
    
    Class representing a CHOP node.
    
    REPLACES
    
    * chopls
    
    * opget
    
    * opsave
    
    * opset
    
    * chop()
    
    * chope()
    
    * chopn()
    
    * chopr()
    
    * chops()
    
    * ic()
    
    * ice()
    
    * icl()
    
    * icmax()
    
    * icmin()
    
    * icn()
    
    * icr()
    
    * ics()
    
    * oc()
    
    * opflag()
    
    
    """
    
    def samplesToTime(samples):
        """
        samplesToTime(self, samples) -> double
        
        Converts a value expressed as samples to a value expressed in
        seconds.
        
        
        """
        pass
        
    
    def setCurrentFlag(on):
        """
        setCurrentFlag(self, on)
        
        Turns the node's audio flag on or off.
        
        
        """
        pass
        
    
    def timeToSamples(time):
        """
        timeToSamples(self, time) -> double
        
        Converts a value expressed in seconds to a value expressed in
        samples.
        
        
        """
        pass
        
    
    def track(track_name):
        """
        track(self, track_name) -> hou.Track or None
        
        Return the track of the given name, or None if it doesn't exist.
        
        
        """
        pass
        
    
    def setClipData(data, binary):
        """
        setClipData(self, data, binary)
        
        Sets the clip data for the CHOP node. Should only be called on
        locked nodes.
        
        
        """
        pass
        
    
    def setDisplayFlag(on):
        """
        setDisplayFlag(self, on)
        
        Turns the node's display flag to on or off.
        
        
        """
        pass
        
    
    def setUnloadFlag(on):
        """
        setUnloadFlag(self, on)
        
        Turns the node's unload flag to on or off.
        
        
        """
        pass
        
    
    def tracks():
        """
        tracks(self) -> tuple of Tracks
        
        Returns a tuple of all the tracks in this node.
        
        
        """
        pass
        
    
    def isCurrentFlagSet():
        """
        isCurrentFlagSet(self) -> bool
        
        Returns whether the node's current flag is on.
        
        
        """
        pass
        
    
    def isBypassed():
        """
        isBypassed(self) -> bool
        
        Returns whether the node's bypass flag is on.
        
        
        """
        pass
        
    
    def samplesToFrame(samples):
        """
        samplesToFrame(self, samples) -> double
        
        Converts a value expressed as samples to a value expressed in
        frames.
        
        
        """
        pass
        
    
    def clipData(binary):
        """
        clipData(self, binary) -> str
        
        Returns the clip data for the CHOP node in ASCII or binary,
        depending on the value of the binary parameter.
        
        
        """
        pass
        
    
    def isExportFlagSet():
        """
        isExportFlagSet(self) -> bool
        
        Returns whether the node's export flag is on.
        
        
        """
        pass
        
    
    def isDisplayFlagSet():
        """
        isDisplayFlagSet(self) -> bool
        
        Returns whether the node's display flag is on.
        
        
        """
        pass
        
    
    def sampleRange():
        """
        sampleRange(self) -> (start, end)
        
        Return a 2-tuple containing the start and end values of the sample
        range. The number of samples for each track in this node is start-
        end+1. Note that samples start from 0, not 1.
        
        
        """
        pass
        
    
    def setLocked(on):
        """
        setLocked(self, on)
        
        Turn this node's lock flag on or off. Locking a node saves its
        current cooked channel data into the node. If you unlock a locked
        node, it will discard its locked channel data and recook, computing
        its channel data from its inputs and parameters.
        
        
        """
        pass
        
    
    def frameToSamples(frame):
        """
        frameToSamples(self, frame) -> double
        
        Converts a value expressed as frames to a value expressed in
        samples.
        
        
        """
        pass
        
    
    def isAudioFlagSet():
        """
        isAudioFlagSet(self) -> bool
        
        Returns whether the node's audio flag is on.
        
        
        """
        pass
        
    
    def setAudioFlag(on):
        """
        setAudioFlag(self, on)
        
        Turns the node's audio flag on or off.
        
        
        """
        pass
        
    
    def isLocked():
        """
        isLocked(self) -> bool
        
        Returns whether this node's lock flag is on.
        
        
        """
        pass
        
    
    def bypass(on):
        """
        bypass(self, on)
        
        Turn the node's bypass flag on or off, making this node have no
        effect.
        
        
        """
        pass
        
    
    def saveClip(file_name):
        """
        saveClip(self, file_name)
        
        Saves the node's output clip to a file. The filename extension
        determines the file format to use.
        
        
        """
        pass
        
    
    def sampleRate():
        """
        sampleRate(self) -> double
        
        Returns the sample rate used by this node in number of samples per
        second.
        
        
        """
        pass
        
    
    def isUnloadFlagSet():
        """
        isUnloadFlagSet(self) -> bool
        
        Returns whether the node's unload flag is on.
        
        
        """
        pass
        
    
    def setExportFlag(on):
        """
        setExportFlag(self, on)
        
        Turns the node's export flag to on or off.
        
        
        """
        pass
        

def ChopNode_swigregister():
    """None"""
    pass
    

class Color(object):
    """
    hou.Color
    
    Represents a color value.
    
    You can get and set the internal values using different color
    representations such as RGB and L*a*b*.
    
    Note that the constructor takes a single _tuple_ of RGB values, not
    three arguments. So, for example, to create red you would say:
    
    > red = hou.Color((1.0, 0, 0))
    
    You can set the color in one color space and get the color in a
    different color space to convert between spaces.
    
    See HSL and HSV, Lab color space, CIE 1931 color space, and Color
    temperature for an introduction to the concepts the methods are based
    on.
    
    REPLACES
    
    * rgb()
    
    
    """
    
    def setLAB(tuple):
        """
        setLAB(self, tuple)
        
        Sets the color as a tuple of (L, a, b) as defined in the L*a*b*
        model. See the lab() method.
        
        
        """
        pass
        
    
    def xyz():
        """
        xyz(self) -> (float, float, float)
        
        Returns the color as a tuple of (x, y, z) "tristimulus" values,
        where each component is 0.0 to 1.0 (but may go out of bounds from
        conversion).
        
        
        """
        pass
        
    
    def hsl():
        """
        hsl(self) -> (float, float, float)
        
        Returns the color as a tuple of (hue, saturation, lightness), where
        hue is 0 - 360, and saturation and lightness are 0.0 - 1.0.
        
        
        """
        pass
        
    
    def hsv():
        """
        hsv(self) -> (float, float, float)
        
        Returns the color as a tuple of (hue, saturation, value), where hue
        is 0 - 360, and saturation and value are 0.0 - 1.0.
        
        
        """
        pass
        
    
    def lab():
        """
        lab(self) -> (float, float, float)
        
        Returns the color as a tuple of (L, a, b) as defined in the L*a*b*
        model, where L is 0 - 100, and a and b are unbound. (Note that a and
        b are restricted to -128 - 127 in TIFF files).
        
        
        """
        pass
        
    
    def setRGB(tuple):
        """
        setRGB(self, tuple)
        
        Sets the color using a tuple of (red, green, blue) floating point
        values. See the rgb() method.
        
        
        """
        pass
        
    
    def staticmethod(function):
        """staticmethod(function) -> method
        
        Convert a function to be a static method.
        
        A static method does not receive an implicit first argument.
        To declare a static method, use this idiom:
        
        class C:
        @staticmethod
        def f(arg1, arg2, ...):
        ...
        
        It can be called either on the class (e.g. C.f()) or on an instance
        (e.g. C().f()).  The instance is ignored except for its class.
        
        Static methods in Python are similar to those found in Java or C++.
        For a more advanced concept, see the classmethod builtin."""
        pass
        
    
    def setTMI(tuple):
        """
        setTMI(self, tuple)
        
        Sets the color as a tuple of (temperature, magenta, intensity). See
        the tmi() method.
        
        
        """
        pass
        
    
    def _asVoidPointer():
        """None"""
        pass
        
    
    def setHSL(tuple):
        """
        setHSL(self, tuple)
        
        Sets the color as a tuple of (hue, saturation, lightness). See the
        hsl() method.
        
        
        """
        pass
        
    
    def setXYZ(tuple):
        """
        setXYZ(self, tuple)
        
        Sets the color as a tuple of (x, y, z) "tristimulus" values. See the
        xyz() method.
        
        
        """
        pass
        
    
    def setHSV(tuple):
        """
        setHSV(self, tuple)
        
        Sets the color as a tuple of (hue, saturation, value). See the hsv()
        method.
        
        
        """
        pass
        
    
    def rgb():
        """
        rgb(self) -> (float, float, float)
        
        Returns the color as a tuple of (red, green, blue) floating point
        values, where each value is in the range 0.0 to 1.0.
        
        
        """
        pass
        
    
    def tmi():
        """
        tmi(self) -> (float, float, float)
        
        Returns the color as a tuple of (temperature, magenta, intensity),
        where each component is -1.0 to 1.0.
        
        
        """
        pass
        

def Color_ocio_spaces():
    """
    ocio_spaces()
    
    Returns a list of the color spaces defined in the Open Color IO
    configuration in Houdini.
    
    
    """
    pass
    

def Color_swigregister():
    """None"""
    pass
    

class CompositorViewer(PathBasedPaneTab):
    """
    hou.CompositorViewer
    
    Minimal class representing a compositing view pane.
    
    This class is currently very simple, implementing a minimal number of
    methods necessary to support compositing shelf tools. It does not
    currently allow programmatic control of most functions available in the
    UI.
    
    You should probably avoid using this object. If you are writing custom
    tools for the compositing view, the higher-level functions in the
    cop2toolutils module are more useful.
    
    
    """
    
    def enterViewState(wait_for_exit=False):
        """
        enterViewState(self, wait_for_exit=False)
        
        Switch to the view tool.
        
        
        """
        pass
        
    
    def setCurrentState(state, wait_for_exit=False):
        """
        setCurrentState(self, state, wait_for_exit=False)
        
        Sets the currently active tool in the view. state is a string
        containing an internal, undocumented designation. See
        currentState().
        
        
        """
        pass
        
    
    def currentState():
        """
        currentState(self) -> str
        
        Returns the name of the tool currently in use in the view. This is
        an internal, undocumented designation but usually corresponds to the
        name of a node. You can change to a different tool using
        setCurrentState.
        
        
        """
        pass
        

def CompositorViewer_swigregister():
    """None"""
    pass
    

class ConstructionPlane(object):
    """
    hou.ConstructionPlane
    
    The grid (a.k.a. construction plane) in the scene viewer pane tab.
    
    REPLACES
    
    * cplane
    
    
    """
    
    def setTransform(matrix):
        """
        setTransform(self, matrix)
        
        Set the transformation matrix for this plane to a hou.Matrix4.
        
        This matrix is used to translate and rotate the plane. See the
        transform method for more information.
        
        Note that scale information inside the transformation matrix is
        ignored. Use the setCellSize and setNumberOfCells methods to adjust
        the size of the plane.
        
        The following function will change the position of the center of the
        plane:
        
        > def set_origin(construction_plane, new_origin):
        >     translation = hou.hmath.buildTranslate(hou.Vector3(new_origin) - origin(construction_plane))
        >     construction_plane.setTransform(construction_plane.transform() * translation)
        >
        > def origin(construction_plane):
        >     return hou.Vector3(0, 0, 0) * construction_plane.transform()
        
        The following function will change the normal of the plane:
        
        > def set_normal(construction_plane, normal_vector):
        >     existing_rotation = hou.Matrix4(construction_plane.transform().extractRotationMatrix3())
        >     rotation = existing_rotation * normal(construction_plane).matrixToRotateTo(normal_vector)
        >     translation = hou.hmath.buildTranslate(origin(construction_plane))
        >     construction_plane.setTransform(rotation * translation)
        >
        > def normal(construction_plane):
        >     return hou.Vector3(0, 0, 1) * construction_plane.transform().inverted().transposed()
        >
        > def origin(construction_plane):
        >     return hou.Vector3(0, 0, 0) * construction_plane.transform()
        
        """
        pass
        
    
    def setNumberOfCells():
        """None"""
        pass
        
    
    def sceneViewer():
        """
        sceneViewer(self) -> hou.SceneViewer
        
        Return the scene viewer containing this plane.
        
        
        """
        pass
        
    
    def setNumberOfCellsPerRulerLine():
        """None"""
        pass
        
    
    def cellSize():
        """
        cellSize(self) -> tuple of float
        
        Return the x and y sizes (width and height) of one cell in the grid
        of cells. The return value is a tuple of two floats.
        
        
        """
        pass
        
    
    def setIsVisible(on):
        """
        setIsVisible(self, on)
        
        Make this grid visible or invisible in the viewer.
        
        
        """
        pass
        
    
    def numberOfCellsPerRulerLine():
        """
        numberOfCellsPerRulerLine(self) -> tuple of int
        
        Return the number of cells in the x and y directions between ruler
        lines. Ruler lines are darker than the normal lines drawn between
        grid cells.
        
        
        """
        pass
        
    
    def setCellSize(size):
        """
        setCellSize(self, size)
        
        Change the x and y sizes (width and height) of each cell in the grid
        of cells. size is a sequence of two floats.
        
        Changing the size of each cell will change the total size of the
        grid.
        
        
        """
        pass
        
    
    def transform():
        """
        transform(self) -> hou.Matrix4
        
        Return the transformation matrix for this plane.
        
        When the transformation matrix is the identity matrix, the plane's
        bottom-left corner is at the origin and it sits in the XY plane. In
        this orientation, increasing the number of cells in x or the size of
        a cell in x grows the plane outward from the origin along the
        x-axis. Similarly, increasing the number of cells or size of a cell
        in y grows the plane along the y-axis.
        
        Note that the transformation matrix does not contain any scale
        information. Use the cellSize and numberOfCells methods to get the
        size of the plane.
        
        The following function will return the position of the center of the
        plane:
        
        > def origin(construction_plane):
        >     return hou.Vector3(0, 0, 0) * construction_plane.transform()
        
        The following function will return the normal of the plane:
        
        > def normal(construction_plane):
        >     return hou.Vector3(0, 0, 1) * construction_plane.transform().inverted().transposed()
        
        """
        pass
        
    
    def numberOfCells():
        """
        numberOfCells(self) -> tuple of int
        
        Return the number of cells in the x and y directions of the grid. In
        other words, return the number of columns and rows.
        
        
        """
        pass
        
    
    def isVisible():
        """
        isVisible(self) -> bool
        
        Return whether the grid is visible in the viewer.
        
        
        """
        pass
        

def ConstructionPlane_swigregister():
    """None"""
    pass
    

class ContextViewer(PathBasedPaneTab):
    """
    hou.ContextViewer
    
    A class representing a context viewer pane tab.
    
    
    """
    
    def compositorViewer():
        """
        compositorViewer(self) -> hou.CompositorViewer
        
        Returns a CompositorViewer if the ContextViewer is displaying a
        compositor viewer. If not, returns None.
        
        
        """
        pass
        
    
    def sceneViewer():
        """
        sceneViewer(self) -> hou.SceneViewer
        
        Returns a SceneViewer if the ContextViewer is displaying a scene
        viewer. If not, returns None.
        
        
        """
        pass
        

def ContextViewer_swigregister():
    """None"""
    pass
    

class CopNode(Node):
    """
    hou.CopNode
    
    Represents a compositing node.
    
    REPLACES
    
    * pic()
    
    * picni()
    
    * opflag()
    
    * opget
    
    * opsave
    
    * res()
    
    * seqanim()
    
    * seqend()
    
    * seqlength()
    
    * seqstart()
    
    * copmeta()
    
    * copmetas()
    
    
    """
    
    def setCompressFlag(on):
        """
        setCompressFlag(self, on)
        
        Turns the node's compress flag on or off. If the compress flag is
        True, this node will not show a preview image in the Network View.
        If the compress flag is False, a preview image will be shown in the
        Network View. The value of the on argument must be True or False.
        
        Raises hou.PermissionError if the node is unwritable.
        
        
        """
        pass
        
    
    def imageBounds(plane="C"):
        """
        imageBounds(self, plane="C") -> tuple of int
        
        Returns the x and y boundaries of the given plane in the form of
        (xmin, ymin, xmax, ymax). The value of the plane argument is the
        plane name. By default, the image bounds of the color plane is
        returned.
        
        Note that the image bounds is not the same as the image resolution.
        For example, the image bounds for a Font COP is the bounding
        rectangle around the displayed letters while the resolution is the
        size of the node's image.
        
        Note that the returned image bounds is for the current frame.
        
        Raises ValueError if plane is None or empty. Raises
        hou.OperationFailed if the node could not be cooked or opened for
        processing. Raises hou.OperationFailed if the given plane does not
        exist.
        
        
        """
        pass
        
    
    def yRes():
        """
        yRes(self)
        
        Returns the y-resolution of the node's image for the current frame.
        
        Raises hou.OperationFailed if the node could not be cooked or opened
        for processing.
        
        
        """
        pass
        
    
    def isRenderFlagSet():
        """
        isRenderFlagSet(self) -> bool
        
        Returns True if the node's render flag is turned on. Returns False
        otherwise.
        
        
        """
        pass
        
    
    def isDisplayFlagSet():
        """
        isDisplayFlagSet(self) -> bool
        
        Returns True if the node's display flag is turned on. Returns False
        otherwise.
        
        
        """
        pass
        
    
    def getMetaDataFloat(metadata_name, index=0):
        """
        getMetaDataFloat(self, metadata_name, index=0) -> double
        
        Returns numeric metadata as a single double precision value. In the
        case of vectors, matrices and arrays, index indicates the component
        to fetch.
        
        
        """
        pass
        
    
    def setPixelsOfCookingPlaneFromString(values, component=None, interleaved=True, depth=None, flip_vertically=False):
        """
        setPixelsOfCookingPlaneFromString(self, values, component=None,
        interleaved=True, depth=None, flip_vertically=False)
        
        Set the pixels of the plane being cooked by the currently-running
        Python COP. This method is like hou.CopNode.setPixelsOfCookingPlane
        except values contains a binary string representation of the data
        instead of a sequence of floats. Consequently, this method is
        faster.
        
        The depth parameter specifies how to interpret the values in the
        binary string, and is a hou.imageDepth enumerated value. If depth is
        None, the depth is assumed to be in the depth of the plane being
        cooked. Note that, by specifying depth explicitly, you can provide
        data in any depth, regardless of the actual depth stored by the COP.
        
        Note that this method can accept more types that just a string: it
        can receive any Python object that supports the buffer interface. In
        particular, arrays from the array and numpy Python modules are
        supported, so there is no need to first construct strings from those
        arrays.
        
        See hou.CopNode.setPixelsOfCookingPlane and
        hou.CopNode.allPixelsAsString for more information.
        
        
        """
        pass
        
    
    def sequenceFrameLength():
        """
        sequenceFrameLength(self) -> float
        
        Returns the frame length of the node's image sequence.
        
        Raises hou.OperationFailed if the node could not be cooked or opened
        for processing.
        
        
        """
        pass
        
    
    def getPixelByUV(plane, u, v, component=None, interpolate=True):
        """
        getPixelByUV(self, plane, u, v, component=None, interpolate=True) ->
        tuple of float
        
        Returns plane values for a single pixel in the node's image. The
        plane is defined by the plane argument which must be set to the
        plane's name. The pixel is defined by (u, v) coordinates where u and
        v are values between 0.0 and 1.0. If the optional component argument
        is specified, then the value for that particular component is
        returned. Otherwise, all of the plane's component values are
        returned. The value of component should be the component's name
        (i.e. "r", "g", "b", etc.).
        
        If the (u, v) coordinates do not fall exactly on a pixel, then the
        return values are calculated by linear blending of the values for
        the surrounding pixels. This can be disabled by setting the
        interpolate argument to False, in which case the values of the pixel
        located immediately to the bottom-left of (u, v) are returned.
        
        Note that the returned values are for the node's image at the
        current frame.
        
        Raises ValueError if either u or v is outside of the 0.0-1.0 range.
        Raises ValueError if plane is None or empty. Raises
        hou.OperationFailed if the node could not be cooked or opened for
        processing. Raises hou.OperationFailed if the given plane does not
        exist. Raises hou.OperationFailed if the given component does not
        exist in the plane.
        
        
        """
        pass
        
    
    def isCompressFlagSet():
        """
        isCompressFlagSet(self) -> bool
        
        Returns True if the node's compress flag is turned on. Returns False
        otherwise. The compress flag controls whether or not a preview image
        is shown for this node in the Network View.
        
        
        """
        pass
        
    
    def hasMetaData(metadata_name):
        """
        hasMetaData(self, metadata_name) -> bool
        
        Returns True if the metadata with name metadata_name exists, False
        otherwise.
        
        
        """
        pass
        
    
    def bypass(on):
        """
        bypass(self, on)
        
        Turns the node's bypass flag on or off. When the bypass flag is on,
        the node will have no effect on the scene. The value of the on
        argument must be True or False.
        
        Raises hou.PermissionError if the node is unwritable.
        
        
        """
        pass
        
    
    def isTemplateFlagSet():
        """
        isTemplateFlagSet(self) -> bool
        
        Returns True if the node's template flag is turned on. Returns False
        otherwise.
        
        
        """
        pass
        
    
    def saveImage(file_name, frame_range=():
        """
        saveImage(self, file_name, frame_range=())
        
        Saves the node's cooked image sequence to disk. For multiple images,
        make sure that the file_name argument contains $F so that the
        sequence is written to multiple files.
        
        The optional frame_range argument can be specified to write only a
        subset of frames in the image sequence. frame_range must be a
        2-tuple or a 3-tuple, where the first element is the start frame,
        the second element is the end frame and the third element is the
        frame increment. If frame_range is not given, then every frame in
        the image sequence is saved to disk.
        
        Raises ValueError if the frame increment in frame_range is 0. Raises
        hou.InvalidSize if the size of frame_range is not 0, 2 or 3. Raises
        hou.OperationFailed if the node could not be cooked or opened for
        processing. Raises hou.OperationFailed if the image could not be
        saved to disk.
        
        
        """
        pass
        
    
    def sequenceStartFrame():
        """
        sequenceStartFrame(self) -> float
        
        Returns the start frame in the node's image sequence.
        
        Raises hou.OperationFailed if the node could not be cooked or opened
        for processing.
        
        
        """
        pass
        
    
    def components(plane):
        """
        components(self, plane) -> tuple of str
        
        Returns a tuple of component names for the specified plane in the
        node's image sequence. The value of the plane argument must be a
        plane name.
        
        Raises ValueError if plane is None or empty. Raises
        hou.OperationFailed if the node could not be cooked or opened for
        processing. Raises hou.OperationFailed if the given plane does not
        exist.
        
        
        """
        pass
        
    
    def isSingleImage():
        """
        isSingleImage(self) -> bool
        
        Returns True if the node has a single image. Returns False if the
        node has an image sequence.
        
        
        """
        pass
        
    
    def allPixelsAsString(plane="C", component=None, interleaved=True, time=-1.0, depth=None):
        """
        allPixelsAsString(self, plane="C", component=None, interleaved=True,
        time=-1.0, depth=None) -> str
        
        Return a binary string representation of the floats containing all
        the values of all voxels. This method is faster than
        hou.CopNode.allPixels, and you can use the array module to convert
        the string into a Python sequence. Note that this method returns
        binary float data, so there are 4 bytes per R, G, and B component,
        not 1 byte.
        
        If depth is hou.imageDepth.Float32, this method provides a faster
        implementation of the following:
        
        > import array
        > def allPixelsAsString(self):
        >     return array.array("f", self.allPixels()).tostring()
        
        If depth is None and this method is called from the code
        implementing a Python COP to get an input plane, the depth will be
        the same as the plane's native depth. If depth is None and this
        method is called from outside a Python COP, the depth will be
        hou.imageDepth.Float32. Otherwise, if depth is a hou.imageDepth
        enumerated value the result will be converted to the specified
        depth.
        
        See hou.CopNode.allPixels for more information. See also
        hou.Volume.setVoxelSliceFromString.
        
        Raises hou.OperationFailed if the time argument is set to a value
        greater than or equal to 0.0 and allPixelsAsString is called from a
        cooking Python COP.
        
        
        """
        pass
        
    
    def getMetaDataInt(metadata_name, index=0):
        """
        getMetaDataInt(self, metadata_name, index=0) -> int
        
        Returns numeric metadata as a single integer. In the case of
        vectors, matrices and arrays, index indicates the component to
        fetch. Floating point metadata will be truncated.
        
        
        """
        pass
        
    
    def xRes():
        """
        xRes(self)
        
        Returns the x-resolution of the node's image for the current frame.
        
        Raises hou.OperationFailed if the node could not be cooked or opened
        for processing.
        
        
        """
        pass
        
    
    def isBypassed():
        """
        isBypassed(self) -> bool
        
        Returns True if the node's bypass flag is turned on. Returns False
        otherwise.
        
        
        """
        pass
        
    
    def setRenderFlag(on):
        """
        setRenderFlag(self, on)
        
        Turns the node's render flag on or off. The render flag controls
        which node in a compositing network will be rendered to or to disk.
        The value of the on argument must be True or False.
        
        Raises hou.PermissionError if the node is unwritable.
        
        
        """
        pass
        
    
    def getMetaDataString(metadata_name):
        """
        getMetaDataString(self, metadata_name) -> str
        
        Returns string metadata from metadata_name.
        
        
        """
        pass
        
    
    def setDisplayFlag(on):
        """
        setDisplayFlag(self, on)
        
        Turns the node's display flag on or off. When the display flag is
        on, the node's image will appear in the image viewport. The value of
        the on argument must be True or False.
        
        Raises hou.PermissionError if the node is unwritable.
        
        
        """
        pass
        
    
    def setPixelsOfCookingPlane(values, component=None, interleaved=True, flip_vertically=False):
        """
        setPixelsOfCookingPlane(self, values, component=None, interleaved=True,
        flip_vertically=False)
        
        Set the pixels of the plane being cooked by the currently-running
        Python COP.
        
        
        values
        A sequence of floats, organized with the contents of the bottom
        scanline first.
        
        If component is None, the length of the sequence of floats must
        be the number of pixels in the image times the number of
        components. Otherwise, it must be the number of pixels in the
        image.
        
        component
        Either the name of one component in the plane being cooked, or
        None. If a component name is given, values will contain only the
        values for that component. Otherwise, it will contain the values
        for all components of all pixels in the plane.
        
        interleaved
        If component is None and interleaved is True, values is contains
        the first component of the first pixel, followed by the second
        component of the first pixel, until the last component of the
        first pixel, then the first component of the second pixel, etc.
        If it is False, values contains all the values of the first
        component for all pixels, followed by all the values of the
        second component, etc.
        
        For example, if the plane is "C" and interleaved is True, the
        values will be organized as rgbrgbrgb.... If it is not
        interleaved, it will be organized as rrr...ggg...bbb....
        
        If component is not None, this parameter is ignored.
        
        flip_vertically
        The default value for this parameter is False, so the first
        scanline in the values array is assumed to be the bottom
        scanline. If flip_vertically is True, the input values are
        assumed to oriented starting at the top scanline.
        
        If you call this method from outside the cook function in a Python
        COP, raises hou.OperationFailed.
        
        See also hou.CopNode.allPixels and
        hou.CopNode.setPixelsOfCookingPlaneFromString. Also see the HOM
        cookbook and the Python COP documentation for examples.
        
        
        """
        pass
        
    
    def getPixelHSVByUV(u, v, interpolate=True):
        """
        getPixelHSVByUV(self, u, v, interpolate=True) -> tuple of float
        
        Returns a 3-tuple containing the hue, saturation and value for a
        single pixel in the node's image. The pixel is defined by (u, v)
        coordinates where u and v are values between 0.0 and 1.0.
        
        If the (u, v) coordinates do not fall exactly on a pixel, then the
        return values are calculated by linear blending of the values for
        the surrounding pixels. This can be disabled by setting the
        interpolate argument to False, in which case the values of the pixel
        located immediately to the bottom-left of (u, v) are returned.
        
        Note that the returned hue, saturation and value are for the node's
        image at the current frame.
        
        Raises ValueError if either u or v is outside of the 0.0-1.0 range.
        Raises hou.OperationFailed if the node could not be cooked or opened
        for processing.
        
        
        """
        pass
        
    
    def getPixelLuminanceByUV(u, v, interpolate=True):
        """
        getPixelLuminanceByUV(self, u, v, interpolate=True) -> float
        
        Returns the luminance value for a single pixel in the node's image.
        The pixel is defined by (u, v) coordinates where u and v are values
        between 0.0 and 1.0.
        
        If the (u, v) coordinates do not fall exactly on a pixel, then the
        luminance is calculated by linear blending of the luminance values
        for the surrounding pixels. This can be disabled by setting the
        interpolate argument to False, in which case the luminance of the
        pixel located immediately to the bottom-left of (u, v) is returned.
        
        Note that the returned luminance value is for the node's image at
        the current frame.
        
        Raises ValueError if either u or v is outside of the 0.0-1.0 range.
        Raises hou.OperationFailed if the node could not be cooked or opened
        for processing.
        
        
        """
        pass
        
    
    def allPixels(plane="C", component=None, interleaved=True, time=-1.0):
        """
        allPixels(self, plane="C", component=None, interleaved=True, time=-1.0)
        -> tuple of float
        
        Return a tuple of floats containing all pixel values for a
        particular image plane. The pixels in the bottom scanline of the
        image are first in the result, followed by the second-last scanline,
        etc. Floating point values in the color plane ("C"), for example,
        are typically in the range 0.0 to 1.0.
        
        
        plane
        The name of the image plane to return. All images have "C"
        (color) and "A" (alpha) planes. Deep raster images may contain
        other planes, such as "Pz" (depth), "N" (normal), etc.
        
        component
        A particular subcomponent of the plane. For example, for the "C"
        plane you could specify one of the "r", "g", or "b"
        subcomponents. Specify None to indicate all components.
        
        interleaved
        Whether the different components of the plane are interleaved in
        the result. For example, if the plane is "C", the interleaved
        result would be organized as rgbrgbrgb... while the
        uninterleaved result would be rrr...ggg...bbb.... This parameter
        has no effect when a particular component is specified.
        
        time
        The time at which to cook the COP node. If this value is
        negative, Houdini uses the current time.
        
        Note that this argument does not apply if allPixels is called
        from a Python COP that is cooking. In that case allPixels
        evaluates at the current cooking time.
        
        This method does not accept a depth parameter like allPixelsAsString
        does. The values are converted to floating point data, regardless of
        the actual depth of the image plane.
        
        Raises hou.OperationFailed if the time argument is set to a value
        greater than or equal to 0.0 and allPixels is called from a cooking
        Python COP.
        
        
        """
        pass
        
    
    def sequenceEndFrame():
        """
        sequenceEndFrame(self) -> float
        
        Returns the last frame in the node's image sequence.
        
        Raises hou.OperationFailed if the node could not be cooked or opened
        for processing.
        
        
        """
        pass
        
    
    def depth(plane):
        """
        depth(self, plane) -> hou.imageDepth enum value
        
        Return the data format used to represent one component of one pixel
        in the given image plane.
        
        For example, if the depth of the "C" (color) plane is
        hou.imageDepth.Int8, each of the red, green, and blue components is
        stored as an (unsigned) 8-bit integer, occupying one byte. If, for
        example, it is instead hou.imageDepth.Float32, each of the red,
        green, and blue components is a 32-bit float and occupies 4 bytes
        (12 bytes total for all 3 components combined).
        
        
        """
        pass
        
    
    def setTemplateFlag(on):
        """
        setTemplateFlag(self, on)
        
        Turns the node's template flag on or off. The value of the on
        argument must be True or False.
        
        Raises hou.PermissionError if the node is unwritable.
        
        
        """
        pass
        
    
    def maskInputIndex():
        """
        maskInputIndex(self) -> int
        
        Return the input index of the mask input for this node. Return -1 if
        this node type does not provide a mask input.
        
        
        """
        pass
        
    
    def planes():
        """
        planes(self) -> tuple of strings
        
        Returns a tuple of plane names in the node's image sequence.
        
        Raises hou.OperationFailed if the node could not be cooked or opened
        for processing.
        
        
        """
        pass
        
    
    def getMetaDataIntArray(metadata_name):
        """
        getMetaDataIntArray(self, metadata_name) -> tuple of int
        
        Returns numeric metadata as an array of integers. Floating point
        metadata values will be truncated.
        
        
        """
        pass
        
    
    def getMetaDataFloatArray(metadata_name):
        """
        getMetaDataFloatArray(self, metadata_name) -> tuple of double
        
        Returns numeric metadata as an array of double-precision values.
        
        
        """
        pass
        

def CopNode_swigregister():
    """None"""
    pass
    

class DataParmTemplate(ParmTemplate):
    """
    hou.DataParmTemplate
    
    Describes a parameter tuple containing data values.
    
    
    """
    
    def defaultExpression():
        """
        defaultExpression(self) -> tuple of strings
        
        Return the default expression for new parameter instances.
        
        The default expression takes precedence over the default value. If a
        component has no default expression (i.e. an empty string), then the
        default value is used for new parameter instances.
        
        Note that the default expression language is needed to interpret the
        meaning of the default expression.
        
        For example, suppose this parm template is named "t", the naming
        scheme is XYZW, it has 3 components, the default value is (1.0, 2.0,
        3.0), the default expression is ("$F", "hou.frame()", "") and the
        default expression language is (hou.scriptLanguage.Hscript,
        hou.scriptLanguage.Python, hou.scriptLanguage.Hscript). Then the
        corresponding parm tuple instance on a node would be named "t" and
        would contain parameters "tx", "ty", "tz". When the node is created,
        "tx" would have a default Hscript expression of "$F", "ty" would
        have a default Python expression of "hou.frame()", and "tz" would
        have a default value of 3.0.
        
        
        """
        pass
        
    
    def setDataParmType():
        """None"""
        pass
        
    
    def dataParmType():
        """
        dataParmType(self) -> hou.dataParmType enum value
        
        Return the type of this data parameter. This type determines whether
        the parameter stores geometry data or a JSON map structure.
        
        See hou.dataParmType for more information.
        
        
        """
        pass
        
    
    def setDefaultExpressionLanguage(default_expression_language):
        """
        setDefaultExpressionLanguage(self, default_expression_language)
        
        Set the default expression language for new parameter instances to a
        sequence of hou.scriptLanguage values.
        
        See the defaultExpressionLanguage method for more information. Note
        that if the number of hou.scriptLanguage values in the sequence is
        different from the number of components in the parm template, any
        extra values will be discarded and any missing expression languages
        will become hou.scriptLanguage.Hscript.
        
        
        """
        pass
        
    
    def defaultExpressionLanguage():
        """
        defaultExpressionLanguage(self) -> tuple of hou.scriptLanguage
        
        Return the default expression language for new parameter instances.
        
        The default expression language only applies if the default
        expression is set. If the default expression of a component is not
        set, then the expression language is set to
        hou.scriptLanguage.Hscript.
        
        
        """
        pass
        
    
    def setDefaultExpression(default_expression):
        """
        setDefaultExpression(self, default_expression)
        
        Set the default expression for new parameter instances to a sequence
        of strings.
        
        See the hou.DataParmTemplate.defaultExpression method for more
        information. Note that if the number of strings in the sequence is
        different from the number of components in the parm template, any
        extra values will be discarded and any missing expressions will
        become the empty string.
        
        
        """
        pass
        

def DataParmTemplate_swigregister():
    """None"""
    pass
    

class DataTree(PaneTab):
    """
    hou.DataTree
    
    Represents a Data Tree panetab.
    
    
    """
    
    def setTreeType(tree_type):
        """
        setTreeType(self, tree_type) -> bool
        
        Changes the tree type being displayed in the Data Tree. Valid values
        are any strings returned by the treeTypes function. Returns True if
        the tree type was successfully changed, otherwise False.
        
        
        """
        pass
        
    
    def setTreeExpanded(expanded):
        """
        setTreeExpanded(self, expanded)
        
        Recursively sets the expanded state of the entire data tree.
        
        
        """
        pass
        
    
    def setCurrentNodeExpanded(expanded):
        """
        setCurrentNodeExpanded(self, expanded)
        
        Sets the expanded state of the currently selected node in the tree.
        If there is no selected node the method has no effect on the tree.
        
        
        """
        pass
        
    
    def currentPath():
        """
        currentPath(self) -> str
        
        Returns the path to the current node in the tree.
        
        
        """
        pass
        
    
    def treeTypes():
        """
        treeTypes(self) -> tuple of str
        
        Returns a tuple of strings that represent the different tree types
        that can be shown in the Data Tree pane.
        
        
        """
        pass
        
    
    def setCurrentPath(path, multi=False, index=-1):
        """
        setCurrentPath(self, path, multi=False, index=-1)
        
        Sets the currently selected node in the tree. If the provided path
        does not match a node in the tree, the tree will still attempt to
        set the current node to the best possible match of the provided
        path.
        
        If multi is set to True, the previous selection will not be cleared
        before selecting the new the node. This allows multiple nodes to be
        selected in the tree.
        
        
        """
        pass
        
    
    def treeType():
        """
        treeType(self) -> str
        
        Returns the current tree type being shown in the Data Tree. This
        function may return an empty string if no tree type has been chosen
        yet.
        
        
        """
        pass
        
    
    def setCurrentPaths(paths, expand):
        """
        setCurrentPaths(self, paths, expand)
        
        Selects mutliple nodes in the data tree based on the array of paths
        passed in. If the expand flag is set to True the tree nodes will be
        expanded after selection.
        
        
        """
        pass
        
    
    def clearCurrentPath():
        """
        clearCurrentPath(self) -> str
        
        Clears the node(s) currently selected in the tree.
        
        
        """
        pass
        

def DataTree_swigregister():
    """None"""
    pass
    

class Desktop(object):
    """
    hou.Desktop
    
    Class representing a Houdini desktop (a pane layout).
    
    A desktop contains one or more panes. Each pane contains one or more
    pane tabs of various types (scene viewer, parameters, network editor,
    etc.) The main desktop window can be split horizontally or vertically
    into two panes, and each pane can itself be split horizontally or
    vertically.
    
    Note that a floating panel also contains one or more panes and a
    floating panel may optionally be attached to a desktop.
    
    The methods in this class that return pane tabs, panes, and floating
    panels only return those objects that are attached to (i.e. saved with)
    the desktop. To access all the visible pane tabs, panes, and floating
    panels, including those not attached to any desktop, use the functions
    in hou.ui.
    
    See also hou.ui.curDesktop, hou.ui.desktops, hou.Pane, hou.PaneTab, and
    hou.FloatingPanel.
    
    
    """
    
    def displayHelp(node_type):
        """
        displayHelp(self, node_type)
        
        Loads the help for the specified node type in the last opened help
        browser pane tab. Creates a help browser pane tab if no such pane
        tab already exists.
        
        
        """
        pass
        
    
    def panes():
        """
        panes(self) -> tuple of hou.Pane
        
        Return the panes inside this desktop. Note that the result includes
        panes in floating panels as long as they are attached to the
        desktop.
        
        The following function will return all visible panes, regardless of
        whether or not they are attached to a desktop:
        
        > def allPanes():
        >     '''Return a tuple of all visible panes, regardless of whether or not
        >        they are attached to a desktop.'''
        >     # Loop through all the pane tabs and add each tab's pane to the result
        >     # if it's not already there.  Note that the only way to uniquely
        >     # identify a pane is using its id.
        >     ids_to_panes = {}
        >     for pane_tab in hou.ui.paneTabs():
        >         pane = pane_tab.pane()
        >         if pane.id() not in ids_to_panes:
        >             ids_to_panes[pane.id()] = pane
        >     return ids_to_panes.values()
        
        """
        pass
        
    
    def createFloatingPaneTab(pane_tab_type, position=():
        """
        createFloatingPaneTab(self, pane_tab_type, position=(), size=(),
        python_panel_interface=None) -> hou.PaneTab
        
        Create and return a new floating window containing a single pane
        tab. Note that this method creates a floating panel with a single
        pane tab, and the graphical interface to add more tabs or split the
        pane inside the panel is not exposed.
        
        
        pane_tab_type
        A hou.paneTabType enumerated variable.
        
        position
        A tuple of two floats specifying the X and Y positions of the
        new window, respectively. The window will open near this
        position, not necessarily exactly at this position. If this
        value is an empty tuple, Houdini will choose a default location.
        
        size
        A tuple of two floats specifying the width and height of the new
        window, respectively. If this value is an empty tuple, Houdini
        will choose a default size.
        
        python_panel_interface
        The name of the Python Panel interface to be displayed in the
        floating pane tab. Specifying the interface name additionally
        hides the Python Panel toolbar. If python_panel_interface is
        None or points to an interface that does not exist then the
        default Python Panel pane tab is displayed along with the
        toolbar.
        
        This argument is ignored if pane_tab_type is not set to
        hou.paneTabType.PythonPanel.
        
        Also note that the floating panel containing the new pane tab does
        not contain any panes: calling hou.PaneTab.pane on the pane tab
        returns None, and calling hou.FloatingPanel.panes on its floating
        panel returns an empty tuple. See hou.FloatingPanel for more
        information on these stripped down floating panels.
        
        See also hou.Desktop.createFloatingPanel.
        
        The following example function takes a hou.Node and opens a floating
        parameter pane pinned to that node.
        
        > def openParmPane(node):
        >     '''Open a floating parameter pane for a particular node.'''
        >     pane_tab = hou.ui.curDesktop().createFloatingPaneTab(hou.paneTabType.Parm)
        >     pane_tab.setCurrentNode(node)
        >     pane_tab.setPin(True)
        >     return pane_tab
        
        """
        pass
        
    
    def displayHelpPyPanel(interface_name):
        """
        displayHelpPyPanel(self, interface_name)
        
        Loads the help for the python panel with the specified name in the
        last opened help browser pane tab. Creates a help browser pane tab
        if no such pane tab already exists.
        
        Raises HOM_Error if the interface name is invalid.
        
        
        """
        pass
        
    
    def findPaneTab(name):
        """
        findPaneTab(self, name) -> hou.PaneTab or None
        
        Return the pane tab with the given name, or None if no such tab
        exists. Like hou.Desktop.paneTabs, this method searches pane tabs in
        the desktop or in floating panels attached to the desktop.
        
        The name may optionally be prefixed by the desktop name and a
        period.
        
        Use hou.ui.findPaneTab to search all the visible pane tabs,
        regardless of whether they are attached to this desktop.
        
        
        """
        pass
        
    
    def shelfDock():
        """
        shelfDock(self) -> hou.ShelfDock
        
        Return the shelf dock for the current desktop.
        
        
        """
        pass
        
    
    def paneTabOfType(type, index=0):
        """
        paneTabOfType(self, type, index=0) -> hou.PaneTab or None
        
        Find and return the pane tab with the desired type. If no such tab
        exists, return None. Like hou.Desktop.paneTabs, this method searches
        pane tabs in the desktop or in floating panels attached to the
        desktop.
        
        Use hou.ui.paneTabOfType to search all the visible pane tabs,
        regardless of whether they are attached to this desktop.
        
        
        type
        A hou.paneTabType enumerated variable.
        
        index
        If there are multiple tabs with the desired type, this parameter
        determines which one is returned. Use index=0 to return the
        first found tab, index=1 to return the second found tab, etc. By
        default, index is 0.
        
        This method can be approximately implemented as follows:
        
        > def paneTabOfType(self, tab_type, index=0):
        >     pane_tabs = [t for t in self.paneTabs() if t.type() == tab_type]
        >
        >     if max(index, 0) > len(pane_tabs):
        >         return None
        >     return pane_tabs[max(index, 0)]
        
        """
        pass
        
    
    def findPane(pane_id):
        """
        findPane(self, pane_id) -> hou.Pane or None
        
        Return the pane with the given unique id, or None if no such pane
        exists. Like hou.Desktop.panes, this method searches panes in the
        desktop or in floating panels attached to the desktop.
        
        Use hou.ui.findPane to search all the visible panes, regardless of
        whether they are attached to this desktop.
        
        
        """
        pass
        
    
    def displaySideHelp(show=True):
        """
        displaySideHelp(self, show=True) -> hou.PaneTab
        
        Show or hide the side help pane.
        
        If show is set to True (default) this method displays the help pane
        and returns a help browser pane tab. If set to False then this
        method hides the help browser pane at the side of the desktop and
        returns None.
        
        
        """
        pass
        
    
    def floatingPaneTabs():
        """
        floatingPaneTabs(self) -> tuple of hou.PaneTab
        
        Return all the pane tabs in floating panels that are attached to
        this desktop.
        
        
        """
        pass
        
    
    def currentPaneTabs():
        """
        currentPaneTabs(self) -> tuple of hou.PaneTab
        
        Return the pane tabs that are contained in this desktop or are in
        floating panels attached to this desktop and are currently selected
        in their containing panes.
        
        This method does not return floating pane tabs that are not attached
        to this desktop. Use hou.ui.currentPaneTabs to get all the selected
        pane tabs, regardless of whether they are attached to this desktop.
        
        
        """
        pass
        
    
    def floatingPanels():
        """
        floatingPanels(self) -> tuple of hou.FloatingPanel
        
        Return all the floating panels attached to this desktop.
        
        Use hou.ui.floatingPanels to get all the visible floating panels,
        including those not attached to this desktop.
        
        See also hou.Desktop.floatingPaneTabs.
        
        
        """
        pass
        
    
    def paneTabs():
        """
        paneTabs(self) -> tuple of hou.PaneTab
        
        Return the pane tabs that are contained in this desktop or are in
        floating panels attached to this desktop.
        
        This method does not return floating pane tabs that are not attached
        to this desktop. Use hou.ui.paneTabs to get all the visible pane
        tabs, regardless of whether they are attached to this desktop.
        
        
        """
        pass
        
    
    def name():
        """
        name(self) -> str
        
        Return the desktop's name.
        
        Each desktop has a unique name. The desktop's name cannot be changed
        through either the scripting interface or through Houdini.
        
        
        """
        pass
        
    
    def paneUnderCursor():
        """
        paneUnderCursor(self)
        
        Return the hou.Pane object located under the mouse cursor. Return
        None if no pane is located under the mouse cursor.
        
        This method does not search floating panes that are not attached to
        this desktop. Use hou.ui.paneUnderCursor to search all the visible
        panes, regardless of whether they are attached to this desktop.
        
        
        """
        pass
        
    
    def displayHelpPath(help_path):
        """
        displayHelpPath(self, help_path)
        
        Loads the help for the specified help path in the last opened help
        browser pane tab. Creates a help browser pane tab if no such pane
        tab already exists. The path can either be a Houdini help URL (i.e.
        op:Sop/copy, tool:curve) or a raw help path (i.e. /nodes/sop/copy,
        shelf/curve).
        
        
        """
        pass
        
    
    def setAsCurrent():
        """
        setAsCurrent(self)
        
        Make this desktop the currently selected one. See also
        hou.ui.desktops.
        
        This example changes to the animate desktop:
        
        > desktops_dict = dict((d.name(), d) for d in hou.ui.desktops())
        > desktops_dict['Animate'].setAsCurrent()
        
        """
        pass
        
    
    def createFloatingPanel(pane_tab_type, position=():
        """
        createFloatingPanel(self, pane_tab_type, position=(), size=(),
        python_panel_interface=None) -> hou.FloatingPanel
        
        Create a floating panel and return it. The returned floating panel
        contains one pane which contains one pane tab of the desired type.
        
        See hou.Desktop.createFloatingPaneTab for a description of the
        parameters. This method differs from createFloatingPaneTab in two
        ways: First, it returns the floating panel instead of the pane tab.
        Second, the floating panel that is created from this method is not
        locked down, and the user can add more pane tabs and split the
        panes.
        
        The following example creates a floating panel with a parameters
        pane tab and a channel viewer (motion viewer) pane tab:
        
        > panel = hou.ui.curDesktop().createFloatingPanel(hou.paneTabType.Parm)
        > pane1 = panel.panes()[0]
        > pane2 = pane1.splitVertically()
        > pane2.tabs()[0].setType(hou.paneTabType.ChannelViewer)
        
        """
        pass
        
    
    def createFloatingPane():
        """None"""
        pass
        
    
    def paneTabUnderCursor():
        """
        paneTabUnderCursor(self)
        
        Similar to hou.Desktop.paneUnderCursor but return the hou.PaneTab
        object instead located under the mouse cursor. Return None if no
        pane tab is located under the mouse cursor.
        
        This method does not search floating pane tabs that are not attached
        to this desktop. Use hou.ui.paneTabUnderCursor to search all the
        visible pane tabs, regardless of whether they are attached to this
        desktop.
        
        
        """
        pass
        

def Desktop_swigregister():
    """None"""
    pass
    

class Dialog(object):
    """
    hou.Dialog
    
    Class representing a Houdini dialog.
    
    This class represents only dialogs created by hou..ui.createDialog.
    
    Custom dialogs can be created with Houdini's User Interface Script
    Language. An overview of the language can be found in the Houdini
    Development Kit (HDK) documentation, specifically in the "Houdini User
    Interface -> The .ui Script Language" section.
    
    
    """
    
    def setValue(name, value):
        """
        setValue(self, name, value)
        
        Set the value of the specified UI variable.
        
        Raises hou.TypeError if either name or value is None. Raises
        hou.OperationFailed if no UI variable with the specified name
        exists.
        
        
        """
        pass
        
    
    def menuItems(name):
        """
        menuItems(self, name) -> tuple of str
        
        Return the menu entries for the specified UI variable.
        
        Raises hou.TypeError if name is None. Raises hou.OperationFailed if
        no UI variable with the specified name exists. Raises
        hou.OperationFailed if the UI variable does not point to a menu.
        
        
        """
        pass
        
    
    def waitForValueToChangeTo(name, new_value):
        """
        waitForValueToChangeTo(self, name, new_value)
        
        Wait for the specified UI variable to change its value to new_value.
        
        This is a blocking call. The method will return execution when the
        variable has changed to the desired value. Note that Houdini will
        remain responsive even when this method is blocked waiting.
        
        If the variable's current value is already set to new_value then
        this method will return immediately.
        
        Raises hou.TypeError if name is None. Raises hou.OperationFailed if
        no UI variable with the specified name exists.
        
        
        """
        pass
        
    
    def enableValue(name, onoff):
        """
        enableValue(self, name, onoff)
        
        Enable or disable the specified UI variable.
        
        Set onoff to True to enable the variable. Set onoff to False to
        disable the variable.
        
        Raises hou.TypeError if either name is None. Raises
        hou.OperationFailed if no UI variable with the specified name
        exists.
        
        
        """
        pass
        
    
    def value(name):
        """
        value(self, name)
        
        Return the value of the given UI variable.
        
        Raises hou.TypeError if name is None. Raises hou.OperationFailed if
        no UI variable with the specified name exists.
        
        
        """
        pass
        
    
    def setMenuItems(name, items):
        """
        setMenuItems(self, name, items)
        
        Set the menu entries in the specified UI variable.
        
        Raises hou.TypeError if name is None. Raises hou.OperationFailed if
        no UI variable with the specified name exists. Raises
        hou.OperationFailed if the UI variable does not point to a menu.
        
        
        """
        pass
        
    
    def callbacks(name):
        """
        callbacks(self, name) -> tuple of callbacks
        
        Return all callback functions registered with the given UI variable.
        
        Raises hou.TypeError if name is None. Raises hou.OperationFailed if
        no UI variable with the specified name exists.
        
        
        """
        pass
        
    
    def destroy():
        """
        destroy(self)
        
        Delete this dialog.
        
        If you call methods on a Dialog instance after it has been
        destroyed, Houdini will raise hou.ObjectWasDeleted.
        
        
        """
        pass
        
    
    def addCallback(name, callback):
        """
        addCallback(self, name, callback)
        
        Register a callback function for the specified UI variable.
        
        The function is invoked when the value of the UI variable changes
        and receives no arguments.
        
        Raises hou.TypeError if name is None. Raises hou.OperationFailed if
        no UI variable with the specified name exists.
        
        
        """
        pass
        
    
    def removeCallback(name, callback):
        """
        removeCallback(self, name, callback)
        
        Remove the specified callback function from the UI variable.
        
        Raises hou.TypeError if name is None. Raises hou.OperationFailed if
        no UI variable with the specified name exists. Raises
        hou.OperationFailed if the specified callback is not registered with
        the UI variable.
        
        
        """
        pass
        

def Dialog_swigregister():
    """None"""
    pass
    

class DopData(object):
    """
    hou.DopData
    
    A piece of data stored inside a DOP network's simulation.
    
    Each DOP network builds a tree of data, and then Houdini examines and
    updates this tree when it runs the simulation. DOP data elements can be
    DOP objects, geometry, volumes, forces, solvers, etc. The data is
    arranged in a tree structure, where child nodes are called subdata and
    are said to be attached to their parent nodes. Under the root of the
    tree are usually the DOP objects and data describing their
    relationships.
    
    Note that the same piece of data can appear in the tree in multiple
    locations, with different names. DopData objects thus do not store their
    name, and the name of a piece of data in the tree is instead stored with
    its parent data(s).
    
    By default, DopData objects store the path within the tree to the data.
    As a consequence, if the time changes and the solvers within the
    simulation change the contents of the tree of data, the Python DopData
    object will update to refer to the simulation's new state. If the data
    path no longer refers to valid data, Houdini raises hou.ObjectWasDeleted
    when you try to access the DopData object from Python.
    
    If you do not want the DopData to update with changes to the simulation,
    you can call hou.DopData.freeze. freeze returns another DopData object
    that refers the simulation's state at the current time, and will not
    change when the simulation time changes.
    
    Each piece of data can contain records, and each record stores a list of
    name and value pairs called fields. Each record has a name, but it's
    possible for multiple records with the same name to exist in the same
    piece of data. In this case, the record also has an index, and you can
    think of the records as rows of a spreadsheet.
    
    
    """
    
    def removeSubData(data_spec):
        """
        removeSubData(self, data_spec)
        
        Remove subdata with the given name. Raises hou.PermissionError if
        called from outside a script solver DOP.
        
        Raises hou.OperationFailed if data with that name already exists.
        
        
        """
        pass
        
    
    def creator():
        """
        creator(self) -> hou.DopNode
        
        Return the DOP node that created this DOP data inside the DOP
        network.
        
        
        """
        pass
        
    
    def dataType():
        """
        dataType(self) -> str
        
        Return a string describing the type of data this object contains.
        
        > >>> obj = hou.node("/obj/AutoDopNetwork").simulation().objects()[0]
        > >>> obj.dataType()
        > 'SIM_Object'
        
        See also hou.DopData.dataTypeObject.
        
        
        """
        pass
        
    
    def attachSubData(data, new_data_name, avoid_name_collisions=False):
        """
        attachSubData(self, data, new_data_name, avoid_name_collisions=False)
        
        Make existing data become subdata of this data. Houdini does not
        create a duplicate of the data. Instead, the data's parent(s) and
        this data will both refer to the same instance of subdata. You would
        call this method from a script solver DOP.
        
        
        data
        The DopData that will become subdata of this data.
        
        new_data_name
        The name of the new subdata.
        
        avoid_name_collisions
        If True and data with the specified name exists, Houdini will
        create a unique name that does not conflict with any existing
        data.
        
        Raises hou.OperationFailed if data with this name already exists. If
        you want to replace existing data it is up to you to first call
        hou.DopData.removeData.
        
        Raises hou.PermissionError if called from outside a script solver
        DOP.
        
        See hou.DopData.copyContentsFrom for an example of how to create a
        copy of existing data.
        
        
        """
        pass
        
    
    def freeze():
        """
        freeze(self) -> hou.DopData
        
        Return a frozen version of this DopData. Frozen versions of the data
        will not update when the simulation updates. Instead, they will
        refer to the state of the simulation at the time they were frozen.
        
        It is ok to call this method on a DopData object that is already
        frozen.
        
        
        """
        pass
        
    
    def records(record_type):
        """
        records(self, record_type) -> tuple of hou.DopRecord
        
        Return a tuple of all the records of this record type. See also
        hou.DopData.record.
        
        This example lists the input affectors for a rigid body box that
        collides with a ground plane:
        
        > >>> obj = hou.node("/obj/AutoDopNetwork").simulation().objects()[-1]
        > >>> obj.records("RelInAffectors")
        > (<hou.DopRecord of type RelInAffectors index 0>, <hou.DopRecord of type RelInAffectors index 1>)
        > >>> [record.field("relname") for record in obj.records("RelInAffectors")]
        > ['merge1', 'staticsolver1_staticsolver1']
        > >>> obj.record("RelInAffectors", 1).field("relname")
        > 'staticsolver1_staticsolver1'
        
        """
        pass
        
    
    def findAllSubData(data_spec, recurse=False):
        """
        findAllSubData(self, data_spec, recurse=False) -> dict of str to
        hou.DopData
        
        Given a pattern, return a dictionary mapping subdata paths to DOP
        data instances for all the subdatas whose name matches the pattern.
        If recurse is True, all grandchildren subdata will be added to the
        result.
        
        > # The following code assumes you have created a box from the shelf and used
        > # Rigid Bodies > RBD Object on the shelf to make it a rigid body.
        > >>> obj = hou.node("/obj/AutoDopNetwork").simulation().objects()[0]
        > >>> obj.findAllSubData("S*").keys()
        > ['SolverParms', 'Solver']
        > >>> obj.findAllSubData("S*", recurse=True).keys()
        > ['SolverParms', 'Solver/Random', 'SolverParms/ActiveValue', 'Solver']
        > >>> obj.findAllSubData("S*/*", recurse=True).keys()
        > ['SolverParms/ActiveValue', 'Solver/Random']
        
        """
        pass
        
    
    def recordTypes():
        """
        recordTypes(self) -> tuple of str
        
        Return a tuple of strings containing the record types stored inside
        this DOP data. Each DOP data contains records named "Basic" and
        "Options", and some types of DOP data contain additional records.
        
        
        """
        pass
        
    
    def path():
        """
        path(self) -> str
        
        Return the path to this object within the tree of DOP data. This
        path includes the DOP object or relationship as the first part of
        the path.
        
        Note that the same piece of DOP data can exist in multiple places of
        the tree. The path returned is the path stored inside this Python
        DopData object, since the Python object uses the path to look up the
        underlying data each time you call a method on it.
        
        Note that the path is only available for unfrozen objects. If you
        call this method on a frozen DopData object it raises
        hou.OperationFailed.
        
        
        """
        pass
        
    
    def selectionPath():
        """
        selectionPath(self) -> str
        
        For DopData objects returned from a hou.SceneViewer.selectDynamics
        function call, this will return the a string that contains both the
        path to the DOP Network that created the data, and the path within
        the DOP data tree which uniquely identifies this DopData. This
        string is specifically intended to be passed in the
        prior_selection_paths argument of the hou.SceneViewer selection
        methods.
        
        
        """
        pass
        
    
    def id():
        """
        id(self) -> str
        
        Return the globally unique identifier (GUID) for this DOP data. This
        method is a shortcut for self.record("Basic").field("uniqueid").
        
        If you want an object's index, hou.DopObject.objid.
        
        > >>> obj = hou.node("/obj/AutoDopNetwork").simulation().objects()[0]
        > >>> obj.id()
        > '0xD011E41C-0x000034AE-0x494C12E4-0x000018B9'
        > >>> obj.objid()
        > 0
        
        """
        pass
        
    
    def dopNetNode():
        """
        dopNetNode(self) -> hou.Node
        
        Return the DOP network node containing this DOP data.
        
        
        """
        pass
        
    
    def findSubData(data_spec):
        """
        findSubData(self, data_spec) -> hou.DopData or None
        
        Return the DOP data with the given name that is attached to this DOP
        data, or None if no such data exists. Note that the name may also be
        a slash-separated path to nested subdata.
        
        See hou.DopData.subData for an example.
        
        This method can be approximately implemented as follows:
        
        > def findSubData(self, data_spec):
        >     data = self
        >     for name in data_spec.split("/"):
        >         if name not in data.subData():
        >             return None
        >         data = data.subData()[name]
        >     return data
        
        """
        pass
        
    
    def subData():
        """
        subData(self) -> dict of str to hou.DopData
        
        Return a dictionary mapping names to DOP data instances for the
        subdata attached to this data.
        
        > # The following code assumes you have created a box from the shelf and used
        > # Rigid Bodies > RBD Object on the shelf to make it a rigid body.
        > >>> obj = hou.node("/obj/AutoDopNetwork").simulation().objects()[0]
        > >>> obj
        > <hou.DopObject box_object1 id 0>
        > >>> obj.recordTypes()
        > ('Basic', 'Options', 'RelInGroup', 'RelInAffectors')
        > >>> record = obj.record("Options")
        > >>> record.fieldNames()
        > ('name', 'groups', 'affectors', 'affectorids', 'objid')
        > >>> record.field("name")
        > 'box_object1'
        >
        > >>> obj.subData().keys()
        > ['PhysicalParms', 'ODE_Body', 'Solver', 'Geometry', 'SolverParms', 'ODE_Geometry', 'Forces', 'Position', 'Colliders']
        > >>> obj.findSubData("Forces/Gravity_gravity1")
        > <hou.DopData of type SIM_ForceGravity>
        > >>> obj.findSubData("Forces/Gravity_gravity1").options().field("force")
        > <hou.Vector3 [0, -9.80665, 0]>
        
        """
        pass
        
    
    def _asVoidPointer():
        """None"""
        pass
        
    
    def copyContentsFrom(data):
        """
        copyContentsFrom(self, data)
        
        Copy the contents of the given DopData into this one, adapting the
        data if it is of a different type. You would call this method from a
        script solver DOP.
        
        Raises hou.PermissionError if called from outside a script solver
        DOP.
        
        Use this method along with hou.DopData.createSubData to copy
        existing subdata:
        
        > def copySubData(new_parent_data, data_to_copy, new_data_name, avoid_name_collisions=False):
        >     '''Create a copy of data and attach it to other data.'''
        >     new_data = new_parent_data.createSubData(new_data_name, data_to_copy.dataType(), avoid_name_collisions)
        >     new_data.copyContentsFrom(data_to_copy)
        >     return new_data
        
        """
        pass
        
    
    def isFrozen():
        """
        isFrozen(self) -> bool
        
        Return whether or not this data is frozen.
        
        See hou.DopData.freeze for more information.
        
        
        """
        pass
        
    
    def simulation():
        """
        simulation(self) -> hou.DopSimulation
        
        Return the DOP simulation containing this DOP data. This method is a
        shortcut for self.dopNetNode().simulation().
        
        
        """
        pass
        
    
    def record(record_type, record_index=0):
        """
        record(self, record_type, record_index=0) -> hou.DopRecord
        
        Given a record type name return that record, or None if no record
        exists with that name. If this DOP data contains multiple records
        with this record type name you can think of each record as a row in
        a spreadsheet, and record_index determines which one is returned.
        Use len(self.records(record_type)) to determine how many records of
        this type are in this DOP data.
        
        Use hou.DopData.recordTypes to get a tuple of record types in a DOP
        data. See also hou.DopData.records for an example, and see
        hou.DopData.options for a way to easily access the "Options" record.
        
        
        """
        pass
        
    
    def options():
        """
        options(self) -> hou.DopRecord
        
        Return the Options record. This method is a shortcut for
        self.record("Options").
        
        
        """
        pass
        
    
    def createSubData(data_name, data_type="SIM_EmptyData", avoid_name_collisions=False):
        """
        createSubData(self, data_name, data_type="SIM_EmptyData",
        avoid_name_collisions=False) -> hou.DopData
        
        Create subdata under this data with the specified name and type. You
        would call this method from a script solver DOP.
        
        
        data_name
        The name of the new data. Note that this name may contain
        slashes to create subdata on existing data.
        
        data_type
        Either the name of the data type to create or a hou.DopDataType
        instance. If you simply want something containing an empty
        options record, use "SIM_EmptyData".
        
        avoid_name_collisions
        If True and data with the specified name exists, Houdini will
        create a unique name that does not conflict with any existing
        data.
        
        Raises hou.OperationFailed if data with this name already exists. If
        you want to replace existing data it is up to you to first call
        hou.DopData.removeData.
        
        Raises hou.PermissionError if called from outside a script solver
        DOP.
        
        Use hou.DopData.attachSubData to create a reference to existing
        data. See hou.DopData.copyContentsFrom for an example of how to
        create a copy of existing data.
        
        
        """
        pass
        

def DopData_swigregister():
    """None"""
    pass
    

class DopNode(Node):
    """
    hou.DopNode
    
    Represents a dynamics node.
    
    
    """
    
    def objectsToProcess():
        """
        objectsToProcess(self) -> tuple of hou.DopObject
        
        Return a tuple of DOP objects that this node should process. Raises
        hou.PermissionError if called from outside a DOP implemented in
        Python.
        
        
        """
        pass
        
    
    def processedObjects():
        """
        processedObjects(self) -> tuple of hou.DopObject
        
        Return a tuple of DOP objects that this DOP node processes.
        
        
        """
        pass
        
    
    def isBypassed():
        """
        isBypassed(self) -> bool
        
        Returns whether the node's bypass flag is on.
        
        
        """
        pass
        
    
    def createdObjects():
        """
        createdObjects(self) -> tuple of hou.DopObject
        
        Return a tuple of DOP objects that this DOP node creates.
        
        
        """
        pass
        
    
    def setDisplayFlag(on):
        """
        setDisplayFlag(self, on)
        
        Turn the node's display flag on or off. This the orange Output flag
        in the interface.
        
        
        """
        pass
        
    
    def dopNetNode():
        """
        dopNetNode(self) -> hou.Node
        
        Return the DOP network node that contains this DOP node.
        
        
        """
        pass
        
    
    def isDisplayFlagSet():
        """
        isDisplayFlagSet(self) -> bool
        
        Return whether this node's display flag is on. This is the orange
        Output flag in the interface.
        
        
        """
        pass
        
    
    def renderNode():
        """None"""
        pass
        
    
    def simulation():
        """
        simulation(self) -> hou.DopSimulation
        
        Return the simulation that this node contributes to. This method is
        a shortcut for self.dopNetNode().simulation().
        
        
        """
        pass
        
    
    def setTemplateFlag(on):
        """
        setTemplateFlag(self, on)
        
        Turns this node's template flag on or off. This is the brown Hidden
        flag in the interface.
        
        
        """
        pass
        
    
    def bypass(on):
        """
        bypass(self, on)
        
        Turn the node's bypass flag on or off, making this node have no
        effect.
        
        
        """
        pass
        
    
    def pythonSolverData():
        """
        pythonSolverData(self) -> hou.DopData
        
        If this node is a Python DOP solver, return the solver data added to
        the DOP network by this node. Otherwise, raises hou.PermissionError.
        
        This method is called from Python DOP solvers when the solver is not
        running, to copy data from the DOP parameters into the solver data.
        
        See also hou.dop.scriptSolverData.
        
        
        """
        pass
        
    
    def isTemplateFlagSet():
        """
        isTemplateFlagSet(self) -> bool
        
        Returns whether this node's template flag is on. This is the brown
        Hidden flag in the interface.
        
        
        """
        pass
        
    
    def displayNode():
        """
        displayNode(self) -> hou.Node or None
        
        If this node is a subnet (i.e. it contains child nodes), return the
        child that has its display flag set, or None if there are no
        children. Otherwise, return None.
        
        
        """
        pass
        

def DopNode_swigregister():
    """None"""
    pass
    

class DopObject(DopData):
    """
    hou.DopObject
    
    A type of DOP data that contains an object in the simulation.
    
    This object might be a rigid body, a fluid, cloth, etc. The type and
    properties of the DOP object are determined by the subdata attached to
    the object.
    
    
    """
    
    def matches(pattern):
        """
        matches(self, pattern) -> bool
        
        Return whether or not this object's name matches a pattern. * will
        match any number of characters and ? will match any single
        character. The pattern string contains only one pattern, so spaces
        in the pattern will be compared against the object name.
        
        > >>> obj = hou.node("/obj/AutoDopNetwork").simulation().objects()[0]
        > >>> obj.name()
        > 'box_object1'
        > >>> obj.matches("box*")
        > True
        > >>> obj.matches("c*")
        > False
        > >>> obj.matches("box* b*")
        > False
        > >>> obj.matches("b?x_object1")
        > True
        
        """
        pass
        
    
    def transform(include_geometry_transform=True):
        """
        transform(self, include_geometry_transform=True) -> hou.Matrix4
        
        Return the transformation matrix for this object. If
        include_geometry_transform is False, the result is determined only
        by the object's Position data. Otherwise, it is the transform in the
        object's Geometry data, followed by the position transform.
        
        For simple DopData types, this method can be approximately
        implemented as follows:
        
        > def transform(self, include_geometry_transform=True):
        >     result = hou.hmath.identityTransform()
        >
        >     geometry = self.findSubData("Geometry")
        >     if include_geometry_transform and geometry is not None:
        >         result *= geometry.record("Transform").field("transform")
        >
        >     # Retrieve the position.  If there is Geometry data, use its
        >     # positionpath field to get the SIM_Position subdata.  If not, look
        >     # for data named Position.
        >     position = None
        >     if geometry is not None:
        >         position = geometry.findSubData(
        >             geometry.options().field("positionpath"))
        >     if position is None:
        >         position = self.findSubData("Position")
        >
        >     # If we found position data, build a transformation from the pivot,
        >     # rotation quaternion, and translate.
        >     if position is not None:
        >         options = position.options()
        >         rotation = hou.Matrix4(options.field("orient").extractRotationMatrix3())
        >         result *= (hou.hmath.buildTranslate(-options.field("p")) *
        >             rotation *
        >             hou.hmath.buildTranslate(options.field("p")) *
        >             hou.hmath.buildTranslate(options.field("t")))
        >
        >     return result
        
        """
        pass
        
    
    def name():
        """
        name(self) -> str
        
        Return the name of this DOP object.
        
        
        """
        pass
        
    
    def geometry(name="Geometry"):
        """
        geometry(self, name="Geometry") -> hou.Geometry or None
        
        If this DOP object has SIM_Geometry subdata with the given name,
        return its corresponding read-only hou.Geometry object. Otherwise,
        this method returns None.
        
        
        """
        pass
        
    
    def editableGeometry(name="Geometry"):
        """
        editableGeometry(self, name="Geometry") -> hou.EditableDopGeometryGuard
        or None
        
        If this method is called from a Python solver DOP and it has
        SIM_Geometry (or SIM_GeometryCopy) subdata with the given name, it
        returns a Python guard object that can be used with the "with"
        statement to access and modify the corresponding hou.Geometry
        object.
        
        In Python 2.5, the with statement is not enabled by default. To
        enable it, you need to add the following line at the beginning of
        your script/module:
        
        > from __future__ import with_statement
        
        For example, the following code in a Python solver DOP will add a
        point at the origin of the geometry:
        
        > with dop_object.editableGeometry() as geo:
        >     geo.createPoint()
        
        Raises hou.PermissionError if not called from a Python solver DOP.
        
        
        """
        pass
        
    
    def objid():
        """
        objid(self) -> int
        
        Return the index of this object in the output from
        hou.DopSimulation.objects. This method is a shortcut for
        self.options().field("objid").
        
        See hou.DopData.id for an example.
        
        Some fields in DOP records store an objid to refer to other objects.
        The following function looks up an object by objid:
        
        > def findObjectByObjid(dopnet_node, objid):
        >     return dopnet_node.simulation().objects()[objid]
        
        """
        pass
        

def DopObject_swigregister():
    """None"""
    pass
    

class DopRecord(object):
    """
    hou.DopRecord
    
    A table of values stored inside a DopData.
    
    See hou.DopData for a description of DOP data, records, and fields.
    
    
    """
    
    def recordType():
        """
        recordType(self) -> str
        
        Return the name of this record. See hou.DopData.recordTypes for more
        information.
        
        
        """
        pass
        
    
    def setFieldBool(field_name, value):
        """
        setFieldBool(self, field_name, value)
        
        Set a field to the specified boolean value. You would call this
        method from a script solver DOP.
        
        To set a field to a different type, use hou.DopRecord.setField.
        
        Raises hou.PermissionError if called from outside a script solver
        DOP.
        
        
        """
        pass
        
    
    def fieldType(field_name):
        """
        fieldType(self, field_name) -> hou.fieldType enum value
        
        Return a hou.fieldType enumerated value that describes the type of
        data stored in a field. Returns hou.fieldType.NoSuchField if no
        field exists with that name.
        
        See hou.DopRecord.field for an example.
        
        
        """
        pass
        
    
    def setField(field_name, value):
        """
        setField(self, field_name, value)
        
        Set a field to the specified value. You would call this method from
        a script solver DOP. value may be an int, float, str, hou.Vector2,
        hou.Vector3, hou.Vector4, hou.Quaternion, hou.Matrix3, or
        hou.Matrix4.
        
        Unfortunately, this method cannot be used to set a field to a
        boolean (True or False) value. If you pass a boolean to this method,
        it will set the field to the integer 1 or 0. To properly set it to a
        boolean value, use hou.DopRecord.setFieldBool.
        
        Raises hou.PermissionError if called from outside a script solver
        DOP.
        
        
        """
        pass
        
    
    def fieldNames():
        """
        fieldNames(self) -> tuple of str
        
        Return the names of all the fields inside this record. See
        hou.DopRecord.field for an example.
        
        
        """
        pass
        
    
    def field():
        """
        field(self) -> int, bool, float, str, hou.Vector2, hou.Vector3,
        hou.Vector4, hou.Quaternion, hou.Matrix3, or hou.Matrix4
        
        Return the value of a field inside this record, or None if no such
        field exists.
        
        Note that you can add the suffixes "x", "y", and "z" to a vector
        field's name to access the individual float values.
        
        > # The following code assumes you have created a box from the shelf and used
        > # Rigid Bodies > RBD Object on the shelf to make it a rigid body.
        > >>> record = hou.node("/obj/AutoDopNetwork").simulation().findData("box_object1/Forces/Gravity_gravity1").options()
        > >>> record.fieldNames()
        > ('force', 'handlepos')
        > >>> record.field("force")
        > <hou.Vector3 [0, -9.80665, 0]>
        > >>> record.field("forcey")
        > -9.8066501617431641
        > >>> record.fieldType("force")
        > fieldType.Vector3
        > >>> record.fieldType("forcey")
        > fieldType.Float
        
        This example function creates a dict out of a record:
        
        > def recordAsDict(record):
        >     return dict((field_name, record.field(field_name))
        >         for field_name in record.fieldNames())
        
        The following function returns the geometry transform of an object:
        
        > def dopGeometryTransform(dopnet_node, object_name):
        >     subdata = dopnet_node.simulation().findObject(object_name).findSubData("Geometry")
        >     return subdata.record("Transform").field("transform")
        
        """
        pass
        
    
    def recordIndex():
        """
        recordIndex(self) -> int
        
        Return the index of this record. See hou.DopData.record and
        hou.DopData.records for more information.
        
        
        """
        pass
        

def DopRecord_swigregister():
    """None"""
    pass
    

class DopRelationship(DopData):
    """
    hou.DopRelationship
    
    A type of DOP data that stores which DOP objects affect one another.
    
    In addition to the "Basic" and "Options" records, a DopRelationship
    contains "ObjInAffectors" and "ObjInGroup" records. The former contains
    the objects doing the affecting and the latter contains the objects
    being affected.
    
    See hou.DopSimulation.relationships for an example.
    
    
    """
    
    def matches(pattern):
        """
        matches(self, pattern) -> bool
        
        Return whether or not this relationship's name matches a pattern.
        See hou.DopObject.matches for more information.
        
        
        """
        pass
        
    
    def setGroup(objects):
        """
        setGroup(self, objects)
        
        Sets the list of objects that are being affected. This corresponds
        to the "ObjInGroup" record.
        
        objects: A list of DOP objects.
        
        Raises hou.PermissionError if called from outside a Python DOP.
        
        
        """
        pass
        
    
    def name():
        """
        name(self) -> str
        
        Return the name of this DOP relationship.
        
        
        """
        pass
        
    
    def setAffectorGroup(objects):
        """
        setAffectorGroup(self, objects)
        
        Sets the list of objects that are doing the affecting. This
        corresponds to the "ObjInAffectors" record.
        
        objects: A list of DOP objects.
        
        Raises hou.PermissionError if called from outside a Python DOP.
        
        
        """
        pass
        

def DopRelationship_swigregister():
    """None"""
    pass
    

class DopSimulation(object):
    """
    hou.DopSimulation
    
    A dynamics simulation contained inside a DOP network node.
    
    See hou.DopData for more information about the contents of a DOP
    simulation. Note that methods of this class implicitly use the
    simulation data from the current frame.
    
    
    """
    
    def relationships():
        """
        relationships(self) -> tuple of hou.DopRelationship
        
        Return a tuple of hou.DopRelationship objects for all the DOP
        relationships in the simulation.
        
        > # The following example assumes you have created two box objects and made
        > # them rigid bodies.
        > >>> simulation = hou.node("/obj/AutoDopNetwork").simulation()
        > >>> relationship = simulation.relationships()[1]
        > >>> affecting_objects = [
        > ...     simulation.objects()[record.field("objid")]
        > ...     for record in relationship.records("ObjInAffectors")]
        > >>> [obj.name() for obj in affecting_objects]
        > ['box_object1']
        > >>> affected_objects = [
        > ...     simulation.objects()[record.field("objid")]
        > ...     for record in relationship.records("ObjInGroup")]
        > >>> [obj.name() for obj in affected_objects]
        > ['box_object2']
        
        """
        pass
        
    
    def findRelationship(rel_spec):
        """
        findRelationship(self, rel_spec) -> hou.DopRelationship
        
        Find a DOP relationship by name. Return None if no such relationship
        with that name exists. See also hou.DopSimulation.relationships.
        
        
        """
        pass
        
    
    def findAllObjects(obj_spec):
        """
        findAllObjects(self, obj_spec) -> tuple of hou.DopObject
        
        Given a pattern, return a tuple of DOP objects whose names match the
        pattern.
        
        > >>> simulation = hou.node("/obj/AutoDopNetwork").simulation()
        > >>> [obj.name() for obj in simulation.findAllObjects("box_object?")]
        > ['box_object1', 'box_object2']
        > >>> [obj.name() for obj in simulation.findAllObjects("o* b*")]
        > ['obj1', 'obj2', 'box_object1', 'box_object2']
        
        """
        pass
        
    
    def memoryUsage():
        """
        memoryUsage(self)
        
        Return the simulation's total memory usage.
        
        
        """
        pass
        
    
    def findAllData(data_spec):
        """
        findAllData(self, data_spec) -> tuple of hou.DopData
        
        Given a pattern, return a tuple of DOP data whose names match the
        pattern. See also hou.DopSimulation.findData.
        
        
        """
        pass
        
    
    def objects():
        """
        objects(self) -> tuple of hou.DopData
        
        Return a tuple of all the DOP objects in the simulation.
        
        You cannot index into this list using the object ID (see
        hou.DopObject.objid). To create a dictionary mapping object IDs to
        hou.DopObjects, do this:
        
        > id_dict = dict((obj.objid(), obj) for obj in simulation.objects())
        
        """
        pass
        
    
    def findAllRelationships(rel_spec):
        """
        findAllRelationships(self, rel_spec) -> tuple of hou.DopRelationship
        
        Return a tuple of hou.DopRelationship objects whose names match a
        pattern. See also hou.DopSimulation.relationships and
        hou.DopSimulation.findRelationship.
        
        
        """
        pass
        
    
    def findData(data_spec):
        """
        findData(self, data_spec) -> hou.DopData or None
        
        Return the DOP data with the given name. Note that the name may also
        be a slash-separated path to nested subdata.
        
        If the data path refers to a DOP object, this method returns a
        hou.DopObject instance. If it refers to a DOP relationship, it
        returns a hou.DopRelationship instance. Otherwise, it returns a
        hou.DopData instance.
        
        Note this method implicitly uses the simulation data from the
        current frame.
        
        See also hou.DopData.findSubData.
        
        
        """
        pass
        
    
    def createRelationship(name):
        """
        createRelationship(self, name) -> hou.DopRelationship
        
        Create and return a new DOP relationship, or return None if the
        relationship was not created successfully.
        
        
        name
        The name of the new relationship.
        
        Raises hou.PermissionError if called from outside a Python DOP.
        
        Use hou.DopData.copyContentsFrom to clone data from an existing
        relationship, and use hou.DopRelationship.setGroup and
        hou.DopRelationship.setAffectorGroup to update the "ObjInGroup" and
        "ObjInAffectors" records.
        
        
        """
        pass
        
    
    def removeRelationship(rel):
        """
        removeRelationship(self, rel)
        
        Remove the given DOP relationship from the simulation.
        
        
        rel
        The hou.DopRelationship to remove.
        
        Raises hou.PermissionError if called from outside a Python DOP.
        
        
        """
        pass
        
    
    def dopNetNode():
        """
        dopNetNode(self) -> hou.Node
        
        Return the DOP network node containing this simulation.
        
        
        """
        pass
        
    
    def createObject(name, solve_on_creation_frame):
        """
        createObject(self, name, solve_on_creation_frame) -> hou.DopObject
        
        Create and return a new DOP object, or return None if the object was
        not created successfully.
        
        
        name
        The name of the new object.
        
        solve_on_creation_frame
        If True, the object will be solved on its first frame of
        existance.
        
        Raises hou.PermissionError if called from outside a Python DOP.
        
        Use hou.DopData.copyContentsFrom to clone data from an existing
        object.
        
        
        """
        pass
        
    
    def time():
        """
        time(self)
        
        Return the simulation's current time. This value is often the same
        as hou.time, unless it is called from a Python solver DOP or the
        Time Scale or Offset Time parameters of the DOP network have been
        changed from their default values.
        
        
        """
        pass
        
    
    def removeObject(object):
        """
        removeObject(self, object)
        
        Remove the given DOP object from the simulation.
        
        
        object
        The hou.DopObject to remove.
        
        Raises hou.PermissionError if called from outside a Python DOP.
        
        
        """
        pass
        
    
    def findObject(obj_spec):
        """
        findObject(self, obj_spec) -> hou.DopObject or None
        
        Return the DOP object with the given name, or None if no object
        exists with that name. See also hou.DopSimulation.findData and
        hou.DopSimulation.objects.
        
        
        """
        pass
        

def DopSimulation_swigregister():
    """None"""
    pass
    

class Drawable(object):
    """
    hou.Drawable
    
    Represents extra geometry to draw in the viewer alongside user content
    (for example, as guide geometry).
    
    OVERVIEW
    
    You can attach geometry to a viewer in a Drawable object, causing
    the geometry to appear in the viewer even though the geometry is not
    actually part of the scene. This is useful to show _guide geometry_
    in a custom Python state.
    
    > import hou
    > # Create an empty geometry object
    > geo = hou.Geometry()
    > # Get the verb from the Box node
    > box_verb = hou.sopNodeTypeCategory().nodeVerb("box")
    > # Set the verb's parameters
    > box_verb.setParms({
    >     "t": hou.Vector3(0.5, 0.5, -0.5),
    >     "scale": 0.5,
    > })
    > # Execute the verb and put its output in the Geometry object
    > box_verb.execute(geo, [])
    >
    > # Grab a reference to the viewer
    > scene_viewer = hou.ui.paneTabOfType(hou.paneTabType.SceneViewer)
    > # Create a Drawable object
    > drawable = hou.Drawable(scene_viewer, geo, "my_guide")
    > # Set the Drawable display mode as wireframe (this is the default)
    > drawable.setDisplayMode(hou.drawableDisplayMode.WireframeMode)
    > # Enable and show the drawable geometry
    > drawable.enable(True)
    > drawable.show(True)
    > # Tumble the view to see the geometry
    > import hou
    > # Create a geometry from the Sphere node
    > sphere_verb = hou.sopNodeTypeCategory().nodeVerb("sphere")
    > geo = hou.Geometry()
    > sphere_verb.execute(geo, [])
    >
    > # Add color and alpha attributes to the sphere
    > color_attrib = geo.addAttrib(hou.attribType.Prim, "Cd", (1.0, 1.0, 1.0))
    > alpha_attrib = geo.addAttrib(hou.attribType.Prim, "Alpha", 1.0)
    >
    > color = hou.Color(1.0, 0.0, 0.0)
    > for prim in geo.prims():
    >     prim.setAttribValue(color_attrib, color.rgb())
    >     prim.setAttribValue(alpha_attrib, 0.7)
    >
    > # Create a Drawable object
    > scene_viewer = hou.ui.paneTabOfType(hou.paneTabType.SceneViewer)
    > drawable = hou.Drawable(scene_viewer, geo, "my_sphere")
    > # Set the Drawable display mode with the current viewport shading mode
    > drawable.setDisplayMode(hou.drawableDisplayMode.CurrentViewportMode)
    > # Set the size of the sphere
    > drawable.setTransform(hou.hmath.buildScale(0.5, 0.5, 0.5))
    > drawable.enable(True)
    > drawable.show(True)
    
    TIPS AND NOTES
    
    * The Drawable object keeps a reference to the Geometry object you
    pass. You can change the Geometry object's contents and the next
    time the viewer redraws it will draw the new contents.
    
    * When you create the Drawable object, it is disabled and hidden. You
    need to call enable(True) and then show(True) for the geometry to
    appear.
    
    * Even after they are activated and shown, Drawable geometry does not
    appear in the viewer until the next redraw (for example, when the
    user changes the view).
    
    You can force an individual viewport to redraw using
    hou.GeometryViewport.draw.
    
    > scene_viewer.curViewport().draw()
    
    * You can generate the contents of a Geometry object from scratch
    using verbs, or grab a copy of the output of a SOP node using
    hou.SopNode.geometry.
    
    * You can also use hou.drawablePrimitive to specify a built-in shape
    to generate the content of a Drawable object.
    
    * enabling/disabling a drawable may cause performances issues if
    performed too often, especially with large geometries. It's good
    practice to use show instead of enable for hiding and showing a
    drawable.
    
    * It's also good practice to disable drawables when they are not
    actively used in a viewer.
    
    * The drawable geometry will appear in the viewer until you disable
    it, or the Drawable object is deleted. If there are no references to
    the object, Python will automatically delete it during garbage
    collection, and the guide geometry will disappear. So, you need to
    make sure to keep a live reference to the object as long as you want
    it to appear.
    
    If you're using Drawable to draw guide geometry for a custom
    state, you will generally store a reference to the Drawable
    object on the state implementation object.
    
    
    """
    
    def enable(selfvalue):
        """
        show(self,value)
        
        Shows or hides the handle.
        
        
        value
        Bool value, True to show the handle, False to hide it.
        
        
        """
        pass
        
    
    def show(value):
        """
        show(self, value)
        
        Displays or hides the geometry in the viewport. The object must be
        enabled first. It will appear the next time the viewer redraws.
        
        
        value
        True to show the geometry or False to hide it.
        
        
        """
        pass
        
    
    def setTransform(xform):
        """
        setTransform(self, xform)
        
        Sets the transform matrix of the geometry. The changes will appear
        the next time the viewer redraws.
        
        
        xform
        A hou.Matrix4 transformation matrix to set the geometry's
        tranlation, rotation, and scale.
        
        
        """
        pass
        
    
    def setDisplayMode():
        """
        displayMode(self): -> hou.drawableDisplayMode
        
        Returns the display mode of the geometry.
        
        
        """
        pass
        
    
    def displayMode():
        """None"""
        pass
        
    
    def setWireframeColor(color):
        """
        setWireframeColor(self, color)
        
        Updates the color of the geometry when the drawable display mode is
        set to hou.drawableDisplayMode.WireframeMode. The change will appear
        the next time the viewer redraws.
        
        
        color
        A hou.Color value to specify the primitive color.
        
        
        """
        pass
        
    
    def transform():
        """
        transform(self): -> hou.Matrix4
        
        Returns the geometry transform matrix.
        
        
        """
        pass
        
    
    def name():
        """
        name(self)
        
        The name of this drawable.
        
        
        """
        pass
        

def Drawable_swigregister():
    """None"""
    pass
    

class Edge(object):
    """
    hou.Edge
    
    Each Edge object resides inside a Geometry object and stores an edge.
    Edges are reprsented as pairs of points.
    
    
    """
    
    def edgeId():
        """
        edgeId(self) -> str
        
        Return a string such as p8-9 that identifies the edge
        
        
        """
        pass
        
    
    def geometry():
        """None"""
        pass
        
    
    def length():
        """
        length(self) -> float
        
        Returns the length of this edge
        
        
        """
        pass
        
    
    def points():
        """
        points(self) -> tuple of hou.Point
        
        Return a tuple of the points that make up this edge.
        
        
        """
        pass
        
    
    def prims():
        """
        prims(self) -> tuple of hou.Prim
        
        Return a tuple of the prims that has this edge
        
        
        """
        pass
        

class EdgeGroup(object):
    """
    hou.EdgeGroup
    
    A named group of edges inside a Geometry object.
    
    Edge groups reside inside the geometry, and each edge group has a unique
    name.
    
    See hou.Edge for more information about edges. See also hou.PrimGroup
    and hou.PointGroup.
    
    REPLACES
    
    
    """
    
    def edges():
        """
        edges(self) -> tuple of hou.Edge
        
        Return the contents of this group.
        
        
        """
        pass
        
    
    def name():
        """
        name(self)
        
        Return the name of the group. Each edge group has a unique name.
        
        
        """
        pass
        
    
    def geometry():
        """
        geometry(self) -> hou.Geometry
        
        Return the geometry object containing this group.
        
        
        """
        pass
        
    
    def clear():
        """None"""
        pass
        
    
    def contains(edge):
        """
        contains(self, edge) -> bool
        
        Return whether or not an edge is in this group.
        
        Raises hou.OperationFailed if the edge belongs to a different
        geometry object than this group.
        
        
        """
        pass
        
    
    def remove(edge_or_list_or_edge_group):
        """
        remove(self, edge_or_list_or_edge_group)
        
        If given a hou.Edge or a list of hou.Edge's, remove the edge(s) from
        the group. If given a hou.EdgeGroup, remove all edges in the other
        group from this group (the other group is unaffected). You would
        typically call this method from the code of a Python-defined SOP.
        
        It is not an error to try to remove an edge from the group that
        wasn't already in the group.
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable.
        
        Raises hou.OperationFailed if the edge belongs to a different
        geometry object than this group.
        
        
        """
        pass
        
    
    def add(edge_or_list_or_edge_group):
        """
        add(self, edge_or_list_or_edge_group)
        
        If given a hou.Edge or a list of hou.Edge's, add the edge(s) to the
        group. If given a hou.EdgeGroup, merge the contents of the other
        edge group with this group (the other group is unaffected). You
        would typically call this method from the code of a Python-defined
        SOP.
        
        It is ok to add edges to the group that were already in the group.
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable.
        
        Raises hou.OperationFailed if the edge or edge group belong to a
        different geometry object than this group.
        
        
        """
        pass
        
    
    def destroy():
        """
        destroy(self)
        
        Remove this group from the geometry. You would typically call this
        method from the code of a Python-defined SOP.
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable.
        
        
        """
        pass
        

def EdgeGroup_swigregister():
    """None"""
    pass
    

def Edge_swigregister():
    """None"""
    pass
    

class EditableDopGeometryGuard(object):
    """None"""

def EditableDopGeometryGuard_swigregister():
    """None"""
    pass
    

class EnumValue(object):
    """
    hou.EnumValue
    
    This class is the base class for an enumeration value. It cannot be
    instanced and is not meant to be used directly by the user.
    
    All the built-in HOM enumeration values are derived from this class such
    as hou.paneTabType.*, hou.severityType.*, and hou.connectivityType.*.
    
    
    """
    
    def name():
        """
        name(self) -> string
        
        Returns the name of the enumeration value.
        
        
        """
        pass
        

def EnumValue_swigregister():
    """None"""
    pass
    

class Error(Error):
    """
    hou.Error
    
    Base class for all exceptions in the hou module.
    
    You can check if an exception instance is a Houdini-specific exception
    using isinstance(ex, hou.Error).
    
    
    """
    
    def exceptionTypeName():
        """
        exceptionTypeName(self) -> str
        
        Return the name of the exception type. Instances of different
        subclasses of hou.Error will return different names. Instances of
        the base class will return "Error".
        
        You can also use str(e.__class__) to get the name of the subclass.
        
        
        """
        pass
        
    
    def instanceMessage():
        """
        instanceMessage(self) -> str
        
        Return a message specific to the exception instance.
        
        
        """
        pass
        
    
    def description():
        """
        description(self) -> str
        
        Return a description of the class of exception. The description is
        not related to the exception instance.
        
        
        """
        pass
        

def Error_swigregister():
    """None"""
    pass
    

class Face(Prim):
    """
    hou.Face
    
    A Face is a kind of geometry primitive (Prim object) that contains a
    sequence of vertices (Vertex objects). How these vertices are used
    depends on the type of face; polygons, for example, use the vertices to
    define the edges of the polygon, while NURBS curves use them as control
    points.
    
    A hou.Surface, on the other hand, stores a two dimension grid of
    vertices, and might be a NURBS surface, Bezier surface, or quadrilateral
    mesh.
    
    
    """
    
    def normal():
        """
        normal(self) -> hou.Vector3
        
        Return the vector that's perpendicular to the face.
        
        
        """
        pass
        
    
    def positionAt(u):
        """
        positionAt(self, u) -> hou.Vector3
        
        Given a normalized (i.e. from 0 to 1) u value, return the position
        of the curve at that parametric location.
        
        
        """
        pass
        
    
    def vertex(index):
        """
        vertex(self, index) -> hou.Vertex
        
        A shortcut for self.vertices()[index]. You probably don't need to
        call this method.
        
        This method supports negative indices to index from the end, just
        like self.vertices()[index] would. Also, like Python's indexing
        operator, it will raise IndexError when the index is out of range.
        
        
        """
        pass
        
    
    def attribValueAt(attrib_or_name, u, du=0):
        """
        attribValueAt(self, attrib_or_name, u, du=0) -> int, float, str or tuple
        
        Return an attribute value at a normalized u parametric position on
        the curve. If du is 0, returns the interpolated attribute value;
        otherwise, returns the derivative of the attribute value.
        
        Raises hou.OperationFailed if the attribute is not a point or vertex
        attribute. If you want a primitive attribute value, it doesn't vary
        across the surface, so use hou.Prim.attribValue.
        
        
        """
        pass
        
    
    def addVertex(point):
        """
        addVertex(self, point) -> hou.Vertex
        
        Create a new vertex inside this face, adding it to the end of the
        vertex list. You would typically call this method from the code of a
        Python-defined SOP.
        
        point is a hou.Point object that the new vertex will refer to. See
        hou.Vertex for information on the relationship between points and
        vertices.
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable.
        
        > # These arrays define point positions and a set of polygons composed
        > # of those points.  Note that the point positions could also be floating
        > # point values.
        > point_positions = ((0,0,0), (1,0,0), (1,1,0), (0,1,0))
        > poly_point_indices = ((0,1,2), (2,3,0))
        >
        > geo = hou.pwd().geometry()
        >
        > # Create all the points.
        > points = []
        > for position in point_positions:
        >     points.append(geo.createPoint())
        >     points[-1].setPosition(position)
        >
        > # Now create the polygons, adding vertices that refer to the points.
        > for point_indices in poly_point_indices:
        >     poly = geo.createPolygon()
        >     for point_index in point_indices:
        >         poly.addVertex(points[point_index])
        
        See also:
        
        * hou.Geometry.createPoint
        
        * hou.Geometry.createPolygon
        
        
        """
        pass
        
    
    def arcLength(u_start, u_stop, divs=10):
        """
        arcLength(self, u_start, u_stop, divs=10) ->float
        
        Given normalized (i.e. from 0 to 1) u_start and u_stop values,
        return the length of the arc of curve. divs represents the number of
        divisions per spans. Increasing it increases the precision of the
        computation.
        
        
        """
        pass
        
    
    def isClosed():
        """
        isClosed(self) -> bool
        
        Return whether the first and last vertex are connected.
        
        An open face forms a multi-segment line or curve, since the first
        and last vertices are not connected. A closed face forms a very thin
        surface.
        
        
        """
        pass
        
    
    def setIsClosed(on):
        """
        setIsClosed(self, on)
        
        Set whether the face is open or closed. See hou.Face.isClosed for
        more information. You would typically call this method from the code
        of a Python-defined SOP.
        
        Note that this method will raise hou.OperationFailed on a Bezier
        curve. See hou.Geometry.createBezierCurve for more information.
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable.
        
        
        """
        pass
        
    
    def closed():
        """None"""
        pass
        

def Face_swigregister():
    """None"""
    pass
    

class FlipbookSettings(object):
    """
    hou.FlipbookSettings
    
    A collection of options for the viewport flipbook dialog.
    
    The viewport flipbook has a set of options beyond the Display Options
    provided by the viewport itself. This object contains all these
    settings.
    
    * Use hou.SceneViewer.flipbookSettings to get this object representing
    the current flipbook settings for the viewer. Changing the options
    on this object changes the settings for future interactive flipbooks
    generated from the viewer.
    
    * You can also pass the settings object directly to
    hou.SceneViewer.flipbook to generate a flipbook using the current
    settings.
    
    * To generate a flipbook using custom settings, first use
    hou.SceneViewer.flipbookSettings to get the current settings, and
    call hou.FlipbookSettings.stash to create a copy (so changing the
    options won't affect the viewer's interactive options). Then modify
    the settings and pass the object to hou.SceneViewer.flipbook.
    
    > # Copy the viewer's current flipbook settings
    > flipbook_options = scene.flipbookSettings().stash()
    >
    > # Change the settings however you need
    > # (for example, set the frame range and output filename)
    > flipbook_options.frameRange( (frame, frame) )
    > flipbook_options.output(filename)
    >
    > # Generate the flipbook using the modified settings
    > scene.flipbook(scene.curViewport(), flip_options)
    
    """
    
    def LUT():
        """
        LUT(self) -> str
        
        The current LUT used for flipbooking.
        
        
        """
        pass
        
    
    def frameIncrement():
        """
        frameIncrement(self) -> int
        
        The current frame increment of the flipbook.
        
        
        """
        pass
        
    
    def visibleTypes():
        """
        visibleTypes(self) -> hou.flipbookObjectType
        
        The current visible object types.
        
        
        """
        pass
        
    
    def initializeSimulations():
        """
        initializeSimulations(self) -> bool
        
        The current state of simulation initialization. True indicates that
        simulations will be reset, and False indicates that any cached
        results will be used.
        
        
        """
        pass
        
    
    def focusDistance():
        """
        focusDistance(self) -> double
        
        Query the focus distance setting, the distance from the camera where
        objects are perfectly in focus.
        
        
        """
        pass
        
    
    def copy(from_settings):
        """
        copy(self, from_settings)
        
        Copy all settings in from_settings into this object.
        
        
        """
        pass
        
    
    def cropOutMaskOverlay():
        """
        cropOutMaskOverlay(self) -> bool
        
        Query if the resulting image will be cropped to the camera area.
        
        
        """
        pass
        
    
    def useResolution():
        """
        useResolution(self) -> bool
        
        Query if the resolution is defined by the flipbook dialog (True) or
        by the current size of the viewport (False).
        
        
        """
        pass
        
    
    def depthOfFieldFromCamera():
        """
        depthOfFieldFromCamera(self) -> bool
        
        Query if the depth of field parameters (focusDistance, aperture,
        fStop) are sourced from a camera (True) or the flipbook dialog
        settings
        
        
        """
        pass
        
    
    def visibleObjects():
        """
        visibleObjects(self) -> str
        
        The current visibility list for objects to be rendered.
        
        
        """
        pass
        
    
    def aperture():
        """
        aperture(self) -> double
        
        Query the default aperture setting.
        
        
        """
        pass
        
    
    def backgroundImage():
        """
        backgroundImage(self) -> str
        
        The pathname of the background image or images.
        
        
        """
        pass
        
    
    def shutterFromCamera():
        """
        shutterFromCamera(self) -> bool
        
        Query if the shutter is sourced from the camera or the flipbook
        dialog.
        
        
        """
        pass
        
    
    def audioFrameStart():
        """
        audioFrameStart(self) -> double
        
        The frame where the audio will be playing audioTimeOffset seconds.
        
        
        """
        pass
        
    
    def useMotionBlur():
        """
        useMotionBlur(self) -> bool
        
        Query if motion blur is enabled.
        
        
        """
        pass
        
    
    def sessionLabel():
        """
        sessionLabel(self) -> str
        
        The current flipbook session label.
        
        
        """
        pass
        
    
    def motionBlurFrameRange():
        """
        motionBlurFrameRange(self) -> hou.flipbookMotionBlurBias
        
        Query the subframe range for motion blur:
        
        * hou.flipbookMotionBlurBias.Centered: Subframe range is centered
        around the currently rendering frame.
        
        * hou.flipbookMotionBlurBias.Forward: Subframe range starts at the
        currently rendering frame.
        
        * hou.flipbookMotionBlurBias.Previous: Subframe range ends at the
        currently rendering frame.
        
        
        """
        pass
        
    
    def outputZoom():
        """
        outputZoom(self) -> int
        
        Query the output zoom level. Valid settings are 100, 75, 50, and 25.
        
        
        """
        pass
        
    
    def useDepthOfField():
        """
        useDepthOfField(self) -> bool
        
        Query if depth of field rendering is on.
        
        
        """
        pass
        
    
    def fStop():
        """
        fStop(self) -> double
        
        Query the f-stop setting.
        
        
        """
        pass
        
    
    def motionBlurSegments():
        """
        motionBlurSegments(self) -> int
        
        Query the number of subframes currently used for motion blur.
        
        
        """
        pass
        
    
    def leaveFrameAtEnd():
        """
        leaveFrameAtEnd(self) -> bool
        
        Query if the playbar frame is being left at the last frame (True) or
        restored to the previous frame (False).
        
        
        """
        pass
        
    
    def audioFilename(audio_file):
        """
        audioFilename(self, audio_file)
        
        The current audio file used by the flipbook.
        
        
        """
        pass
        
    
    def frameRange():
        """
        frameRange(self) -> tuple of double
        
        The current frame range of the flipbook, as a tuple of 2 ints
        (start, end).
        
        
        """
        pass
        
    
    def fromAudioPanel():
        """
        fromAudioPanel(self) -> bool
        
        When enabled, the flipbook gets it's audio settings from the Audio
        Panel.
        
        
        """
        pass
        
    
    def audioTimeOffset():
        """
        audioTimeOffset(self) -> double
        
        The audio time that will be playing at audioFrameStart frames.
        
        
        """
        pass
        
    
    def beautyPassOnly():
        """
        beautyPassOnly(self) -> bool
        
        The current state of the beauty pass render flag.
        
        
        """
        pass
        
    
    def overrideLUT():
        """
        overrideLUT(self) -> bool
        
        The current state of the LUT override.
        
        
        """
        pass
        
    
    def outputToMPlay():
        """
        outputToMPlay(self) -> bool
        
        Query if images are being sent to an interactive MPlay sesion.
        
        
        """
        pass
        
    
    def renderAllViewports():
        """
        renderAllViewports(self) -> bool
        
        Render all visible viewports (True), or only the currently selected
        one.
        
        
        """
        pass
        
    
    def scopeChannelKeyframesOnly():
        """
        scopeChannelKeyframesOnly(self) -> bool
        
        The current state of scoped keyframe mode.
        
        
        """
        pass
        
    
    def overrideGamma():
        """
        overrideGamma(self) -> bool
        
        The current state of the gamma override.
        
        
        """
        pass
        
    
    def stash():
        """
        stash(self) -> hou.FlipbookSettings
        
        Return a new copy of this FlipbookSettings object. Changes to this
        new object will not update the flipbook dialog, but can be passed to
        hou.SceneViewer.flipbook() as the settings to use.
        
        
        """
        pass
        
    
    def shutter():
        """
        shutter(self) -> double
        
        Query the current camera shutter for motion blur.
        
        
        """
        pass
        
    
    def depthOfFieldQuality():
        """
        depthOfFieldQuality(self) -> double
        
        Return the number of images rendered to simulate depth of field
        blur.
        
        
        """
        pass
        
    
    def blockEditing():
        """
        blockEditing(self) -> bool
        
        The current state of block editing mode.
        
        
        """
        pass
        
    
    def output():
        """
        output(self) -> str
        
        The current output destination for flipbooking.
        
        
        """
        pass
        
    
    def antialias():
        """
        antialias(self) -> hou.flipbookAntialias
        
        Query the current flipbook antialiasing setting:
        
        * hou.flipbookAntialias.UseViewportSetting: Use the current viewport
        setting.
        
        * hou.flipbookAntialias.Off: No antialiasing.
        
        * hou.flipbookAntialias.Fast: Minimal 2-sample antialiasing.
        
        * hou.flipbookAntialias.Good: 4-sample antialiasing.
        
        * hou.flipbookAntialias.HighQuality: 8-sample antialiasing.
        
        
        """
        pass
        
    
    def resolution():
        """
        resolution(self) -> tuple of int
        
        Returns a 2-tuple of ints representing the width and height of the
        flipbook dialog image output resolution. This is not used unless
        useResolution is enabled.
        
        
        """
        pass
        
    
    def appendFramesToCurrent():
        """
        appendFramesToCurrent(self) -> bool
        
        The current state of the flipbook append mode, either Append (True)
        or Overwrite (False).
        
        
        """
        pass
        
    
    def gamma():
        """
        gamma(self) -> double
        
        The current gamma value.
        
        
        """
        pass
        

def FlipbookSettings_swigregister():
    """None"""
    pass
    

class FloatParmTemplate(ParmTemplate):
    """
    hou.FloatParmTemplate
    
    Describes a parameter tuple containing floating point values.
    
    
    """
    
    def setDefaultExpression(tuple_of_default_expressions):
        """
        setDefaultExpression(self, tuple_of_default_expressions)
        
        Set the default expression for new parameter instances to a sequence
        of strings.
        
        See the hou.FloatParmTemplate.defaultExpression method for more
        information. Note that if the number of strings in the sequence is
        different from the number of components in the parm template, any
        extra values will be discarded and any missing expressions will
        become the empty string.
        
        
        """
        pass
        
    
    def setDefaultValue(tuple_of_default_values):
        """
        setDefaultValue(self, tuple_of_default_values)
        
        Set the default value for new parameter instances to a sequence of
        floats.
        
        See the defaultValue method for more information. Note that if the
        number of floats in the sequence is different from the number of
        components in the parm template, any extra values will be discarded
        and any missing values will become zeros.
        
        
        """
        pass
        
    
    def setDefaultExpressionLanguage(tuple_of_default_expression_languages):
        """
        setDefaultExpressionLanguage(self,
        tuple_of_default_expression_languages)
        
        Set the default expression language for new parameter instances to a
        sequence of hou.scriptLanguage values.
        
        See the defaultExpressionLanguage method for more information. Note
        that if the number of hou.scriptLanguage values in the sequence is
        different from the number of components in the parm template, any
        extra values will be discarded and any missing expression languages
        will become hou.scriptLanguage.Hscript.
        
        
        """
        pass
        
    
    def maxValue():
        """
        maxValue(self) -> float
        
        Return the minimum value of the parameter.
        
        See also the minIsStrict method.
        
        
        """
        pass
        
    
    def minValue():
        """
        minValue(self) -> float
        
        Return the minimum value of the parameter.
        
        See also the minIsStrict method.
        
        
        """
        pass
        
    
    def setMaxValue(max_value):
        """
        setMaxValue(self, max_value)
        
        Set the maximum value of the parameter.
        
        See the maxValue method for more information.
        
        
        """
        pass
        
    
    def setMinIsStrict(on):
        """
        setMinIsStrict(self, on)
        
        Set whether the minimum value is strictly enforced.
        
        See the minIsStrict method for more information.
        
        
        """
        pass
        
    
    def setMaxIsStrict(on):
        """
        setMaxIsStrict(self, on)
        
        Set whether the maximum value is strictly enforced.
        
        See the maxIsStrict method for more information.
        
        
        """
        pass
        
    
    def defaultExpression():
        """
        defaultExpression(self) -> tuple of strings
        
        Return the default expression for new parameter instances.
        
        The default expression takes precedence over the default value. If a
        component has no default expression (i.e. an empty string), then the
        default value is used for new parameter instances.
        
        Note that the default expression language is needed to interpret the
        meaning of the default expression.
        
        For example, suppose this parm template is named "t", the naming
        scheme is XYZW, it has 3 components, the default value is (1.0, 2.0,
        3.0), the default expression is ("$F", "hou.frame()", "") and the
        default expression language is (hou.scriptLanguage.Hscript,
        hou.scriptLanguage.Python, hou.scriptLanguage.Hscript). Then the
        corresponding parm tuple instance on a node would be named "t" and
        would contain parameters "tx", "ty", "tz". When the node is created,
        "tx" would have a default Hscript expression of "$F", "ty" would
        have a default Python expression of "hou.frame()", and "tz" would
        have a default value of 3.0.
        
        
        """
        pass
        
    
    def defaultValue():
        """
        defaultValue(self) -> tuple of float
        
        Return the default value for new parameter instances.
        
        For example, suppose this parm template is named "t", the naming
        scheme is XYZW, it has 3 components, and the default value is (1.0,
        2.0, 3.0). The corresponding parm tuple instance on a node would be
        named "t" and would contain parameters "tx", "ty", and "tz". When
        the node is created, "tx" would be 1.0, "ty" would be 2.0, and "tz"
        would be 3.0.
        
        
        """
        pass
        
    
    def setMinValue(min_value):
        """
        setMinValue(self, min_value)
        
        Set the minimum value of the parameter.
        
        See the minValue method for more information.
        
        
        """
        pass
        
    
    def defaultExpressionLanguage():
        """
        defaultExpressionLanguage(self) -> tuple of hou.scriptLanguage
        
        Return the default expression language for new parameter instances.
        
        The default expression language only applies if the default
        expression is set. If the default expression of a component is not
        set, then the expression language is set to
        hou.scriptLanguage.Hscript.
        
        
        """
        pass
        
    
    def minIsStrict():
        """
        minIsStrict(self) -> bool
        
        Return whether the minimum value is strictly enforced.
        
        If a minimum value is not strictly enforced, the slider will not let
        you change the value below the minimum, but you can set the value to
        be lower than the minimum by typing it in, changing it via
        hou.Parm.setValue, or using the ladder handle.
        
        If it is strictly enforced and you try to change it below the
        minimum value using any mechanism, Houdini will set it to the
        minimum value.
        
        See also the minValue method.
        
        
        """
        pass
        
    
    def maxIsStrict():
        """
        maxIsStrict(self) -> bool
        
        Return whether the maximum value is strictly enforced.
        
        See the minIsStrict method for more information.
        
        
        """
        pass
        

def FloatParmTemplate_swigregister():
    """None"""
    pass
    

class FloatingPanel(object):
    """
    hou.FloatingPanel
    
    A floating window that contains one or more panes.
    
    Much like a desktop, a floating panel contains panes. A floating panel
    may be attached to a desktop, in which case it is saved with the
    desktop, hidden when the desktop is closed, and shown when the desktop
    is opened. You can use floating panels to create desktops that span
    multiple monitors.
    
    When you create a new floating panel, for example, it contains a single
    pane, which in turn contains a single pane tab showing the network
    editor.
    
    Note that a floating panel may be locked to one particular pane tab.
    These stripped down panels do not display the interface for adding new
    pane tabs or splitting panes. In fact, these stripped down floating
    panels do not contain any panes at all, and hou.FloatingPanel.panes will
    return an empty tuple. You can create such a stripped down floating
    panel with hou.Desktop.createFloatingPaneTab.
    
    See hou.Desktop for more information about panes and pane tabs.
    
    
    """
    
    def panes():
        """
        panes(self) -> tuple of hou.Pane
        
        Return all the panes inside the panel. As mentioned in the
        documentation for this class, a floating panel may be stripped down
        and locked to one particular pane tab, and these stripped down
        floating panels do not contain any panes.
        
        
        """
        pass
        
    
    def setName(name):
        """
        setName(self, name)
        
        Set this panel's name. Any characters in the name that are not
        letters, numbers, or underscores are replaced with underscores.
        
        Raises hou.OperationFailed if the name is an empty string.
        
        
        """
        pass
        
    
    def findPaneTab(name):
        """
        findPaneTab(self, name) -> hou.PaneTab or None
        
        Return the pane tab with the given name, or None if no such tab
        exists.
        
        
        """
        pass
        
    
    def isAttachedToDesktop():
        """
        isAttachedToDesktop(self) -> bool
        
        Return whether or not this panel is attached to the desktop. Panels
        attached to the desktop are saved with the desktop and are opened
        when the desktop is opened and closed when the desktop is closed.
        
        See also hou.FloatingPanel.attachToDesktop.
        
        
        """
        pass
        
    
    def setIsFullscreen(on):
        """
        setIsFullscreen(self, on)
        
        Set whether or not this panel is in full screen mode.
        
        See also hou.FloatingPanel.isFullscreen.
        
        
        """
        pass
        
    
    def containsMenuBar():
        """
        containsMenuBar(self) -> bool
        
        Return whether or not this panel contains Houdini's main menu bar.
        
        See also hou.FloatingPanel.setContainsMenuBar.
        
        
        """
        pass
        
    
    def paneTabOfType(type, index=0):
        """
        paneTabOfType(self, type, index=0) -> hou.PaneTab or None
        
        Find and return the pane tab with the desired type or None if no
        such pane tab exists.
        
        
        type
        A hou.paneTabType enumerated variable.
        
        index
        If there are multiple tabs with the desired type, this parameter
        determines which one is returned. Use index=0 to return the
        first found tab, index=1 to return the second found tab, etc. By
        default, index is 0.
        
        
        """
        pass
        
    
    def setContainsPlaybar(on):
        """
        setContainsPlaybar(self, on)
        
        If on is True, move Houdini's playbar to this panel. Otherwise, move
        it back to the main desktop window.
        
        See also hou.FloatingPanel.containsPlaybar.
        
        
        """
        pass
        
    
    def setContainsStatusBar(on):
        """
        setContainsStatusBar(self, on)
        
        If on is True, move Houdini's status bar to this panel. Otherwise,
        move it back to the main desktop window.
        
        See also hou.FloatingPanel.containsStatusBar.
        
        
        """
        pass
        
    
    def close():
        """
        close(self)
        
        Close the floating panel's window, closing all the pane tabs inside
        it.
        
        
        """
        pass
        
    
    def setPosition(position):
        """
        setPosition(self, position)
        
        Move the floating panel window to the specified desktop position (in
        pixels).
        
        Raise hou.TypeError if position does not contain exactly two values.
        
        
        """
        pass
        
    
    def containsPlaybar():
        """
        containsPlaybar(self) -> bool
        
        Return whether or not this panel contains Houdini's playbar.
        
        See also hou.FloatingPanel.setContainsPlaybar.
        
        
        """
        pass
        
    
    def setContainsShelf(on):
        """
        setContainsShelf(self, on)
        
        If on is True, move Houdini's shelf to this panel. Otherwise, move
        it back to the main desktop window.
        
        See also hou.FloatingPanel.containsShelf.
        
        
        """
        pass
        
    
    def size():
        """
        size(self) -> hou.Vector2
        
        Return the floating panel window's size (in pixels).
        
        
        """
        pass
        
    
    def name():
        """
        name(self) -> str
        
        Return the name of the floating panel. The panel's name is displayed
        in its window's title.
        
        
        """
        pass
        
    
    def isFullscreen():
        """
        isFullscreen(self) -> bool
        
        Return whether or not this panel is in full screen mode.
        
        See also hou.FloatingPanel.setIsFullscreen.
        
        
        """
        pass
        
    
    def containsShelf():
        """
        containsShelf(self) -> bool
        
        Return whether or not this panel contains Houdini's shelf.
        
        See also hou.FloatingPanel.setContainsShelf.
        
        
        """
        pass
        
    
    def attachToDesktop(on):
        """
        attachToDesktop(self, on)
        
        Attach this panel to the desktop. See
        hou.FloatingPanel.isAttachedToDesktop for more information.
        
        
        """
        pass
        
    
    def paneTabs():
        """
        paneTabs(self) -> tuple of hou.PaneTab
        
        Return all the pane tabs that are in this floating panel, regardless
        of which pane they are in.
        
        
        """
        pass
        
    
    def position():
        """
        position(self) -> hou.Vector2
        
        Return the desktop position (in pixels) of the floating panel
        window.
        
        
        """
        pass
        
    
    def setContainsMenuBar(on):
        """
        setContainsMenuBar(self, on)
        
        If on is True, move Houdini's main menu bar to this panel.
        Otherwise, move it back to the main desktop window.
        
        See also hou.FloatingPanel.containsMenuBar.
        
        
        """
        pass
        
    
    def setSize(size):
        """
        setSize(self, size)
        
        Resize the floating panel window (in pixels).
        
        Raise hou.TypeError if size does not contain exactly two values.
        Raise hou.TypeError if size contains a value that is less than or
        equal to zero.
        
        
        """
        pass
        
    
    def containsStatusBar():
        """
        containsStatusBar(self) -> bool
        
        Return whether or not this panel contains Houdini's status bar (the
        bar at the bottom of the desktop for status messages).
        
        See also hou.FloatingPanel.setContainsStatusBar.
        
        
        """
        pass
        

def FloatingPanel_swigregister():
    """None"""
    pass
    

class FolderParmTemplate(ParmTemplate):
    """
    hou.FolderParmTemplate
    
    Describes a folder in a parameter dialog.
    
    Unlike all other hou.ParmTemplate subclasses, a folder does not
    correspond to an individual hou.ParmTuple. Instead, the set of adjacent
    folders form a folder set, and there is one parameter for this set that
    controls which folder is currently visible. These folder sets correspond
    to hou.FolderSetParmTemplate objects.
    
    Folder parm template objects are useful when manipulating the parameter
    interface of a node or a digital asset definition. Unlike folder set
    parm templates, they contain the parm templates inside the folder. They
    also let you add, remove, or hide an individual folder or move it from
    set one to another using hou.ParmTemplateGroup objects. Doing these
    individual folder-level operations is not possible with folder set parm
    templates.
    
    Note that folder parm templates are also used to represent multiparm
    blocks, much like the <Type Properties> dialog does. The folder parm
    template's hou.folderType determines whether it is a folder or a
    multiparm block. Unlike folder parm templates, which do not correspond
    directly to parameter instances, a multiparm parm template does
    correspond to an integer parameter that controls the number of instances
    of the multiparm.
    
    
    """
    
    def endsTabGroup():
        """
        endsTabGroup(self) -> bool
        
        Return whether this folder will be the last in the folder set, even
        if the next parameter is also a folder. In that case, the next
        parameter will begin a new folder set.
        
        This parameter only has meaning if the parm template is for an
        actual folder and not for a multiparm block.
        
        
        """
        pass
        
    
    def setTabConditional(type, conditional):
        """
        setTabConditional(self, type, conditional)
        
        Set a conditional string of the given hou.parmCondType type that
        affects the folder tab generated by this parameter template. The
        string consists of rules on how this parameter's folder tab's
        display behaves when other parameters change.
        
        See the Conditionals section of the <Operator Type Properties
        window> help for more information on conditional strings.
        
        Raises hou.OperationFailed if this parameter template is for a
        multi-parameter or import block.
        
        
        """
        pass
        
    
    def setDefaultValue(tuple_of_default_values):
        """
        setDefaultValue(self, tuple_of_default_values)
        
        Set the default value to an integer.
        
        The default value is only used for folders that are multiparm
        blocks. See the defaultValue method for more information.
        
        
        """
        pass
        
    
    def addParmTemplate(parm_template):
        """
        addParmTemplate(self, parm_template)
        
        Append a parm template to the end of the list of parm templates
        inside the folder.
        
        Note that hou.ParmTemplateGroup provides a number of methods to
        insert parm templates inside folders, including
        hou.ParmTemplateGroup.appendToFolder.
        
        
        """
        pass
        
    
    def parmTemplates():
        """
        parmTemplates(self) -> tuple of hou.ParmTemplate
        
        Return a tuple of copies of the parm templates stored inside this
        folder.
        
        Because copies are returned, you cannot change the contents of the
        parm templates inside this folder by modifying the parm templates
        returned. Instead, use methods in hou.ParmTemplateGroup to modify
        parm templates in this folder.
        
        
        """
        pass
        
    
    def tabConditionals():
        """
        tabConditionals(self) -> dict of [Hom:hou.parmCondType] enum value to
        string
        
        Returns the set of conditionals that affect the folder tab generated
        by this parameter template. The conditionals correspond to the Tab
        disable when and Tab hide when properties that appear Edit Parameter
        Interface window for folder parameters.
        
        See the Conditionals section of the <Operator Type Properties
        window> help for more information on conditional strings.
        
        This method returns an empty dictionary if this parameter template
        is for a multi-parameter or import block.
        
        
        """
        pass
        
    
    def folderType():
        """
        folderType(self) -> hou.folderType enum value
        
        Return the type of folder. Note that the folder may actually be a
        multiparm block.
        
        
        """
        pass
        
    
    def setEndsTabGroup():
        """None"""
        pass
        
    
    def folderStyle():
        """None"""
        pass
        
    
    def defaultValue():
        """
        defaultValue(self) -> int
        
        Return the integer default value.
        
        The default value is only used for folders that are multiparm
        blocks, and controls the default number of multiparm instances in
        newly created nodes.
        
        
        """
        pass
        
    
    def isActualFolder():
        """
        isActualFolder(self) -> bool
        
        Return whether or not this parm template corresponds to an actual
        folder, as opposed to a multiparm or import block.
        
        This method can be implemented as follows:
        
        > def isActualFolder(self):
        >     return self.folderType() in (
        >         hou.folderType.Tabs, hou.folderType.RadioButtons)
        
        """
        pass
        
    
    def setFolderType(folder_type):
        """
        setFolderType(self, folder_type)
        
        Set the type of folder to a hou.folderType enum value.
        
        
        """
        pass
        
    
    def setParmTemplates(parm_templates):
        """
        setParmTemplates(self, parm_templates)
        
        Replace the parm templates inside this folder with a new sequence of
        parm templates.
        
        
        """
        pass
        

def FolderParmTemplate_swigregister():
    """None"""
    pass
    

class FolderSetParmTemplate(ParmTemplate):
    """
    hou.FolderSetParmTemplate
    
    Describes a set of folders.
    
    A folder set is a group of adjacent folders, and only one of those
    folders can be displayed at a time. A folder set corresponds to one
    parameter, and the value of that parameter determines which folder is
    displayed.
    
    Note that there is also a hou.FolderParmTemplate class. Folder sets are
    used when there is a mapping to a parameter; for example, asking a
    hou.ParmTuple for its parm template may return a folder set, but it will
    never return a folder. Folder parm templates are used by
    hou.ParmTemplateGroup because they easily let you add, remove, and move
    individual folders, and they let you easily place parameters inside
    folders. Attempting to place folder set parm templates in
    hou.ParmTemplateGroup objects will raise hou.OperationFailed.
    
    
    """
    
    def folderStyle():
        """
        folderStyle(self) -> hou.folderType enum value
        
        This method is deprecated. It is an alias for the folderType method.
        
        
        """
        pass
        
    
    def setFolderNames():
        """None"""
        pass
        
    
    def folderNames(folder_names):
        """
        setFolderNames(self, folder_names)
        
        Set the names of the folders in this set to the given sequence of
        strings.
        
        See the folderNames method for more information.
        
        Raises hou.OperationFailed if folder_names is an empty sequence.
        
        
        """
        pass
        
    
    def setFolderType(folder_type):
        """
        setFolderType(self, folder_type)
        
        Set the type of folder to a hou.folderType enum value.
        
        Raises TypeError if the folder type is for a multiparm or import
        block.
        
        
        """
        pass
        
    
    def folderType():
        """
        folderType(self) -> hou.folderType enum value
        
        Return the type of folder.
        
        
        """
        pass
        

def FolderSetParmTemplate_swigregister():
    """None"""
    pass
    

class Gallery(object):
    """
    hou.Gallery
    
    A collection of gallery entries that can be applied to operator nodes to
    set their parameters to predefined values.
    
    In Houdini, a gallery is a collection of node templates and their
    parameter presets, which are represented by a hou.GalleryEntry. A
    gallery corresponds to a file where such templates are saved. Galleries
    can be managed with a hou.galleries module.
    
    
    """
    
    def createEntry():
        """None"""
        pass
        
    
    def galleryEntries(name_pattern=None, label_pattern=None, keyword_pattern=None, category=None, node_type=None):
        """
        galleryEntries(self, name_pattern=None, label_pattern=None,
        keyword_pattern=None, category=None, node_type=None) -> tuple of
        hou.GalleryEntry
        
        Return a tuple of entries that are stored in the gallery. See also
        hou.galleries.galleryEntries.
        
        
        name_pattern
        A pattern that the gallery entry name must match to be included
        in the returned tuple. The pattern can contain '?' to match a
        single character, '*' to match any number of characters, and ''
        to match any character in the set. If None, all gallery entries
        are considered to match it.
        
        label_pattern
        A pattern that the gallery entry label must match to be included
        in the returned tuple. See the name_pattern above for special
        characters in the pattern. If None, all gallery entries are
        considered to match it.
        
        keyword_pattern
        A pattern that any of the the gallery entry keywords needs to
        match for the entry to be included in the returned tuple. See
        the name_pattern above for special characters in the pattern. If
        None, all gallery entries are considered to match it.
        
        category
        If not None, only gallery entries in the specified category will
        be included in the returned tuple.
        
        node_type
        If not None, only gallery entries for a given node type will be
        included in the returned tuple.
        
        
        """
        pass
        
    
    def deleteEntry():
        """None"""
        pass
        

class GalleryEntry(object):
    """
    hou.GalleryEntry
    
    A gallery entry that can be applied to operator nodes to set their
    parameters to predefined values.
    
    A gallery entry is an entity containing data about an operator node
    setup. It has information about the node's parameter values, any
    additional spare parameters, channels, and for subnet nodes the
    information about the children, etc. Thus, a gallery entry is like a
    node template or a parameter preset. Such templates can be created from
    and applied to existing nodes.
    
    A gallery entry is identified by a unique, and has a non-unique label,
    and is usually associated with a specific hou.NodeType (or several node
    types) of the nodes to which it applies. In addition to the node
    information, gallery entries can have own categories that organize them
    into manageable sets and also can have keywords that identify their
    purpose. For more information about gallery entries, please see a
    gallery entry editor.
    
    In order for your gallery entries to appear in the Material Palette
    pane, they must satisfy two conditions. First, the node category must be
    set to indicate the gallery entry creates a SHOP node. Use code like:
    
    > hou.galleries.galleryEntries("entry_name")[0].setNodeTypeCategory(hou.shopNodeTypeCategory())
    
    The second condition is that the entry must contain one or more keywords
    that indicate what renderer the SHOP works with. This affects whether
    the gallery entry appears when a specific renderer is chosen in the
    Material Palette renderer menu. Even if "All" is chosen in that menu,
    the gallery entry must contain a keyword that matches one of the
    renderers that appears in that menu. To associate a gallery entry with
    the Mantra renderer, do the following:
    
    > hou.galleries.galleryEntries("entry_name")[0].setKeywords(('Mantra',))
    
    In HOM the gallery entries can be managed using hou.Gallery.
    
    
    """
    
    def setContentsFromNode(node):
        """
        setContentsFromNode(self, node)
        
        Save the information about the node contents (i.e., child nodes).
        When applying the node entry later on, these nodes will be
        reconstructed in a new parent to match the contents of the current
        parent.
        
        
        node
        The parent of the nodes whose data should be saved.
        
        
        """
        pass
        
    
    def setScript(script):
        """
        setScript(self, script)
        
        Set a script that modifies the parameters when the gallery entry is
        applied to a node.
        
        
        script
        A string that contains the commands setting the node's
        parameters.
        
        
        """
        pass
        
    
    def setLabel(label):
        """
        setLabel(self, label)
        
        Set the gallery entry label.
        
        
        label
        The label string.
        
        
        """
        pass
        
    
    def setHelpURL(helpurl):
        """
        setHelpURL(self, helpurl)
        
        Set the URL of the help document for this gallery entry.
        
        
        """
        pass
        
    
    def keywords():
        """
        keywords(self) -> tuple of strings
        
        Return the keywords that describe this gallery entry.
        
        
        """
        pass
        
    
    def setNodeTypeNames(nodetypes):
        """
        setNodeTypeNames(self, nodetypes)
        
        Set the names of the node types this gallery should be associated
        with.
        
        
        nodetypes
        A string containing white-space separated list of node type
        names.
        
        
        """
        pass
        
    
    def setDescription(description):
        """
        setDescription(self, description)
        
        Set the description of the gallery entry.
        
        
        description
        The text briefly describing the gallery entry purpose.
        
        
        """
        pass
        
    
    def nodeTypeNames():
        """
        nodeTypeNames(self) -> tuple of strings
        
        Return the names of the node type this gallery is associated with.
        The gallery can be safely applied to the nodes of these types.
        
        
        """
        pass
        
    
    def script():
        """
        script(self) -> string
        
        Return a script that modifies the node parameters to match the
        information stored in the gallery entry.
        
        
        """
        pass
        
    
    def label():
        """
        label(self) -> str
        
        Return the gallery entry label.
        
        
        """
        pass
        
    
    def setScriptFromNode(node):
        """
        setScriptFromNode(self, node)
        
        Set a script that modifies node parameters. Later on, when applying
        this gallery entry to a node, the script will reconstruct that
        node's parameters to match exactly the parameters of a node passed
        to this method.
        
        
        node
        A node object from which to build the script.
        
        
        """
        pass
        
    
    def setCategories(categories):
        """
        setCategories(self, categories)
        
        Set the categories this gallery entry subscribes to.
        
        
        categories
        A string with comma separated categories to set the gallery
        entry to.
        
        
        """
        pass
        
    
    def setIcon(icon):
        """
        setIcon(self, icon)
        
        Set the icon name or an icon file path that should be used for this
        gallery entry.
        
        
        """
        pass
        
    
    def setEqual(entry):
        """
        setEqual(self, entry)
        
        Set this gallery entry to be exactly the same as the given entry,
        except for the name, which is left unchanged.
        
        
        entry
        The gallery entry to copy the information from.
        
        
        """
        pass
        
    
    def description():
        """
        description(self) -> string
        
        Return a description of the gallery entry. A description is a short
        string that states the gallery entry purpose. It is used for tool-
        tip pop-ups.
        
        
        """
        pass
        
    
    def setName(name):
        """
        setName(self, name)
        
        Set the gallery entry name.
        
        
        name
        The name string.
        
        
        """
        pass
        
    
    def setNodeTypeCategory(category):
        """
        setNodeTypeCategory(self, category)
        
        Set the category of the node types this gallery entry should be
        associated with.
        
        
        category
        A hou.NodeTypeCategory to associate this gallery entry with.
        
        
        """
        pass
        
    
    def createChildNode(parent):
        """
        createChildNode(self, parent) -> Node
        
        Create a new node in the parent network and then apply this gallery
        entry to that newly created node.
        
        
        parent
        A subnetwork within which the new node should be created. If
        None, an implicit natural parent is chosen using a node type
        this gallery entry is associated with.
        
        
        """
        pass
        
    
    def setRequiredHDAFile(hda_file):
        """
        setRequiredHDAFile(self, hda_file)
        
        Set a file path to an HDA library on which this gallery entry
        depends.
        
        
        hda_file
        A path of the HDA library file (OTL).
        
        
        """
        pass
        
    
    def categories():
        """
        categories(self) -> tuple of strings
        
        Return the categories this gallery entry subscribes to.
        
        
        """
        pass
        
    
    def icon():
        """
        icon(self) -> string
        
        Return the icon name or a icon file path that should be used for
        this gallery entry.
        
        
        """
        pass
        
    
    def requiredHDAFile():
        """
        requiredHDAFile(self) -> string
        
        Return a file path to an HDA library that should be loaded before
        trying to apply this gallery entry. It is often used for gallery
        entries associated with a non-native operator type.
        
        
        """
        pass
        
    
    def canCreateChildNode(parent):
        """
        canCreateChildNode(self, parent) -> bool
        
        Return True if hou.GalleryEntry.createChildNode can succeed.
        
        
        """
        pass
        
    
    def canApplyToNode(node):
        """
        canApplyToNode(self, node) -> bool
        
        Return True if this gallery entry can be safely applied to the given
        node. See hou.GalleryEntry.applyToNode for more info.
        
        
        node
        A node to test whether the gallery entry can be applied to.
        
        
        """
        pass
        
    
    def nodeTypeCategory():
        """
        nodeTypeCategory(self) -> NodeTypeCategory
        
        Return the category of the node types this gallery entry is
        associated with.
        
        
        """
        pass
        
    
    def name():
        """
        name(self) -> string
        
        Return the gallery entry name.
        
        
        """
        pass
        
    
    def applyToNode(node):
        """
        applyToNode(self, node)
        
        Apply the gallery entry to a given node. This method sets the node's
        parameter values to match the ones stored by the entry. It may also
        add spare parameters and channels to the node and for the subnets,
        it may create new child nodes.
        
        
        node
        A node to which to apply the gallery entry.
        
        
        """
        pass
        
    
    def bestNodeType():
        """
        bestNodeType(self) -> NodeType or None
        
        Return a best node type which this gallery entry is associated with
        and whose nodes it can be applied to.
        
        
        """
        pass
        
    
    def helpURL():
        """
        helpURL(self) -> string
        
        Return the URL of the help document for this gallery entry.
        
        
        """
        pass
        
    
    def allowIconRegeneration():
        """
        allowIconRegeneration(self) -> bool
        
        Return True if this gallery entry wants to let Houdini regenerate
        the icon for it automatically using an appropriate renderer. Only
        applies to material gallery entries.
        
        
        """
        pass
        
    
    def setKeywords(keywords):
        """
        setKeywords(self, keywords)
        
        Set the keywords that describe this gallery entry.
        
        
        keywords
        A string containing a white-space separated list of keywords.
        
        
        """
        pass
        
    
    def setAllowIconRegeneration(allow):
        """
        setAllowIconRegeneration(self, allow)
        
        Sets the allow icon regneration flag on this gallery entry.
        
        
        """
        pass
        

def GalleryEntry_swigregister():
    """None"""
    pass
    

def Gallery_swigregister():
    """None"""
    pass
    

class Geometry(object):
    """
    hou.Geometry
    
    A Geometry object contains the points and primitives that define a 3D
    geometric shape. For example, each SOP node in Houdini generates a
    single Geometry object.
    
    If you ask a SOP for its geometry via hou.SopNode.geometry, you'll get a
    read-only reference to it. If the SOP recooks, the corresponding
    Geometry object will update to the SOP's new geometry. If the SOP is
    deleted, accessing the Geometry object will raise a hou.ObjectWasDeleted
    exception. If you call methods that try to modify the geometry, they
    will raise a hou.GeometryPermissionError exception.
    
    If you do not want the geometry to update when the SOP recooks, you can
    call hou.Geometry.freeze. freeze returns another Geometry object that
    will not change when the SOP recooks. Accessing frozen Geometry is
    slightly faster, since Houdini does not need to look up the SOP node for
    each access, so you may want to use frozen geometry for speed-crucial
    operations.
    
    If you're writing a SOP using Python, you will have read-write access to
    the geometry, and it will be frozen. To create a Python-defined SOP,
    select File > New Operator Type... and place the Python code in the Code
    tab.
    
    Finally, you can allocate a new frozen geometry with read-write access
    by creating an instance of hou.Geometry.
    
    
    """
    
    def setVertexFloatAttribValues(name, values):
        """
        setVertexFloatAttribValues(self, name, values)
        
        For a particular attribute, set the attribute values for all
        vertices. You would typically call this method from the code of a
        Python-defined SOP.
        
        
        name
        The name of the vertex attribute.
        
        values
        A sequence of int or float values in the same format as that
        returned by hou.Geometry.vertexFloatAttribValues. See that
        method for more information.
        
        Raises hou.OperationFailed if the attribute name is not valid, the
        attribute is not an int or float (i.e. it's a string), or the array
        of values is not the correct size.
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable.
        
        Also see hou.Geometry.vertexFloatAttribValues.
        
        
        """
        pass
        
    
    def selection():
        """
        selection(self) -> hou.Selection
        
        Returns the current cook component selection associated with this
        geometry. This is the default selection set by the SOP that created
        the geometry.
        
        
        """
        pass
        
    
    def prim(index):
        """
        prim(self, index) -> hou.Prim
        
        Return the primitive at the specified index.
        
        This is a convenience method for accessing a particular primitive
        without the overhead of obtaining all primitives via
        hou.Geometry.prims.
        
        Return None if no such primitive at the specified index exists.
        
        
        """
        pass
        
    
    def setPrimFloatAttribValuesFromString():
        """None"""
        pass
        
    
    def point(index):
        """
        point(self, index) -> hou.Point
        
        Return the point at the specified index.
        
        This is a convenience method for accessing a particular point
        without the overhead of obtaining all points via
        hou.Geometry.points.
        
        Return None if no such point at the specified index exists.
        
        
        """
        pass
        
    
    def loadFromFile(file_name):
        """
        loadFromFile(self, file_name)
        
        Replace the contents of this geometry object with the data stored in
        a file. You would typically call this method from the code of a
        Python-defined SOP.
        
        You may specify any type of file supported by Houdini's File SOP.
        See hou.Geometry.saveToFile for more information.
        
        Raises hou.OperationFailed if the file does not exist or otherwise
        cannot be loaded.
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable.
        
        See also hou.Geometry.merge.
        
        
        """
        pass
        
    
    def _guDetailHandle():
        """None"""
        pass
        
    
    def renameVertexAttrib(old_name, new_name):
        """
        renameVertexAttrib(self, old_name, new_name)
        
        Rename the vertex attribute with the specified old name to the new
        name. This method is typically called from within a Python-defined
        SOP when the SOP's geometry is writable.
        
        Raises GeometryPermissionError if called on a read-only geometry.
        Raises TypeError if old_name or new_name is None. Raises
        OperationFailed if no such vertex attribute with the old name
        exists. Raises OperationFailed if a vertex attribute with the new
        name already exists.
        
        
        """
        pass
        
    
    def createEdgeGroup(name):
        """
        createEdgeGroup(self, name) -> hou.EdgeGroup
        
        Create a new edge group in this geometry.
        
        
        name
        The name of the new group. Raises hou.OperationFailed if a group
        with this name already exists.
        
        Use hou.EdgeGroup.destroy to remove an edge group from the geometry.
        
        
        """
        pass
        
    
    def intrinsicValue(intrinsic_name):
        """
        intrinsicValue(self, intrinsic_name) -> int, float, str, or tuple
        
        Gets the value of an "intrinsic", often computed, value of the
        geometry, such as memoryusage, pointcount, pointattributes, and so
        on. Raises OperationFailed if the given intrinsic name does not
        exist.
        
        You can also view these values in the user interface using the
        geometry spreadsheet.
        
        In Houdini, some primitives have "intrinsic" values which can't be
        accessed directly through the attribute interface. Most intrinsic
        values are computed, such as measuredarea, however a few are
        writeable with the setIntrinsicValue method. For example, sphere
        primitives have a transform matrix as part of their definition.
        
        You can get a list of the available intrinsic value names with the
        intrinsicNames method. Different geometry types will have different
        intrinsic values available.
        
        
        """
        pass
        
    
    def pointFloatAttribValues(name):
        """
        pointFloatAttribValues(self, name) -> tuple of float
        
        Return a tuple of floats containing one attribute's values for all
        the points.
        
        This method only works on int or float attributes. If the attribute
        contains more than one element, each point will correspond to
        multiple values in the result. For example, if "Cd" is a float
        attribute of size 3 and there are 3 points with values (0.1, 0.2,
        0.3), (0.5, 0.5, 0.5), and (0.8, 0.7, 0.6) then the result will be
        (0.1, 0.2, 0.3, 0.5, 0.5, 0.5, 0.8, 0.7, 0.6).
        
        Calling this method is faster than looping over all the points and
        calling hou.Point.attribValue.
        
        If the attribute name is invalid or the attribute is not an int or
        float (e.g. it's a string attribute), this method raises
        hou.OperationFailed.
        
        Note that you cannot pass a hou.Attrib object to this method like
        you can with many methods dealing with attributes. However, you can
        use hou.Attrib.name to easily get the name from an Attrib object.
        
        
        """
        pass
        
    
    def stringListAttribValue(name_or_attrib):
        """
        stringListAttribValue(self, name_or_attrib) -> tuple of int
        
        Return the global (a.k.a. detail) attribute value for a particular
        string attribute. The attribute may be specified by name or by
        hou.Attrib object. The return value is a list of strings. See
        hou.Geometry.floatListAttribValue for more information.
        
        
        """
        pass
        
    
    def primIntAttribValues(name):
        """
        primIntAttribValues(self, name) -> tuple of int
        
        Return a tuple of integers containing one attribute's values for all
        the primitives.
        
        This method only works on int or float attributes. If the attribute
        contains more than one element, each primitive will correspond to
        multiple values in the result. For example, if idmap is an integer
        attribute of size 2 and there are 3 primitives with values (1, 2),
        (2, 3), and (3,4) then the result will be (1, 2, 2, 3, 3, 4).
        
        Calling this method is faster than looping over all the primitives
        and calling hou.Prim.attribValue.
        
        If the attribute name is invalid or the attribute is not an int or
        float (e.g. it's a string attribute), this method raises
        hou.OperationFailed.
        
        Note that you cannot pass a hou.Attrib object to this method like
        you can with many methods dealing with attributes. However, you can
        use hou.Attrib.name to easily get the name from an Attrib object.
        
        
        """
        pass
        
    
    def intrinsicValueDict(self):
        """
        intrinsicValueDict(self) -> dict of str to value
        
        Returns a dictionary mapping intrinsic names to their values.
        
        """
        pass
        
    
    def edgeGroups():
        """
        edgeGroups(self) -> tuple of hou.EdgeGroup
        
        Return a tuple of all the edge groups in the geometry.
        
        
        """
        pass
        
    
    def pointGroups():
        """
        pointGroups(self) -> tuple of hou.PointGroup
        
        Return a tuple of all the point groups in the geometry.
        
        The following function returns the names of all the groups in the
        geometry:
        
        > def pointGroupNames(geometry):
        >     return [group.name() for group in geometry.pointGroups()]
        
        """
        pass
        
    
    def setVertexIntAttribValues(name, values):
        """
        setVertexIntAttribValues(self, name, values)
        
        For a particular attribute, set the attribute values for all
        vertices. You would typically call this method from the code of a
        Python-defined SOP.
        
        
        name
        The name of the vertex attribute.
        
        values
        A sequence of int or float values in the same format as that
        returned by hou.Geometry.vertexIntAttribValues. See that method
        for more information.
        
        Raises hou.OperationFailed if the attribute name is not valid, the
        attribute is not an int or float (i.e. it's a string), or the array
        of values is not the correct size.
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable.
        
        Also see hou.Geometry.vertexIntAttribValues.
        
        
        """
        pass
        
    
    def createBezierSurface(rows, cols, is_closed_in_u=False, is_closed_in_v=False):
        """
        createBezierSurface(self, rows, cols, is_closed_in_u=False,
        is_closed_in_v=False) -> hou.Surface
        
        Create a Bezier surface in the XY plane centered at the origin with
        size (1, 1) and return it. You would typically call this method from
        the code of a Python-defined SOP.
        
        
        rows, cols
        Determines the size of the 2D array of vertices defining the
        control points of the surface.
        
        Note that the number of rows corresponds to v and the number or
        columns corresponds to u, which can be slightly confusing. For
        example, geo.createBezierSurface(9, 7, is_closed_in_u=False,
        is_closed_in_v=True) is valid, but geo.createBezierSurface(9, 7,
        is_closed_in_u=True, is_closed_in_v=False) raises
        hou.OperationFailed.
        
        is_closed_in_u, is_closed_in_v
        Determines if it is open or closed in each of the u and v
        directions; see hou.Surface.isClosedInU for more information.
        
        order_u, order_v
        Specifies the surface's order in of the U and V directions. The
        default order for both is 4, corresponding to a cubic NURBS
        surface. An order of 2, the lowest order, will give a surface
        with linear segments, essentially a mesh.
        
        As with Bezier curves, a Bezier surface has some restrictions on the
        point count in each of the U and V directions. For a given
        direction; if it's open the number of points in the direction must
        be (order - 1) * n + 1 for some integer n >= 1 (e.g. 4, 7, 10, ...).
        If it's open, the number of points must be (order - 1) * n where n
        >= 1 in that direction (e.g. 2, 4, 6, .. for order 3).
        
        You can move or resize the surface using
        hou.Geometry.transformPrims.
        
        If the geometry contains primitive attributes, the new surface
        receives the default values for those attributes.
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable.
        
        > import math
        >
        > # This code will work from inside a Python SOP, but not from the Python
        > # shell.
        > geo = hou.pwd().geometry()
        >
        > # Build a tube-like object about the y axis.
        > num_rows, num_cols = (10, 9)
        > surf = geo.createBezierSurface(num_rows, num_cols, is_closed_in_u=True)
        > for v_index in range(num_rows):
        >     for u_index in range(num_cols):
        >         angle = u_index * (2.0 * math.pi) / num_cols
        >         surf.vertex(u_index, v_index).point().setPosition(
        >             (math.cos(angle), v_index / float(num_cols-1), math.sin(angle)))
        
        """
        pass
        
    
    def intListAttribValue(name_or_attrib):
        """
        intListAttribValue(self, name_or_attrib) -> tuple of int
        
        Return the global (a.k.a. detail) attribute value for a particular
        integer attribute. The attribute may be specified by name or by
        hou.Attrib object. The return value is a list of ints. See
        hou.Geometry.floatListAttribValue for more information.
        
        
        """
        pass
        
    
    def globalAttribs():
        """
        globalAttribs(self) -> tuple of hou.Attrib
        
        Return a tuple of all the global (a.k.a. detail) attributes.
        
        
        """
        pass
        
    
    def globPoints(pattern):
        """
        globPoints(self, pattern) -> tuple of hou.Point
        
        Return a tuple of points corresponding to a pattern of point
        numbers.
        
        The pattern format is the same one used by the group fields on SOP
        nodes that take point selections. Elements in the pattern are
        separated by spaces, and elements can be point numbers, point number
        ranges, or group names.
        
        This method can be useful when writing a Python SOP that works on
        only a selected set of points.
        
        Raises hou.OperationFailed if the pattern is not valid or if it
        refers to a group that does not exist. Note that an empty pattern is
        considered to be invalid. Numbers that do not refer to valid points
        are not errors, and simply do not match points.
        
        > # Return a tuple containing points 5 and 7.
        > geo.globPoints("5 7")
        >
        > # Return a tuple containing points 5 to 10.
        > geo.globPoints("5-10")
        >
        > # Return a tuple containing all the points in the pointgroup called group1.
        > geo.globPoints("group1")
        >
        > # Return all the points except those from 0 to 98.
        > geo.globPoints("!0-98")
        >
        > # Return points 5, 10 to 20, and those in group1.
        > geo.globPoints("5 group1 10-20")
        
        The following Python SOP example is behaves similarly to the Point
        sop.
        
        > # This code will work from inside a Python SOP, but not from the Python
        > # shell.  It assumes the Python sop has the following parm tuples:
        > #     group: A string containing which points to affect
        > #     t:     A set of 3 floats that behaves like the point sop's position
        > #            parameter.  Set these parameters to the expressions ($TX, $TY, $TZ).
        > geo = hou.pwd().geometry()
        >
        > # Use the group field to determine which points to affect.  If it's blank,
        > # operate on all points.
        > pattern = hou.ch("group")
        > if pattern == "":
        >     points = geo.points()
        > else:
        >     points = geo.globPoints(pattern)
        >
        > # Loop through the points, setting the SOP's current point as we go.
        > # Then evaluate the t parm tuple, so it can use the current point (e.g.
        > # with hscript's $TX or Python's pwd().curPoint()).
        > for point in points:
        >     hou.pwd().setCurPoint(point)
        >     new_position = hou.pwd().evalParmTuple("t")
        >     point.setPosition(new_position)
        
        """
        pass
        
    
    def setIntrinsicValue(intrinsic_name, value):
        """
        setIntrinsicValue(self, intrinsic_name, value)
        
        Some "intrinsic" values can be modified. For example, you change the
        internal size and rotation (transform) of a sphere primitive by
        passing a 16 float tuple representing the transform to
        setIntrinsicValue. Raises Error if the intrinsic is not writeable or
        does not accept the passed value, or if the given intrinsic name
        does not exist.
        
        
        NOTE
        Modifying the geometry directly will lock the geometry's parent
        node.
        
        See the intrinsicValue method for more information.
        
        
        """
        pass
        
    
    def floatListAttribValue(name_or_attrib):
        """
        floatListAttribValue(self, name_or_attrib) -> tuple of float
        
        Return the global (a.k.a. detail) attribute value for a particular
        floating point attribute. The attribute may be specified by name or
        by hou.Attrib object. The return value is a list of floats.
        
        It is valid to call this method when the attribute's size is 1. In
        this case, a list with one element is returned.
        
        See also:
        
        * hou.Geometry.attribValue
        
        
        """
        pass
        
    
    def iterPrims():
        """
        iterPrims(self) -> generator of hou.Prim
        
        Return a generator that iterates through all the primitives in the
        geometry.
        
        Whereas hou.Geometry.prims allocates and returns a tuple of all the
        primitives in the geometry, this method returns a generator object
        that will yield hou.Prim objects on demand. This object is very fast
        at random access into the sequence.
        
        If you're accessing a specific primitive by index and the geometry
        contains many primitives, it is faster to use iterPrims() than
        prims(). If, however, you are iterating over all the primitives in
        the geometry, it is generally faster to use prims() than
        iterPrims().
        
        > # This is preferred:
        > geo.iterPrims()[23]
        >
        > # over this:
        > geo.prims()[23]
        >
        > # But this is preferred:
        > for prim in geo.prims():
        >     ...process prim...
        >
        > # over this:
        > for prim in geo.iterPrims():
        >     ...process prim...
        
        See also the hou.Geometry.prims method.
        
        
        """
        pass
        
    
    def sopNodeOutputIndex():
        """
        sopNodeOutputIndex(self) -> int
        
        If the Geometry is not frozen, return the index of the SOP node
        output that this geometry corresponds to. Otherwise, return -1.
        
        For most cases this method will return 0 to indicate that the
        geometry corresponds to the first output. This method will only
        return a value other than 0 for SOP nodes that have multiple
        outputs.
        
        See hou.Geometry.freeze for more information on frozen geometry.
        
        
        """
        pass
        
    
    def pointBoundingBox(pointpattern):
        """
        pointBoundingBox(self, pointpattern) -> hou.BoundingBox
        
        Return an axis-aligned 3D bounding box that is sized and positioned
        to include the points specified by the point pattern. If the pattern
        is blank, all points will be included.
        
        Some primitives, such as spheres, extend beyond their points. This
        extension will not be included.
        
        
        """
        pass
        
    
    def findPrimAttrib(name):
        """
        findPrimAttrib(self, name) -> hou.Attrib or None
        
        Look up a primitive attribute by name. Returns the corresponding
        hou.Attrib object, or None if no attribute exists with that name.
        
        
        """
        pass
        
    
    def renamePointAttrib(old_name, new_name):
        """
        renamePointAttrib(self, old_name, new_name)
        
        Rename the point attribute with the specified old name to the new
        name. This method is typically called from within a Python-defined
        SOP when the SOP's geometry is writable.
        
        Raises GeometryPermissionError if called on a read-only geometry.
        Raises TypeError if old_name or new_name is None. Raises
        OperationFailed if no such point attribute with the old name exists.
        Raises OperationFailed if a point attribute with the new name
        already exists.
        
        
        """
        pass
        
    
    def attributeCaptureObjectPaths():
        """
        attributeCaptureObjectPaths(self) -> tuple of str
        
        Returns a tuple of strings representing the capture object paths for
        this geometry. The capture objects are those used to capture this
        geometry and are identified from the geometry's capture attributes.
        The skeleton root path is prepended to the capture object paths and
        the object nodes are given by:
        
        > # This code will work from inside a Python SOP, but not from the Python
        > # shell.
        > geo = hou.pwd().geometry()
        > nodes = [hou.node(x) for x in geo.attributeCaptureObjectPaths()]
        
        See also:
        
        * hou.Geometry.attributeCaptureRegions
        
        
        """
        pass
        
    
    def setPointIntAttribValues(name, values):
        """
        setPointIntAttribValues(self, name, values)
        
        For a particular attribute, set the attribute values for all points.
        You would typically call this method from the code of a Python-
        defined SOP.
        
        
        name
        The name of the point attribute.
        
        values
        A sequence of int or float values in the same format as that
        returned by hou.Geometry.pointIntAttribValues. See that method
        for more information.
        
        Raises hou.OperationFailed if the attribute name is not valid, the
        attribute is not an int or float (i.e. it's a string), or the array
        of values is not the correct size.
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable.
        
        Also see hou.Geometry.pointIntAttribValues.
        
        
        """
        pass
        
    
    def setPrimIntAttribValues(name, values):
        """
        setPrimIntAttribValues(self, name, values)
        
        For a particular attribute, set the attribute values for all
        primitives. You would typically call this method from the code of a
        Python-defined SOP.
        
        
        name
        The name of the primitive attribute.
        
        values
        A sequence of int or float values in the same format as that
        returned by hou.Geometry.primFloatAttribValues. See that method
        for more information.
        
        Raises hou.OperationFailed if the attribute name is not valid, the
        attribute is not an int or float (i.e. it's a string), or the array
        of values is not the correct size.
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable.
        
        Also see hou.Geometry.primIntAttribValues.
        
        
        """
        pass
        
    
    def primFloatAttribValues(name):
        """
        primFloatAttribValues(self, name) -> tuple of float
        
        Return a tuple of floats containing one attribute's values for all
        the primitives.
        
        This method only works on int or float attributes. If the attribute
        contains more than one element, each primitive will correspond to
        multiple values in the result. For example, if Cd is a float
        attribute of size 3 and there are 3 primitives with values (0.1,
        0.2, 0.3), (0.5, 0.5, 0.5), and (0.8, 0.7, 0.6) then the result will
        be (0.1, 0.2, 0.3, 0.5, 0.5, 0.5, 0.8, 0.7, 0.6).
        
        Calling this method is faster than looping over all the primitives
        and calling hou.Prim.attribValue.
        
        If the attribute name is invalid or the attribute is not an int or
        float (e.g. it's a string attribute), this method raises
        hou.OperationFailed.
        
        Note that you cannot pass a hou.Attrib object to this method like
        you can with many methods dealing with attributes. However, you can
        use hou.Attrib.name to easily get the name from an Attrib object.
        
        
        """
        pass
        
    
    def vertexAttribs():
        """
        vertexAttribs(self) -> tuple of hou.Attrib
        
        Return a tuple of all the vertex attributes.
        
        
        """
        pass
        
    
    def vertexIntAttribValues(name):
        """
        vertexIntAttribValues(self, name) -> tuple of int
        
        Return a tuple of integers containing one attribute's values for all
        the vertices.
        
        This method only works on int or float attributes. If the attribute
        contains more than one element, each vertex will correspond to
        multiple values in the result. For example, if "idmap" is an integer
        attribute of size 2 and there are 3 vertices with values (1, 2), (2,
        3), and (3, 4) then the result will be (1, 2, 2, 3, 3, 4).
        
        Calling this method is faster than looping over all the vertices and
        calling hou.Vertex.attribValue.
        
        If the attribute name is invalid or the attribute is not an int or
        float (e.g. it's a string attribute), this method raises
        hou.OperationFailed.
        
        Note that you cannot pass a hou.Attrib object to this method like
        you can with many methods dealing with attributes. However, you can
        use hou.Attrib.name to easily get the name from an Attrib object.
        
        
        """
        pass
        
    
    def vertexIntAttribValuesAsString(name, int_type=hou.numericData.Int32):
        """
        vertexIntAttribValuesAsString(self, name,
        int_type=hou.numericData.Int32) -> str
        
        Return a string representation of the integers of one attribute's
        value for all the vertices. This method is faster than
        hou.Geometry.vertexIntAttribValues, and you can use the array module
        to convert the string into a Python sequence.
        
        
        int_type
        A hou.numericData value to specify the integer data type (either
        Int8, Int16, Int32 or Int64).
        
        This method provides a faster implementation of the following:
        
        > import array
        > def vertexIntAttribValuesAsString(self, name):
        >     return array.array("i", self.vertexIntAttribValues(name)).tostring()
        
        You can convert the return value from this method to an array using
        the following method:
        
        > import array
        > def vertexIntAttribValuesAsArray(geometry, name):
        >     a = array.array("i")
        >     a.fromstring(geometry.vertexIntAttribValuesAsString(name))
        >     return a
        
        See hou.Geometry.vertexIntAttribValues for more information.
        
        
        """
        pass
        
    
    def findEdge(p0, p1):
        """
        findEdge(self, p0, p1) -> hou.Edge
        
        
        p0
        The first point that makes up the edge. See hou.Point for more
        information.
        
        p1
        The second point that makes up the edge. See hou.Point for more
        information.
        
        finds an edge given two points, or None if no such edge exists
        
        
        """
        pass
        
    
    def deletePoints(points):
        """
        deletePoints(self, points)
        
        Delete a sequence of points. You would typically call this method
        from the code of a Python-defined SOP.
        
        Note that Houdini will delete any vertices that reference the point.
        For example, suppose you have a box with 6 polygons, each with 4
        vertices. Also suppose that each point on the box is shared by 3
        vertices on 3 separate polygons. If you delete one of those points,
        Houdini will remove each of those vertices from their corresponding
        polygons, leaving 3 polygons with 4 vertices and 3 polygons with 3
        vertices.
        
        To delete a single primitive, pass in a sequence with one point.
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable.
        
        
        """
        pass
        
    
    def execute(self, verb, inputs=[]):
        """
        execute(self, verb, inputs=[]) -> HOM_Geometry
        
        Invokes verb.execute() with myself as the first input, and returns
        the resulting geometry. This allows one to chain a series of verbs
        invocations: geo.execute(subdivide).execute(subdivide).
        
        The optional inputs will have the geometry itself prepended.
        
        """
        pass
        
    
    def primFloatAttribValuesAsString(name):
        """
        primFloatAttribValuesAsString(self, name) -> str
        
        Return a string representation of the floats of one attribute's
        value for all the primitives. This method is faster than
        hou.Geometry.primFloatAttribValues, and you can use the array module
        to convert the string into a Python sequence.
        
        This method provides a faster implementation of the following:
        
        > import array
        > def primFloatAttribValuesAsString(self, name):
        >     return array.array("f", self.primFloatAttribValues(name)).tostring()
        
        You can convert the return value from this method to an array using
        the following method:
        
        > import array
        > def primFloatAttribValuesAsArray(geometry, name):
        >     a = array.array("f")
        >     a.fromstring(geometry.primFloatAttribValuesAsString(name))
        >     return a
        
        See hou.Geometry.primFloatAttribValues for more information.
        
        
        """
        pass
        
    
    def boundingBox():
        """
        boundingBox(self) -> hou.BoundingBox
        
        Return an axis-aligned 3D bounding box that is sized and positioned
        to be large enough to hold this geometry.
        
        
        """
        pass
        
    
    def pointStringAttribValues(name):
        """
        pointStringAttribValues(self, name) -> tuple of str
        
        Return a tuple of strings containing one attribute's values for all
        the points.
        
        This method only works on string attributes. If the attribute
        contains more than one element, each point will correspond to
        multiple values in the result. For example, if "strmap" is a string
        attribute of size 2 and there are 3 points with values ("apple",
        "orange"), ("red", "blue"), and ("one", "two") then the result will
        be ("apple", "orange", "red", "blue", "one", "two").
        
        Calling this method is faster than looping over all the points and
        calling hou.Point.attribValue.
        
        If the attribute name is invalid or the attribute is not a string
        attribute then this method raises hou.OperationFailed.
        
        Note that you cannot pass a hou.Attrib object to this method like
        you can with many methods dealing with attributes. However, you can
        use hou.Attrib.name to easily get the name from an Attrib object.
        
        
        """
        pass
        
    
    def createTetrahedron():
        """
        createTetrahedron(self) -> hou.Prim
        
        Create a new tetrahedron and return the corresponding hou.Prim
        object. You would typically call this method from the code of a
        Python-defined SOP.
        
        The newly created tetrahedron has four vertices and new points have
        been allocated for them. To build a tetrahedron out of existin
        points, use
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable.
        
        
        """
        pass
        
    
    def attribType():
        """
        attribType(self) -> hou.attribType enum value
        
        Return the enumerated value hou.attribType.Global. Points,
        primitives, vertices, and geometry support the same set of methods
        for querying their attributes, and this method is one of them.
        
        See also:
        
        * hou.Prim.attribType
        
        * hou.Point.attribType
        
        * hou.Vertex.attribType
        
        
        """
        pass
        
    
    def deletePrims(prims, keep_points=False):
        """
        deletePrims(self, prims, keep_points=False)
        
        Delete a sequence of primitives. You would typically call this
        method from the code of a Python-defined SOP.
        
        
        keep_points
        if True, the primitive will be deleted but its points will
        remain.
        
        To delete a single primitive, pass in a sequence with one primitive.
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable.
        
        > # Delete every other primitive:
        > prims = [p for p in geo.prims() if p.number() % 2 == 0]
        > geo.deletePrims(prims)
        >
        > # Delete the first primitive:
        > geo.deletePrims([geo.iterPrims()[0]])
        
        """
        pass
        
    
    def findPointAttrib(name):
        """
        findPointAttrib(self, name) -> hou.Attrib or None
        
        Look up a point attribute by name. Returns the corresponding
        hou.Attrib object, or None if no attribute exists with that name.
        
        Note that the point position attribute is named P and is 3 floats in
        size. Also, the point weight attribute is named Pw and is 1 float in
        size. These attributes always exist in HOM, even though they are not
        listed by Houdini's UI.
        
        See hou.Point.attribValue for an example.
        
        
        """
        pass
        
    
    def setPointFloatAttribValues(name, values):
        """
        setPointFloatAttribValues(self, name, values)
        
        For a particular attribute, set the attribute values for all points.
        You would typically call this method from the code of a Python-
        defined SOP.
        
        
        name
        The name of the point attribute.
        
        values
        A sequence of int or float values in the same format as that
        returned by hou.Geometry.pointFloatAttribValues. See that method
        for more information.
        
        Raises hou.OperationFailed if the attribute name is not valid, the
        attribute is not an int or float (i.e. it's a string), or the array
        of values is not the correct size.
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable.
        
        Also see hou.Geometry.pointFloatAttribValues.
        
        
        """
        pass
        
    
    def addAttrib(self):
        """None"""
        pass
        
    
    def createPoint():
        """
        createPoint(self) -> hou.Point
        
        Create a new point located at (0, 0, 0) and return the corresponding
        hou.Point object. You would typically call this method from the code
        of a Python-defined SOP.
        
        If the geometry contains point attributes, the new point receives
        the default values for those attributes.
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable.
        
        See hou.Geometry.addAttrib, hou.Geometry.createPolygon, and
        hou.Face.addVertex for examples.
        
        
        """
        pass
        
    
    def setPrimIntAttribValuesFromString():
        """None"""
        pass
        
    
    def findGlobalAttrib(name):
        """
        findGlobalAttrib(self, name) -> hou.Attrib or None
        
        Look up a global (a.k.a. detail) attribute by name. Returns the
        corresponding hou.Attrib object, or None if no attribute exists with
        that name.
        
        
        """
        pass
        
    
    def attributeCaptureRegions():
        """
        attributeCaptureRegions(self) -> tuple of str
        
        Returns a tuple of strings representing the capture region paths for
        this geometry. The capture regions are identified from the
        geometry's capture attributes.
        
        See also:
        
        * hou.Geometry.attributeCaptureObjectPaths
        
        
        """
        pass
        
    
    def setPointIntAttribValuesFromString():
        """None"""
        pass
        
    
    def vertexFloatAttribValuesAsString(name, float_type=hou.numericData.Float32):
        """
        vertexFloatAttribValuesAsString(self, name,
        float_type=hou.numericData.Float32) -> str
        
        Return a string representation of the floats of one attribute's
        value for all the vertices. This method is faster than
        hou.Geometry.vertexFloatAttribValues, and you can use the array
        module to convert the string into a Python sequence.
        
        
        float_type
        A hou.numericData value to specify the float data type (either
        Float16, Float32 or Float64).
        
        This method provides a faster implementation of the following:
        
        > import array
        > def vertexFloatAttribValuesAsString(self, name):
        >     return array.array("f", self.vertexFloatAttribValues(name)).tostring()
        
        You can convert the return value from this method to an array using
        the following method:
        
        > import array
        > def vertexFloatAttribValuesAsArray(geometry, name):
        >     a = array.array("f")
        >     a.fromstring(geometry.vertexFloatAttribValuesAsString(name))
        >     return a
        
        See hou.Geometry.vertexFloatAttribValues for more information.
        
        
        """
        pass
        
    
    def setPointStringAttribValues(name, values):
        """
        setPointStringAttribValues(self, name, values)
        
        For a particular attribute, set the attribute values for all points.
        You would typically call this method from the code of a Python-
        defined SOP.
        
        
        name
        The name of the point attribute.
        
        values
        A sequence of string values in the same format as that returned
        by hou.Geometry.pointStringAttribValues. See that method for
        more information.
        
        Raises hou.OperationFailed if the attribute name is not valid, the
        attribute is not a string, or the array of values is not the correct
        size.
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable.
        
        Also see hou.Geometry.pointStringAttribValues.
        
        
        """
        pass
        
    
    def containsPrimType(type_or_name):
        """
        containsPrimType(self, type_or_name) -> bool
        
        Returns whether the geometry contains at least one primitive of the
        specified type.
        
        
        type_or_name
        A hou.primType, or a string containing the name of a primitive
        type.
        
        Typical examples of string values are "Poly" (polygon) or
        "PackedAgent" (agent packed primitive). To see a complete list
        of possible typename values, run ginfo -P on a Houdini tools
        command line.
        
        
        """
        pass
        
    
    def prims():
        """
        prims(self) -> tuple of hou.Prim
        
        Return a tuple of all the primitives in the geometry. The primitives
        returned will be subclasses of hou.Prim (e.g.polygons, volumes,
        etc.).
        
        See also:
        
        * hou.Geometry.iterPrims
        
        * hou.Face
        
        * hou.Polygon
        
        * hou.Surface
        
        * hou.Volume
        
        
        """
        pass
        
    
    def nearestPrim(position):
        """
        nearestPrim(self, position) -> (hou.Prim or None, float, float, float)
        
        Given a sequence of three floats containing a position, find the
        location on the primitive closest to that position and return a
        tuple containing that primitive, the u value on the primitive, the v
        value on the primitive, and the distance to the primitive.
        
        Note that the first value in the return tuple can be None if there
        are no primitives in the geometry.
        
        
        """
        pass
        
    
    def findEdgeGroup(name):
        """
        findEdgeGroup(self, name) -> hou.EdgeGroup or None
        
        
        name
        The name of the edge group.
        
        Return the edge group with the given name, or None if no such group
        exists.
        
        
        """
        pass
        
    
    def countPrimType(type_or_name):
        """
        countPrimType(self, type_or_name) -> long
        
        Returns the number of primitives of the specified type in the
        geometry.
        
        
        type_or_name
        A hou.primType, or a string containing the name of a primitive
        type.
        
        Typical examples of string values are "Poly" (polygon) or
        "PackedAgent" (agent packed primitive). To see a complete list
        of possible typename values, run ginfo -P on a Houdini tools
        command line.
        
        
        """
        pass
        
    
    def transform(matrix):
        """
        transform(self, matrix)
        
        Transforms (e.g. rotates, scales, translates, etc.) the geometry by
        a transformation matrix. You would typically call this method from
        the code of a Python-defined SOP.
        
        See hou.hmath for functions that build transformation matrices.
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable.
        
        
        """
        pass
        
    
    def setVertexIntAttribValuesFromString():
        """None"""
        pass
        
    
    def edgeLoop(edges, loop_type, full_loop_per_edge, force_ring, allow_ring):
        """
        edgeLoop(self, edges, loop_type, full_loop_per_edge, force_ring,
        allow_ring) -> tuple of hou.Edge
        
        Returns a tuple of hou.Edge objects that make a path connecting the
        edges provided in the edges parameter. If multiple paths are being
        returned, they will be separated in the single returned tuple by a
        value of None. The paths are generated using the same algorithm used
        when performing loop selections in the viewport.
        
        edges: A list of hou.Edge objects that define the path or paths of
        connected edges this function should return. Must contain at least
        one or two edges depending on the loop options.
        
        loop_type: Controls the type of path returned. Can be any of the
        hou.componentLoopType values. If using either the
        hou.componentLoopType.Extended or hou.componentLoopType.Closed loop
        types, the inputs edges cannot contain any None entries. If these
        conditions are not met, a hou.OperationFailed exception will be
        thrown.
        
        full_loop_per_edge: If set to True, with the loop_type set to
        hou.componentLoopType.Extended or hou.componentLoopType.Closed loop
        types, each inputs edge is used to create its own full loop or ring.
        If False, the edges are taken in pairs, and so the number of edges
        must be even.
        
        force_ring: If set to True, this function will return edge rings
        instead of edge loops.
        
        allow_ring: If set to True, this function may return an edge ring if
        the edges provided produce a ring more naturally than they produce a
        loop (for example if two perpendicular edges are provided from the
        same row on a polygonal grid). If set to False, only edge loops will
        be returned.
        
        Raises a hou.OperationFailed if it was unable to construct a loop
        from the desired components.
        
        
        """
        pass
        
    
    def setPrimFloatAttribValues(name, values):
        """
        setPrimFloatAttribValues(self, name, values)
        
        For a particular attribute, set the attribute values for all
        primitives. You would typically call this method from the code of a
        Python-defined SOP.
        
        
        name
        The name of the primitive attribute.
        
        values
        A sequence of int or float values in the same format as that
        returned by hou.Geometry.primFloatAttribValues. See that method
        for more information.
        
        Raises hou.OperationFailed if the attribute name is not valid, the
        attribute is not an int or float (i.e. it's a string), or the array
        of values is not the correct size.
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable.
        
        Also see hou.Geometry.primFloatAttribValues.
        
        
        """
        pass
        
    
    def stringAttribValue(name_or_attrib):
        """
        stringAttribValue(self, name_or_attrib) -> str
        
        Return the global (a.k.a. detail) attribute value for a particular
        string attribute. The attribute may be specified by name or by
        hou.Attrib object. See hou.Geometry.floatAttribValue for more
        information.
        
        
        """
        pass
        
    
    def setGlobalAttribValue(name_or_attrib, attrib_value):
        """
        setGlobalAttribValue(self, name_or_attrib, attrib_value)
        
        Set a global (a.k.a. detail) attribute value. The attribute may be
        specified by name or by hou.Attrib object. You would typically call
        this method from the code of a Python-defined SOP.
        
        Raises hou.OperationFailed if no attribute exists with this name or
        if the attribute's data type does not match the value passed in. If
        the attribute's size is more than 1, the attribute value must be a
        sequence of integers/floats, and the size of the sequence must match
        the attribute's size.
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable.
        
        > # This code will work from inside a Python SOP, but not from the Python
        > # shell.
        > geo = hou.pwd().geometry()
        > geo.addAttrib(hou.attribType.Global, "author", "")
        > geo.addAttrib(hou.attribType.Global, "version", (0, 0, 0))
        > geo.setGlobalAttribValue("author", "Joe")
        > geo.setGlobalAttribValue("version", (1, 0, 7))
        
        See also:
        
        * hou.Geometry.attribValue
        
        * hou.Point.setAttribValue
        
        * hou.Prim.setAttribValue
        
        * hou.Vertex.setAttribValue
        
        
        """
        pass
        
    
    def freeze(read_only=False):
        """
        freeze(self, read_only=False) -> hou.Geometry
        
        Return another Geometry object that is not linked to a particular
        SOP.
        
        Normally, when you call hou.SopNode.geometry, the resultant Geometry
        object retains a reference to that SOP, and is said to be unfrozen.
        Each time you access points, primitives, attributes, etc. in an
        unfrozen Geometry object, Houdini uses the SOP's latest cooked
        geometry. So, if you change parameters or change the time for an
        animated SOP, the Geometry object will update to the SOP's new
        geometry.
        
        Unless Python SOPs are involved, a frozen Geometry object does not
        have a similar live association with a particular SOP. If you ask a
        SOP for its geometry and then store a frozen copy of that geometry,
        when the SOP recooks the frozen Geometry object will not update.
        Instead, the frozen geometry saves its own copy of the point and
        primitive data, and is unaffected by subsequent changes to the SOP.
        When a frozen Geometry object is destroyed, any geometry copy it
        created is also destroyed.
        
        Note that accessing a Geometry object's points, primitives,
        attributes, etc. may be faster when dealing with frozen objects. You
        may want to work with frozen Geometry in speed-sensitive operations.
        
        Calling this method on an unfrozen Geometry object returns a frozen
        one. Calling it on a frozen object has no effect, and it returns a
        frozen object.
        
        When a Python-defined SOP cooks and runs Python code that asks for
        the SOP's geometry, the returned Geometry object is writable.
        Modifying this Geometry object affects the output of this SOP. For
        efficiency, this geometry object is already frozen, so calling
        freeze on it has no effect.
        
        
        read_only
        If True, the resulting frozen geometry will be read-only. Use
        read-only frozen geometry to share embedded geometry among
        multiple packed primitives.
        
        
        """
        pass
        
    
    def intAttribValue(name_or_attrib):
        """
        intAttribValue(self, name_or_attrib) -> int
        
        Return the global (a.k.a. detail) attribute value for a particular
        integer attribute of size 1. The attribute may be specified by name
        or by hou.Attrib object. See hou.Geometry.floatAttribValue for more
        information.
        
        
        """
        pass
        
    
    def averageEdgeLength():
        """
        averageEdgeLength(self) -> float
        
        Return the average edge length of the mesh.
        
        Raises hou.OperationFailed if mesh does not contain any edges.
        
        > # Return the average edge length.
        > geo.averageEdgeLength()
        
        """
        pass
        
    
    def createVolume(xres, yres, zres, bounding_box=None):
        """
        createVolume(self, xres, yres, zres, bounding_box=None) -> hou.Volume
        
        Given the x, y, and z resolution (or size) of a voxel array, add a
        new volume primitive to the geometry and return it. The values in
        the new volume's voxels are all zero.
        
        
        xres, yres, zres
        Integers greater than zero that specify the size of the voxel
        array in one dimension. Raises hou.OperationFailed if any of
        these values are not positive.
        
        bounding_box
        A hou.BoundingBox that specifies the volume's 3D size. Note that
        this size is independent of the volume's voxel resolution. If
        this parameter is None, Houdini uses a bounding box going from
        (-1,-1,-1) to (1,1,1).
        
        
        """
        pass
        
    
    def vertexFloatAttribValues(name):
        """
        vertexFloatAttribValues(self, name) -> tuple of float
        
        Return a tuple of floats containing one attribute's values for all
        the vertices.
        
        This method only works on int or float attributes. If the attribute
        contains more than one element, each vertex will correspond to
        multiple values in the result. For example, if "attrib" is a float
        attribute of size 3 and there are 3 vertices with values (0.1, 0.2,
        0.3), (0.5, 0.5, 0.5), and (0.8, 0.7, 0.6) then the result will be
        (0.1, 0.2, 0.3, 0.5, 0.5, 0.5, 0.8, 0.7, 0.6).
        
        Calling this method is faster than looping over all the vertices and
        calling hou.Vertex.attribValue.
        
        If the attribute name is invalid or the attribute is not an int or
        float (e.g. it's a string attribute), this method raises
        hou.OperationFailed.
        
        Note that you cannot pass a hou.Attrib object to this method like
        you can with many methods dealing with attributes. However, you can
        use hou.Attrib.name to easily get the name from an Attrib object.
        
        
        """
        pass
        
    
    def averageMinDistance(local_transform, geometry, geometry_transform):
        """
        averageMinDistance(self, local_transform, geometry, geometry_transform)
        -> float
        
        Return the average over all points in <geometry> of the minimum
        distance to the point set of <self>
        
        
        local_transform
        A transform to be applied to all points in this geometry.
        
        geometry
        The geometry to find distances from.
        
        geometry_transform
        A transform to be applied to all points in <geometry>.
        
        Raises hou.OperationFailed if <geometry> has no vertices.
        
        > query_geometry = query_node.geometry()
        > queried_geometry = queried_node.geometry()
        >
        > # Return the average over all points in <queried_geometry> of the minimum
        > # distance to the point set of <query_geometry>
        > query_geometry.averageMinDistance(
        >     query_node.worldTransform(),
        >     queried_geometry,
        >     queried_node.worldTransform())
        
        """
        pass
        
    
    def saveToFile(file_name):
        """
        saveToFile(self, file_name)
        
        Save the contents of the geometry object to a file. The file
        extension determines what file format to use.
        
        All file formats supported by Houdini (e.g. geo, bgeo, obj, etc.),
        including extensions listed in GEOio, are supported. If the file
        extension is not recognized, the bgeo format is used.
        
        Raises hou.OperationFailed if the path to the file is invalid or
        there were permission or other I/O errors.
        
        
        """
        pass
        
    
    def createPointGroup(name, is_ordered=False):
        """
        createPointGroup(self, name, is_ordered=False) -> hou.PointGroup
        
        Create a new point group in this geometry.
        
        
        name
        The name of the new group. Raises hou.OperationFailed if a group
        with this name already exists.
        
        is_ordered
        Whether or not the new group should be ordered. See
        hou.PointGroup for more information about ordered groups.
        
        Use hou.PointGroup.destroy to remove a point group from the
        geometry.
        
        
        """
        pass
        
    
    def findVertexAttrib(name):
        """
        findVertexAttrib(self, name) -> hou.Attrib or None
        
        Look up a vertex attribute by name. Returns the corresponding
        hou.Attrib object, or None if no attribute exists with that name.
        
        
        """
        pass
        
    
    def setPointFloatAttribValuesFromString():
        """None"""
        pass
        
    
    def intrinsicSize():
        """None"""
        pass
        
    
    def merge(geometry):
        """
        merge(self, geometry)
        
        Merge the points and primitives from another hou.Geometry object
        into this one. The new points and primitives are appended to this
        geometry's points and primitives. You would typically call this
        method from the code of a Python-defined SOP.
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable.
        
        See also hou.Geometry.loadFromFile.
        
        
        """
        pass
        
    
    def transformPrims(prims, matrix):
        """
        transformPrims(self, prims, matrix)
        
        Transforms a set of primitives (e.g. rotates, scales, translates,
        etc.) by a transformation matrix. You would typically call this
        method from the code of a Python-defined SOP.
        
        > import math
        >
        > # This code will work from inside a Python SOP, but not from the Python
        > # shell.
        >
        > def createCircle(geo, num_vertices=10):
        >     # Create a closed curve with the specified number of vertices.
        >     curve = geo.createNURBSCurve(num_vertices)
        >     curve.setIsClosed(True)
        >
        >     # Arrange the points into a unit circle on the XZ plane,
        >     # centered about the origin.
        >     for i, vertex in enumerate(curve.vertices()):
        >         angle = i * (2.0 * math.pi) / num_vertices
        >         position = (math.cos(angle), 0, math.sin(angle))
        >         vertex.point().setPosition(position)
        >     return curve
        >
        > # Create a bunch of circles on the XZ plane, tilt them slightly
        > # about X, translate them away from the origin, and rotate each
        > # one about the y axis by a different amount.
        > geo = hou.pwd().geometry()
        > num_copies = 20
        > for i in range(num_copies):
        >     curve = createCircle(geo)
        >     geo.transformPrims([curve],
        >         hou.hmath.buildRotateAboutAxis((1, 0, 0), 30) *
        >         hou.hmath.buildTranslate((2, 0, 0)) *
        >         hou.hmath.buildRotateAboutAxis((0, 1, 0), i * 360.0 / num_copies))
        
        See hou.hmath functions that build transformation matrices.
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable.
        
        
        """
        pass
        
    
    def vertexStringAttribValues(name):
        """
        vertexStringAttribValues(self, name) -> tuple of str
        
        Return a tuple of strings containing one attribute's values for all
        the vertices.
        
        This method only works on string attributes. If the attribute
        contains more than one element, each vertex will correspond to
        multiple values in the result. For example, if "strmap" is a string
        attribute of size 2 and there are 3 vertices with values ("apple",
        "orange"), ("red", "blue"), and ("one", "two") then the result will
        be ("apple", "orange", "red", "blue", "one", "two").
        
        Calling this method is faster than looping over all the vertices and
        calling hou.Vertex.attribValue.
        
        If the attribute name is invalid or the attribute is not a string
        attribute then this method raises hou.OperationFailed.
        
        Note that you cannot pass a hou.Attrib object to this method like
        you can with many methods dealing with attributes. However, you can
        use hou.Attrib.name to easily get the name from an Attrib object.
        
        
        """
        pass
        
    
    def sopNode():
        """
        sopNode(self) -> hou.SopNode
        
        If the Geometry is not frozen, return the hou.SopNode object
        corresponding to this Geometry. Otherwise, return None.
        
        See hou.Geometry.freeze for more information on frozen geometry.
        
        
        """
        pass
        
    
    def createPolygon():
        """
        createPolygon(self) -> hou.Polygon
        
        Create a new polygon and return the corresponding hou.Polygon
        object. You would typically call this method from the code of a
        Python-defined SOP.
        
        The newly created polygon has no vertices. Use hou.Face.addVertex to
        add them. The polygon is also closed (see hou.Face.isClosed for more
        information).
        
        If the geometry contains primitive attributes, the new polygon
        receives the default values for those attributes.
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable.
        
        > geo = hou.pwd().geometry()
        > poly = geo.createPolygon()
        > for position in (0,0,0), (1,0,0), (0,1,0):
        >     point = geo.createPoint()
        >     point.setPosition(position)
        >     poly.addVertex(point)
        
        See hou.Face.addVertex for a slightly more complicated example.
        
        
        """
        pass
        
    
    def attribValue(name_or_attrib):
        """
        attribValue(self, name_or_attrib) -> int, float, str, or tuple
        
        Return the global (a.k.a. detail) attribute value for a particular
        attribute. The attribute may be specified by name or by hou.Attrib
        object.
        
        Raises hou.OperationFailed if no attribute exists with this name.
        
        
        """
        pass
        
    
    def createPoints(point_positions):
        """
        createPoints(self, point_positions) -> tuple of hou.Point
        
        Create a set of points located at the specified positions and return
        a tuple of the new hou.Point objects. You would typically call this
        method from the code of a Python-defined SOP.
        
        point_positions can be either a tuple of hou.Vector3 objects or a
        tuple of 3-tuple floating point numbers. For example, if
        point_positions is ((0, 1, 2), (1, 2, 3)) then this method will
        create 2 points with one positioned at (0, 1, 2) and the other at
        (1, 2, 3).
        
        If the geometry contains point attributes, the new points receive
        the default values for those attributes.
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable. Raises hou.InvalidSize if one of the specified point
        positions does not contain 3 values (for x, y, z).
        
        See hou.Geometry.addAttrib, hou.Geometry.createPolygons, and
        hou.Face.addVertex for examples.
        
        
        """
        pass
        
    
    def intersect(ray_origin, ray_direction, position_out, normal_out, uvw_out, pattern=None, min_hit=0.01, max_hit=1E18, tolerance=0.01):
        """
        intersect(self, ray_origin, ray_direction, position_out, normal_out,
        uvw_out, pattern=None, min_hit=0.01, max_hit=1E18, tolerance=0.01) ->
        int
        
        Determines the intersection point of a ray with the geometry in this
        object.
        
        
        NOTE
        This method is unusual in that instead of returning multiple
        pieces of information about the intersection, it requires that
        you pass it objects which it modifies in-place with the
        information.
        
        > # Get some geometry from a SOP node
        > geometry = hou.node("/obj/geo1/sphere1").geometry()
        > # Shoot a ray from high up in the "sky" straight down at the origin
        > origin = hou.Vector3(0, 100, 0)
        > direction = hou.Vector3(0, -1, 0)
        > # Make objects for the intersect() method to modify
        > position = hou.Vector3()
        > normal = hou.Vector3()
        > uvw = hou.Vector3()
        > # Find the first intersection (if it exists)
        > did_intersect = geometry.intersect(origin, direction, position, normal, uvw)
        
        Returns the ID number of the hit primitive if the ray intersected
        the geometry, or -1 if the ray did not hit.
        
        
        ray_origin
        A hou.Vector3 object representing the starting point of the ray
        in world space.
        
        ray_direction
        A hou.Vector3 object representing the direction vector of the
        ray.
        
        position_out
        Pass a hou.Vector3 object to this argument. The method will
        change the object's values to represent the intersection
        position in world space.
        
        normal_out
        Pass a hou.Vector3 object to this argument. The method will
        change the object's values to represent the normal direction
        from the surface to the ray.
        
        uvw_out
        Pass a hou.Vector3 object to this argument. The method will
        change the object's values to represent the UVW position within
        the intersecting primitive where the ray hit.
        
        pattern
        If you pass a string containing primitive group syntax, the ray
        can only intersect primitives that match the pattern.
        
        min_hit
        Ignore intersections closer than this distance. You can use the
        min_hit argument to iterate through all possible hits along the
        ray, by setting the min_hit a tiny bit farther than the previous
        hit.
        
        > hit_positions = []
        > prev_dist = 0.01
        > while geometry.intersect(origin, direction, position, normal, uvw,
        >                          min_hit=prev_dist):
        >     # Make sure to store a *copy* of the position, not the object
        >     # that is being modified in each iteration of the loop
        >     hit_positions.append(hou.Vector3(position))
        >     prev_dist = origin.distanceTo(position) + 0.01
        
        max_hit
        Ignore intersections farther than this distance.
        
        tolerance
        Use this parameter to adjust the accuracy of intersections. If
        the ray approaches the geometry within the tolerance value, an
        intersection hit is assumed. A 0.01 tolerance (default) gives
        strict intersections while larger values produces less accurate
        intersections.
        
        
        """
        pass
        
    
    def pointAttribs():
        """
        pointAttribs(self) -> tuple of hou.Attrib
        
        Return a tuple of all the point attributes.
        
        Note that the point position attribute is named P and is 3 floats in
        size. Also, the point weight attribute is named Pw and is 1 float in
        size. These attributes always exist in HOM, even though they are not
        listed by Houdini's UI.
        
        
        """
        pass
        
    
    def iterPoints():
        """
        iterPoints(self) -> generator of hou.Point
        
        Return a generator that iterates through all the points in the
        geometry.
        
        Whereas hou.Geometry.points allocates and returns a tuple of all the
        points in the geometry, this method returns a generator object that
        will allocate hou.Point objects on demand. This object is very fast
        at random access into the sequence.
        
        If you're accessing a specific point by index and the geometry
        contains many points, it is faster to use iterPoints() than
        points(). If, however, you are iterating over all the points in the
        geometry, it is generally faster to use points() than iterPoints().
        
        > # This is preferred:
        > geo.iterPoints()[23]
        >
        > # over this:
        > geo.points()[23]
        >
        > # But this is preferred:
        > for point in geo.points():
        >     ...process point...
        >
        > # over this:
        > for point in geo.iterPoints():
        >     ...process point...
        
        """
        pass
        
    
    def primGroups():
        """
        primGroups(self) -> tuple of hou.PrimGroup
        
        Return a tuple of all the primitive groups in the geometry.
        
        
        """
        pass
        
    
    def pointIntAttribValues(name):
        """
        pointIntAttribValues(self, name) -> tuple of int
        
        Return a tuple of integers containing one attribute's values for all
        the points.
        
        This method only works on int or float attributes. If the attribute
        contains more than one element, each point will correspond to
        multiple values in the result. For example, if "idmap" is an integer
        attribute of size 2 and there are 3 points with values (1, 2), (2,
        3), and (3, 4) then the result will be (1, 2, 2, 3, 3, 4).
        
        Calling this method is faster than looping over all the points and
        calling hou.Point.attribValue.
        
        If the attribute name is invalid or the attribute is not an int or
        float (e.g. it's a string attribute), this method raises
        hou.OperationFailed.
        
        Note that you cannot pass a hou.Attrib object to this method like
        you can with many methods dealing with attributes. However, you can
        use hou.Attrib.name to easily get the name from an Attrib object.
        
        
        """
        pass
        
    
    def pointNormals(points):
        """
        pointNormals(self, points) -> tuple of hou.Vector3
        
        Returns a tuple of hou.Vector3 objects representing the point
        normals for the supplied points.
        
        points: A list of hou.Point objects for which to compute point
        normals.
        
        
        """
        pass
        
    
    def pointIntAttribValuesAsString(name, int_type=hou.numericData.Int32):
        """
        pointIntAttribValuesAsString(self, name, int_type=hou.numericData.Int32)
        -> str
        
        Return a string representation of the integers of one attribute's
        value for all the points. This method is faster than
        hou.Geometry.pointIntAttribValues, and you can use the array module
        to convert the string into a Python sequence.
        
        
        int_type
        A hou.numericData value to specify the integer data type (either
        Int8, Int16, Int32 or Int64).
        
        This method provides a faster implementation of the following:
        
        > import array
        > def pointIntAttribValuesAsString(self, name):
        >     return array.array("i", self.pointIntAttribValues(name)).tostring()
        
        You can convert the return value from this method to an array using
        the following method:
        
        > import array
        > def pointIntAttribValuesAsArray(geometry, name):
        >     a = array.array("i")
        >     a.fromstring(geometry.pointIntAttribValuesAsString(name))
        >     return a
        
        See hou.Geometry.pointIntAttribValues for more information.
        
        
        """
        pass
        
    
    def intrinsicNames():
        """
        intrinsicNames(self) -> tuple of str
        
        Returns a tuple of strings representing the intrinsic values
        available for this geometry. Different geometry types will have
        different intrinsic values available. You can then get or set the
        value using intrinsicValue and/or setIntrinsicValue.
        
        See the intrinsicValue method for more information.
        
        
        """
        pass
        
    
    def renamePrimAttrib(old_name, new_name):
        """
        renamePrimAttrib(self, old_name, new_name)
        
        Rename the primitive attribute with the specified old name to the
        new name. This method is typically called from within a Python-
        defined SOP when the SOP's geometry is writable.
        
        Raises GeometryPermissionError if called on a read-only geometry.
        Raises TypeError if old_name or new_name is None. Raises
        OperationFailed if no such primitive attribute with the old name
        exists. Raises OperationFailed if a primitive attribute with the new
        name already exists.
        
        
        """
        pass
        
    
    def createPolygons(points):
        """
        createPolygons(self, points) -> tuple of hou.Polygon
        
        Create a set of polygons with the specified points as vertices and
        return a tuple of the new hou.Polygon objects. You would typically
        call this method from the code of a Python-defined SOP.
        
        points can be either a tuple of tuples of hou.Point objects or a
        tuple of tuples of integers representing the point numbers. For
        example, if points is ((0, 1, 2), (3, 4, 5, 6)) then this method
        will create 2 polygons with one having points 0, 1 and 2 as its
        vertices and the other one having points 3, 4, 5 and 6 as its
        vertices.
        
        The created polygons are closed (see hou.Face.isClosed for more
        information).
        
        If the geometry contains primitive attributes, then the new polygons
        receive the default values for those attributes.
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable. Raises hou.InvalidSize if one of the specified point
        tuples does not contain at least 3 elements. Raises hou.InvalidInput
        if one of the point numbers or hou.Point objects do not exist in the
        geometry.
        
        Example:
        
        > # Create 6 points in the geometry.
        > geo = hou.pwd().geometry()
        > point_positions = (
        >     (1, 0, 0), (0, 1, 0), (0, 0, 1),
        >     (1, 1, 0), (1, 0, 1), (0, 1, 1),
        > )
        > points = geo.createPoints(point_positions)
        >
        > # Create 2 polygons.
        > # The first polygon uses the first 3 points in the geometry as its vertices.
        > # The second polygon uses the last 3 points in the geometry as its vertices.
        > polygons = geo.createPolygons(
        >     ((points[0], points[1], points[2]), (points[3], points[4], points[5])))
        
        """
        pass
        
    
    def setVertexStringAttribValues(name, values):
        """
        setVertexStringAttribValues(self, name, values)
        
        For a particular attribute, set the attribute values for all
        vertices. You would typically call this method from the code of a
        Python-defined SOP.
        
        
        name
        The name of the vertex attribute.
        
        values
        A sequence of string values in the same format as that returned
        by hou.Geometry.vertexStringAttribValues. See that method for
        more information.
        
        Raises hou.OperationFailed if the attribute name is not valid, the
        attribute is not a string, or the array of values is not the correct
        size.
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable.
        
        Also see hou.Geometry.vertexStringAttribValues.
        
        
        """
        pass
        
    
    def renameGlobalAttrib(old_name, new_name):
        """
        renameGlobalAttrib(self, old_name, new_name)
        
        Rename the global attribute with the specified old name to the new
        name. This method is typically called from within a Python-defined
        SOP when the SOP's geometry is writable.
        
        Raises GeometryPermissionError if called on a read-only geometry.
        Raises TypeError if old_name or new_name is None. Raises
        OperationFailed if no such global attribute with the old name
        exists. Raises OperationFailed if a global attribute with the new
        name already exists.
        
        
        """
        pass
        
    
    def pointLoop(points, full_loop):
        """
        pointLoop(self, points, full_loop) -> tuple of hou.Point
        
        Returns a tuple of hou.Point objects that make a path connecting the
        points provided in the points parameter. If multiple paths are being
        returned, they will be separated in the single returned tuple by a
        value of None. The paths are generated using the same algorithm used
        when performing loop selections in the viewport.
        
        points: A list of hou.Point objects that define the path or paths of
        connected points this function should return. Must contain at least
        two points.
        
        loop_type: Controls the type of path returned. Can be any of the
        hou.componentLoopType values. If using either the
        hou.componentLoopType.Extended or hou.componentLoopType.Closed loop
        types, the inputs points cannot contain any None entries.
        Furthermore, each pair of points is used to define a separate full
        loop, so the number of points must be even. If these conditions are
        not met, a hou.OperationFailed exception will be thrown.
        
        Raises a hou.OperationFailed if it was unable to construct a loop
        from the desired components.
        
        
        """
        pass
        
    
    def createTetrahedronInPlace(p0, p1, p2, p3):
        """
        createTetrahedronInPlace(self, p0, p1, p2, p3) -> hou.Prim
        
        Create a new tetrahedron and return the corresponding hou.Prim
        object. You would typically call this method from the code of a
        Python-defined SOP.
        
        The newly created tetrahedron has four vertices and uses the points
        that have been passed into it.
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable.
        
        
        """
        pass
        
    
    def primIntAttribValuesAsString(name, int_type=hou.numericData.Int32):
        """
        primIntAttribValuesAsString(self, name, int_type=hou.numericData.Int32)
        -> str
        
        Return a string representation of the integers of one attribute's
        value for all the primitives. This method is faster than
        hou.Geometry.primFloatAttribValues, and you can use the array module
        to convert the string into a Python sequence.
        
        
        int_type
        A hou.numericData value to specify the integer data type (either
        Int8, Int16, Int32 or Int64).
        
        This method provides a faster implementation of the following:
        
        > import array
        > def primIntAttribValuesAsString(self, name):
        >     return array.array("i", self.primIntAttribValues(name)).tostring()
        
        You can convert the return value from this method to an array using
        the following method:
        
        > import array
        > def primIntAttribValuesAsArray(geometry, name):
        >     a = array.array("i")
        >     a.fromstring(geometry.primIntAttribValuesAsString(name))
        >     return a
        
        See hou.Geometry.primIntAttribValues for more information.
        
        
        """
        pass
        
    
    def findPointGroup(name):
        """
        findPointGroup(self, name) -> hou.PointGroup or None
        
        Return the point group with the given name, or None if no such group
        exists.
        
        
        """
        pass
        
    
    def createMeshSurface(rows, cols, is_closed_in_u=False, is_closed_in_v=False):
        """
        createMeshSurface(self, rows, cols, is_closed_in_u=False,
        is_closed_in_v=False) -> hou.Surface
        
        Create a quadrilateral mesh surface in the XY plane centered at the
        origin with size (1, 1) and return it. You would typically call this
        method from the code of a Python-defined SOP.
        
        Note that a mesh object is not the same as a set of polygons
        defining the same shape. A mesh object is a single primitive.
        
        See hou.Geometry.createNURBSSurface for more information.
        
        
        """
        pass
        
    
    def primLoop(prims, loop_type):
        """
        primLoop(self, prims, loop_type) -> tuple of hou.Prim
        
        Returns a tuple of hou.Prim objects that make a path connecting the
        primitives provided in the prims parameter. If multiple paths are
        being returned, they will be separated in the single returned tuple
        by a value of None. The paths are generated using the same algorithm
        used when performing loop selections in the viewport.
        
        prims: A list of hou.Prim objects that define the path or paths of
        connected primitives this function should return. Must contain at
        least two primitives.
        
        loop_type: Controls the type of path returned. Can be any of the
        hou.componentLoopType values. If using either the
        hou.componentLoopType.Extended or hou.componentLoopType.Closed loop
        types, the inputs prims cannot contain any None entries.
        Furthermore, each pair of primitives is used to define a separate
        full loop, so the number of primitives must be even. If these
        conditions are not met, a hou.OperationFailed exception will be
        thrown.
        
        Raises a hou.OperationFailed if it was unable to construct a loop
        from the desired components.
        
        
        """
        pass
        
    
    def createNURBSCurve(num_vertices=4, is_closed=False, order=4):
        """
        createNURBSCurve(self, num_vertices=4, is_closed=False, order=4) ->
        hou.Face
        
        Create a new NURBS with the specified number of vertices and return
        it. You would typically call this method from the code of a Python-
        defined SOP.
        
        
        num_vertices
        The number of verticies in the curve. A new point is added to
        the geometry for each vertex, and this point is located at the
        origin until you change its position. You can also add more
        vertices with hou.Face.addVertex.
        
        The minimum number of vertices for a NURBS curve is identical to
        its order. So for the default order of 4, the curve must have a
        minimum of 4 vertices. If you specify too few vertices, this
        method raises hou.OperationFailed.
        
        is_closed
        Controls if the curve is open or closed; see hou.Face.isClosed
        for more information. If not specified, the resulting curve is
        open. This behavior is different from
        hou.Geometry.createPolygon, where the new polygon is closed. You
        can also open or close it with hou.Face.setIsClosed.
        
        order
        Specifies the curve's order. The default order is 4,
        corresponding to a cubic NURBS curve. An order of 2, the lowest
        order, will give a curve with linear segments.
        
        If the geometry contains primitive attributes, the new curve
        receives the default values for those attributes.
        
        > # This code will work from inside a Python SOP, but not from the Python
        > # shell.
        > geo = hou.pwd().geometry()
        > curve = geo.createNURBSCurve(10)
        > i = 0
        > for vertex in curve.vertices():
        >     vertex.point().setPosition((i, i % 3, 0))
        >     i = i + 1
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable.
        
        See also:
        
        * hou.Prim.vertices
        
        * hou.Point.setPosition
        
        
        """
        pass
        
    
    def createNURBSSurface(rows, cols, is_closed_in_u=False, is_closed_in_v=False):
        """
        createNURBSSurface(self, rows, cols, is_closed_in_u=False,
        is_closed_in_v=False) -> hou.Surface
        
        Create a NURBS surface in the XY plane centered at the origin with
        size (1, 1) and return it. You would typically call this method from
        the code of a Python-defined SOP.
        
        
        rows, cols
        Determines the size of the 2D array of vertices defining the
        control points of the surface. The number of cols and rows in
        each direction, must be equal to or larger than the U and V
        orders, respectively.
        
        is_closed_in_u, is_closed_in_v
        Controls if the surface is open or closed in each of the U and V
        directions; see hou.Surface.isClosedInU for more information. If
        not specified, the default behavior is to build an open surface.
        
        order_u, order_v
        Specifies the surface's order in each of the U and V directions.
        The default order for both is 4, corresponding to a cubic NURBS
        surface. An order of 2, the lowest order, will give a surface
        with linear segments, essentially a mesh.
        
        If the geometry contains primitive attributes, the new surface
        receives the default values for those attributes.
        
        You can move or resize the surface using
        hou.Geometry.transformPrims.
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable.
        
        Raises hou.OperationFailed if the number of rows and/or columns is
        invalid.
        
        > # This code will work from inside a Python SOP, but not from the Python
        > # shell.
        > geo = hou.pwd().geometry()
        >
        > # Create a surface with a 10x10 grid of vertices.
        > surf = geo.createNURBSSurface(10, 10)
        >
        > # Initially, the center is at (0, 0, 0), size is (1, 1, 1), on the XY
        > # plane.  Scale to (20, 10) and rotate into the XZ plane.
        > geo.transformPrims((surf,),
        >     hou.hmath.buildScale((20, 10, 1)) *
        >     hou.hmath.buildRotateAboutAxis((1, 0, 0), 90))
        
        See also:
        
        * hou.Geometry.transformPrims
        
        * hou.Matrix4
        
        * hou.hmath
        
        
        """
        pass
        
    
    def primStringAttribValues(name):
        """
        primStringAttribValues(self, name) -> tuple of str
        
        Return a tuple of strings containing one attribute's values for all
        the primitives.
        
        This method only works on string attributes. If the attribute
        contains more than one element, each primitive will correspond to
        multiple values in the result. For example, if "strmap" is a string
        attribute of size 2 and there are 3 primitives with values ("apple",
        "orange"), ("red", "blue"), and ("one", "two") then the result will
        be ("apple", "orange", "red", "blue", "one", "two").
        
        Calling this method is faster than looping over all the primitives
        and calling hou.Prim.attribValue.
        
        If the attribute name is invalid or the attribute is not a string
        attribute) then this method raises hou.OperationFailed.
        
        Note that you cannot pass a hou.Attrib object to this method like
        you can with many methods dealing with attributes. However, you can
        use hou.Attrib.name to easily get the name from an Attrib object.
        
        
        """
        pass
        
    
    def createBezierCurve(num_vertices=4, is_closed=False, order=4):
        """
        createBezierCurve(self, num_vertices=4, is_closed=False, order=4) ->
        hou.Face
        
        Create a new Bezier curve with the specified number of vertices and
        return it. You would typically call this method from the code of a
        Python-defined SOP.
        
        
        num_vertices
        The number of verticies in the curve. A new point is added to
        the geometry for each vertex, and this point is located at the
        origin until you change its position. You can also add more
        vertices with hou.Face.addVertex.
        
        is_closed
        Controls if the curve is open or closed; see hou.Face.isClosed
        for more information. If not specified, the resulting curve is
        open. This behavior is different from
        hou.Geometry.createPolygon, where the new polygon is closed.
        
        order
        Specifies the curve's order. The default order is 4,
        corresponding to a cubic Bezier curve. An order of 2, the lowest
        order, will give a curve with linear segments.
        
        An open Bezier curve must have (order - 1) * n + 1 vertices for some
        integer n>=1 (so valid values for order 4 curves are 4, 7, 10,
        etc.). A closed Bezier curve must have (order - 1) * n vertices
        (e.g. 3, 6, 9, etc. for order 4 curve). This restriction does not
        apply to curves of order 2, however.
        
        As a consequence, you cannot use hou.Face.setIsClosed on non-linear
        Bezier curves, since the number of vertices would need to change.
        
        See hou.Geometry.createNURBSCurve for more information.
        
        
        """
        pass
        
    
    def data():
        """
        data(self) -> str
        
        Return the geometry data in bgeo format.
        
        For example:
        
        > geometry = hou.node("/obj/geo1/torus1").geometry()
        > bgeo_data = geometry.data()
        > open("/tmp/torus.bgeo", "wb").write(bgeo_data)
        
        """
        pass
        
    
    def addArrayAttrib(type, name, data_type, tuple_size=1):
        """
        addArrayAttrib(self, type, name, data_type, tuple_size=1) -> hou.Attrib
        
        Create a new point, primitive, vertex, or global (a.k.a. detail)
        array attribute. Returns a hou.Attrib object describing the newly
        created attribute. You would typically call this method from the
        code of a Python-defined SOP.
        
        
        type
        A hou.attribType value to specify if the new attribute should be
        a point, primitive, vertex, or global attribute.
        
        name
        The new attribute's name. Each attribute in the geometry must
        have a unique name.
        
        data_type
        A hou.attribData value to specify if the new attribute should be
        an int, float, or string attribute.
        
        tuple_size
        The new attribute's tuple size.
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable.
        
        Raises hou.OperationFailed if an attribute with this name already
        exists. If you are familiar with the C++ Houdini Development Kit
        (HDK), you know that Houdini can support attributes with the same
        name but with different types. However, many SOPs do not let you
        distinguish between attributes that have the same name, and multiple
        attributes with the same name are discouraged. For this reason, you
        cannot create them with this method.
        
        
        """
        pass
        
    
    def _orderedPoints():
        """None"""
        pass
        
    
    def pointFloatAttribValuesAsString(name, float_type=hou.numericData.Float32):
        """
        pointFloatAttribValuesAsString(self, name,
        float_type=hou.numericData.Float32) -> str
        
        Return a string representation of the floats of one attribute's
        value for all the points. This method is faster than
        hou.Geometry.pointFloatAttribValues, and you can use the array
        module to convert the string into a Python sequence.
        
        
        float_type
        A hou.numericData value to specify the float data type (either
        Float16, Float32 or Float64).
        
        This method provides a faster implementation of the following:
        
        > import array
        > def pointFloatAttribValuesAsString(self, name):
        >     return array.array("f", self.pointFloatAttribValues(name)).tostring()
        
        You can convert the return value from this method to an array using
        the following method:
        
        > import array
        > def pointFloatAttribValuesAsArray(geometry, name):
        >     a = array.array("f")
        >     a.fromstring(geometry.pointFloatAttribValuesAsString(name))
        >     return a
        
        See hou.Geometry.pointFloatAttribValues for more information.
        
        
        """
        pass
        
    
    def createPacked(typename):
        """
        createPacked(self, typename) -> hou.PackedPrim
        
        
        typename
        A string containing the name of a type of packed primitive.
        Typical examples are "PackedDisk" (on-disk geometry file) or
        "AlembicRef" (Alembic file).
        
        To see a complete list of possible typename values, run ginfo -P
        on a Houdini tools command line.
        
        See hou.PackedPrim for more information.
        
        
        """
        pass
        
    
    def globEdges():
        """None"""
        pass
        
    
    def clear():
        """
        clear(self)
        
        Remove everything from this geometry object. The geometry will have
        no points or primitives after calling this method.
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable.
        
        
        """
        pass
        
    
    def findPrimGroup(name):
        """
        findPrimGroup(self, name) -> hou.PrimGroup or None
        
        Return the primitive group with the given name, or None if no such
        group exists.
        
        
        """
        pass
        
    
    def primAttribs():
        """
        primAttribs(self) -> tuple of hou.Attrib
        
        Return a tuple of all the primitive attributes.
        
        
        """
        pass
        
    
    def intrinsicReadOnly():
        """None"""
        pass
        
    
    def globVertices():
        """None"""
        pass
        
    
    def points():
        """
        points(self) -> tuple of hou.Point
        
        Return a tuple of all the points in the geometry.
        
        See also the hou.Geometry.iterPoints method.
        
        
        """
        pass
        
    
    def globPrims(pattern):
        """
        globVertices(self, pattern) -> tuple of hou.Vertex
        
        Return a tuple of vertices corresponding to a pattern of vertex
        numbers.
        
        The pattern format is the same one used by the group fields on SOP
        nodes that take vertex selections. See hou.Geometry.globPoints for
        more information.
        
        
        """
        pass
        
    
    def setVertexFloatAttribValuesFromString():
        """None"""
        pass
        
    
    def setPrimStringAttribValues(name, values):
        """
        setPrimStringAttribValues(self, name, values)
        
        For a particular attribute, set the attribute values for all
        primitives. You would typically call this method from the code of a
        Python-defined SOP.
        
        
        name
        The name of the primitive attribute.
        
        values
        A sequence of string values in the same format as that returned
        by hou.Geometry.primStringAttribValues. See that method for more
        information.
        
        Raises hou.OperationFailed if the attribute name is not valid, the
        attribute is not a string, or the array of values is not the correct
        size.
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable.
        
        Also see hou.Geometry.primStringAttribValues.
        
        
        """
        pass
        
    
    def createPrimGroup(name, is_ordered=False):
        """
        createPrimGroup(self, name, is_ordered=False) -> Hou.PrimGroup
        
        Create a new primitive group in this geometry.
        
        
        name
        The name of the new group. Raises hou.OperationFailed if a group
        with this name already exists.
        
        is_ordered
        Whether or not the new group should be ordered. See
        hou.PrimGroup for more information about ordered groups.
        
        Use hou.PrimGroup.destroy to remove a primitive group from the
        geometry.
        
        
        """
        pass
        
    
    def primBoundingBox(primpattern):
        """
        primBoundingBox(self, primpattern) -> hou.BoundingBox
        
        Return an axis-aligned 3D bounding box that is sized and positioned
        to include the primitives specified by the primitive pattern. If the
        pattern is blank, all primitives will be included.
        
        Some primitives, such as spheres, extend beyond their points. This
        extension will be included.
        
        
        """
        pass
        
    
    def floatAttribValue(name_or_attrib):
        """
        floatAttribValue(self, name_or_attrib) -> float
        
        Return the global (a.k.a. detail) attribute value for a particular
        floating point attribute. The attribute may be specified by name or
        by hou.Attrib object.
        
        Raises hou.OperationFailed if no attribute exists with this name or
        the attribute is not a float of size 1.
        
        In most cases, you'll just use hou.Geometry.attribValue to access
        attribute values. Houdini uses this method internally to implement
        attribValue.
        
        
        """
        pass
        

class GeometryDelta(object):
    """
    hou.GeometryDelta
    
    Geometry delta provides access to the geometry differences (deltas)
    stored by some Geometry nodes such as the edit SOP.
    
    If you ask a SOP for its geometry delta via hou.SopNode.geometryDelta,
    you'll get a reference to it. If the SOP recooks, the corresponding
    geometry delta objects will update to the SOP's new geometry delta
    object. If the SOP is deleted, accessing the geometry delta object will
    raise a hou.ObjectWasDeleted exception.
    
    
    """
    
    def setPointPositionsFromString(positions):
        """
        setPointPositionsFromString(self, positions)
        
        Stores the differences between the provided positions and this SOP
        node's input geometry into this node's geometry delta object. This
        can be used, for example, to preload an edit SOP's delta so its
        output geometry matches a desired shape without changing the input
        geometry.
        
        The positions parameter should be a binary representation of the
        positions. For example, the result of calling
        hou.Geometry.pointFloatAttribValuesAsString.
        
        
        """
        pass
        

def GeometryDelta_swigregister():
    """None"""
    pass
    

class GeometryPermissionError(Error):
    """
    hou.GeometryPermissionError
    
    Exception that is raised when you try to modify geometry from outside of
    a Python SOP.
    
    
    """
    
    def description():
        """
        description(self) -> str
        
        Return a description of the class of exception. The description is
        not related to the exception instance.
        
        
        """
        pass
        
    
    def exceptionTypeName():
        """
        exceptionTypeName(self) -> str
        
        Return the name of the exception type. Instances of different
        subclasses of hou.Error will return different names. Instances of
        the base class will return "Error".
        
        You can also use str(e.__class__) to get the name of the subclass.
        
        
        """
        pass
        

def GeometryPermissionError_swigregister():
    """None"""
    pass
    

class GeometrySelection(object):
    """
    hou.GeometrySelection
    
    Represents a component selection performed by the user in a viewport.
    
    Calling hou.SceneViewer.selectGeometry waits for the user to perform a
    selection in the viewport, and returns an object of this type
    representing the elected components. The returned selection can be
    manipulated by converting it to a specific component type, grown, or
    shrunk. Then the selection can be converted to a string that can be used
    in a SOP node group parameter.
    
    If the selection contains components from more than one SOP, you can use
    the hou.GeometrySelection.mergedNode function to create a Merge SOP
    and/or Object Merge SOPs that brings all the referenced geometry into a
    single node.
    
    
    """
    
    def ordered():
        """
        ordered(self) -> bool
        
        Returns true if this is an ordered selection. This means that the
        order in which the user selected the components is preserved. To
        have an ordered selection, the ordered parameter needs to have been
        set to True when calling hou.SceneViewer.geometrySelection.
        
        
        """
        pass
        
    
    def shrinkSelection(checkuv, =, true):
        """
        shrinkSelection(checkuv = true)
        
        Removes components that are on the boundary of the selection.
        
        
        """
        pass
        
    
    def connectivity():
        """
        connectivity(self) -> hou.connectivityType enum value
        
        Returns the hou.connectivityType that has been set on this geometry
        selection. Unless you call hou.GeometrySelection.setConnectivity,
        this function will return the no connectivity value.
        
        
        """
        pass
        
    
    def needsMergedNode(parent):
        """
        needsMergedNode(self, parent) -> bool
        
        Returns true if a Merge SOP needs to be created in order to access
        all components in the selection.
        
        
        """
        pass
        
    
    def setGeometryType(type):
        """
        setGeometryType(self, type)
        
        Changes the type of component contained in the selection, converting
        the existing selection to the new component type.
        
        
        """
        pass
        
    
    def mergedSelectionString(empty_string_selects_all=True, force_numeric=False):
        """
        mergedSelectionString(self, empty_string_selects_all=True,
        force_numeric=False) -> string
        
        Returns a single string that can be used in group parameters of the
        merged node returned by hou.GeometrySelection.mergedNode. If all
        components are selected from a single node this is equivalent to the
        first string in the tuple returned by
        hou.GeometrySelection.selectionStrings.
        
        
        """
        pass
        
    
    def selections():
        """
        selections(self) -> tuple of [Hom:hou.Selection]
        
        Returns a tuple of component selection objects. These correspond to
        the nodes returned by the nodes function.
        
        
        """
        pass
        
    
    def setPrimitiveTypes(primitive_types):
        """
        setPrimitiveTypes(self, primitive_types)
        
        Sets the tuple of primitive types allowed in the selection. Any
        primitives that are not of an allowed type are removed from the
        selection. Only has an effect if this is a primitive selection.
        
        
        """
        pass
        
    
    def selectionStrings(empty_string_selects_all=True, bool, force_numeric=False):
        """
        selectionStrings(self, empty_string_selects_all=True, bool
        force_numeric=False) -> tuple of strings
        
        Returns a tuple of strings that can be used to refer to the selected
        components in each SOP node referenced by the selection.
        
        
        """
        pass
        
    
    def setConnectivity(connectivity):
        """
        setConnectivity(self, connectivity)
        
        Sets the type of connectivity to enforce when modifying the
        selection. The current selection is also expanded so that all
        connected components (using the supplied style of connectivity)
        become part of the selection.
        
        
        """
        pass
        
    
    def geometryType():
        """
        geometryType(self) -> hou.geometryType enum value
        
        Returns the type of component that was selected.
        
        
        """
        pass
        
    
    def mergedNode(parent, creator_name, force_keep_original_objects=False, display_original_objects=False):
        """
        mergedNode(self, parent, creator_name,
        force_keep_original_objects=False, display_original_objects=False) ->
        Node
        
        Creates a Merge SOP that combines all the SOPs referenced by the
        selection. Most selections will only reference a single SOP in which
        case no Merge SOP is required, and the selected SOP will be
        returned.
        
        
        """
        pass
        
    
    def growSelection():
        """
        growSelection()
        
        Expands the selection by adding all components that are connected to
        components currently in the selection.
        
        
        """
        pass
        
    
    def primitiveTypes():
        """
        primitiveTypes(self) -> tuple of hou.primitiveType enum values
        
        Returns a tuple containing all primitive types that are contained in
        the selection.
        
        
        """
        pass
        
    
    def nodes():
        """
        nodes(self) -> tuple of Nodes
        
        Returns a tuple of all nodes referenced by the selection.
        
        
        """
        pass
        

def GeometrySelection_swigregister():
    """None"""
    pass
    

class GeometryViewport(object):
    """
    hou.GeometryViewport
    
    REPLACES
    
    * viewcamera
    
    * viewhome
    
    * viewwrite
    
    
    """
    
    def viewTransform():
        """
        viewTransform(self) -> hou.Matrix4
        
        Returns the transform matrix of the view. To set the viewpoint
        programmatically, use defaultCamera() to get a hou.ViewportCamera
        object and manipulate that.
        
        
        """
        pass
        
    
    def queryPrimAtPixel(node, x, y):
        """
        queryPrimAtPixel(self, node, x, y) -> hou.Prim or None
        
        Return the primitive drawn at the specified pixel in the viewport,
        or None if there is nothing there. The primitive returned will be a
        subclass of hou.Prim.
        
        The parameter node is used to restrict the query to geometry within
        a particular node. If node is None, then the query is unrestricted.
        
        
        """
        pass
        
    
    def saveViewToCamera(camera_node):
        """
        saveViewToCamera(self, camera_node)
        
        Copies the viewpoint transform of the current view onto the
        transformation parameters of a camera or light node.
        
        
        camera_node
        A hou.ObjNode object representing the node to save the view to.
        
        
        """
        pass
        
    
    def queryInspectedGeometry():
        """
        queryInspectedGeometry(self) -> hou.Geometry or None
        
        Return the geometry currently being inspected in the viewport, or
        None when nothing is being inspected or when called outside of an
        inspect script.
        
        
        """
        pass
        
    
    def setDefaultCamera(stashed_cam):
        """
        setDefaultCamera(self, stashed_cam)
        
        Takes a hou.GeometryViewportCamera and copies its values into this
        viewport.
        
        Set the current camera settings of the viewport to the settings
        stored in cam_setting. If the viewport is looking through a camera
        and the view is not locked to the camera, it will be switched to "No
        camera". If the view is locked to the camera, the camera object will
        be updated instead.
        
        
        """
        pass
        
    
    def home():
        """
        home(self)
        
        Moves/tumbles the viewport to the default view.
        
        
        """
        pass
        
    
    def setCamera(camera_node):
        """
        setCamera(self, camera_node)
        
        Copies the viewport transform from the transformation parameters of
        a camera or light onto the current view. This is the same as
        choosing a camera/light from the Look through submenu in the
        viewport's Camera menu.
        
        
        camera_node
        A hou.ObjNode object representing the node to save the view
        from.
        
        
        """
        pass
        
    
    def homeAll():
        """
        homeAll(self)
        
        Moves/tumbles the view to show all geometry/objects (including
        templated geometry). See also homeNonTemplated().
        
        
        """
        pass
        
    
    def frameNonTemplated():
        """
        frameNonTemplated(self)
        
        Moves the view to show all _non-templated_ geometry.
        
        
        """
        pass
        
    
    def homeNonTemplated():
        """
        homeNonTemplated(self)
        
        Moves/tumbles the view to show all _non-templated_ geometry.
        
        
        """
        pass
        
    
    def resolutionInPixels():
        """
        resolutionInPixels(self) -> 2-tuple of int
        
        Returns the resolution of the viewport in pixels, as (width,
        height).
        
        
        """
        pass
        
    
    def clearEventCallbacks():
        """
        clearEventCallbacks(self)
        
        Remove all Python callbacks that have been registered with
        hou.GeometryViewport.addEventCallback.
        
        
        """
        pass
        
    
    def camera():
        """None"""
        pass
        
    
    def eventCallbacks():
        """
        eventCallbacks(self) -> tuple of callbacks
        
        Return a tuple of all the Python callbacks that have been registered
        with hou.GeometryViewport.addEventCallback.
        
        
        """
        pass
        
    
    def viewPivot():
        """
        viewPivot(self) -> hou.Vector3
        
        Returns a hou.Vector3 representing the view pivot as a point in
        world space.
        
        
        """
        pass
        
    
    def queryInspectedPrim():
        """
        queryInspectedPrim(self) -> hou.Prim or None
        
        Return the primitive currently being inspected in the viewport, or
        None when nothing is being inspected or when called outside of an
        inspect script. The primitive returned will be a subclass of
        hou.Prim.
        
        
        """
        pass
        
    
    def type():
        """
        type(self) -> hou.geometryViewportType enum value
        
        Query the viewport type (UV, 3D, top, left, etc).
        
        
        """
        pass
        
    
    def frameGrid():
        """
        frameGrid(self)
        
        Frames the view on the grid.
        
        
        """
        pass
        
    
    def mapToWorld(x, y):
        """
        mapToWorld(self, x, y) -> tuple of (hou.Vector3, hou.Vector3)
        
        Convert viewport coordinates to world coordinates. Returns a ray
        (direction vector and an origin point).
        
        
        """
        pass
        
    
    def draw():
        """
        draw(self)
        
        Request that the viewport redraw. Multiple draw() calls within the
        same script will be merged into a single call.
        
        
        """
        pass
        
    
    def lockCameraToView():
        """
        lockCameraToView(self)
        
        Set the viewport camera lock. When True, any changes to the view
        will affect the camera object being viewed though. When False, the
        camera will become disconnected from the viewport and revert to the
        default viewport camera when the user tumbles the view. It is
        possible to enable this without the viewport looking through a
        camera, though view changes will not affect any objects until the
        user sets the viewport to look through a camera or light.
        
        
        """
        pass
        
    
    def addEventCallback(callback):
        """
        addEventCallback(self, callback)
        
        Register a Python callback to be called whenever a viewport event
        occurs. The event types are defined in hou.geometryViewportEvent.
        
        'callback':
        
        Any callable Python object that expects keyworded arguments specific
        to an event type. This callback can be used for any geometry
        viewport event type.
        
        Arguments for hou.geometryViewportEvent.CameraSwitched:
        
        * event_type: This viewport event.
        
        * desktop: The desktop object holding the scene viewer.
        
        * viewer: The scene viewer object holding the viewport.
        
        * viewport: The viewport object that triggered the event.
        
        > import hou
        >
        > def myViewportCB(**kwargs):
        >         event_type=kwargs['event_type']
        >         desktop=kwargs['desktop']
        >         viewer=kwargs['viewer']
        >         viewport=kwargs['viewport']
        >
        >         print "
        myViewportCB=",myViewportCB
        >         print "event type=",event_type
        >         print "desktop=",desktop
        >         print "viewer=",viewer
        >         print "viewport=",viewport
        >
        >         cam = viewport.camera()
        >         print "camera=%s
        
        "%(cam.name())
        >
        > curSceneViewer = [item for item in hou.ui.curDesktop().currentPaneTabs() if item.type() == hou.paneTabType.SceneViewer][0]
        > curSceneViewer.curViewport().addEventCallback(myViewportCB)
        
        """
        pass
        
    
    def changeType([Hom:hou.geometryViewportType]):
        """
        changeType(self, [Hom:hou.geometryViewportType])
        
        Set the viewport type (hou.geometryViewportType). This method first
        attempts to restore a stashed view for the new viewport type, but
        failing that, will home the viewport.
        
        
        """
        pass
        
    
    def queryNodeAtPixel(x, y):
        """
        queryNodeAtPixel(self, x, y) -> hou.ObjNode, hou.SopNode, or None
        
        Return the node draw at the specified pixel in the viewport, or None
        if there is nothing there. The type of node returned depends on the
        level of the viewer.
        
        
        """
        pass
        
    
    def mapFromMouseChop(x, y):
        """
        mapFromMouseChop(self, x, y) -> tuple of (int, int)
        
        Convert from the Mouse CHOP's X and Y screen values (which range
        from -1 to 1) to viewport coordinates, where (0,0) is the bottom
        left corner of the viewport.
        
        
        """
        pass
        
    
    def mapToScreen(position):
        """
        mapToScreen(self, position) -> hou.Vector2
        
        Convert world coordinates to viewport coordinates.
        
        
        position
        A hou.Vector3 containing a world space position.
        
        
        """
        pass
        
    
    def isCameraLockedToView():
        """
        isCameraLockedToView(self) -> bool
        
        Query to see if the camera is locked to the view. This returns the
        state of the camera lock only; this can be enabled without viewing
        through a camera.
        
        
        """
        pass
        
    
    def frameAll():
        """
        frameAll(self)
        
        Moves the view to show all geometry/objects. See also
        frameNonTemplates().
        
        
        """
        pass
        
    
    def homeSelected():
        """
        homeSelected(self)
        
        Moves/tumbles the view to show the selected geometry/objects.
        
        
        """
        pass
        
    
    def homeGrid():
        """
        homeGrid(self)
        
        Homes the viewport on the grid.
        
        
        """
        pass
        
    
    def name():
        """
        name(self) -> str
        
        Query of the name of the viewport (persp1, top1, etc).
        
        
        """
        pass
        
    
    def frameBoundingBox(bbox):
        """
        frameBoundingBox(self, bbox)
        
        Moves the view to show an arbitrary area in the scene.
        
        
        bbox
        A hou.BoundingBox representing the volume of space to focus on.
        
        
        """
        pass
        
    
    def settings():
        """
        settings(self) -> hou.GeometryViewportSettings
        
        Set the name of the viewport. Setting the name does not affect its
        type, so naming a perspective view front will be confusing. This is
        best used in conjunction with changeType().
        
        
        """
        pass
        
    
    def usesConstructionPlane():
        """
        usesConstructionPlane(self) -> bool
        
        Returns whether this viewport uses the construction plane when it is
        on.
        
        
        """
        pass
        
    
    def useDefaultCamera():
        """
        useDefaultCamera(self)
        
        Set the viewport camera to "No camera" and stop looking through a
        camera object (or light).
        
        
        """
        pass
        
    
    def changeName(str):
        """
        changeName(self, str)
        
        Set the name of the viewport.
        
        
        """
        pass
        
    
    def frameSelected():
        """
        frameSelected(self)
        
        Moves the view to show the selected geometry/objects.
        
        
        """
        pass
        
    
    def removeEventCallback(selfcallback):
        """
        removeEventCallback(self,callback)
        
        Remove a specific Python callback that have been registered with
        hou.GeometryViewport.addEventCallback.
        
        
        """
        pass
        
    
    def defaultCamera():
        """
        defaultCamera(self) -> hou.GeometryViewportCamera
        
        Returns an object representing the viewport's viewpoint. The
        returned object is "live" in that changing its settings will
        immediately change the view
        
        If a camera/ight is locked to the view, changing the settings of the
        GeometryViewportCamera will change the camera/light node's
        parameters as well.
        
        Instead of a live object, you can get a "disconnected" version of
        the viewpoint using hou.GeometryViewportCamera.stash. This is a
        useful way to remember a certain viewpoint in code for later. You
        can restore a "stashed" camera using setDefaultCamera().
        
        > # Remember the current view
        > cam = viewport.defaultCamera()
        > saved = cam.stash()
        >
        > # Change the view somehow
        >
        > # Restore the original view
        > viewport.setDefaultCamera(saved)
        
        """
        pass
        

class GeometryViewportBackground(object):
    """
    hou.GeometryViewportBackground
    
    """
    
    def setBrightness(intensity):
        """
        setBrightness(self, intensity)
        
        Set the intensity multiplier of the background image. A value of 1
        keeps it at its original intensity, and values less than that dim
        it.
        
        
        """
        pass
        
    
    def sourceFromCOP(use_cop):
        """
        sourceFromCOP(self, use_cop)
        
        Fetch the background image from a composite operator instead of a
        disk file. If False, a disk file is used.
        
        
        """
        pass
        
    
    def autoPlace():
        """
        autoPlace(self) -> bool
        
        Query if the background image is automatically fit to the viewport.
        
        
        """
        pass
        
    
    def imageOffset():
        """
        imageOffset(self) -> tuple of float
        
        Query the background image offset.
        
        
        """
        pass
        
    
    def imageFile():
        """
        imageFile(self) -> str
        
        Query the filename of the background image.
        
        
        """
        pass
        
    
    def imageCOP():
        """
        imageCOP(self) -> str
        
        Query the operation path of the background image.
        
        
        """
        pass
        
    
    def imageScale():
        """
        imageScale(self) -> tuple of float
        
        Query the background image scale.
        
        
        """
        pass
        
    
    def isCOPSource():
        """
        isCOPSource(self) -> bool
        
        Query if the background image is sourced from a composite operator.
        
        
        """
        pass
        
    
    def imageSource():
        """
        imageSource(self) -> str
        
        Query the file or cop path, depending on the current background
        image source.
        
        
        """
        pass
        
    
    def brightness():
        """
        brightness(self) -> float
        
        Query the intensity multiplier of the background image.
        
        
        """
        pass
        
    
    def setImageOffset(offset):
        """
        setImageOffset(self, offset)
        
        Set the background image offset, which is a 2-tuple of float. The
        values should be in the 0-1 range, representing fractions of the
        viewport width and height.
        
        
        """
        pass
        
    
    def setImageScale(scale):
        """
        setImageScale(self, scale)
        
        Set the background image scale, which is a 2-tuple of float. The
        values should be in the 0-1 range, representing fractions of the
        viewport width and height.
        
        
        """
        pass
        
    
    def isFileSource():
        """
        isFileSource(self) -> bool
        
        Query if the background image is sourced from a disk file.
        
        
        """
        pass
        
    
    def setAutoPlace(enable):
        """
        setAutoPlace(self, enable)
        
        Automatically fit the background image to the viewport. If False,
        use the manual offset and scale to position the image.
        
        
        """
        pass
        
    
    def setImageCOP(op_path):
        """
        setImageCOP(self, op_path)
        
        Set the path to the Composite operator defining the background image
        and set the background source to 'COP'.
        
        
        """
        pass
        
    
    def setImageFile(file_path):
        """
        setImageFile(self, file_path)
        
        Set the filename of the background image and set the background
        source to 'File'.
        
        
        """
        pass
        
    
    def setImageSource(file_or_op_path):
        """
        setImageSource(self, file_or_op_path)
        
        Set the file or cop path, depending on the current background image
        source.
        
        
        """
        pass
        

def GeometryViewportBackground_swigregister():
    """None"""
    pass
    

class GeometryViewportCamera(object):
    """
    hou.GeometryViewportCamera
    
    """
    
    def clipPlanes():
        """
        clipPlanes(self) -> 2-tuple of float
        
        Query the clip planes of the viewport camera as (near,far).
        
        
        """
        pass
        
    
    def isPerspective():
        """
        isPerspective(self) -> bool
        
        Query if the camara view uses a perspective projection.
        
        
        """
        pass
        
    
    def setFocalLength(fl):
        """
        setFocalLength(self, fl)
        
        Set the focal length of the viewport camera. Throws an error if the
        viewport is looking though camera object and the view is not locked
        to that camera.
        
        
        """
        pass
        
    
    def windowSize():
        """
        windowSize(self) -> 2-tuple of float
        
        Query the window size of the viewport, in (0,1) space.
        
        
        """
        pass
        
    
    def orthoWidth():
        """
        orthoWidth(self) -> float
        
        
        """
        pass
        
    
    def windowOffset():
        """
        windowOffset(self) -> 2-tuple of float
        
        Query the window offset of the viewport, in (0,1) space.
        
        
        """
        pass
        
    
    def pivot():
        """
        pivot(self) -> 3-tuple of float
        
        Query the pivot of the viewport camera.
        
        
        """
        pass
        
    
    def translation():
        """
        translation(self) -> 3-tuple of float
        
        Query the translation (position) of the viewport camera.
        
        
        """
        pass
        
    
    def setAperture(ap):
        """
        setAperture(self, ap)
        
        Set the aperture of the viewport camera. Throws an error if the
        viewport is looking though camera object and the view is not locked
        to that camera.
        
        
        """
        pass
        
    
    def rotation():
        """None"""
        pass
        
    
    def setAspectRatio(ar):
        """
        setAspectRatio(self, ar)
        
        Set the view aspect ratio of the viewport camera (16:9 would be
        1.777). Throws an error if the viewport is looking though camera
        object and the view is not locked to that camera.
        
        
        """
        pass
        
    
    def setClipPlanes(near_far):
        """
        setClipPlanes(self, near_far)
        
        
        """
        pass
        
    
    def focalLength():
        """
        focalLength(self) -> float
        
        Query the focal length of the viewport camera (or current camera).
        
        
        """
        pass
        
    
    def setWindowSize(size):
        """
        setWindowSize(self, size)
        
        
        """
        pass
        
    
    def stash():
        """
        stash(self) -> hou.GeometryViewportCamera
        
        Create a copy of the camera settings which can be used to store the
        view, usually so it can be restored later. Stashed camera settings
        are not connected to a viewport, so modifying them will have no
        effect on the viewport until it is passed to the viewport via
        hou.GeometryViewport.setDefaultCamera().
        
        
        """
        pass
        
    
    def setPerspective(perspective):
        """
        setPerspective(self, perspective)
        
        Set the camera view to perspective (True) or orthographic (False).
        Fixed orthographics views cannot be changed to perspective (Top,
        Bottom, Left, Right, Front, and Back).
        
        
        """
        pass
        
    
    def setWindowOffset(xy):
        """
        setWindowOffset(self, xy)
        
        
        """
        pass
        
    
    def setPivot(xyz):
        """
        setPivot(self, xyz)
        
        
        """
        pass
        
    
    def setOrthoWidth(ow):
        """
        setOrthoWidth(self, ow)
        
        Set the orthographic width of the viewport camera. Throws an error
        if the viewport is looking though camera object and the view is not
        locked to that camera. This has no effect on perspective cameras.
        
        
        """
        pass
        
    
    def aperture():
        """
        aperture(self) -> float
        
        Query the aperture of the viewport camera (or current camera).
        
        
        """
        pass
        
    
    def setRotation():
        """None"""
        pass
        
    
    def aspectRatio():
        """
        aspectRatio(self) -> float
        
        
        """
        pass
        
    
    def isOrthographic():
        """
        isOrthographic(self) -> bool
        
        Query if the camara view uses an orthographic projection.
        
        
        """
        pass
        
    
    def setTranslation(xyz):
        """
        setTranslation(self, xyz)
        
        
        """
        pass
        

def GeometryViewportCamera_swigregister():
    """None"""
    pass
    

class GeometryViewportDisplaySet(object):
    """
    hou.GeometryViewportDisplaySet
    
    A Display Set represents a group of 3D viewport display options that
    apply to a particular context of geometry.
    
    OVERVIEW
    
    In Houdini's 3D viewer display options window, you can apply
    different display options to certain subsets of objects/geometry,
    for example selected objects, or the displayed SOP. This object
    represents a set of options that apply to one of these subsets. For
    example, you can set templated SOPs to display as wireframe:
    
    > # Get a reference to the geometry viewer
    > pane = hou.ui.curDesktop().paneTabOfType(hou.paneTabType.SceneViewer)
    >
    > # Get the display settings
    > settings = pane.curViewport().settings()
    >
    > # Get the GeometryViewportDisplaySet for objects
    > tmplset = settings.displaySet(hou.displaySetType.TemplateModel)
    >
    > # Tell Houdini to show set the shading mode for this subset to wireframe
    > tmplset.setShadedMode(hou.glShadingType.Wire)
    
    There are several subsets available:
    
    Objects
    
    hou.displaySetType.SceneObject
    Object nodes which are not selected or ghosted.
    
    hou.displaySetType.SelectedObject
    Object nodes which are selected.
    
    hou.displaySetType.GhostObject
    Object nodes which ghosted, which occurs when they are visible
    when at the SOP level and "Ghost Other Objects" is the current
    object mode, but are not the current object.
    
    Geometry
    
    hou.displaySetType.DisplayModel
    SOP with the display flag. This takes precedence over
    TemplateModel and CurrentModel, if the SOP has either the
    template flag set or is selected.
    
    hou.displaySetType.CurrentModel
    SOP that is currently selected. This takes precedence over
    TemplateModel, if that SOP also has the template flag set.
    
    hou.displaySetType.TemplateModel
    SOP that has a template flag set.
    
    You can set the options in each display set independently of the
    other sets. You can also link a subset to another, so this subset
    uses the linked set's options.
    
    
    """
    
    def showPointMarkers(on):
        """
        showPointMarkers(self, on)
        
        Show or hide point markers.
        
        
        """
        pass
        
    
    def isShowingPrimBreakpoints():
        """
        isShowingPrimBreakpoints(self) -> bool
        
        Query if breakpoints are displayed. Breakpoints are only available
        on NURBS and bezier surfaces and curves.
        
        
        """
        pass
        
    
    def pointPositionVisibility():
        """
        pointPositionVisibility(self) -> hou.markerVisibility
        
        Query the visibility setting of point UVs.
        
        
        """
        pass
        
    
    def primNumberVisibility():
        """
        primNumberVisibility(self) -> hou.markerVisibility
        
        Query the visibility setting of primitive numbers.
        
        
        """
        pass
        
    
    def pointNumberVisibility():
        """
        pointNumberVisibility(self) -> hou.markerVisibility
        
        Query the visibility setting of point numbers.
        
        
        """
        pass
        
    
    def isUniqueDisplaySet():
        """
        isUniqueDisplaySet(self) -> bool
        
        A display set can be linked to another display set, so that all of
        its options are taken from that linked set rather than its own. This
        method returns True if the display set is unique, in that it is not
        linked to another display set, and False if the set refers to
        another display set.
        
        
        """
        pass
        
    
    def setBoundaryMode(hou.boundaryDisplay):
        """
        setBoundaryMode(self, hou.boundaryDisplay)
        
        Set the viewport types that highlight 3D boundaries for the geometry
        in the display set.
        
        * hou.boundaryDisplay.Off:
        
        No 3D boundaries are displayed.
        
        * hou.boundaryDisplay.On:
        
        3D boundaries are shown in all viewports.
        
        * hou.boundaryDisplay.View3D:
        
        3D boundaries are shown in 3D viewports only.
        
        * hou.boundaryDisplay.ViewUV: .
        
        3D boundaries are shown in UV viewports only.
        
        
        """
        pass
        
    
    def vertexNumberVisibility():
        """
        vertexNumberVisibility(self) -> hou.markerVisibility
        
        Query the visibility setting of vertex numbers.
        
        
        """
        pass
        
    
    def isShowingUVBackfaces():
        """
        isShowingUVBackfaces(self) -> bool
        
        Query if UV Backface highlighting is enabled in the UV view.
        Highlight polygons that are facing away, as the texture will appear
        backwards on these polygons.
        
        
        """
        pass
        
    
    def showPrimBackfaces(on):
        """
        showPrimBackfaces(self, on)
        
        Enable to tint backfacing polygons to distinguish them from front
        facing polygons.
        
        
        """
        pass
        
    
    def isShowingPointUVs():
        """
        isShowingPointUVs(self) -> bool
        
        Query if point texture coordinates are being shown, as text:
        "(u,v)".
        
        
        """
        pass
        
    
    def isShowingVertexNumbers():
        """
        isShowingVertexNumbers(self) -> bool
        
        Query if vertex numbers are shown. Each vertex on a polygon or mesh
        is numbered 0 to #edges-1.
        
        
        """
        pass
        
    
    def pointTrailVisibility():
        """
        pointTrailVisibility(self) -> hou.markerVisibility
        
        Query the visibility setting of point trails.
        
        
        """
        pass
        
    
    def isShowingPrimProfileNumbers():
        """
        isShowingPrimProfileNumbers(self) -> bool
        
        Query if profile curve numbers are shown, on NURBS surfaces only.
        Each profile curve has an index from 0 to #profiles-1.
        
        
        """
        pass
        
    
    def setVertexMarkerVisibility(visibility):
        """
        setVertexMarkerVisibility(self, visibility)
        
        Controls how vertex markers are shown when displayed.
        
        
        """
        pass
        
    
    def isShowingPointTrails():
        """
        isShowingPointTrails(self) -> bool
        
        Query if point trails are shown (based on the velocity v attribute).
        
        
        """
        pass
        
    
    def isShowingPointMarkers():
        """
        isShowingPointMarkers(self) -> bool
        
        Query if point markers are shown (blue dots at points).
        
        
        """
        pass
        
    
    def useLighting(on):
        """
        useLighting(self, on)
        
        Enable lighting for the geometry in the display set. This works in
        conjunction with the global lighting mode in the viewport. Both this
        option and the global lighting mode must be set to a lighting mode
        in order to see lighting (ie, enabling Lighting on this display set
        will not cause it to be lit if the global viewport mode is "No
        Lighting").
        
        
        """
        pass
        
    
    def isShowingPrimNormals():
        """
        isShowingPrimNormals(self) -> bool
        
        Query if the primitive face normals are shown. Only polygon-based
        primitives have face normals.
        
        
        """
        pass
        
    
    def showUVBackfaces(on):
        """
        showUVBackfaces(self, on)
        
        Enable or disable UV backface highlighting in the UV viewport.
        Backfacing polygons would have the texture displayed on them
        backwards, from the point of view of the background image in the UV
        viewport.
        
        
        """
        pass
        
    
    def vertexNormalVisibility():
        """
        vertexNormalVisibility(self) -> hou.markerVisibility
        
        Query the visibility setting of vertex normals.
        
        
        """
        pass
        
    
    def showPointPositions(on):
        """
        showPointPositions(self, on)
        
        Show or hide point position text display, drawn by each point.
        
        
        """
        pass
        
    
    def isShowingPointPositions():
        """
        isShowingPointPositions(self) -> bool
        
        Query if 3D point positions are being shown, as text: "(x,y,z)".
        
        
        """
        pass
        
    
    def isShowingUVOverlap():
        """
        isShowingUVOverlap(self) -> bool
        
        Query if the UV overlap is shown in the UV texture viewport. UV
        areas that reuse the same UV coordinates will be highlighted.
        
        
        """
        pass
        
    
    def isShowingPrimProfiles():
        """
        isShowingPrimProfiles(self) -> bool
        
        Query if profile curves are shown, on NURBS surfaces only.
        
        
        """
        pass
        
    
    def isShadingModeLocked():
        """
        isShadingModeLocked(self) -> bool
        
        Query if the shading mode is locked. When locked, changing the
        shading mode in the viewport will not affect the look of geometry in
        this display set.
        
        
        """
        pass
        
    
    def showPointUVs(on):
        """
        showPointUVs(self, on)
        
        Show or hide point UVs. If the geometry does not have point UVs,
        nothing will be displayed (ie. no UVs or vertex UVs).
        
        
        """
        pass
        
    
    def isShowingPointNumbers():
        """
        isShowingPointNumbers(self) -> bool
        
        Query if point numbers are shown as text (blue point numbers, one
        per point).
        
        
        """
        pass
        
    
    def setShadingModeLocked(on):
        """
        setShadingModeLocked(self, on)
        
        Locks the shading mode so that it cannot be changed by the user
        using the Shading Mode menu in the viewport or the wireframe toggle
        hotkey. Passing False unlocks the display set so that it follows the
        viewport's shading mode.
        
        
        """
        pass
        
    
    def setVertexUVVisibility(visibility):
        """
        setVertexUVVisibility(self, visibility)
        
        Controls how vertex normals are shown when displayed.
        
        
        """
        pass
        
    
    def useFadedLook(on):
        """
        useFadedLook(self, on)
        
        Suppress geometry color (Cd attribute, point, primitive, or vertex)
        on the geometry in the display set.
        
        
        """
        pass
        
    
    def showVertexUVs(on):
        """
        showVertexUVs(self, on)
        
        Enable or disable vertex UV texture display. Vertex UVs are drawn
        inset into its parent polygon. The geometry must have vertex texture
        coordinates to be shown (vertex uv).
        
        
        """
        pass
        
    
    def showPrimNumbers(on):
        """
        showPrimNumbers(self, on)
        
        Enable or disable the display of primitive numbers, which are shown
        in the middle of the primitive.
        
        
        """
        pass
        
    
    def isUsingGhostedLook():
        """
        isUsingGhostedLook(self) -> bool
        
        Query if the display set is ghosted. Ghosted geometry appears
        transluscent so that geometry behind it can be easily seen.
        
        
        """
        pass
        
    
    def setPrimNumberVisibility(visibility):
        """
        setPrimNumberVisibility(self, visibility)
        
        Controls how primitive numbers are shown when displayed.
        
        * hou.markerVisibility.Always: All are shown.
        
        * hou.markerVisibility.Selected: Only numbers for selected primitives
        are shown.
        
        * hou.markerVisibility.AroundPointer: Numbers close to the 3D point
        the mouse cursor is currently over are shown.
        
        * hou.markerVisibility.UnderPointer: Numbers under the mouse cursor
        are shown.
        
        
        """
        pass
        
    
    def setPointNumberVisibility(visibility):
        """
        setPointNumberVisibility(self, visibility)
        
        Controls how point numbers are shown when displayed.
        
        * hou.markerVisibility.Always: All are shown.
        
        * hou.markerVisibility.Selected: Only numbers for selected points are
        shown.
        
        * hou.markerVisibility.AroundPointer: Numbers close to the 3D point
        the mouse cursor is currently over are shown.
        
        * hou.markerVisibility.UnderPointer: Numbers under the mouse cursor
        are shown.
        
        
        """
        pass
        
    
    def useXRay(on):
        """
        useXRay(self, on)
        
        Draw the geometry in the display set as XRay, which draws the
        geometry normally if not occluded, and as a dimmed wireframe where
        occluded by other geometry.
        
        
        """
        pass
        
    
    def setPrimNormalVisibility(visibility):
        """
        setPrimNormalVisibility(self, visibility)
        
        Controls how primitive face normals are shown when displayed.
        
        * hou.markerVisibility.Always: All are shown.
        
        * hou.markerVisibility.Selected: Only normals for selected primitives
        are shown.
        
        * hou.markerVisibility.AroundPointer: Normals close to the 3D point
        the mouse cursor is currently over are shown.
        
        * hou.markerVisibility.UnderPointer: Normals under the mouse cursor
        are shown.
        
        
        """
        pass
        
    
    def setPointUVVisibility(visibility):
        """
        setPointUVVisibility(self, visibility)
        
        Controls how point UVs are shown when displayed.
        
        * hou.markerVisibility.Always: All are shown.
        
        * hou.markerVisibility.Selected: Only UVs for selected points are
        shown.
        
        * hou.markerVisibility.AroundPointer: UVs close to the 3D point the
        mouse cursor is currently over are shown.
        
        * hou.markerVisibility.UnderPointer: UVs under the mouse cursor are
        shown.
        
        
        """
        pass
        
    
    def useGhostedLook(on):
        """
        useGhostedLook(self, on)
        
        Make all geometry in the display set appear ghosted - slightly
        translucent. This allows geometry behind the ghosted to seen and de-
        emphasizes the ghosted geometry in the viewport. This is normal used
        to direct focus to other geometry (displayed SOP within an object,
        for example).
        
        
        """
        pass
        
    
    def showPointNumbers(on):
        """
        showPointNumbers(self, on)
        
        Show or hide point numbers.
        
        
        """
        pass
        
    
    def isShowingPrimHulls():
        """
        isShowingPrimHulls(self) -> bool
        
        Query if primitive hulls are shown. Only some primitives have hulls,
        such as volumes, NURBS, crowd agents, and bezier curves.
        
        
        """
        pass
        
    
    def uvBoundaryMode():
        """
        uvBoundaryMode(self) -> hou.boundaryDisplay
        
        Query which viewport types display UV boundaries
        (hou.boundaryDisplay).
        
        * hou.boundaryDisplay.Off:
        
        No UV boundaries are displayed.
        
        * hou.boundaryDisplay.On:
        
        UV boundaries are shown in all viewports.
        
        * hou.boundaryDisplay.View3D:
        
        UV boundaries are shown in 3D viewports only.
        
        * hou.boundaryDisplay.ViewUV: .
        
        UV boundaries are shown in UV viewports only.
        
        
        """
        pass
        
    
    def setVertexNormalVisibility(visibility):
        """
        setVertexNormalVisibility(self, visibility)
        
        Controls how vertex normals are shown when displayed.
        
        
        """
        pass
        
    
    def showVertexMarkers(on):
        """
        showVertexMarkers(self, on)
        
        Enable or disable vertex markers. Vertex markers are drawn as small
        squares inset into its parent polygon slightly.
        
        
        """
        pass
        
    
    def setVertexNumberVisibility(visibility):
        """
        setVertexNumberVisibility(self, visibility)
        
        Controls how vertex numbers are shown when displayed.
        
        
        """
        pass
        
    
    def isShowingVertexUVs():
        """None"""
        pass
        
    
    def showVertexNormals(on):
        """
        showVertexNormals(self, on)
        
        Enable or disable vertex normal display. Vertex normals are drawn
        inset into its parent polygon slightly. The geometry must have
        vertex normals to be shown (vertex N).
        
        
        """
        pass
        
    
    def setPointMarkerVisibility(visibility):
        """
        setPointMarkerVisibility(self, visibility)
        
        Controls how point markers are shown when displayed.
        
        * hou.markerVisibility.Always: All are shown.
        
        * hou.markerVisibility.Selected: Only markers for selected points are
        shown.
        
        * hou.markerVisibility.AroundPointer: Markers close to the 3D point
        the mouse cursor is currently over are shown.
        
        * hou.markerVisibility.UnderPointer: Markers under the mouse cursor
        are shown.
        
        
        """
        pass
        
    
    def primNormalVisibility():
        """
        primNormalVisibility(self) -> hou.markerVisibility
        
        Query the visibility setting of primitive normals.
        
        
        """
        pass
        
    
    def setToolbarLinked(on):
        """
        setToolbarLinked(self, on)
        
        Link the display set's options to the option toggles in the right
        viewport toolbar. When linked, clicking a display option button on
        this toolbar will affect the corresponding option in this display
        set.
        
        
        """
        pass
        
    
    def showPrimNormals(on):
        """
        showPrimNormals(self, on)
        
        Enable or disable primitive face normals. This shows the face
        normals of polygons, not the value of a primitive N attribute.
        
        
        """
        pass
        
    
    def isShowingPrimNumbers():
        """
        isShowingPrimNumbers(self) -> bool
        
        Query if primitive numbers are shown. The primitive numbers can be
        used to specify primitives in primitive groups. The number is shown
        at the center of the primitive.
        
        
        """
        pass
        
    
    def isShowingPointNormals():
        """
        isShowingPointNormals(self) -> bool
        
        Query if point normals are shown.
        
        If the point normals are blue, the geometry has point normals. If
        they are dimmed, the model does not have normals and the normals
        shown have been automatically generated for display. If no normals
        are shown, the geometry has vertex normals. This query does not
        check for those conditions, but just the current setting of the
        display option.
        
        
        """
        pass
        
    
    def showCoincidentPoints(on):
        """
        showCoincidentPoints(self, on)
        
        Enable or disable coincident point detection. Orange points markers
        and a duplicate count are placed where coincident points are
        detected.
        
        Coindicent point detection has affects viewport performance more
        significantly than other markers. It is best used when zoomed in on
        an area of the geometry for dense meshes, to avoid false positives.
        
        
        NOTE
        Coindicent point detection has affects viewport performance more
        significantly than other markers. It is best used when zoomed in
        on an area of the geometry for dense meshes, to avoid false
        positives.
        
        
        """
        pass
        
    
    def showPrimBreakpoints(on):
        """
        showPrimBreakpoints(self, on)
        
        Enable or disable breakpoints display. Breakpoints are only
        available on NURBS and bezier surfaces and curves, and appear as
        hollow circles along the isoparms.
        
        
        """
        pass
        
    
    def pointMarkerVisibility():
        """
        pointMarkerVisibility(self) -> hou.markerVisibility
        
        Query the visibility setting of point markers.
        
        
        """
        pass
        
    
    def setUVBoundaryMode(hou.boundaryDisplay):
        """
        setUVBoundaryMode(self, hou.boundaryDisplay)
        
        Set viewport types that highlight UV boundaries for the geometry in
        the display set.
        
        * hou.boundaryDisplay.Off:
        
        No UV boundaries are displayed.
        
        * hou.boundaryDisplay.On:
        
        UV boundaries are shown in all viewports.
        
        * hou.boundaryDisplay.View3D:
        
        UV boundaries are shown in 3D viewports only.
        
        * hou.boundaryDisplay.ViewUV: .
        
        UV boundaries are shown in UV viewports only.
        
        
        """
        pass
        
    
    def pointNormalVisibility():
        """
        pointNormalVisibility(self) -> hou.markerVisibility
        
        Query the visibility setting of point normals.
        
        
        """
        pass
        
    
    def vertexUVVisibility():
        """
        vertexUVVisibility(self) -> hou.markerVisibility
        
        Query the visibility setting of vertex UVs.
        
        
        """
        pass
        
    
    def isShowingPrimBackfaces():
        """
        isShowingPrimBackfaces(self) -> bool
        
        Query if backfacing polygons are tinted to distinguish them from
        front facing polygons.
        
        
        """
        pass
        
    
    def setUniqueDisplaySet(on):
        """
        setUniqueDisplaySet(self, on)
        
        When True, remove any link from this display set to another display
        set. Its own settings will be used. Passing False has no effect; use
        setLinkToDisplaySet to link this set to another display set.
        
        
        """
        pass
        
    
    def setPrimBreakpointVisibility(visibility):
        """
        setPrimBreakpointVisibility(self, visibility)
        
        Controls how primitive breakpoints are shown when displayed.
        
        
        """
        pass
        
    
    def displaySetType():
        """
        displaySetType() -> hou.displaySetType
        
        Returns the geometry context this display set represents:
        
        * hou.displaySetType.SceneObject - object nodes which are not selected
        or ghosted.
        
        * hou.displaySetType.SelectedObject - object nodes which are selected.
        
        * hou.displaySetType.GhostObject - object nodes which ghosted, which
        occurs when they are visible when at the SOP level and "Ghost Other
        Objects" is the current object mode, but are not the current object.
        
        * hou.displaySetType.DisplayModel - SOP with the display flag. This
        takes precedence over TemplateModel and CurrentModel, if the SOP has
        either the template flag set or is selected.
        
        * hou.displaySetType.CurrentModel - SOP that is currently selected.
        This takes precedence over TemplateModel, if that SOP also has the
        template flag set.
        
        * hou.displaySetType.TemplateModel - SOP that has a template flag set.
        
        
        """
        pass
        
    
    def showPrimProfileNumbers(on):
        """
        showPrimProfileNumbers(self, on)
        
        Enable or disable profile curve number display on NURBS surfaces.
        Each profile on a NURBS surface has an index from 0 to #profiles-1.
        
        
        """
        pass
        
    
    def isUsingFadedLook():
        """
        isUsingFadedLook(self) -> bool
        
        Query if the display set is faded. Faded geometry suppresses the
        display of geometry color.
        
        
        """
        pass
        
    
    def isUsingLighting():
        """
        isUsingLighting(self) -> bool
        
        Query if lighting is used for this display set. When off, the
        geometry is displayed without any lighting (often much brighter).
        
        
        """
        pass
        
    
    def isToolbarLinked():
        """
        isToolbarLinked(self) -> bool
        
        Query if the display set is linked to the right viewport toolbar.
        When linked, clicking a display option button on this toolbar will
        affect the corresponding option in this display set.
        
        
        """
        pass
        
    
    def showUVOverlap(on):
        """
        showUVOverlap(self, on)
        
        Enable or disable highlighting of UV overlap. Areas of the texture
        that would be share the same UVs are highlighted.
        
        
        """
        pass
        
    
    def showPrimProfiles(on):
        """
        showPrimProfiles(self, on)
        
        Enable or disable profile curve display on NURBS surfaces.
        
        
        """
        pass
        
    
    def pointUVVisibility():
        """
        pointUVVisibility(self) -> hou.markerVisibility
        
        Query the visibility setting of point UVs.
        
        
        """
        pass
        
    
    def setPointTrailVisibility(visibility):
        """
        setPointTrailVisibility(self, visibility)
        
        Controls how point trails are shown when displayed.
        
        * hou.markerVisibility.Always: All are shown.
        
        * hou.markerVisibility.Selected: Only trails for selected points are
        shown.
        
        * hou.markerVisibility.AroundPointer: Trails close to the 3D point the
        mouse cursor is currently over are shown.
        
        * hou.markerVisibility.UnderPointer: Trails under the mouse cursor are
        shown.
        
        
        """
        pass
        
    
    def primBreakpointVisibility():
        """
        primBreakpointVisibility(self) -> hou.markerVisibility
        
        Query the visibility setting of primitive breakpoints.
        
        
        """
        pass
        
    
    def shadedMode():
        """
        shadedMode(self) -> hou.glShadingType
        
        Query the shading mode of the display set (hou.glShadingType):
        
        * hou.glShadingType.WireBoundingBox: no geometry, only bounding box
        outline
        
        * hou.glShadingType.ShadedBoundingBox: no geometry, solid bounding box
        
        * hou.glShadingType.Wire: wireframe
        
        * hou.glShadingType.WireGhost: wireframe with muted hidden lines
        
        * hou.glShadingType.HiddenLineInvisible: wireframe with hidden lines
        
        * hou.glShadingType.HiddenLineGhost: wireframe with solid constant
        faces
        
        * hou.glShadingType.Flat: shaded with primitive face normals
        
        * hou.glShadingType.FlatWire: shaded with primitive face normals,
        outlined polygons
        
        * hou.glShadingType.Smooth: shaded with point or vertex normals
        
        * hou.glShadingType.SmoothWire: shaded with point or vertex normals,
        outlined polygons
        
        
        """
        pass
        
    
    def linkedToDisplaySet():
        """
        linkedToDisplaySet(self) -> hou.displaySetType
        
        A display set can be linked to another display set, so that all of
        its options are taken from that linked set rather than its own. This
        method returns the display set this set is linked to. If it is not
        linked to another set, it will return the its own set.
        
        
        """
        pass
        
    
    def isUsingXRay():
        """
        isUsingXRay(self) -> bool
        
        Query if the display set is drawn with XRay. XRay geometry will
        appear as a faded wireframe behind other geometry that occludes it.
        
        
        """
        pass
        
    
    def showPrimHulls(on):
        """
        showPrimHulls(self, on)
        
        Enable or disable primitive hulls. Only certain primitive types have
        hulls, such as NURBS, volumes, agents, and bezier curves.
        
        
        """
        pass
        
    
    def isShowingVertexMarkers():
        """
        isShowingVertexMarkers(self) -> bool
        
        Query if vertex markers are shown. Vertex markers are inset into
        their polygon slightly, for ease of selection and selection display.
        The markers are small hollow squares. Not all primitive types have
        vertex markers.
        
        
        """
        pass
        
    
    def setPointPositionVisibility(visibility):
        """
        setPointPositionVisibility(self, visibility)
        
        Controls how point positions are shown when displayed.
        
        * hou.markerVisibility.Always: All are shown.
        
        * hou.markerVisibility.Selected: Only positions for selected points
        are shown.
        
        * hou.markerVisibility.AroundPointer: Positions close to the 3D point
        the mouse cursor is currently over are shown.
        
        * hou.markerVisibility.UnderPointer: Positions under the mouse cursor
        are shown.
        
        
        """
        pass
        
    
    def isShowingVertexNormals():
        """
        isShowingVertexNormals(self) -> bool
        
        Query if vertex normals are shown. If the geometry does not have
        vertex normals, they will not be shown. The base of the vertex
        normal is inset slightly into its polygon to make it easier to see
        which polygon the normal is influencing.
        
        
        """
        pass
        
    
    def setLinkToDisplaySet(view_display_set):
        """
        setLinkToDisplaySet(self, view_display_set)
        
        Link this display set to the settings of another display set. This
        display set's option settings are then ignored, and the other sets
        are used in their place. Linking a set to itself restores its own
        settings.
        
        * hou.displaySetType.SceneObject
        
        * hou.displaySetType.SelectedObject
        
        * hou.displaySetType.GhostObject
        
        * hou.displaySetType.DisplayModel
        
        * hou.displaySetType.CurrentModel
        
        * hou.displaySetType.TemplateModel
        
        
        """
        pass
        
    
    def setPointNormalVisibility(visibility):
        """
        setPointNormalVisibility(self, visibility)
        
        Controls how point normals are shown when displayed.
        
        * hou.markerVisibility.Always: All are shown.
        
        * hou.markerVisibility.Selected: Only normals for selected points are
        shown.
        
        * hou.markerVisibility.AroundPointer: Normals close to the 3D point
        the mouse cursor is currently over are shown.
        
        * hou.markerVisibility.UnderPointer: Normals under the mouse cursor
        are shown.
        
        
        """
        pass
        
    
    def showPointNormals(on):
        """
        showPointNormals(self, on)
        
        Show or hide point normals.
        
        
        """
        pass
        
    
    def boundaryMode():
        """
        boundaryMode(self) -> hou.boundaryDisplay
        
        Query which viewport types display 3D boundaries
        (hou.boundaryDisplay).
        
        * hou.boundaryDisplay.Off:
        
        No 3D boundaries are displayed.
        
        * hou.boundaryDisplay.On:
        
        3D boundaries are shown in all viewports.
        
        * hou.boundaryDisplay.View3D:
        
        3D boundaries are shown in 3D viewports only.
        
        * hou.boundaryDisplay.ViewUV: .
        
        3D boundaries are shown in UV viewports only.
        
        
        """
        pass
        
    
    def vertexMarkerVisibility():
        """
        vertexMarkerVisibility(self) -> hou.markerVisibility
        
        Query the visibility setting of vertex markers.
        
        
        """
        pass
        
    
    def showVertexNumbers(on):
        """
        showVertexNumbers(self, on)
        
        Enable or disable vertex numbers. Vertex numbers are drawn as
        numbers inset into its parent polygon slightly, ranging 0 to
        #edges-1.
        
        
        """
        pass
        
    
    def isShowingCoincidentPoints():
        """
        isShowingCoincidentPoints(self) -> bool
        
        Query if coincident point detection is enabled (yellow points and a
        duplicate count where coincident points are detected).
        
        
        """
        pass
        
    
    def showPointTrails(on):
        """
        showPointTrails(self, on)
        
        Show or hide point trails on all points. Geometry must have a
        velocity attribute v.
        
        
        """
        pass
        
    
    def setShadedMode(shaded_mode):
        """
        setShadedMode(self, shaded_mode)
        
        Sets the shading mode for this display set:
        
        * hou.glShadingType.WireBoundingBox: no geometry, only bounding box
        outline
        
        * hou.glShadingType.ShadedBoundingBox: no geometry, solid bounding box
        
        * hou.glShadingType.Wire: wireframe
        
        * hou.glShadingType.WireGhost: wireframe with muted hidden lines
        
        * hou.glShadingType.HiddenLineInvisible: wireframe with hidden lines
        
        * hou.glShadingType.HiddenLineGhost: wireframe with solid constant
        faces
        
        * hou.glShadingType.Flat: shaded with primitive face normals
        
        * hou.glShadingType.FlatWire: shaded with primitive face normals,
        outlined polygons
        
        * hou.glShadingType.Smooth: shaded with point or vertex normals
        
        * hou.glShadingType.SmoothWire: shaded with point or vertex normals,
        outlined polygons
        
        
        """
        pass
        

def GeometryViewportDisplaySet_swigregister():
    """None"""
    pass
    

class GeometryViewportSettings(object):
    """
    hou.GeometryViewportSettings
    
    REPLACES
    
    * cplane
    
    * viewbackground
    
    * viewcamera
    
    * viewcopy
    
    * viewdisplay
    
    * viewls
    
    * viewname
    
    * vieworthogrid
    
    * viewprojection
    
    * viewsnapshot
    
    * viewtransform
    
    * viewtype
    
    * viewuvgrid
    
    
    """
    
    def setHdrRendering():
        """
        hdrRendering(self) -> bool
        
        Queries if High Dynamic Range (HDR) rendering is enabled.
        
        
        """
        pass
        
    
    def shadowMapSizeFromLight():
        """
        shadowMapSizeFromLight(self) -> bool
        
        Query if the shadow map size is defined by the light object.
        
        
        """
        pass
        
    
    def autoGenerateVertexNormals():
        """
        autoGenerateVertexNormals(self) -> bool
        
        Query if vertex normals are produced when geometry is missing
        normals. If false, point numbers are produced.
        
        
        """
        pass
        
    
    def setTextureAnisotropicFilter(num_samples):
        """
        setTextureAnisotropicFilter(self, num_samples)
        
        Set the number of samples for anisotropic texture filtering. More
        samples produces better results for textures on polygons on an angle
        to the view direction.
        
        
        """
        pass
        
    
    def setSingleBoneDeform(viewportAgentBoneDeform):
        """
        setSingleBoneDeform(self, viewportAgentBoneDeform)
        
        Set the complexity of bone-based deformation on agents.
        
        * hou.viewportAgentBoneDeform.Always:
        
        Only use 1 bone to deform on all agent instances (the one with
        the most influence).
        
        * hou.viewportAgentBoneDeform.ReducedLOD:
        
        Use up to 4 bones to deform the highest LOD agent instances, and
        1 bone on all the reduced LOD instances.
        
        * hou.viewportAgentBoneDeform.Disabled:
        
        Use up to 4 bones to deform on all agent instances.
        
        
        """
        pass
        
    
    def setUVReferenceGrid(enable):
        """
        setUVReferenceGrid(self, enable)
        
        Display the grid in UV viewports.
        
        
        """
        pass
        
    
    def pointInstancingLimit():
        """
        pointInstancingLimit(self) -> int
        
        Query the current polygon limit for instancing.
        
        
        """
        pass
        
    
    def setTextureMaxRes3D(res):
        """
        setTextureMaxRes3D(self, res)
        
        Set the maximum resolution of a 3D texture (volume). res is an
        integer 3-tuple of (width, height, depth). OpenGL has its own limit,
        and setting this limit higher than that will have no effect. The
        image will be scaled to fit the limit if it exceeds it.
        
        
        """
        pass
        
    
    def closureSelection(hou.viewportClosureSelection):
        """
        closureSelection(self, hou.viewportClosureSelection)
        
        Change the closure selection display setting. A Closure selection is
        shown on a primitive when any part of that primitive is selected.
        
        * hou.viewportClosureSelection.Hide: Do not show closure selections.
        
        * hou.viewportClosureSelection.HullPrimitives: Only show closure
        selections on primitives that have hulls which are disconnected from
        the tessellated surface or curve (such as a NURBS surface).
        
        * hou.viewportClosureSelection.Show: Show closure selections on all
        primitive types.
        
        
        """
        pass
        
    
    def selectWireframeAsSolid():
        """
        selectWireframeAsSolid(self) -> bool
        
        Query if selection of wireframe polygons is done by face (true) or
        edge (false).
        
        
        """
        pass
        
    
    def usingReflections():
        """
        usingReflections(self) -> bool
        
        Query if reflection mapping is enabled.
        
        
        """
        pass
        
    
    def uvAutoAttribute():
        """
        uvAutoAttribute(self) -> bool
        
        Return True if the UV viewport is auto-detecting the class of the
        displayed UV attribute.
        
        
        """
        pass
        
    
    def setReflectMapSize(size):
        """
        setReflectMapSize(self, size)
        
        Set the size of the cubemap used to store the surrounding scene as
        an environment map. Larger cubemaps produce sharper reflections but
        increase memory use.
        
        
        """
        pass
        
    
    def setAgentShapePointCutoff(num_points):
        """
        setAgentShapePointCutoff(self, num_points)
        
        Set the minimum number of points in an agent LOD level. If an LOD
        level would go below this number, it is not generated.
        
        
        """
        pass
        
    
    def usingDisplacement():
        """
        usingDisplacement(self) -> bool
        
        Query if displacement mapping is allowed.
        
        
        """
        pass
        
    
    def showBadges():
        """
        showBadges(self) -> bool
        
        Query if viewport status badges are displayed. Badges are icons
        which present additional state information.
        
        
        """
        pass
        
    
    def guideFontSize():
        """None"""
        pass
        
    
    def setBackgroundImageGammaLUT(apply_to_bg):
        """
        setBackgroundImageGammaLUT(self, apply_to_bg)
        
        Apply gamma and Lookup Table (LUT) color correction to the
        background image.
        
        
        """
        pass
        
    
    def shadowSensitivity():
        """
        shadowSensitivity(self) -> tuple of int
        
        Query the variable and constant shadow offsets, returned in a
        2-tuple.
        
        
        """
        pass
        
    
    def xrayDrawing():
        """
        xrayDrawing(self) -> bool
        
        Query if X-ray drawing is enabled globally.
        
        
        """
        pass
        
    
    def setSceneGamma(gamma):
        """
        setSceneGamma(self, gamma)
        
        Set the gamma correction for the scene. This value should match the
        calibrated gamma of the display device.
        
        
        """
        pass
        
    
    def setDisplayTextureLayers(enable):
        """
        setDisplayTextureLayers(self, enable)
        
        Enable multiple texture layers when texturing. This causes an extra
        render of the geometry per texture layer.
        
        
        """
        pass
        
    
    def setDisplayTextures(enable):
        """
        setDisplayTextures(self, enable)
        
        Enable material texturing.
        
        
        """
        pass
        
    
    def wireBlend():
        """
        wireBlend(self) -> double
        
        Query the blend factor between wires and the surface in wire-over-
        shaded modes. Values close to 0 produce very faint lines, values
        closer to 1 produce solid lines.
        
        
        """
        pass
        
    
    def setDisplacementLevel(level):
        """
        setDisplacementLevel(self, level)
        
        Set the level of detail for displacement mapping. Displacement
        mapping adaptively subdivides the geometry to provide finer detail.
        Higher values result in denser subdivision, while lower values
        produce lighter meshes. The default is 1.0.
        
        
        """
        pass
        
    
    def setDefaultMaterialEmission():
        """
        setDefaultMaterialEmission(self) -> hou.Color
        
        Query the default material's emission color.
        
        
        """
        pass
        
    
    def setShadowSensitivity(offset):
        """
        setShadowSensitivity(self, offset)
        
        Set the shadow bias to avoid self-shadowing. A 2-tuple is expected,
        with the first value setting the variable offset (depending on how
        parallel the surface is to the view direction) and the second a
        constant offset. Generally these don't need to be changed from their
        default, but larger values reduce self shadowing but increase the
        risk of missing shadows for very close geometry.
        
        
        """
        pass
        
    
    def setOriginGnomonSize(size):
        """
        setOriginGnomonSize(self, size)
        
        Sets the world size of the gnomon axes that appear at the world
        origin.
        
        
        """
        pass
        
    
    def displayEnvironmentBackgroundImage():
        """
        displayEnvironmentBackgroundImage(self) -> bool
        
        Query if environmenty lights' envirnoment maps are shown as 360
        degree background images.
        
        
        """
        pass
        
    
    def sceneLUT():
        """
        sceneLUT(self) -> str
        
        Query the current Lookup Table (LUT) file.
        
        
        """
        pass
        
    
    def geometryInfo(hou.viewportGeometryInfo):
        """
        geometryInfo(self, hou.viewportGeometryInfo)
        
        Queries the current geometry information display setting:
        
        * hou.viewportGeometryInfo.Off: No information displayed.
        
        * hou.viewportGeometryInfo.SelectedOnly: only display information if
        something is selected.
        
        * hou.viewportGeometryInfo.Always: Always display information.
        
        
        """
        pass
        
    
    def showEmission(enable):
        """
        showEmission(self, enable)
        
        Enable emissive lighting. Emission lighting comes from materials on
        geometry, not lights, so modifying the lights in the scene has no
        effect on it. This can be used to debug lighting.
        
        
        """
        pass
        
    
    def textureAutoReduce2D():
        """
        textureAutoReduce2D(self) -> bool
        
        Query if auto-reduction of regular 2D textures is allowed.
        
        
        """
        pass
        
    
    def setOnionSkinOpacity(opacity):
        """
        setOnionSkinOpacity(self, opacity)
        
        Set the opacity of the onion skins to make them more or less
        prominent.
        
        
        """
        pass
        
    
    def useDisplacement(enable):
        """
        useDisplacement(self, enable)
        
        Enable displacement mapping for materials that have a displacement
        map. When disabled, the displacement map is ignored. This can have a
        significant hit for lower-end GPUs.
        
        
        """
        pass
        
    
    def useTransparency(enable):
        """
        useTransparency(self, enable)
        
        Enable transparency rendering. When transparency is enabled, another
        pass handles areas of the geometry that have Alpha less than one
        (either due to an Alpha attribute or material opacity). When
        disabled, alpha is ignored and rendered as opaque.
        
        
        """
        pass
        
    
    def colorScheme():
        """
        colorScheme(self) -> hou.viewportColorScheme
        
        Query the current viewport color scheme.
        
        * hou.viewportColorScheme.Dark:
        
        Black background.
        
        * hou.viewportColorScheme.Grey:
        
        Light grey background.
        
        * hou.viewportColorScheme.Light:
        
        Light blue gradient background.
        
        
        """
        pass
        
    
    def setMaterialUpdate(viewportMaterialUpdate):
        """
        setMaterialUpdate(self, viewportMaterialUpdate)
        
        Set the material assignment update frequency.
        
        * hou.viewportMaterialUpdate.Always:
        
        Update assignments whenever needed.
        
        * hou.viewportMaterialUpdate.OffForPlayback:
        
        Update assignments whenever needed, but not during playback.
        
        * hou.viewportMaterialUpdate.Manual:
        
        Only update assignments when Update Materials is pressed.
        
        
        """
        pass
        
    
    def defaultMaterialSpecular():
        """
        defaultMaterialSpecular(self) -> hou.Color
        
        Query the default material's specular color.
        
        
        """
        pass
        
    
    def distanceBasedPackedCulling():
        """
        distanceBasedPackedCulling(self) -> bool
        
        Query if packed primitive culling is enabled.
        
        
        """
        pass
        
    
    def onionSkinFramesAfterTint():
        """
        onionSkinFramesAfterTint(self) -> tuple of double
        
        Query the tint color of skins that appear after the current frame.
        
        
        """
        pass
        
    
    def setOnionSkinFramesAfterCount(num_frames):
        """
        setOnionSkinFramesAfterCount(self, num_frames)
        
        Set the number of onion skins after the current frame. Their spacing
        depends on the onion skin frame increment.
        
        
        """
        pass
        
    
    def ambientOcclusionLevel():
        """
        ambientOcclusionLevel(self) -> int
        
        Return the current occlusion level for ambient occlusion.
        
        
        """
        pass
        
    
    def setAspectRatio(aspect):
        """
        setAspectRatio(self, aspect)
        
        Set the viewport aspect ratio (width/height).
        
        
        """
        pass
        
    
    def polygonConvexQuality():
        """
        polygonConvexQuality(self) -> bool
        
        Query the polygon convexing quality, true for high quality and false
        for fast convexing.
        
        
        """
        pass
        
    
    def enableGuide(hou.viewportGuide, on):
        """
        enableGuide(self, hou.viewportGuide, on)
        
        Show or hide the guide specified by hou.viewportGuide.
        
        
        """
        pass
        
    
    def setTextureBitDepthLimit2D(viewportTextureDepth):
        """
        setTextureBitDepthLimit2D(self, viewportTextureDepth)
        
        Set the maximum bit depth for a 2D texture. Textures with a bit
        depth higher than this will be downconverted to this bit depth.
        Textures with an equal or lower bit depth will not be converted.
        
        * hou.viewportTextureDepth.Compressed8:
        
        Compressed, 8b SDR texture format. Smallest memory use.
        
        * hou.viewportTextureDepth.Fixed8:
        
        8b SDR texture format. Good balance between memory and quality.
        
        * hou.viewportTextureDepth.HDR16:
        
        16b HDR texture format. Excellent dynamic range, but more memory
        use and slower texturing performance.
        
        * hou.viewportTextureDepth.FullHDR:
        
        32b HDR texture format. Extreme dynamic range, but very high
        memory use and slow texturing performance. Use with care.
        
        
        """
        pass
        
    
    def textureResLimit3D():
        """
        textureResLimit3D(self) -> bool
        
        Query if 3D textures have their resolutions limited.
        
        
        """
        pass
        
    
    def useReflections(enable):
        """
        useReflections(self, enable)
        
        Enable reflection mapping. Objects with reflective materials
        generate reflection maps of the scene around them, which can be
        quite expensive.
        
        
        """
        pass
        
    
    def showingMaterials():
        """
        showingMaterials(self) -> bool
        
        Query if materials are shown.
        
        
        """
        pass
        
    
    def scenePolygonLimit():
        """
        scenePolygonLimit(self) -> int
        
        Query the maximum allowed number of polygons in the view frustum, in
        millions of polygons.
        
        
        """
        pass
        
    
    def setUVAutoAttribute():
        """None"""
        pass
        
    
    def viewAspectRatio(masked):
        """
        viewAspectRatio(self, masked) -> float
        
        Query the actual viewport aspect ratio. If masked is True, return
        the aspect ratio of the area inside the camera mask, otherwise
        return the full viewport aspect ratio.
        
        
        """
        pass
        
    
    def setSceneAntialias(aalevel):
        """
        setSceneAntialias(self, aalevel)
        
        Sets the viewports full-scene antialiasing level to one of 1, 2, 4,
        8, 16, 32, 64, or 128. This represents the number of samples
        rendered to produce a higher quality image. Higher numbers produce
        better antialiasing, but this can affect the viewport's rendering
        performance. Some graphics hardware only support a subset of these
        modes (eg. up to 8 or 32).
        
        
        """
        pass
        
    
    def showsCameraName(show):
        """
        showsCameraName(self, show)
        
        Display the camera name and menu in the upper right corner.
        
        
        """
        pass
        
    
    def displayProjectedTextures():
        """
        displayProjectedTextures(self) -> bool
        
        Query if projected textures from spotlights are rendered.
        
        
        """
        pass
        
    
    def instanceStandInGeometry():
        """
        instanceStandInGeometry(self) -> hou.viewportStandInGeometry
        
        Query the current stand-in geometry for culled instances.
        
        * hou.viewportStandInGeometry.DisplayOff: Show nothing for culled
        instances.
        
        * hou.viewportStandInGeometry.LocationMarker: Show a location marker
        at the local space origin of each instanced.
        
        * hou.viewportStandInGeometry.BoundingBox: Show the culled instances'
        bounding boxes.
        
        
        """
        pass
        
    
    def setDistanceBasedPackedCulling(enable):
        """
        setDistanceBasedPackedCulling(self, enable)
        
        Enable culling of packed primitives when the polygon count of the
        visible objects in the frustum exceeds a certain amount, starting
        with the most distant.
        
        
        """
        pass
        
    
    def setHeadlightSpecular(enable):
        """
        setHeadlightSpecular(self, enable)
        
        Enable specular reflections when in Headlight lighting mode. Turning
        this off results in purely diffuse lighting.
        
        
        """
        pass
        
    
    def volumeQuality():
        """
        volumeQuality(self) -> hou.viewportVolumeQuality
        
        Query the volume display quality.
        
        * hou.viewportVolumeQuality.VeryLow: Very fast, low quality preview
        
        * hou.viewportVolumeQuality.Low: Fewer slices than Normal for speed
        
        * hou.viewportVolumeQuality.Normal: Good quality vs. speed setting.
        
        * hou.viewportVolumeQuality.High: Large number of slices with
        jittering
        
        
        """
        pass
        
    
    def handleHighlight(hou.viewportHandleHighlight):
        """
        handleHighlight(self, hou.viewportHandleHighlight)
        
        Sets the size of the handle highlight when the mouse is over a
        handle part:
        
        * hou.viewportHandleHighlight.Off: Handles do not show highlights.
        
        * hou.viewportHandleHighlight.Small: Handles have a subtle highlight.
        
        * hou.viewportHandleHighlight.Normal: Handles use their default
        highlight, which is twice the width of the small highlight.
        
        
        """
        pass
        
    
    def setTextureScale3D(scale):
        """
        setTextureScale3D(self, scale)
        
        Uniformly downscale all 3D textures (volumes) by this fraction
        (default 1.0, no scale).
        
        
        """
        pass
        
    
    def materialUpdate():
        """
        materialUpdate(self) -> hou.viewportMaterialUpdate
        
        Query the material assignment update frequency.
        
        * hou.viewportMaterialUpdate.Always:
        
        Update assignments whenever needed.
        
        * hou.viewportMaterialUpdate.OffForPlayback:
        
        Update assignments whenever needed, but not during playback.
        
        * hou.viewportMaterialUpdate.Manual:
        
        Only update assignments when Update Materials is pressed.
        
        
        """
        pass
        
    
    def setSingleObjectMaterialLimit(num_materials):
        """
        setSingleObjectMaterialLimit(self, num_materials)
        
        Set the maximum number of material variations for a single object.
        
        
        """
        pass
        
    
    def particleDisplayType():
        """
        particleDisplayType(self) -> hou.viewportParticleDisplay
        
        Query the default particle display.
        
        * hou.viewportParticleDisplay.Points: Constant sized point marker,
        with the diameter specified by particlePointSize. This marker is
        unaffected by pscale.
        
        * hou.viewportParticleDisplay.Pixels: Single pixel drawn for a
        particle.
        
        * hou.viewportParticleDisplay.Lines: Streak trail plus marker.
        
        * hou.viewportParticleDisplay.Discs: World-space circle, affected by
        pscale or discSize.
        
        
        """
        pass
        
    
    def setHomeAutoAdjustsClip(viewportHomeClipMode):
        """
        setHomeAutoAdjustsClip(self, viewportHomeClipMode)
        
        Set which camera clip planes are adjusted when performing a homing
        operation.
        
        * hou.viewportHomeClipMode.Neither:
        
        Neither clip plane is adjusted.
        
        * hou.viewportHomeClipMode.FarOnly:
        
        Only the far clip plane is adjusted.
        
        * hou.viewportHomeClipMode.NearOnly:
        
        Only the near clip plane is adjusted.
        
        * hou.viewportHomeClipMode.NearAndFar:
        
        Both clip planes are adjusted.
        
        
        """
        pass
        
    
    def originGnomonSize():
        """
        originGnomonSize(self) -> float
        
        Queries the world size of the gnomon axes that appear at the world
        origin.
        
        
        """
        pass
        
    
    def setTextureAutoReduce3D(enable):
        """
        setTextureAutoReduce3D(self, enable)
        
        Allow auto-reduction of 3D textures (volumes).
        
        
        """
        pass
        
    
    def pointInstancing():
        """
        pointInstancing(self) -> bool
        
        Query if point instancing is globally enabled.
        
        
        """
        pass
        
    
    def setTextureResLimit2D(enable):
        """
        setTextureResLimit2D(self, enable)
        
        Limit the resolution of all 2D textures, so that the width and
        height cannot exceed the limit. Even if disabled, OpenGL has its own
        texture limits which will be applied (usually 8k or 16k).
        
        
        """
        pass
        
    
    def volumeWireAsPoints():
        """
        volumeWireAsPoints(self) -> bool
        
        Query if volumes are currently drawn as a point field in wireframe.
        
        
        """
        pass
        
    
    def orthoGridRuler():
        """
        orthoGridRuler(self) -> tuple of int
        
        Query the spacing of the grid numbers in fixed orthographic views as
        a 2-tuple.
        
        
        """
        pass
        
    
    def interiorWireAlpha():
        """
        interiorWireAlpha(self) -> double
        
        Query the dimness of the interior wires in a tet mesh. Outer wires
        are drawn normally, inner wires are dimmed. This only affects tet
        meshes in wireframe mode.
        
        
        """
        pass
        
    
    def setMaxLODLevels(num_levels):
        """
        setMaxLODLevels(self, num_levels)
        
        Set the maximum number of levels to generate for an agent. This will
        be the original model plus this number.
        
        
        """
        pass
        
    
    def subdivsionLimit():
        """
        subdivsionLimit(self) -> int
        
        Returns the current subdivision polygon limit, in millions of
        polygons.
        
        
        """
        pass
        
    
    def setOrthoRuler(viewportGridRuler):
        """
        setOrthoRuler(self, viewportGridRuler)
        
        Where to display the grid numbers on the fixed orthographic view
        grid.
        
        * hou.viewportGridRuler.Hide:
        
        Do not display.
        
        * hou.viewportGridRuler.MainAxis:
        
        Display along the main axes at grid line intersections.
        
        * hou.viewportGridRuler.GridPoints:
        
        Display on grid line intersections.
        
        
        """
        pass
        
    
    def setColorScheme(viewportColorScheme):
        """
        setColorScheme(self, viewportColorScheme)
        
        Set the color scheme for the viewport.
        
        * hou.viewportColorScheme.Dark:
        
        Black background.
        
        * hou.viewportColorScheme.Grey:
        
        Light grey background.
        
        * hou.viewportColorScheme.Light:
        
        Light blue gradient background.
        
        
        """
        pass
        
    
    def agentLODReductionBias():
        """
        agentLODReductionBias(self) -> int
        
        Query the LOD bias for agents.
        
        
        """
        pass
        
    
    def textureAutoReduce():
        """
        textureAutoReduce(self) -> bool
        
        Query if auto-reduction of viewport textures is enabled.
        
        
        """
        pass
        
    
    def hullsOnly():
        """
        hullsOnly(self) -> bool
        
        Query if only hulls are drawn for complex curves and surfaces.
        
        
        """
        pass
        
    
    def setHeadlightOcclusion(enable):
        """
        setHeadlightOcclusion(self, enable)
        
        Enables ambient occlusion when in headlight mode. This has no effect
        if a lighting mode other than headlight is active.
        
        
        """
        pass
        
    
    def camera():
        """
        camera(self) -> ObjNode or None
        
        Return the camera or light node that the viewport is looking
        through. Return None if the viewport is not looking through a camera
        or light node.
        
        
        """
        pass
        
    
    def setUVVertexType():
        """None"""
        pass
        
    
    def setInteractiveMaterialUpdate(enable):
        """
        setInteractiveMaterialUpdate(self, enable)
        
        Update materials when they are changed to reflect their new state.
        When disabled, Update Materials must be pressed manually for changes
        to be reflected in the viewport.
        
        
        """
        pass
        
    
    def headlightOcclusion():
        """
        headlightOcclusion(self) -> bool
        
        Query if ambient occlusion is active for headlight mode.
        
        
        """
        pass
        
    
    def defaultMaterialDiffuse():
        """
        defaultMaterialDiffuse(self) -> hou.Color
        
        Query the default material's diffuse color.
        
        
        """
        pass
        
    
    def pointInstancingPercent():
        """
        pointInstancingPercent(self) -> double
        
        Query the percentage of instances shown in the viewport for point
        instancing.
        
        
        """
        pass
        
    
    def onionSkinFramesBeforeTint():
        """
        onionSkinFramesBeforeTint(self) -> tuple of double
        
        Query the tint color of skins that appear before the current frame.
        
        
        """
        pass
        
    
    def setHullsOnly(enable):
        """
        setHullsOnly(self, enable)
        
        Draw only hulls for complex curves and surfaces like NURBS and
        Beziers.
        
        
        """
        pass
        
    
    def setXrayQuality(quality):
        """
        setXrayQuality(self, quality)
        
        Enable high-quality X-ray rendering, which draws X-rayed objects as
        dimmed shaded surfaces when occluded, with up to 8 levels of overlap
        between X-rayed objects. This looks better but takes longer to
        render. Regular X-ray rendering displays X-ray objects as wireframe
        when occluded.
        
        
        """
        pass
        
    
    def setTextureMaxRes2D(res):
        """
        setTextureMaxRes2D(self, res)
        
        Set the maximum resolution of a 2D texture. res is an integer
        2-tuple of (width, height). OpenGL has its own limit, and setting
        this limit higher than that will have no effect. The image will be
        scaled to fit the limit if it exceeds it.
        
        
        """
        pass
        
    
    def usingPerPrimStylesheets():
        """
        usingPerPrimStylesheets(self) -> bool
        
        Query if per-primitive stylesheets are evaluated.
        
        
        """
        pass
        
    
    def setHeadlightDirection(dir):
        """
        setHeadlightDirection(self, dir)
        
        Set the direction of the headlight used in Headlight lighting mode.
        This is expressed as a direction vector in camera space (the camera
        looks down -Z).
        
        
        """
        pass
        
    
    def setTextureAutoReduce(enable):
        """
        setTextureAutoReduce(self, enable)
        
        Enable auto-reduction of viewport textures. This attempts to scale
        down textures to fit within the texture cache.
        
        
        """
        pass
        
    
    def setOnionSkinFramesBeforeCount(num_frames):
        """
        setOnionSkinFramesBeforeCount(self, num_frames)
        
        Set the number of onion skins before the current frame. Their
        spacing depends on the onion skin frame increment.
        
        
        """
        pass
        
    
    def vertexNormalCuspAngle():
        """
        vertexNormalCuspAngle(self) -> double
        
        Query the cusp angle for vertex normal generation. Any shared edge
        between polygons will be considered a hard edge if the polygon faces
        differ by more than this angle, otherwise the normals will be smooth
        over the edge.
        
        
        """
        pass
        
    
    def ambientOcclusion():
        """
        ambientOcclusion(self) -> bool
        
        Query if ambient occlusion is enabled. This can return true even if
        not in a high quality mode as this queries the raw display option
        value, not a reflection of whether the pass is active. If querying
        it the pass is active, the lighting mode should also be checked.
        
        
        """
        pass
        
    
    def interactiveMaterialUpdate():
        """
        interactiveMaterialUpdate(self) -> bool
        
        Query if materials are updated when they change.
        
        
        """
        pass
        
    
    def particlePointSize():
        """
        particlePointSize(self) -> double
        
        Query the point diameter for particles drawn as Points or Lines.
        
        
        """
        pass
        
    
    def uvReferenceGridOverImage():
        """None"""
        pass
        
    
    def setMinHomeSize(min_size):
        """
        setMinHomeSize(self, min_size)
        
        Set the smallest area that viewport can home to, in world units.
        
        
        """
        pass
        
    
    def onionSkinFrameIncrement():
        """
        onionSkinFrameIncrement(self) -> int
        
        Query the frame increment between onion skins.
        
        
        """
        pass
        
    
    def showingDiffuse():
        """
        showingDiffuse(self) -> bool
        
        Query if diffuse lighting is enabled.
        
        
        """
        pass
        
    
    def vectorScale():
        """
        vectorScale(self) -> float
        
        Query the scale applied to the length of vector decorations.
        
        
        """
        pass
        
    
    def setWireOverPackedGeo(wire_over_packed):
        """
        setWireOverPackedGeo(self, wire_over_packed)
        
        Show polygon outlines on meshes in packed geometry when drawing a
        wire-over-shaded mode. Disabling this hides the outlines on packed
        geometry, making meshes appear as a single shape, which packed
        geometry technically is.
        
        
        """
        pass
        
    
    def clampUVGridToBackground():
        """
        clampUVGridToBackground(self) -> bool
        
        Query if the grid is restricted to the background image's area.
        
        
        """
        pass
        
    
    def guideEnabled(hou.viewportGuide):
        """
        guideEnabled(self, hou.viewportGuide) -> bool
        
        Query if the guide specified by hou.viewportGuide is shown (True) or
        hidden (False).
        
        
        """
        pass
        
    
    def setPackedBoundingBoxMode(viewportPackedBoxMode):
        """
        setPackedBoundingBoxMode(self, viewportPackedBoxMode)
        
        Define how culled packed primitives are displayed.
        
        * hou.viewportPackedBoxMode.NoDisplay:
        
        Culled packed primitives are not displayed at all.
        
        * hou.viewportPackedBoxMode.Wireframe:
        
        A wireframe bounding box replaces the packed primitive.
        
        * hou.viewportPackedBoxMode.Shaded:
        
        A shaded bounding box replaces the packed primitive.
        
        * hou.viewportPackedBoxMode.CurrentShadingMode:
        
        A bounding box replaces the packed primitive, drawn wireframe in
        wireframe shading modes and shaded otherwise.
        
        
        """
        pass
        
    
    def saveViewToCamera(camera_node):
        """
        saveViewToCamera(self, camera_node)
        
        Saves the viewport's current view into the given camera node. It
        does this by setting the camera's transform parameters to match the
        viewport's view transform matrix.
        
        
        """
        pass
        
    
    def filterBackgroundImage():
        """
        filterBackgroundImage(self) -> bool
        
        Query if texture filtering of background images is enabled.
        
        
        """
        pass
        
    
    def textureBitDepthLimit3D():
        """
        textureBitDepthLimit3D(self) -> hou.viewportTextureDepth
        
        Query the maximum bit depth of a 3D texture (volume).
        
        * hou.viewportTextureDepth.Fixed8:
        
        8b SDR texture format. Good balance between memory and quality.
        
        * hou.viewportTextureDepth.HDR16:
        
        16b HDR texture format. Excellent dynamic range, but more memory
        use and slower texturing performance.
        
        * hou.viewportTextureDepth.FullHDR:
        
        32b HDR texture format. Extreme dynamic range, but very high
        memory use and slow texturing performance. Use with extreme
        care.
        
        
        """
        pass
        
    
    def setAgentWireframe(viewportAgentWireframe):
        """
        setAgentWireframe(self, viewportAgentWireframe)
        
        Set the appearance of agents in wireframe mode.
        
        * hou.viewportAgentWireframe.Bone:
        
        Agents are rendered as bone-based skeletons.
        
        * hou.viewportAgentWireframe.Line:
        
        Agents are rendered as line-based skeletons.
        
        
        """
        pass
        
    
    def setScenePolygonLimit(millions_of_polygons):
        """
        setScenePolygonLimit(self, millions_of_polygons)
        
        Set the maximum number of polygons in the view frustum, in millions,
        before the viewport begins culling packed primitives.
        
        
        """
        pass
        
    
    def setDisplayUVTileBoundaries(enable):
        """
        setDisplayUVTileBoundaries(self, enable)
        
        Display the boundaries of UV tiles at integral U and V numbers.
        
        
        """
        pass
        
    
    def setXrayDrawing(global_enable):
        """
        setXrayDrawing(self, global_enable)
        
        Globally enable or disable X-ray drawing. Object must have their
        X-ray flag set in order to render as X-ray. X-ray causes the object
        to be visible when occluded.
        
        
        """
        pass
        
    
    def minHomeSize():
        """
        minHomeSize(self) -> float
        
        Query the smallest area that viewport can home to, in world units.
        
        
        """
        pass
        
    
    def objectOrigins():
        """
        objectOrigins(self) -> bool
        
        Query if object origin display is globally enabled.
        
        
        """
        pass
        
    
    def showsBadges(show):
        """
        showsBadges(self, show)
        
        Display viewport status badges as icons beside the camera menu,
        which presents additional state information.
        
        
        """
        pass
        
    
    def setOnionSkinning(global_enable):
        """
        setOnionSkinning(self, global_enable)
        
        Globally allow onion skinning to be displayed. Onion skinning is
        enabled on a per-object basis in the Misc tab of objects. This shows
        animation as a series of ghosted poses at other frames around the
        current frame.
        
        
        """
        pass
        
    
    def setCamera(camera_node):
        """
        setCamera(self, camera_node)
        
        Makes the viewport look through the given camera node.
        
        
        """
        pass
        
    
    def usingMaterialStylesheets():
        """
        usingMaterialStylesheets(self) -> bool
        
        Query if material stylesheet assignment is active.
        
        
        """
        pass
        
    
    def backgroundImage(viewportBGImageView, layer):
        """
        backgroundImage(self, viewportBGImageView, layer) ->
        hou.GeometryViewportBGImage
        
        Access the background image parameters for the target view type.
        layer is currently not used but reserved for future use.
        
        * hou.viewportBGImageView.Perspective:
        
        The 3D view not attached to a camera ("No cam").
        
        * hou.viewportBGImageView.Camera:
        
        The 3D view looking through a camera.
        
        * hou.viewportBGImageView.Top:
        
        The orthographic top view.
        
        * hou.viewportBGImageView.Front:
        
        The orthographic front view.
        
        * hou.viewportBGImageView.Right:
        
        The orthographic right view.
        
        * hou.viewportBGImageView.Bottom:
        
        The orthographic bottom view.
        
        * hou.viewportBGImageView.Back:
        
        The orthographic back view.
        
        * hou.viewportBGImageView.Left:
        
        The orthographic left view.
        
        * hou.viewportBGImageView.UV:
        
        The UV texture viewport.
        
        
        """
        pass
        
    
    def agentLODReduction():
        """
        agentLODReduction(self) -> bool
        
        Query if multiple levels of detail (LOD) are generated for crowd
        agents.
        
        
        """
        pass
        
    
    def onionSkinFramesAfterCount():
        """
        onionSkinFramesAfterCount(self) -> int
        
        Queries the number of onion skins after the current frame.
        
        
        """
        pass
        
    
    def maxLODLevels():
        """
        maxLODLevels(self) -> int
        
        Query the maximum number of levels generated for an agent.
        
        
        """
        pass
        
    
    def xrayStrength():
        """
        xrayStrength(self) -> double
        
        Query the strength of occluded x-ray objects.
        
        
        """
        pass
        
    
    def setDisplayBackgroundImage(enable):
        """
        setDisplayBackgroundImage(self, enable)
        
        Globally enable background image display.
        
        
        """
        pass
        
    
    def setVisibleObjects(uv):
        """
        setVisibleObjects(self, uv)
        
        Set the mask for all visible objects in the viewport. Wilcards can
        be used.
        
        
        """
        pass
        
    
    def showAmbient(enable):
        """
        showAmbient(self, enable)
        
        Enable ambient lighting. When disabled, all ambient lights will not
        contribute to the final lit color. This can be used to debug
        lighting.
        
        
        """
        pass
        
    
    def displaySet(display_set):
        """
        displaySet(self, display_set) -> GeometryViewportDisplaySet
        
        Returns the display set associated with the context 'display_set',
        which contains context-sensitive display options such as Draw Mode
        and Point Numbers.
        
        
        """
        pass
        
    
    def textureScale2D():
        """
        textureScale2D(self) -> float
        
        Query the uniform scale applied to 2D textures.
        
        
        """
        pass
        
    
    def lightSampling():
        """
        lightSampling(self) -> int
        
        Query the number of lighting samples.
        
        
        """
        pass
        
    
    def backgroundImageQuality():
        """
        backgroundImageQuality(self) -> int
        
        Query the quality of background image display, from 0-100.
        
        
        """
        pass
        
    
    def setTextureCacheSize(size_in_mb):
        """
        setTextureCacheSize(self, size_in_mb)
        
        Set the size of the texture cache, in megabytes. The viewport will
        use as much texture memory as it needs, even if it exceeds this
        level, but textures will be culled once they are no longer used to
        remain within this limit.
        
        
        """
        pass
        
    
    def lighting():
        """
        lighting(self) -> hou.viewportLighting
        
        Query the current global lighting mode.
        
        
        """
        pass
        
    
    def setHeadlightIntensity(intensity):
        """
        setHeadlightIntensity(self, intensity)
        
        Set the intensity of the headlight used in Headlight lighting mode.
        
        
        """
        pass
        
    
    def showGeometryColor(enable):
        """
        showGeometryColor(self, enable)
        
        Enable contribution of the geometry Cd attribute to the material.
        When disabled, this is ignored. Cd multiplies both the the material
        diffuse and ambient colors.
        
        
        """
        pass
        
    
    def wireOverPackedGeo():
        """
        wireOverPackedGeo(self) -> bool
        
        Query if polygon outlines are visible on packed geometry when a
        wire-over-shaded mode is active.
        
        
        """
        pass
        
    
    def uvGridPixelOffset():
        """
        uvGridPixelOffset(self) -> tuple of float
        
        Query the spacing of the dot grid in pixels.
        
        
        """
        pass
        
    
    def setAgentLODReduction(enable):
        """
        setAgentLODReduction(self, enable)
        
        Enable the use of multiple levels of detail for crowd agents, each
        LOD level being half the polygon count of the previous level.
        
        
        """
        pass
        
    
    def texture2DSettingsFor3D():
        """
        texture2DSettingsFor3D(self) -> bool
        
        Query if the 2D settings are used for 3D textures.
        
        
        """
        pass
        
    
    def setUseSceneLUT(enable):
        """
        setUseSceneLUT(self, enable)
        
        Enable Lookup Table (LUT) color correction. A valid LUT file must
        also be present.
        
        
        """
        pass
        
    
    def showingGeometryColor():
        """
        showingGeometryColor(self) -> bool
        
        Query if geometry Cd contributes to the material.
        
        
        """
        pass
        
    
    def setOrthoGridSpacing(offset):
        """
        setOrthoGridSpacing(self, offset)
        
        Set the spacing of the grid lines in fixed orthographic views as a
        2-tuple.
        
        
        """
        pass
        
    
    def clipPlanes():
        """
        clipPlanes(self) -> tuple of float
        
        Query the near and far camera clip planes, returning them in a
        2-tuple.
        
        
        """
        pass
        
    
    def onionSkinFramesBeforeCount():
        """
        onionSkinFramesBeforeCount(self) -> int
        
        Queries the number of onion skins before the current frame.
        
        
        """
        pass
        
    
    def baseLODLevel():
        """
        baseLODLevel(self) -> int
        
        Query the base level of detail.
        
        
        """
        pass
        
    
    def useSceneLUT():
        """
        useSceneLUT(self) -> bool
        
        Query if Lookup Table color correction is enabled. This will return
        True even no LUT file exists.
        
        
        """
        pass
        
    
    def textureMipmapping():
        """
        textureMipmapping(self) -> bool
        
        Query if texture mipmapping is enabled.
        
        
        """
        pass
        
    
    def setTransparencyQuality(viewportTransparency):
        """
        setTransparencyQuality(self, viewportTransparency)
        
        Set the quality of the transparency pass performed by the viewport.
        
        * hou.viewportTransparency.Cutout:
        
        Fast test to render the transparent pixel as opaque (>0) or to
        discard it (0). This can be used for texture cards such as
        leaves. This doesn't require an additional pass for
        transparency.
        
        * hou.viewportTransparency.Low:
        
        Render transparent pixels in a separate pass. Only the front-
        most transparent pixel is rendered.
        
        * hou.viewportTransparency.Medium:
        
        Render transparent pixels in an Order-Independent buffer of 8
        samples, which is then sorted and composited together to do
        multi-layer transparency for up to 8 layers of overlapping
        transparency.
        
        * hou.viewportTransparency.High:
        
        Render transparent pixels in an Order-Independent buffer of 16
        samples, which is then sorted and composited together to do
        multi-layer transparency for up to 16 layers of overlapping
        transparency.
        
        
        """
        pass
        
    
    def setTextureAutoReduce2D(enable):
        """
        setTextureAutoReduce2D(self, enable)
        
        Allow auto-reduction of regular 2D textures.
        
        
        """
        pass
        
    
    def setShadowMapSize(size):
        """
        setShadowMapSize(self, size)
        
        Set the maximum shadow map size, in pixels. Larger maps will produce
        sharper shadows but increase memory usage. Shadow maps are always
        square.
        
        
        """
        pass
        
    
    def showsName(show):
        """
        showsName(self, show)
        
        Display the viewport name and menu in the upper right corner.
        
        
        """
        pass
        
    
    def useMaterialStylesheets(enable):
        """
        useMaterialStylesheets(self, enable)
        
        Enable evaluation of material stylesheets for viewport material
        assignment.
        
        
        """
        pass
        
    
    def setAgentLODReductionBias(reduce_bias):
        """
        setAgentLODReductionBias(self, reduce_bias)
        
        Set the LOD balance from Performance (0) to Quality (10), which
        biases which LOD levels are chosen.
        
        
        """
        pass
        
    
    def displayTextures():
        """
        displayTextures(self) -> bool
        
        Query if material texturing is enabled.
        
        
        """
        pass
        
    
    def stereoMode():
        """
        stereoMode(self) -> hou.viewportStereoMode
        
        Query the current stereo display mode.
        
        
        """
        pass
        
    
    def textureAutoReduce3D():
        """
        textureAutoReduce3D(self) -> bool
        
        Query if auto-reduction of 3D textures is allowed.
        
        
        """
        pass
        
    
    def sceneAntialias():
        """
        sceneAntialias(self)
        
        Returns the number of samples used to antialias the viewport.
        Possible values are 1 (no antialiasing), 2, 4 (default for most
        hardware), 8, 16, 32, 64, or 128.
        
        
        """
        pass
        
    
    def shadeOpenCurves():
        """
        shadeOpenCurves(self) -> bool
        
        Query if shaded open curves are enabled or not.
        
        
        """
        pass
        
    
    def xrayQuality():
        """
        xrayQuality(self) -> bool
        
        Queries if high quality X-ray rendering is active.
        
        
        """
        pass
        
    
    def backgroundImageGammaLUT():
        """
        backgroundImageGammaLUT(self) -> bool
        
        Query if color correction is applied to the background image.
        
        
        """
        pass
        
    
    def setTexture2DSettingsFor3D(enable):
        """
        setTexture2DSettingsFor3D(self, enable)
        
        When enabled, use all the 2D texture settings for 3D textures.
        
        
        """
        pass
        
    
    def setRemoveBackfaces(enable):
        """
        setRemoveBackfaces(self, enable)
        
        Cull polygons facing backwards instead of rasterizing them.
        
        
        """
        pass
        
    
    def usingPackedStylesheets():
        """
        usingPackedStylesheets(self) -> bool
        
        Query if material stylesheet assignments are applied to geometry
        within packed primitives.
        
        
        """
        pass
        
    
    def singleObjectMaterialLimit():
        """
        singleObjectMaterialLimit(self) -> int
        
        Query the maximum number of material variations for a single object.
        
        
        """
        pass
        
    
    def vertexNormalLimit():
        """
        vertexNormalLimit(self) -> int
        
        Query the polygon limit for generating vertex normals, in millions
        of polygons.
        
        
        """
        pass
        
    
    def setUVGridPixelOffset(offset):
        """
        setUVGridPixelOffset(self, offset)
        
        Set the spacing, in pixels, of the dot grid.
        
        
        """
        pass
        
    
    def shadowMapSize():
        """
        shadowMapSize(self) -> int
        
        Query the maximum size of the shadow maps used by High Quality
        Lighting with Shadows lighting mode.
        
        
        """
        pass
        
    
    def headlightDirection():
        """
        headlightDirection(self) -> tuple of double
        
        Query the vector direction of the headlight.
        
        
        """
        pass
        
    
    def setClampUVGridToBackground(enable):
        """
        setClampUVGridToBackground(self, enable)
        
        Restrict the grid to the background image's area.
        
        
        """
        pass
        
    
    def uvDisplayAttribute():
        """
        uvDisplayAttribute(self) -> str
        
        Return the attribute currently displayed in the UV viewport.
        
        
        """
        pass
        
    
    def viewportType():
        """
        viewportType(self) -> hou.geometryViewportType enum value
        
        Query the viewport type (UV, 3D, top, left, etc).
        
        
        """
        pass
        
    
    def setUVDisplayGridOverImage():
        """None"""
        pass
        
    
    def displayTextureLayers():
        """
        displayTextureLayers(self) -> bool
        
        Query if multiple texture layers are rendered.
        
        
        """
        pass
        
    
    def packedBoundingBoxMode():
        """
        packedBoundingBoxMode(self) -> hou.viewportPackedBoxMode
        
        Query how culled packed primitives are displayed.
        
        * hou.viewportPackedBoxMode.NoDisplay:
        
        Culled packed primitives are not displayed at all.
        
        * hou.viewportPackedBoxMode.Wireframe:
        
        A wireframe bounding box replaces the packed primitive.
        
        * hou.viewportPackedBoxMode.Shaded:
        
        A shaded bounding box replaces the packed primitive.
        
        * hou.viewportPackedBoxMode.CurrentShadingMode:
        
        A bounding box replaces the packed primitive, drawn wireframe in
        wireframe shading modes and shaded otherwise.
        
        
        """
        pass
        
    
    def setAmbientOcclusionLevel(level):
        """
        setAmbientOcclusionLevel(self, level)
        
        Set the level of occlusion to generate, from 1-4. Higher levels
        produce a larger area of effect, while lower values produce fine
        detail.
        
        
        """
        pass
        
    
    def agentWireframe():
        """
        agentWireframe(self) -> hou.viewportAgentWireframe
        
        Query the appearance of agents in wireframe mode.
        
        * hou.viewportAgentWireframe.Bone:
        
        Agents are rendered as bone-based skeletons.
        
        * hou.viewportAgentWireframe.Line:
        
        Agents are rendered as line-based skeletons.
        
        
        """
        pass
        
    
    def setDefaultMaterialSpecular(tint):
        """
        setDefaultMaterialSpecular(self, tint)
        
        Set the specular color of the default material (used when no
        material assignment is present or Show Materials is disabled).
        
        
        """
        pass
        
    
    def setBackgroundImageQuality(quality):
        """
        setBackgroundImageQuality(self, quality)
        
        Set the quality of the background image, from 0-100. Values less
        than 100 will scale down the resolution of the background image.
        
        
        """
        pass
        
    
    def shadowQuality():
        """
        shadowQuality(self) -> hou.viewportShadowQuality
        
        Query the current shadow quality.
        
        
        """
        pass
        
    
    def usingMaterialOverrides():
        """
        usingMaterialOverrides(self) -> bool
        
        Query if material overrides are being applied to material
        assignments.
        
        
        """
        pass
        
    
    def showStateStatus():
        """
        showStateStatus(self) -> bool
        
        Query if the tool status messages are displayed.
        
        
        """
        pass
        
    
    def setSceneLUT(lut_file):
        """
        setSceneLUT(self, lut_file)
        
        Specify a Lookup Table (LUT) file to use for color correction.
        
        
        """
        pass
        
    
    def viewMaskOpacity():
        """
        viewMaskOpacity(self) -> float
        
        Query the opacity of the bars used to mask areas out the viewport
        outside the aspect ratio.
        
        
        """
        pass
        
    
    def showingEmission():
        """
        showingEmission(self) -> bool
        
        Query if emission lighting is enabled.
        
        
        """
        pass
        
    
    def sceneGamma():
        """
        sceneGamma(self) -> double
        
        Query the scene gamma correction.
        
        
        """
        pass
        
    
    def setOrthoGridRuler(offset):
        """
        setOrthoGridRuler(self, offset)
        
        Set the spacing of the grid numbers in fixed orthographic views as a
        2-tuple.
        
        
        """
        pass
        
    
    def orthoGridSpacing():
        """
        orthoGridSpacing(self) -> tuple of float
        
        Query the spacing of the grid lines in fixed orthographic views as a
        2-tuple.
        
        
        """
        pass
        
    
    def useAspectRatio(enable):
        """
        useAspectRatio(self, enable)
        
        Enforce a specific aspect ratio for the viewport, which will add
        bars if the viewport aspect ratio does not match.
        
        
        """
        pass
        
    
    def setOffsetVertexMarkers(enable):
        """
        setOffsetVertexMarkers(self, enable)
        
        When enabled, vertex markers and normals are inset into the polygon
        so they can be selected independently when part of a seamless mesh.
        When disabled, the markers and normals are placed at the actual
        vertex, potentially overlapping.
        
        
        """
        pass
        
    
    def onionSkinning():
        """
        onionSkinning(self) -> bool
        
        Query if onion skinning is globally enabled.
        
        
        """
        pass
        
    
    def uvGridPixelSpacing():
        """
        uvGridPixelSpacing(self) -> tuple of float
        
        Query the spacing of the UV dot grid displayed over background
        images.
        
        
        """
        pass
        
    
    def setPointMarkerSize(point_size):
        """
        setPointMarkerSize(self, point_size)
        
        Set the size of point marker decorations, in pixels.
        
        
        """
        pass
        
    
    def setClipPlanes(clip):
        """
        setClipPlanes(self, clip)
        
        Set the near and far camera clip planes from a 2-tuple.
        
        
        """
        pass
        
    
    def setDefaultMaterialDiffuse(tint):
        """
        setDefaultMaterialDiffuse(self, tint)
        
        Set the diffuse color of the default material (used when no material
        assignment is present or Show Materials is disabled).
        
        
        """
        pass
        
    
    def setTextureScale2D(scale):
        """
        setTextureScale2D(self, scale)
        
        Uniformly downscale all 2D textures by this fraction (default 1.0,
        no scale).
        
        
        """
        pass
        
    
    def setLighting(viewportLighting):
        """
        setLighting(self, viewportLighting)
        
        Set the global lighting mode for all viewports.
        
        * hou.viewportLighting.Off:
        
        No lighting, constant shaded.
        
        * hou.viewportLighting.Headlight:
        
        Basic lighting from a single directional light defined in the
        display options.
        
        * hou.viewportLighting.Normal:
        
        Good quality lighting from up to 10 basic lights (area lights
        modeled as point lights, limited environment lights).
        
        * hou.viewportLighting.HighQuality:
        
        High quality lighting from an unlimited number of lights
        including area, geometry, environment and ambient occlusion.
        
        * hou.viewportLighting.HighQualityWithShadows:
        
        High quality lighting with shadows.
        
        
        """
        pass
        
    
    def setDisplayProjectedTextures(enable):
        """
        setDisplayProjectedTextures(self, enable)
        
        Enable projected textures from spotlights with a valid texture.
        
        
        """
        pass
        
    
    def singleBoneDeform():
        """
        singleBoneDeform(self) -> hou.viewportAgentBoneDeform
        
        Query the complexity of bone-based deformation on agents.
        
        * hou.viewportAgentBoneDeform.Always:
        
        Only use 1 bone to deform on all agent instances (the one with
        the most influence).
        
        * hou.viewportAgentBoneDeform.ReducedLOD:
        
        Use up to 4 bones to deform the highest LOD agent instances, and
        1 bone on all the reduced LOD instances.
        
        * hou.viewportAgentBoneDeform.Disabled:
        
        Use up to 4 bones to deform on all agent instances.
        
        
        """
        pass
        
    
    def orientDiscToNormal():
        """
        orientDiscToNormal(self) -> bool
        
        Queries if discs and sprites are oriented to the normal (true) or
        not. The normal will be orthogonal to the disc (they will face in
        that direction).
        
        
        """
        pass
        
    
    def showSpecular(enable):
        """
        showSpecular(self, enable)
        
        Enable specular highlights. When disabled, specular will not
        contribute to the final lit color. This will also disable most
        reflections. This can be used to debug lighting.
        
        
        """
        pass
        
    
    def useMaterialOverrides(enable):
        """
        useMaterialOverrides(self, enable)
        
        Allow material overrides from material stylesheets and the
        material_override attribute.
        
        
        """
        pass
        
    
    def spriteTextureLimit():
        """
        spriteTextureLimit(self) -> tuple of int
        
        Query the maximum texture resolution for sprites. This is primarily
        a performance vs. quality trade-off option. Larger sprites look
        better but may cause slowdowns for large particle systems.
        
        
        """
        pass
        
    
    def orthoGridOffset():
        """
        orthoGridOffset(self) -> tuple of float
        
        Query the offset of the grid in fixed orthographic views.
        
        
        """
        pass
        
    
    def usePerPrimStylesheets(enable):
        """
        usePerPrimStylesheets(self, enable)
        
        Enable evaluation of per-primitive stylesheets.
        
        
        """
        pass
        
    
    def textureMaxMemory():
        """
        textureMaxMemory(self) -> int
        
        Return the maximum size of a single texture, in megabytes.
        
        
        """
        pass
        
    
    def setVectorScale(scale):
        """
        setVectorScale(self, scale)
        
        Set the scale applied to vector decorations, to make them longer or
        shorter.
        
        
        """
        pass
        
    
    def setMinReflectAmount(min_reflect):
        """
        setMinReflectAmount(self, min_reflect)
        
        Set the minimum level of reflection required for a reflection
        cubemap to be generated for an object. This is based on the largest
        reflective value from all the materials assigned to the object. The
        larger this value, the more reflective an object must be to generate
        a reflection maps. A value of zero is not recommended, as all
        objects will generate a reflection map.
        
        
        """
        pass
        
    
    def optimizeGeometry():
        """
        optimizeGeometry(self) -> bool
        
        Query if packed geometry is optimized.
        
        
        """
        pass
        
    
    def setApplyZoomToBackgroundImage(enable):
        """
        setApplyZoomToBackgroundImage(self, enable)
        
        Allow the camera zoom to affect the background image.
        
        
        """
        pass
        
    
    def setFilterBackgroundImage(enable):
        """
        setFilterBackgroundImage(self, enable)
        
        Enable texture filtering of background images. When off, individual
        pixels are shown as blocks at high zoome levels rather than blended.
        
        
        """
        pass
        
    
    def showsStateStatus(show):
        """
        showsStateStatus(self, show)
        
        Display any status messages of the current tool.
        
        
        """
        pass
        
    
    def textureResLimit2D():
        """
        textureResLimit2D(self) -> bool
        
        Query if 2D textures have their resolutions limited.
        
        
        """
        pass
        
    
    def setShadowMapSizeFromLight(enable):
        """
        setShadowMapSizeFromLight(self, enable)
        
        Set whether to use the shadow map size specified by the Shadow Map
        size parameter in the light object (clamped to the maximum size
        specified in the display options) or always use the maximum size.
        
        
        """
        pass
        
    
    def wireWidth():
        """
        wireWidth(self) -> double
        
        Query the width of lines drawn for wireframe and wire-over-shaded
        modes.
        
        
        """
        pass
        
    
    def setOnionSkinFramesAfterTint(tint):
        """
        setOnionSkinFramesAfterTint(self, tint)
        
        Tint all onion skins that appear after the current frame with this
        color.
        
        
        """
        pass
        
    
    def aspectRatio():
        """
        aspectRatio(self) -> float
        
        Query the viewport aspect ratio display option. Use
        viewAspectRatio() to query the current viewport aspect ratio.
        
        
        """
        pass
        
    
    def setUVGridPixelSpacing(offset):
        """
        setUVGridPixelSpacing(self, offset)
        
        Set the spacing of the UV dot grid displayed over the background
        image.
        
        
        """
        pass
        
    
    def setObjectOrigins(globel_enable):
        """
        setObjectOrigins(self, globel_enable)
        
        Globally allow object origins to be displayed. Object origins are
        enabled by setting the Origin flag on objects.
        
        
        """
        pass
        
    
    def setXrayStrength(strength):
        """
        setXrayStrength(self, strength)
        
        Sets the strength of the occluded x-ray objects. Lower values make
        occluded X-ray objects dimmer.
        
        
        """
        pass
        
    
    def setTextureMaxMemory(size_in_mb):
        """
        setTextureMaxMemory(self, size_in_mb)
        
        Set the maximum size of a single texture, in megabytes. This
        prevents extremely large textures from starving the graphics
        hardware's bandwidth (mostly by 3D textures).
        
        
        """
        pass
        
    
    def textureScale3D():
        """
        textureScale3D(self) -> float
        
        Query the uniform scale applied to 3D textures (volumes).
        
        
        """
        pass
        
    
    def normalScale():
        """None"""
        pass
        
    
    def setHdrReflections(hdr_reflect):
        """
        setHdrReflections(self, hdr_reflect)
        
        Enable High Dynamic Range (HDR) color buffers for the generated
        scene cubemap, which allows for higher contrast and bright spots in
        reflections.
        
        
        """
        pass
        
    
    def showingSpecular():
        """
        showingSpecular(self) -> bool
        
        Query if specular lighting is enabled.
        
        
        """
        pass
        
    
    def particleDiscSize():
        """
        particleDiscSize(self) -> double
        
        Query the disc diameter for particles drawn as Discs or Sprites if
        the pscale attribute does not exist. This is specified in world-
        space units.
        
        
        """
        pass
        
    
    def onionSkinOpacity():
        """
        onionSkinOpacity(self) -> double
        
        Query the current onion skin opacity.
        
        
        """
        pass
        
    
    def setNormalScale(normal_scale):
        """
        setNormalScale(self, normal_scale)
        
        Set a scale factor for the display of normals to increase or
        decrease their length.
        
        
        """
        pass
        
    
    def setTextureMipmapping(enable):
        """
        setTextureMipmapping(self, enable)
        
        Enable mipmapping for textures, improving display quality but
        increasing texture memory use by 50%.
        
        
        """
        pass
        
    
    def showMaterials(enable):
        """
        showMaterials(self, enable)
        
        Enable materials on geometry from SHOPs or VOPs. When disabled,
        these material assignments are ignored and only the attributes on
        the geometry will affect shading.
        
        
        """
        pass
        
    
    def visibleObjects():
        """
        visibleObjects(self) -> str
        
        Query the current visible object mask.
        
        
        """
        pass
        
    
    def headlightIntensity():
        """
        headlightIntensity(self) -> double
        
        Query the intensity of the headlight.
        
        
        """
        pass
        
    
    def setDisplayEnvironmentBackgroundImage(enable):
        """
        setDisplayEnvironmentBackgroundImage(self, enable)
        
        Allow environment lights to show their environment maps as 360
        degree background images.
        
        
        """
        pass
        
    
    def usingTransparency():
        """
        usingTransparency(self) -> bool
        
        Query if transparency rendering is enabled.
        
        
        """
        pass
        
    
    def setStereoMode(viewportStereoMode):
        """
        setStereoMode(self, viewportStereoMode)
        
        Set the stereo display mode when viewing through a stereo camera.
        
        * hou.viewportStereoMode.Anaglyph:
        
        Anaglyph display of left/right as red/cyan.
        
        * hou.viewportStereoMode.HorizontalInterlace:
        
        Interlace left and right on alternating scanlines. Only useful
        for 3D monitors which support this.
        
        * hou.viewportStereoMode.HorizontalInterlaceReverse:
        
        Interlace left and right on alternating scanlines, swapping
        which scanlines are used for left and right.
        
        * hou.viewportStereoMode.QuadBufferGL:
        
        Use OpenGL quad buffer stereo, generally only available on
        professional cards.
        
        
        """
        pass
        
    
    def textureMaxRes2D():
        """
        textureMaxRes2D(self) -> 2-tuple of int
        
        Return the maximum resolution for a 2D texture.
        
        
        """
        pass
        
    
    def levelOfDetail():
        """
        levelOfDetail(self) -> double
        
        Query the current level of detail used for tessellating geometry.
        
        
        """
        pass
        
    
    def updateMaterials():
        """
        updateMaterials(self)
        
        Manually update all materials and material assignments.
        
        
        """
        pass
        
    
    def hdrRendering():
        """None"""
        pass
        
    
    def setTextureBitDepthLimit3D(viewportTextureDepth):
        """
        setTextureBitDepthLimit3D(self, viewportTextureDepth)
        
        Set the maximum bit depth for a 3D texture (volume). Textures with a
        bit depth higher than this will be downconverted to this bit depth.
        Textures with an equal or lower bit depth will not be converted. 3D
        textures do not support compressed formats.
        
        * hou.viewportTextureDepth.Fixed8:
        
        8b SDR texture format. Good balance between memory and quality.
        
        * hou.viewportTextureDepth.HDR16:
        
        16b HDR texture format. Excellent dynamic range, but more memory
        use and slower texturing performance.
        
        * hou.viewportTextureDepth.FullHDR:
        
        32b HDR texture format. Extreme dynamic range, but very high
        memory use and slow texturing performance. Use with care.
        
        
        """
        pass
        
    
    def homeAutoAdjustClip():
        """
        homeAutoAdjustClip(self) -> hou.viewportHomeClipMode
        
        Queries which camara clip planes are adjusted when performing a
        homing operation.
        
        
        """
        pass
        
    
    def hdrReflections():
        """
        hdrReflections(self) -> bool
        
        Query if High Dynamic Range (HDR) color buffers are use for the
        scene cubemap.
        
        
        """
        pass
        
    
    def showCameraName():
        """
        showCameraName(self) -> bool
        
        Query if the camera name menu is displayed.
        
        
        """
        pass
        
    
    def textureCacheSize():
        """
        textureCacheSize(self) -> int
        
        Query the texture cache size, in megabytes.
        
        
        """
        pass
        
    
    def setLightSampling(num_samples):
        """
        setLightSampling(self, num_samples)
        
        Set the number of lighting samples to perform when doing high
        quality lighting for area and environment lights.
        
        
        """
        pass
        
    
    def defaultMaterialEmission(tint):
        """
        defaultMaterialEmission(self, tint)
        
        Set the emission color of the default material (used when no
        material assignment is present or Show Materials is disabled).
        
        
        """
        pass
        
    
    def showName():
        """
        showName(self) -> bool
        
        Query if the viewport name menu is displayed.
        
        
        """
        pass
        
    
    def minReflectAmount():
        """
        minReflectAmount(self) -> double
        
        Query the minimum reflection level required for a cubemap to be
        generated for an object.
        
        
        """
        pass
        
    
    def setAmbientOcclusion(enable):
        """
        setAmbientOcclusion(self, enable)
        
        Enable an ambient occlusion pass in high quality lighting modes.
        This generates local occlusion shadows.
        
        
        """
        pass
        
    
    def allowParticleSprites():
        """
        allowParticleSprites(self) -> bool
        
        Query if particles are drawn as sprites when sprite attributes are
        detected on the particle (sprite* or shop_materialpath).
        
        
        """
        pass
        
    
    def removeBackfaces():
        """
        removeBackfaces(self) -> bool
        
        Query if backwards facing polygons are culled.
        
        
        """
        pass
        
    
    def applyZoomToBackgroundImage():
        """
        applyZoomToBackgroundImage(self) -> bool
        
        Query if the camera zoom is affecting the background image.
        
        
        """
        pass
        
    
    def setShadowQuality(viewportShadowQuality):
        """
        setShadowQuality(self, viewportShadowQuality)
        
        Set the quality of shadow sampling in High Quality Lighting with
        Shadows lighting mode.
        
        * hou.viewportShadowQuality.Point:
        
        Area lights are treated as point lights when generating and
        sampling shadow maps. This is the fastest option.
        
        * hou.viewportShadowQuality.PointAA:
        
        Do some antialiasing of shadow edges. Treat area lights as point
        lights when generating and sampling shadow maps.
        
        * hou.viewportShadowQuality.Area:
        
        Area lights generate multiple shadow maps which are sampled to
        generate an approximation of a blurred shadow from an area
        source.
        
        * hou.viewportShadowQuality.AreaAA:
        
        Area lights generate multiple maps and antialias the shadow
        lookups.
        
        
        """
        pass
        
    
    def setOnionSkinFrameIncrement(frame_increment):
        """
        setOnionSkinFrameIncrement(self, frame_increment)
        
        Set the frame increment between onion skins. Using 1 will draw every
        frame around the current frame ($F-2 $F-1 $F $F+1 $F+2, while 5
        would step by 5 ($F-10 $F-5 $F $F+5 $F+10).
        
        
        """
        pass
        
    
    def agentShapePointCutoff():
        """
        agentShapePointCutoff(self) -> int
        
        Query the minimum number of points in an agent LOD level.
        
        
        """
        pass
        
    
    def textureMaxRes3D():
        """
        textureMaxRes3D(self) -> 3-tuple of int
        
        Query the maximum resolution of a 3D texture (volume).
        
        
        """
        pass
        
    
    def usePackedStylesheets(enable):
        """
        usePackedStylesheets(self, enable)
        
        Enable assignment of material stylesheets to geometry within packed
        primitives.
        
        
        """
        pass
        
    
    def offsetVertexMarkers():
        """
        offsetVertexMarkers(self) -> bool
        
        When enabled, vertex markers and normals are inset into the polygon
        so they can be selected independently when part of a seamless mesh.
        When disabled, the markers and normals are placed at the actual
        vertex, potentially overlapping.
        
        
        """
        pass
        
    
    def setOnionSkinFramesBeforeTint(tint):
        """
        setOnionSkinFramesBeforeTint(self, tint)
        
        Tint all onion skins that appear before the current frame with this
        color.
        
        
        """
        pass
        
    
    def setOrthoGridOffset(offset):
        """
        setOrthoGridOffset(self, offset)
        
        Set the offset of the grid in fixed orthographic views, as a 3-tuple
        in world space.
        
        
        """
        pass
        
    
    def displacementLevel():
        """
        displacementLevel(self) -> double
        
        Query the level of detail used for displacement mapping.
        
        
        """
        pass
        
    
    def setViewMaskOpacity(opacity):
        """
        setViewMaskOpacity(self, opacity)
        
        Set the opacity of the bars used to mask areas out the viewport
        outside the aspect ratio.
        
        
        """
        pass
        
    
    def textureAnisotropicFilter():
        """
        textureAnisotropicFilter(self) -> int
        
        Query the number of samples used for anisotropic texture filtering.
        
        
        """
        pass
        
    
    def uvVertexType():
        """
        uvVertexType(self) -> bool
        
        Return the class of the UV attribute, Point or Vertex. This returns
        the viewport setting, and not the detected class of the current UV
        attribute. If uvAutoAttribute is enabled, the class will be the same
        as the currently displayed attribute, but if it is disabled it may
        be different.
        
        
        """
        pass
        
    
    def displayUVTileBoundaries():
        """
        displayUVTileBoundaries(self) -> bool
        
        Query if the boundaries of UV tiles are displayed.
        
        
        """
        pass
        
    
    def uvReferenceGrid():
        """
        uvReferenceGridOverImage(self) -> bool
        
        Query if the dot grid is displayed.
        
        
        """
        pass
        
    
    def headlightSpecular():
        """
        headlightSpecular(self) -> bool
        
        Query if specular reflections are generated by the headlight.
        
        
        """
        pass
        
    
    def textureBitDepthLimit2D():
        """
        textureBitDepthLimit2D(self) -> hou.viewportTextureDepth
        
        Query the maximum bit depth for a 2D texture.
        
        * hou.viewportTextureDepth.Compressed8:
        
        Compressed, 8b SDR texture format. Smallest memory use.
        
        * hou.viewportTextureDepth.Fixed8:
        
        8b SDR texture format. Good balance between memory and quality.
        
        * hou.viewportTextureDepth.HDR16:
        
        16b HDR texture format. Excellent dynamic range, but more memory
        use and slower texturing performance.
        
        * hou.viewportTextureDepth.FullHDR:
        
        32b HDR texture format. Extreme dynamic range, but very high
        memory use and slow texturing performance. Use with care.
        
        
        """
        pass
        
    
    def setDisplayOrthoGrid(enable):
        """
        setDisplayOrthoGrid(self, enable)
        
        Display the grid in fixed orthographic views (Top, Left, Front,
        Bottom, Right, Back).
        
        
        """
        pass
        
    
    def reflectMapSize():
        """
        reflectMapSize(self) -> int
        
        Query the size of reflection cubemaps.
        
        
        """
        pass
        
    
    def setTextureResLimit3D(enable):
        """
        setTextureResLimit3D(self, enable)
        
        Limit the resolution of all 3D textures (volumes), so that the
        width, height, and depth cannot exceed the limit. Even if disabled,
        OpenGL has its own texture limits which will be applied (usually 2k
        or 8k).
        
        
        """
        pass
        
    
    def showDiffuse(enable):
        """
        showDiffuse(self, enable)
        
        Enable diffuse contribution of lighting. When disabled, diffuse will
        not contribute to the final lit color. This can be used to debug
        lighting.
        
        
        """
        pass
        
    
    def showingAmbient():
        """
        showingAmbient(self) -> bool
        
        Query if ambient lighting is enabled.
        
        
        """
        pass
        
    
    def pointMarkerSize():
        """
        pointMarkerSize(self) -> float
        
        Queries the size of point marker decorations, in pixels.
        
        
        """
        pass
        
    
    def usingAspectRatio():
        """
        usingAspectRatio(self) -> bool
        
        Query if a specific aspect ratio is being enforced.
        
        
        """
        pass
        
    
    def setBaseLODLevel(base_level):
        """
        setBaseLODLevel(self, base_level)
        
        Set the level to use as the full level of detail model, generally 0
        (the original agent model). For very heavy poly count agents, this
        can be set to higher values to reduce the polygon count of the
        highest level of detail model.
        
        
        """
        pass
        
    
    def setDefaultMaterialAmbient():
        """
        setDefaultMaterialAmbient(self) -> hou.Color
        
        Query the default material's ambient color.
        
        
        """
        pass
        
    
    def displayOrthoGrid():
        """
        displayOrthoGrid(self) -> bool
        
        Query if the grid is displayed in fixed orthographic views.
        
        
        """
        pass
        
    
    def transparencyQuality():
        """
        transparencyQuality(self) -> hou.viewportTransparency
        
        Query the transparency quality.
        
        
        """
        pass
        
    
    def setUVDisplayAttribute():
        """None"""
        pass
        
    
    def displayBackgroundImage():
        """
        displayBackgroundImage(self) -> bool
        
        Query if background image display is globally enabled.
        
        
        """
        pass
        
    
    def defaultMaterialAmbient(tint):
        """
        defaultMaterialAmbient(self, tint)
        
        Set the ambient color of the default material (used when no material
        assignment is present or Show Materials is disabled).
        
        
        """
        pass
        
    
    def orthoRuler():
        """
        orthoRuler(self) -> hou.viewportGridRuler
        
        Query where the grid numbers are displayed on the fixed orthographic
        view grid.
        
        * hou.viewportGridRuler.Hide:
        
        Not displayed.
        
        * hou.viewportGridRuler.MainAxis:
        
        Displayed along the main axes at grid line intersections.
        
        * hou.viewportGridRuler.GridPoints:
        
        Displayed on grid line intersections.
        
        
        """
        pass
        
    
    def setOptimizeGeometry(enable):
        """
        setOptimizeGeometry(self, enable)
        
        Optimize packed geometry when loaded to make it faster for display
        (triangulating and splitting meshes).
        
        
        """
        pass
        

def GeometryViewportSettings_swigregister():
    """None"""
    pass
    

def GeometryViewport_swigregister():
    """None"""
    pass
    

def Geometry_swigregister():
    """None"""
    pass
    

class HDADefinition(object):
    """
    hou.HDADefinition
    
    Represents the definition of a houdini digital asset (HDA).
    
    A digital asset definition defines a node type and exists inside an hda
    file. The node type is implemented in terms of other nodes wired
    together inside a subnet. These nodes inside the subnet are called the
    definition's contents.
    
    An hda file contains one or more digital asset definitions, and
    installing an hda file installs all the definitions in the file. When a
    digital asset definition is installed, the node type it defines is added
    to Houdini. Note that you can access an HDADefinition without installing
    it.
    
    A digital asset's algorithm is determined by the nodes inside it. To
    edit those nodes you create an instance of the digital asset, unlock it,
    modify the contents, and save the definition. New digital asset
    instances are normally locked, meaning that they are read-only, and they
    automatically update when the asset's definition changes. An unlocked
    instance is editable, does not update when the definition changes, and
    you can save its contents to change the definition.
    
    To unlock a node, select Allow Editing of Contents or call
    hou.Node.allowEditingOfContents. To save the contents of an unlocked
    node to the definition, select Save Operator Type or call
    hou.HDADefinition.updateFromNode. To revert an unlocked instance back to
    the last saved definition and change it back into a locked instance,
    select Match Current Definition or call hou.Node.matchCurrentDefinition.
    
    See also hou.hda and hou.HDAOptions.
    
    
    """
    
    def comment():
        """None"""
        pass
        
    
    def isPreferred():
        """
        isPreferred(self) -> bool
        
        Return whether this definition is preferred.
        
        After loading hda files, Houdini uses a set of rules to resolve
        conflicts when it encounters multiple definitions for the same node
        type (e.g. preferring the most recent hda file, preferring
        definitions embedded in the hip file, etc.). When these rules do not
        use the definition you want, you can override them by explicitly
        marking a definition as preferred. Houdini saves this list of
        preferred definitions with the hip file. Marking a definition as not
        preferred will remove it from this list, and the normal rules will
        apply again.
        
        
        """
        pass
        
    
    def removeParmTuple(self, name):
        """
        removeParmTuple(self, name)
        
        Remove a parameter tuple from this node type's parameters.
        
        See also hou.HDADefinition.addParmTuple and
        hou.HDADefinition.removeParmFolder.
        
        This method is deprecated in favor of
        hou.HDADefinition.setParmTemplateGroup.
        
        """
        pass
        
    
    def setExtraInfo(extra_info):
        """
        setExtraInfo(self, extra_info)
        
        Set extra information about the asset definition that isn't stored
        elsewhere, like the representative node, guide geometry, etc. This
        string is encoded in a specific format, so it is recommended that
        you only call this method with values returned from
        hou.HDADefinition.extraInfo.
        
        
        """
        pass
        
    
    def installed():
        """None"""
        pass
        
    
    def setIsPreferred(preferred):
        """
        setIsPreferred(self, preferred)
        
        Set whether this definition is preferred. See
        hou.HDADefinition.isPreferred for more information.
        
        
        """
        pass
        
    
    def addParmTuple(self, parm_template, in_folder=():
        """
        addParmTuple(self, parm_template, in_folder=(),
        create_missing_folders=False)
        
        Add a parameter tuple to this node type's parameters. Houdini places
        the new parameter at the bottom of the parameters in a particular
        folder.
        
        
        parm_template
        An instance of a hou.ParmTemplate subclass that describes the
        parameter.
        
        in_folder
        A sequence of folder name strings to tell Houdini which folder
        to put the parameter in. If this sequence is empty, the
        parameter will go in top level set of folders. It it is, for
        example, ("Transform",), the parameter is added inside the
        Transform folder. If it is ("Transform", "Options"), it will go
        inside the Options folder inside the Transform folder.
        
        create_missing_folders
        Whether Houdini should create folders specified in in_folder
        that do not already exist. If this parameter is True, you can
        create folders without having to call
        hou.HDADefinition.addParmFolder.
        
        Note that this method can add a single folder by passing a
        hou.FolderParmTemplate for parm_template.
        
        See also hou.HDADefinition.replaceParmTuple.
        
        This method is deprecated in favor of
        hou.HDADefinition.setParmTemplateGroup.
        
        """
        pass
        
    
    def minNumInputs():
        """
        minNumInputs(self) -> int
        
        Return the minimum number of connected inputs that node instances of
        this digital asset can have. If these inputs are not connected, the
        node will generate an error.
        
        See also hou.NodeType.minNumInputs.
        
        
        """
        pass
        
    
    def setDescription(description):
        """
        setDescription(self, description)
        
        Set the description for this definition's node type. Houdini uses
        this description for user interface elements such as the TAB menu.
        This description is also called the operator label in Houdini.
        
        See also hou.HDADefinition.description and hou.NodeType.description.
        
        
        """
        pass
        
    
    def current():
        """None"""
        pass
        
    
    def addParmFolder(self, folder_name, in_folder=():
        """
        addParmFolder(self, folder_name, in_folder=(), parm_name=None,
        create_missing_folders=False)
        
        Adds a folder to this node type's parameters.
        
        
        folder_name
        The name of the folder that is displayed in the parameter
        dialog.
        
        in_folder
        A sequence of folder name strings to indicate where the folder
        should go. If this sequence is empty, the folder will go in top
        level set of folders. It it is, for example, ("Transform",), the
        folder is added inside the Transform folder. If it is
        ("Transform", "Options"), it will go inside the Options folder
        inside the Transform folder.
        
        parm_name
        The name of the underlying parameter tuple corresponding to the
        set of folders. For example, the folders in a set might be named
        Transform, Subnet, and Controls, and these correspond to one
        parameter tuple named, say, 'stdswitcher0'. The value of the
        parameter in this tuple is the index of the folder that is open.
        
        If this is the first folder to go in the set, parm_name is used
        as the parameter name. Otherwise, it is ignored and Houdini uses
        the parameter name of the first folder in the set.
        
        If this is the first folder in the set and parm_name is None, it
        will default to 'folder0'. If parm_name is already in use,
        Houdini automatically generates a unique name.
        
        create_missing_folders
        Whether Houdini should create folders specified in in_folder
        that do not already exist. If this parameter is True, you can
        use this method to add nested folders in one call.
        
        Note that you can add folders by passing a hou.FolderParmTemplate to
        the addSpareParmTuple method, so this method is deprecated. Note
        also that addSpareParmTuple is deprecated in favor of
        setParmTemplateGroup.
        
        See also the removeParmFolder and addParmTuple methods.
        
        This method is deprecated in favor of setParmTemplateGroup.
        
        """
        pass
        
    
    def hideDefaultParameters():
        """
        hideDefaultParameters(self) -> bool
        
        Return whether the parameters that are common to nodes types in this
        node type category are hidden or not. For example, nearly all
        objects have common translation, rotation, scale, etc. parameters,
        and object level digital assets have these parameters by default. If
        hidden, though, these parameters are still there but are not
        displayed to the user.
        
        Note that this value is also stored in the string returned by
        hou.HDADefinition.extraInfo.
        
        
        """
        pass
        
    
    def extraFileOptions():
        """
        extraFileOptions(self) -> dict of str to bool, int, float, str
        
        Return a dictionary containing the extra options attached to
        sections in the asset's definition. For example, event handler
        scripts such as OnCreated are stored as sections inside the asset,
        and extra metadata in this dictionary determines whether Houdini
        runs these scripts as Python as as Hscript.
        
        These is one dictionary for the entire asset, and keys in this
        dictionary are usually of the form section_name/option_name. For
        example, if the OnCreated section is marked as containing Python
        code, this dictionary will contain "OnCreated/IsPython" set to True.
        
        Note that the contents of this dictionary are saved in the
        ExtraFileOptions section and are encoded in a binary format.
        
        See also hou.HDADefinition.setExtraFileOption and
        hou.HDADefinition.removeExtraFileOption.
        
        
        """
        pass
        
    
    def setPreferred():
        """None"""
        pass
        
    
    def hasSection(name):
        """
        hasSection(self, name) -> bool
        
        Return True if the HDA definition contains a section with the
        specified name and False otherwise.
        
        See hou.HDASection for more information on sections.
        
        
        """
        pass
        
    
    def representativeNodePath():
        """
        representativeNodePath(self) -> str
        
        Return the contents of the Representative Node field on the Basic
        tab of the Type Properties dialog.
        
        For object-level digital assets that contain other object nodes, it
        is possible to make Houdini treat your digital asset like a camera
        or light by choosing a node inside the asset to represent it. For
        example, if you choose a camera inside the asset as the
        representative node, instances of the digital asset will appear in
        the viewport's list of camera objects.
        
        Note that this value is also stored in the string returned by
        hou.HDADefinition.extraInfo.
        
        
        """
        pass
        
    
    def version():
        """None"""
        pass
        
    
    def replaceParmTuple(self, parm_tuple_name, parm_template):
        """
        replaceParmTuple(self, parm_tuple_name, parm_template)
        
        Replace an existing parameter tuple with a new one. The old
        parameter tuple is removed and the new one is added in its place.
        
        
        parm_tuple_name
        The name of the parameter tuple to replace. Raises
        hou.OperationFailed if no parameter tuple exists with this name.
        
        parm_template
        A hou.ParmTemplate describing the new parameter tuple.
        
        The new parameter tuple may or may not have the same name as the old
        one. By providing a parameter tuple with the same name, you can
        modify an existing parameter tuple. The following example function
        changes the definition of the asset to make a parameter tuple
        visible or invisible in all nodes of that type.
        
        To show or hide a parameter in just one instance of a node, use
        hou.ParmTuple.hide.
        
        To change a spare parameter on a node, use
        hou.Node.replaceSpareParmTuple or hou.Node.setParmTemplateGroup.
        
        This method is deprecated in favor of
        hou.HDADefinition.setParmTemplateGroup.
        
        """
        pass
        
    
    def embeddedHelp():
        """
        embeddedHelp(self) -> str
        
        Return the help text embedded in the digital asset. Return an empty
        string if no embedded help exists.
        
        Embedded help typically comes from the Help tab of the operator type
        properties window, but it may also come from a dialog script.
        
        
        """
        pass
        
    
    def setMaxNumInputs(max_num_inputs):
        """
        setMaxNumInputs(self, max_num_inputs)
        
        Set the maximum number of inputs that node instances of this digital
        asset may have. This number must be greater than or equal to the
        minimum number of inputs. If it is 5 or greater, Houdini will use a
        merge SOP-style input connector that allows an unlimited number of
        inputs. Otherwise, the node will have between 0 and 4 input
        connectors, each of which may or may not be connected, that
        correspond to the subnet indirect inputs inside the digital asset.
        
        See hou.Node.inputConnectors and hou.SubnetIndirectInput for more
        information on input connectors and subnet indirect inputs.
        
        
        """
        pass
        
    
    def removeSection(name):
        """
        removeSection(self, name)
        
        Remove an existing section. Only remove sections that you explicitly
        added. Do not remove the special sections that Houdini uses to store
        the contents of the digital asset definition, or Houdini will
        generate errors or strange side effects.
        
        See hou.HDASection for more information on sections. Note that
        hou.HDASection.destroy will also remove a section.
        
        Raises hou.OperationFailed if no such section exists in the
        definition.
        
        
        """
        pass
        
    
    def nodeTypeName():
        """
        nodeTypeName(self) -> str
        
        Return the name of the node type defined by this digital asset.
        Raises hou.OperationFailed if the digital asset is not installed.
        
        If the digital asset is installed, this method is a shortcut for
        self.nodeType().name().
        
        
        """
        pass
        
    
    def save(file_name, template_node=None, options=None, create_backup=True):
        """
        save(self, file_name, template_node=None, options=None,
        create_backup=True)
        
        Save the definition into an hda file.
        
        
        file_name
        Where to save the definition. To save to the current hda file,
        use the return value from hou.HDADefinition.libraryFilePath.
        
        template_node
        Either None or a hou.Node object containing an unlocked instance
        of the digital asset that defines the definition's new contents.
        If None, this method does not update the definition's contents.
        
        options
        Either None or a hou.HDAOptions object that specifies extra
        behaviors of the definition. If template_node is not None, the
        compressContents, lockContents, saveSpareParms, and
        makeInitialParmsDefaults values of the hou.HDAOptions object are
        used. Otherwise, only the compressContents value is used.
        
        create_backup
        Create a backup before modifying existing hda files.
        
        See also hou.HDADefinition.updateFromNode for a way to save an
        unlocked node's definition to the current hda file. See also
        hou.HDADefinition.copyToHDAFile.
        
        
        """
        pass
        
    
    def sections():
        """
        sections(self) -> dict of str to hou.HDASection
        
        Return a dictionary mapping section names to hou.HDASection objects.
        See hou.HDASection for more information on sections.
        
        
        """
        pass
        
    
    def removeParmFolder(self, folder):
        """
        removeParmFolder(self, folder)
        
        Remove an empty folder from this node type's parameters.
        
        
        folder
        A _sequence of folder names_. For example, to remove the Output
        folder, pass in ("Output",) and not "Output".
        
        Raises hou.OperationFailed if the folder does not exist or it is not
        empty. Use hou.HDADefinition.removeParmTuple to remove all the
        parameters inside the folder before calling this method.
        
        See also addParmFolder, hou.ParmTemplateGroup.remove, and
        hou.ParmTemplateGroup.findFolder.
        
        This method is deprecated in favor of
        hou.HDADefinition.setParmTemplateGroup.
        
        """
        pass
        
    
    def isInstalled():
        """
        isInstalled(self) -> bool
        
        Return whether this definition is installed in Houdini.
        
        It is possible to access HDADefinition objects in hda files that are
        not installed with hou.hda.definitionsInFile.
        
        See also hou.hda.installFile.
        
        
        """
        pass
        
    
    def nodeType():
        """
        nodeType(self) -> hou.NodeType
        
        Return the node type defined by this digital asset. Raises
        hou.OperationFailed if the digital asset is not installed.
        
        
        """
        pass
        
    
    def description():
        """
        description(self) -> str
        
        Return the description for this definition's node type. Houdini uses
        this description for user interface elements such as the TAB menu.
        This description is also called the operator label in Houdini.
        
        See also hou.NodeType.description.
        
        
        """
        pass
        
    
    def addSection(name, contents="", compression_type=hou.compressionType.NoCompression):
        """
        addSection(self, name, contents="",
        compression_type=hou.compressionType.NoCompression) -> hou.HDASection
        
        Create a new section with the specified contents. If a section
        already exists with this name, changes the existing contents to the
        new contents. Note that the contents may contain binary data. Also
        note that section names may contain '/'.
        
        You can optionally specify a compression type, hou.compressionType,
        to compress the contents. Note that you must specify the same
        compression type when reading the contents back to decompress them.
        
        See hou.HDASection for more information on sections. To remove a
        section, use hou.HDASection.destroy.
        
        Sections can have associated properties stored in the
        hou.HDADefinition.extraFileOptions.
        
        > def addSectionFromFile(hda_definition, section_name, file_name):
        >     '''Add a section whose contents come from a file.  If the section
        >        already exists, replace its contents.'''
        >     section_file = open(file_name, "r")
        >     hda_definition.addSection(section_name, section_file.read())
        >     section_file.close()
        
        """
        pass
        
    
    def copyToHDAFile(file_name, new_name=None, new_menu_name=None):
        """
        copyToHDAFile(self, file_name, new_name=None, new_menu_name=None)
        
        Copy this definition into an hda file.
        
        
        file_name
        The hda file where the definition will be saved. If the file
        does not already exist, it will be created. If it already
        contains a definition for this node type, it will be
        overwritten.
        
        new_name
        The new name of the node type. If None, the definition will be
        saved as the existing node type name. See also
        hou.NodeType.name.
        
        new_menu_name
        The new description of the node type that appears in the tab
        menu. If None, Houdini will use the existing description. Note
        that the node type name must be unique within the hda file, so
        saving the definition with a new description to an hda file
        containing a definition with the old node name will still
        overwrite the existing definition. See also
        hou.NodeType.description.
        
        
        """
        pass
        
    
    def preferred():
        """None"""
        pass
        
    
    def modificationTime():
        """
        modificationTime(self) -> int
        
        Return the time when the definition was last modified. This time is
        returned as a POSIX timestamp, such as is returned by time.time().
        
        > >>> import time
        > >>> time.ctime(hou.nodeType(hou.objNodeTypeCategory(), "toon_character").
        > ...     definition().modificationTime())
        > 'Thu Nov  6 18:22:38 2008'
        
        """
        pass
        
    
    def setOptions(options):
        """
        setOptions(self, options)
        
        Set this digital asset definition's options to the data in a
        hou.HDAOptions object. See hou.HDAOptions for more information.
        
        
        """
        pass
        
    
    def setParmTemplateGroup(parm_template_group, rename_conflicting_parms=False):
        """
        setParmTemplateGroup(self, parm_template_group,
        rename_conflicting_parms=False)
        
        Change the spare parameters for this node.
        
        
        parm_template_group
        A hou.ParmTemplateGroup object containing the new parameter
        layout.
        
        rename_conflicting_parms
        If True, parameters in the group with the same parm tuple names
        will be automatically renamed. If False and there are parms with
        the same name, this method raises hou.OperationFailed.
        
        Note that each node type has a set of parameters which must exist
        and must be of certain types. If your parm template group does not
        contain the required parameters for the node type the will be added
        at the bottom and will be made invisible. Similarly, if your parm
        template group attempts to modify the type, range, label, or other
        property of a required parameter, all changes to that parameter
        other than visibility settings will be ignored.
        
        This method is preferred over the other parameter-related methods in
        this class (addSpareParmTuple, removeSpareParmTuple,
        replaceSpareParmTuple, addSpareParmFolder, removeSpareParmFolder)
        because it lets you more easily make manipulate parameters.
        
        See hou.HDADefinition.setParmTemplateGroup to change the parameter
        interface of a digital asset.
        
        
        """
        pass
        
    
    def setVersion():
        """None"""
        pass
        
    
    def maxNumInputs():
        """
        maxNumInputs(self) -> int
        
        Return the maximum number of inputs that node instances of this
        digital asset can have. Return a number greater than 4 if this node
        type can accept an unlimited number of inputs.
        
        See also hou.NodeType.maxNumInputs.
        
        
        """
        pass
        
    
    def isCurrent():
        """
        isCurrent(self) -> bool
        
        Return whether this definition is the one currently in use by
        Houdini.
        
        This example shows how you can access other definitions for the same
        node type:
        
        > def otherDefinitions(definition):
        >     '''Given an HDADefinition object, return the other loaded definitions
        >        for the same node type.'''
        >     # Look through all the loaded hda files for definitions providing
        >     # the same node type.
        >     result = []
        >     for hda_file in hou.hda.loadedFiles():
        >         # Skip the hda file containing the definition that was passed in.
        >         if hda_file == definition.libraryFilePath():
        >             continue
        >
        >         for other_definition in hou.hda.definitionsInFile(hda_file):
        >             if other_definition.nodeType() == definition.nodeType():
        >                 result.append(other_definition)
        >     return result
        > # Print the paths to hda files providing other definitions for a digital asset instance.
        > >>> for other_definition in otherDefinitions(hou.node("/obj/my_hda1").type().definition()):
        > ...     print other_definition.libraryFilePath()
        > /path/to/file1.hda
        > /path/to/file2.hda
        
        """
        pass
        
    
    def destroy():
        """
        destroy(self)
        
        Uninstall this definition and _delete it from the hda file_. Any
        node instances of this asset will warn that they are using an
        incomplete asset definition.
        
        See also hou.hda.uninstallFile.
        
        
        """
        pass
        
    
    def compileCodeSection(source_section, destination_section):
        """
        compileCodeSection(self, source_section, destination_section)
        
        This function is deprecated. Compiled VEX code should no longer be
        stored inside of an HDA.
        
        
        """
        pass
        
    
    def parsedContents(self):
        """
        parsedContents(self) -> tuple of (str, str)
        
        Return a list of (name, value) pairs of the parsed from the Contents
        section.
        
        The Contents section consists of the child nodes used to create a
        node instance of the HDA.
        
        See also hou.HDADefinition.uncompressedContents.
        
        """
        pass
        
    
    def icon():
        """
        icon(self) -> str
        
        Return the name or path of the icon for this definition's node type.
        Note that Houdini uses its search path to locate icons, so you do
        not need to pass in a full path.
        
        See also hou.NodeType.icon.
        
        
        """
        pass
        
    
    def uncompressedContents(self):
        """
        uncompressedContents(self) -> str
        
        Return a string containing the data of the uncompressed Contents
        section.
        
        The Contents section consists of data in the CPIO format
        representing the child nodes used to create a node instance of the
        HDA.
        
        See also hou.HDADefinition.parsedContents.
        
        """
        pass
        
    
    def nodeTypeCategory():
        """
        nodeTypeCategory(self) -> hou.NodeTypeCategory
        
        Return the node type category (e.g. Objects, SOPs, DOPs, etc.) for
        the node type defined by this digital asset. See
        hou.NodeTypeCategory for more information.
        
        It is safe to call this method if the digital asset is not
        installed. If the digital asset is installed, this method is
        equivalent to self.nodeType().category().
        
        
        """
        pass
        
    
    def setIcon(icon):
        """
        setIcon(self, icon)
        
        Set the icon for this definition's node type. See
        hou.HDADefinition.icon for more information.
        
        
        """
        pass
        
    
    def extraInfo():
        """
        extraInfo(self) -> str
        
        Return a string storing extra information about the asset definition
        that isn't stored elsewhere, like the representative node, guide
        geometry, whether default parameters are hidden, etc.
        
        See also hou.HDADefinition.representativeNodePath and
        hou.HDADefinition.hideDefaultParameters to more easily retrieve some
        portions of the extra info.
        
        
        """
        pass
        
    
    def setModificationTime(time=-1):
        """
        setModificationTime(self, time=-1)
        
        Set the modification time for the definition to the given POSIX
        timestamp. If the time parameter is negative, uses the current time.
        
        See also hou.HDADefinition.modificationTime.
        
        
        """
        pass
        
    
    def setComment():
        """None"""
        pass
        
    
    def libraryFilePath():
        """
        libraryFilePath(self) -> str
        
        Return the path to the hda file containing the digital asset's
        definition.
        
        Note that it is possible to save an asset with a hip file, without
        storing it in an hda file. In this case, this method returns
        "Embedded".
        
        
        """
        pass
        
    
    def setExtraFileOption(name, value, type_hint, =, hou.fieldType::NoSuchField):
        """
        setExtraFileOption(self, name, value, type_hint =
        hou.fieldType::NoSuchField)
        
        Set an entry in the dictionary of extra file options. See
        hou.HDADefinition.extraFileOptions for more information.
        
        
        name
        The name of the option to set.
        
        value
        An integer, float, string, hou.Vector2, hou.Vector3,
        hou.Vector4, hou.Quaternion, hou.Matrix3, hou.matrix4, or
        sequence of numbers.
        
        type_hint
        Used to determine the exact hou.fieldType desired when the
        specified value type is not enough to unambiguously determine
        it.
        
        The following example function marks an section, such as OnCreated,
        as containing Python code:
        
        > def markSectionAsPython(definition, section_name):
        >     definition.setExtraFileOption(section_name + "/IsPython", True)
        
        """
        pass
        
    
    def parmTemplateGroup():
        """
        parmTemplateGroup(self) -> hou.ParmTemplateGroup
        
        Return the group of parm templates corresponding to the current
        parameter layout for this node.
        
        You can edit the parameter layout for this node (add or remove spare
        parameters, reorder or hide built-in parameters, etc.) by getting
        the current parameter group, modifying it, and calling
        hou.Node.setParmTemplateGroup with it.
        
        The following example creates a geometry object, adds a My Parms
        folder to it, and adds a My Parm float parameter to it in that
        folder. The parameters are added only to the geometry object
        created; other geometry objects are unaffected.
        
        > >>> node = hou.node("/obj").createNode("geo")
        > >>> group = node.parmTemplateGroup()
        > >>> folder = hou.FolderParmTemplate("folder", "My Parms")
        > >>> folder.addParmTemplate(hou.FloatParmTemplate("myparm", "My Parm", 1))
        > >>> group.append(folder)
        > >>> node.setParmTemplateGroup(group)
        
        See hou.ParmTemplateGroup and the setParmTemplateGroup method for
        more information and examples.
        
        
        """
        pass
        
    
    def updateFromNode(node):
        """
        updateFromNode(self, node)
        
        Update and save the definition to match the contents of a given
        unlocked instance of the asset. Calling this method is the same as
        selecting Save Operator Type on the node's menu.
        
        > def saveUnlockedNodes():
        >     '''Look through all the nodes in the file for unlocked digital asset
        >        instances and save and lock them.'''
        >     for node in hou.node("/").allSubChildren():
        >         if node.type().definition() is None or node.matchesCurrentDefinition():
        >             continue
        >
        >         node.type().definition().updateFromNode(node)
        >         node.matchCurrentDefinition()
        
        """
        pass
        
    
    def setUserInfo(extra_info):
        """
        setUserInfo(self, extra_info)
        
        Set user information about the asset definition. This info isn't
        used by Houdini so it can contain any text.
        
        
        """
        pass
        
    
    def setMinNumInputs(min_num_inputs):
        """
        setMinNumInputs(self, min_num_inputs)
        
        Set the minimum number of connected inputs that node instances of
        this digital asset must have. min_num_inputs must be between 0 and
        4, inclusive. If a node does not have the minimum number of inputs,
        it will generate an error.
        
        
        """
        pass
        
    
    def options():
        """
        options(self) -> hou.HDAOptions
        
        Return a hou.HDAOptions object for the options stored in this
        digital asset. See hou.HDAOptions for more information.
        
        
        """
        pass
        
    
    def removeExtraFileOption(name):
        """
        removeExtraFileOption(self, name)
        
        Remove an entry in the dictionary of extra file options. See
        hou.HDADefinition.extraFileOptions for more information.
        
        Raises hou.OperationFailed if there is no entry in the dictionary
        with this name.
        
        
        """
        pass
        
    
    def userInfo():
        """
        userInfo(self) -> str
        
        Return a string containing user specified information about the
        asset definition.
        
        
        """
        pass
        

def HDADefinition_swigregister():
    """None"""
    pass
    

class HDAModule(object):
    """
    hou.HDAModule
    
    User-defined Python module containing functions, classes, and constants
    that are stored with and accessed from a digital asset.
    
    In Python, a module lets you organize functions, classes, and constants
    into a common namespace. For example, os is a module and os.getcwd is a
    function inside that module, and you access the contents of a module by
    looking up Python attributes on it.
    
    An HDAModule is a Python module that is associated with a particular
    digital asset type. It lets you store a library of Python code in one
    location in your asset, and you can invoke that code from parameters,
    event handlers, and callbacks inside that asset.
    
    The module's source code is stored in the Python Module section of the
    Scripts tab in the Type Properties dialog. For example, suppose the
    digit asset is an object named gear and the Python Module section
    contains the following:
    
    > def position():
    >     return (hou.frame() * 1.2, 0.0, 3.2)
    >
    > def onButtonPress():
    >     print "you pressed the button"
    >
    > def onLoaded():
    >     print "onLoaded section running"
    
    Unlike regular Python modules, which you access by name, you access a
    digital asset's Python module by calling hou.NodeType.hdaModule on its
    node type. For example, suppose you created an object-level digital
    asset named gear and put the above code in its Python Module section.
    You could then access the contents of the Python module as follows:
    
    > >>> node_type = hou.nodeType(hou.objNodeTypeCategory(), "gear")
    > >>> node_type.hdaModule().position()
    > (1.2, 0.0, 3.2)
    > >>> node_type.hdaModule().onButtonPress()
    > you pressed the button
    
    One use for the Python module is drive parameter expressions on nodes
    inside the digital asset. For example, suppose /obj/gear1 is an instance
    of the digital asset and /obj/gear1/geo1 is a node inside the asset. You
    could put the following inside geo1's tx parameter expression:
    
    > hou.node("..").type().hdaModule().position()[0]
    
    For convenience, you can also access the module from a node instance of
    the digital asset using hou.Node.hdaModule. So, you could simplify the
    above expression to:
    
    > hou.node("..").hdaModule().position()[0]
    
    And since you don't need to use the hou. prefix inside expressions, you
    could further simplify it to:
    
    > node("..").hdaModule().position()[0]
    
    The following example shows how you might run code in the module from
    the Callback Script field of a button parameter:
    
    > hou.pwd().hdaModule().onButtonPress()
    
    In an event handler script, such as On Loaded, you can use the kwargs
    dict to access the node type:
    
    > kwargs["type"].hdaModule().onLoaded()
    
    Note that Houdini creates a local kwargs dict that's accessible from the
    Python Module, too. It contains one entry with the key "type", to give
    you access to the hou.NodeType defined by the digital asset.
    
    If you find that a digital asset has too much Python code to store in
    one module, it's possible to create submodules. For example, if you want
    to create a submodule named bar, put its source code in a new digital
    asset section (say, "bar_PythonModule"). Then, from the Python Module
    section, you can write the following:
    
    > import toolutils
    > bar = toolutils.createModuleFromSection("bar", kwargs["type"], "bar_PythonModule")
    
    bar now appears as a submodule of the main module. If, for example, the
    bar_PythonModule section contains:
    
    > def foo():
    >     return 3.2
    
    then you could write the following from a parameter on the digital asset
    node:
    
    > pwd().hdaModule().bar.foo()
    
    Note that the Python Module code is stored in a section of the digital
    asset named "PythonModule". For example, you can get a string containing
    that source code using
    node_type.definition().sections()["PythonModule"].contents().
    
    
    """
    
    def _reload():
        """None"""
        pass
        

def HDAModule_swigregister():
    """None"""
    pass
    

class HDAOptions(object):
    """
    hou.HDAOptions
    
    Stores miscellaneous options about a houdini digital asset (HDA).
    
    The contents of this object correspond to some of the checkboxes on the
    Basic tab of the Type Properties dialog. These values are stored in the
    TypePropertiesOptions section of a digital asset definition.
    
    Call hou.HDADefinition.options to get an HDAOptions instance. Note that
    an instance of this class is simply a data structure, and is not
    associated with an particular digital asset instance. In other words,
    changing the values inside this object will not change the digital
    asset. To save these values to the digital asset definition, call
    hou.HDADefinition.setOptions.
    
    > >>> node = hou.node("/obj/my_digital_asset1")
    > >>> definition = node.type().definition()
    > >>> print definition.sections()['TypePropertiesOptions'].contents()
    > ParmsFromVfl := 0;
    > PrefixDroppedParmName := 1;
    > UseDSParms := 1;
    > ForbidOutsideParms := 1;
    > LockContents := 1;
    > SaveSpareParms := 0; # <-- Currently 0
    > CheckExternal := 1;
    > GzipContents := 1;
    > MakeDefault := 1;
    > PrefixDroppedParmLabel := 1;
    > UnlockOnCreate := 0;
    >
    > >>> options = definition.options()
    > >>> options.saveSpareParms()
    > False
    > >>> options.setSaveSpareParms(True)
    > >>> definition.setOptions(options)
    > >>> print definition.sections()['TypePropertiesOptions'].contents()
    > ParmsFromVfl := 0;
    > PrefixDroppedParmName := 1;
    > UseDSParms := 1;
    > ForbidOutsideParms := 1;
    > LockContents := 1;
    > SaveSpareParms := 1; # <-- Now 1
    > CheckExternal := 1;
    > GzipContents := 1;
    > MakeDefault := 1;
    > PrefixDroppedParmLabel := 1;
    > UnlockOnCreate := 0;
    
    """
    
    def setSaveSpareParms(save_spare_parms):
        """
        setSaveSpareParms(self, save_spare_parms)
        
        Set the Save Spare Parameters option. See
        hou.HDAOptions.saveSpareParms for more information.
        
        
        """
        pass
        
    
    def setForbidOutsideParms(forbid_outside_parms):
        """
        setForbidOutsideParms(self, forbid_outside_parms)
        
        Sets the Forbid Linking Parameters from Outside this Subnet option.
        See hou.HDAOptions.forbidOutsideParms for more information.
        
        
        """
        pass
        
    
    def parametersFromVexCode():
        """
        parametersFromVexCode(self) -> bool
        
        Return whether the Get Properties from VEX Code option is on.
        
        When this option is set, most properties and parameters of the
        operator come from pragma statements in the VEX source code.
        
        
        """
        pass
        
    
    def setCompressionType():
        """None"""
        pass
        
    
    def forbidOutsideParms():
        """
        forbidOutsideParms(self) -> bool
        
        Return whether the Forbid Linking Parameters from Outside this
        Subnet option is set.
        
        When set, this option does not allow you to drag parameters from
        nodes outside the contents of the digital asset.
        
        
        """
        pass
        
    
    def checkForExternalLinks():
        """
        checkForExternalLinks(self) -> bool
        
        Return whether the Check for External Node References option is set.
        
        If set, this option changes all absolute node references inside the
        digital asset into relative references.
        
        
        """
        pass
        
    
    def setParametersFromVexCode(parameters_from_vex_code):
        """
        setParametersFromVexCode(self, parameters_from_vex_code)
        
        Sets the Get Properties from VEX Code option. See
        hou.HDAOptions.parametersFromVexCode for more information.
        
        
        """
        pass
        
    
    def setSaveCachedCode(save_cached_code):
        """
        setSaveCachedCode(self, save_cached_code)
        
        Set the Save Cached Code option. See hou.HDAOptions.saveCachedCode
        for more information.
        
        
        """
        pass
        
    
    def compressContents():
        """
        compressContents(self) -> bool
        
        Return whether the Compress Contents option is on.
        
        When this option is set, Houdini compresses the contents of the
        asset definition to reduce the size of the .hda file. Note that this
        option only as effect when the result of hou.HDAOptions.lockContents
        is True.
        
        
        """
        pass
        
    
    def saveSpareParms():
        """
        saveSpareParms(self) -> bool
        
        Return the Save Spare Parameters option.
        
        When set, this option will add code into the asset creation script
        to recreate the node's current spare parameters. New node instances
        of the digital asset will contain the same spare parameters as those
        on the representative node.
        
        
        """
        pass
        
    
    def setUnlockNewInstances(unlock_new_instances):
        """
        setUnlockNewInstances(self, unlock_new_instances)
        
        Sets the Unlock New Nodes on Creation option. See
        hou.HDAOptions.unlockNewInstances for more information.
        
        
        """
        pass
        
    
    def makeInitialParmsDefaults():
        """
        makeInitialParmsDefaults(self) -> bool
        
        Return whether the Save Defaults as Initial Parameters option is on.
        
        When set, this option uses the default values of the original
        parameters as the initial values for new nodes, instead of their
        current values.
        
        
        """
        pass
        
    
    def setCheckForExternalLinks(check_for_external_links):
        """
        setCheckForExternalLinks(self, check_for_external_links)
        
        Sets the Check for External Node References option. See
        hou.HDAOptions.checkForExternalLinks for more information.
        
        
        """
        pass
        
    
    def saveCachedCode():
        """
        saveCachedCode(self) -> bool
        
        Return the Save Cached Code option.
        
        When set, this option will save cached code for applicable
        definitions, such as digital assets defined by VOP networks that
        generate VEX code. With this option on, the compiled code will be
        saved to the HDA section(s) and will be used for shaders, etc,
        without the need to recompile the network. This can save significant
        amounts of time for complex shaders.
        
        
        """
        pass
        
    
    def setPrefixDroppedParmNames(prefix_dropped_parm_names):
        """
        setPrefixDroppedParmNames(self, prefix_dropped_parm_names)
        
        Sets the Prefix Dropped Parameter Names option. See
        hou.HDAOptions.prefixDroppedParmNames for more information.
        
        
        """
        pass
        
    
    def setSaveInitialParmsAndContents(save_initial_parms_and_contents):
        """
        setSaveInitialParmsAndContents(self, save_initial_parms_and_contents)
        
        Set the Save Initial Contents and Parameters option. See
        hou.HDAOptions.saveInitialParmsAndContents for more information.
        
        
        """
        pass
        
    
    def setPrefixDroppedParmLabels(prefix_dropped_parm_labels):
        """
        setPrefixDroppedParmLabels(self, prefix_dropped_parm_labels)
        
        Sets the Prefix Dropped Parameter Labels option. See
        hou.HDAOptions.prefixDroppedParmLabels for more information.
        
        
        """
        pass
        
    
    def setCompressContents(compress_contents):
        """
        setCompressContents(self, compress_contents)
        
        Sets the Compress Contents option. See
        hou.HDAOptions.compressContents for more information.
        
        
        """
        pass
        
    
    def prefixDroppedParmLabels():
        """None"""
        pass
        
    
    def lockContents():
        """
        lockContents(self) -> bool
        
        Return whether the Save Contents as Locked option is on.
        
        When this option is not set, Houdini will use a creation script to
        store the contents of the digital asset instead of storing the node
        data. A creation script cannot store extra data like locked SOPs,
        edit SOP information, paint SOP information, etc.
        
        If this option is not set, new instances of the digital asset will
        be locked, so the user can edit the contents. However, you probably
        do not ever want to turn this option off. Instead, if you want to
        lock new instances of the digital asset, see
        hou.HDAOptions.unlockNewInstances.
        
        
        """
        pass
        
    
    def compressionType():
        """None"""
        pass
        
    
    def unlockNewInstances():
        """
        unlockNewInstances(self) -> bool
        
        Return whether the Unlock New Nodes on Creation option is set.
        
        When this option is set, Houdini will unlock new instances of the
        digital asset when they are created. Note that this option only has
        effect when the result of hou.HDAOptions.lockContents is True.
        
        
        """
        pass
        
    
    def prefixDroppedParmNames():
        """
        prefixDroppedParmNames(self) -> bool
        
        Return whether the Prefix Dropped Parameter Names option is on.
        
        When this option is set, Houdini will not include a prefix on
        parameter names when you drag and drop parameters into the Existing
        Parameters areas of the Parameters tab of the Type Properties
        dialog.
        
        See also hou.HDAOptions.prefixDroppedParmLabels.
        
        
        """
        pass
        
    
    def setMakeInitialParmsDefaults(make_initial_parms_defaults):
        """
        setMakeInitialParmsDefaults(self, make_initial_parms_defaults)
        
        Sets the Save Defaults as Initial Parameters option. See
        hou.HDAOptions.makeInitialParmsDefaults for more information.
        
        
        """
        pass
        
    
    def saveInitialParmsAndContents():
        """
        saveInitialParmsAndContents(self) -> bool
        
        Return whether the Save Initial Contents and Parameters option is
        on.
        
        When this option is set, Houdini saves any parameter values and node
        contents referenced by the digital asset to be saved as part of the
        asset's definition.
        
        
        """
        pass
        
    
    def setLockContents(lock_contents):
        """
        setLockContents(self, lock_contents)
        
        Sets the Save Contents as Locked option. See
        hou.HDAOptions.lockContents for more information.
        
        
        """
        pass
        

def HDAOptions_swigregister():
    """None"""
    pass
    

class HDASection(object):
    """
    hou.HDASection
    
    Represents a "section" of data stored along with a digital asset.
    
    A digital asset stores its contents in a number of different pieces of
    data called sections. Each section is named and contains an arbitrarily
    sized piece of data, often textual. Each section is like a file embedded
    inside the definition, and Houdini uses specially named sections to
    store the node contents, list of parameters, etc. You can embed your own
    data into a digital asset by putting it inside a section.
    
    Any parameter in Houdini that references a file can also reference a
    section inside a digital asset. For example, if car is an object-level
    digital asset and the section is named "texture.jpg", you can reference
    that texture with opdef:/Object/car?texture.jpg. Note that hou.readFile
    also supports this opdef: syntax.
    
    By moving files into digital asset sections, you can build self-
    contained digital assets that can be distributed via a single hda file.
    
    Note that section names may contain '/'.
    
    
    """
    
    def name():
        """
        name(self) -> str
        
        Return the name of this section.
        
        Note that is is not possible to rename a section, but the following
        function will emulate renaming:
        
        > def renameSection(section):
        >     '''Rename a section by removing it and creating a new one.  Return the new section.'''
        >     new_section = section.definition().addSection(new_name, section.contents())
        >     section.destroy()
        >     return new_section
        
        """
        pass
        
    
    def modificationTime():
        """
        modificationTime(self) -> int
        
        Return the time when the section was last modified. This time is
        returned as a POSIX timestamp, such as is returned by time.time().
        
        > >>> hou.nodeType(hou.cop2NodeTypeCategory(), "colorwheel").definition()
        > <hou.HDADefinition of Cop2 colorwheel in /opt/hfs9.5/houdini/hda/OPlibCop2.hda>
        > >>> definition = hou.nodeType(hou.cop2NodeTypeCategory(), "colorwheel").definition()
        > >>> definition.sections().keys()
        > ['VflCode', 'DialogScript', 'VexCode']
        > >>> section = definition.sections()['VflCode']
        > >>> section.modificationTime()
        > 1177535169
        > >>> import datetime, time
        > >>> datetime.datetime.fromtimestamp(section.modificationTime())
        > datetime.datetime(2007, 4, 25, 17, 6, 9)
        > >>> time.ctime(section.modificationTime())
        > 'Wed Apr 25 17:06:09 2007'
        
        """
        pass
        
    
    def contents(compressionType=hou.compressionType.NoCompression):
        """
        contents(self, compressionType=hou.compressionType.NoCompression) -> str
        
        Return a string containing the contents of this section.
        
        You can optionally specify a compression type, hou.compressionType,
        to decompress the contents.
        
        Raises hou.OperationFailed if a compression type is specified and
        the contents are not compressed by that type.
        
        > def saveSectionToFile(section, file_name):
        >     '''Given a section, save it to a file.'''
        >     section_file = file(file_name, "w")
        >     section_file.write(section.contents())
        >     section_file.close()
        
        """
        pass
        
    
    def size():
        """
        size(self) -> int
        
        Return the number of bytes in the contents. This method is a
        shortcut for len(self.contents()).
        
        
        """
        pass
        
    
    def definition():
        """
        definition(self) -> hou.HDADefinition
        
        Return the digital asset definition containing this section.
        
        
        """
        pass
        
    
    def destroy():
        """
        destroy(self)
        
        Remove this section from the HDA definition. You can also remove a
        section with hou.HDADefinition.removeSection, and this method is
        equivalent to self.definition().removeSection(self.name()).
        
        Only remove sections that you explicitly added. Do not remove the
        special sections that Houdini uses to store the contents of the
        digital asset definition, or Houdini will generate errors or strange
        side effects.
        
        To add a section, use hou.HDADefinition.addSection.
        
        
        """
        pass
        
    
    def setContents(contents, compressionType=hou.compressionType.NoCompression):
        """
        setContents(self, contents,
        compressionType=hou.compressionType.NoCompression)
        
        Set the contents of this section to the given string. A section may
        contain binary information, like bgeo files, images, etc.
        
        You can optionally specify a compression type, hou.compressionType,
        to compress the contents. Note that you must specify the same
        compression type when reading the contents back to decompress them.
        
        See hou.HDADefinition.addSection for an example of how to create a
        section from a file on disk.
        
        
        """
        pass
        

def HDASection_swigregister():
    """None"""
    pass
    

class Handle(object):
    """
    hou.Handle
    
    Gives access to an handle bound to a viewer state.
    
    OVERVIEW
    
    The Handle class lets you manipulate handles bound to viewer states.
    
    
    """
    
    def show():
        """None"""
        pass
        
    
    def update():
        """
        update(self)
        
        This method forces the handle to update. Useful if a change made to
        a viewer state requires one of its handle to get updated. For
        dynamic handles, this will trigger a call to the onStateToHandle
        callback, allowing the viewer state to update the proper handle
        parameter(s).
        
        
        """
        pass
        
    
    def visible():
        """
        visible(self): -> bool
        
        Returns True if the handle is visible, False otherwise.
        
        
        """
        pass
        
    
    def type():
        """
        type(self): -> string
        
        Returns the type name of the handle. The return value corresponds to
        the type used for binding the handle. See
        hou.ViewerStateTemplate.bindHandle or
        hou.ViewerStateTemplate.bindStaticHandle for details.
        
        
        """
        pass
        
    
    def name():
        """
        name(self): -> string
        
        The name of this handle.
        
        
        """
        pass
        

def Handle_swigregister():
    """None"""
    pass
    

class HelpBrowser(PaneTab):
    """
    hou.HelpBrowser
    
    Class representing a help browser pane tab. Provides methods for
    controlling the help browser.
    
    REPLACES
    
    * helpbrowser
    
    
    """
    
    def displayHelp(node_type):
        """
        displayHelp(self, node_type)
        
        Loads the help for the specified node type.
        
        Raises HOM_ObjectWasDeleted if the help browser pane tab was
        deleted.
        
        
        """
        pass
        
    
    def displayHelpPath(help_path):
        """
        displayHelpPath(self, help_path)
        
        Loads the help for the specified help path. The path can either be a
        Houdini help URL (i.e. op:Sop/copy, tool:curve) or a raw help path
        (i.e. /nodes/sop/copy, shelf/curve).
        
        
        """
        pass
        
    
    def displayHelpPyPanel(interface_name):
        """
        displayHelpPyPanel(self, interface_name)
        
        Loads the help for the python panel with the specified name.
        
        Raises HOM_Error if the interface name is invalid.
        
        
        """
        pass
        
    
    def url():
        """
        url(self) -> str
        
        Return the current URL of this help browser.
        
        Raises HOM_ObjectWasDeleted if the help browser pane tab was
        deleted.
        
        
        """
        pass
        
    
    def setUrl(url):
        """
        setUrl(self, url)
        
        Loads the specified URL.
        
        Raises HOM_ObjectWasDeleted if the help browser pane tab was
        deleted, and raises HOM_Error if url is not given.
        
        
        """
        pass
        
    
    def showUI(show):
        """
        showUI(self, show)
        
        Shows or hides the help browser's navigation controls.
        
        Raises HOM_ObjectWasDeleted if the help browser pane tab was
        deleted.
        
        
        """
        pass
        
    
    def homePage():
        """
        homePage(self) -> str
        
        Returns the home page URL of this help browser.
        
        Raises HOM_ObjectWasDeleted if the help browser pane tab was
        deleted.
        
        
        """
        pass
        
    
    def setHomePage(home_page):
        """
        setHomePage(self, home_page)
        
        Sets the home page for this help browser to the specified URL.
        
        Raises HOM_ObjectWasDeleted if the help browser pane tab was
        deleted, and raises HOM_Error if home_page is not given.
        
        
        """
        pass
        

def HelpBrowser_swigregister():
    """None"""
    pass
    

class IPRViewer(PaneTab):
    """
    hou.IPRViewer
    
    An interactive preview render (IPR) window.
    
    The IPR viewer progressively refines a render, first providing a rough
    view of the rendered image and eventually providing the fully rendered
    image. When you change a shader value, move an object, etc., the viewer
    will re-render the image.
    
    When you Ctrl+click on a pixel in the rendered image, Houdini searches
    $HOUDINI_PATH for scripts/ipr/pickpixel.py and runs it. The version of
    this file that ships with Houdini pops up the shader contributing the
    pixel, or an information window if there is is no shader. If Houdini
    cannot find that Python file it then looks for the Hscript file
    scripts/ipr/pickpixel.cmd.
    
    When you drag a SHOP node onto the rendered image, Houdini searches for
    and runs scripts/ipr/dragdrop.py. By default, this script assigns the
    SHOP to the object contributing the pixel. If it cannot find a Python
    version, Houdini then looks for scripts/ipr/dragdrop.cmd.
    
    Note that shelf scripts can access the last location the user clicked on
    with hou.IPRViewer.lastClickLocation.
    
    
    """
    
    def cropRegion():
        """
        cropRegion(self) -> (float, float, float, float)
        
        Return the x0, x1, y0, and y1 normalized coordinates of the
        subregion that is selected, where (x0, y0) is the bottom-left corner
        and (x1, y1) is the top-right corner of the subregion.
        
        You can optionally tell the IPR viewer to only re-render only a
        portion of the image. To select a subportion of the image, hold down
        shift and select the box.
        
        Note that the bottom-left corner is (0.0, 0.0) and the top-right
        corner is (1.0, 1.0). For example, if the entire image is being
        rendered, this method returns (0.0, 1.0, 0.0, 1.0).
        
        
        """
        pass
        
    
    def updateTime():
        """
        updateTime(self) -> float
        
        Return the contents of the viewer's Update Time field. This value
        determines approximately how long each progressive refinement should
        take. Smaller values will produce more progressive renders where
        detail is added more gradually.
        
        See also hou.IPRViewer.setUpdateTime and hou.IPRViewer.delay.
        
        
        """
        pass
        
    
    def saveFrame(file_path, snapshot=0, xres=-1, yres=-1, color='C', alpha='C', scope='*', lut='', gamma=1.0, convert=True):
        """
        saveFrame(self, file_path, snapshot=0, xres=-1, yres=-1, color='C',
        alpha='C', scope='*', lut='', gamma=1.0, convert=True) -> bool
        
        Saves the current IPR render to the specified file path. It is
        possible to save an in progress/incomplete render.
        
        The output image type is inferred from the file extension on the
        provided file path. The snapshot parameter controls which IPR
        snapshot to save. A value of 0 indicates the active render.
        
        The native IPR resolution is used by default, however a custom
        resolution can be specified with the xres and yres parameters. The
        color and alpha parameters control which render planes are used when
        writing RGBA images like .jpg or .png. If a deep image format such
        as .pic or .exr is used, the scope parameter can be used to specify
        which image planes to include in the output.
        
        
        """
        pass
        
    
    def lastClickLocation():
        """
        lastClickLocation(self) -> (int, int)
        
        Return the x and y coordinates for the pixel location where the user
        last clicked in the IPR viewer. Note that this location might be
        outside the image: the x and y coordinates can be negative and can
        be greater than or equal to the image resolution. Note that if the
        user never clicked in the viewer, the x and y coordinates will be
        negative.
        
        You would typically call this method from a shelf script. For
        example, a user can click on a pixel in the IPR viewer and then
        click on the shelf to perform an action on that pixel (e.g. display
        the shader parameters, assign a shader, etc.).
        
        Use hou.IPRViewer.imageResolution to get the valid range for pixel
        coordinates.
        
        Note that when you Ctrl-click on a pixel, Houdini searches
        $HOUDINI_PATH for scripts/ipr/pickpixel.py and runs it. This script
        can access the viewer with kwargs["viewer"] and the location where
        the user clicked with kwargs["position"].
        
        The following script opens a floating parameter window for the
        shader corresponding to the pixel the user last clicked on.
        
        > viewer = hou.ui.paneTabOfType(hou.paneTabType.IPRViewer)
        > px, py = viewer.lastClickLocation()
        >
        > if (px < 0 or px > viewer.imageResolution()[0] or
        >         py < 0 or py >= viewer.imageResolution()[1]):
        >     hou.ui.displayMessage("Click on the image and then run this script again")
        > else:
        >     material = viewer.materialNode(px, py)
        >
        >     if material is not None:
        >         parm_window = hou.ui.curDesktop().createFloatingPaneTab(
        >             hou.paneTabType.Parm)
        >         parm_window.setCurrentNode(material)
        >         parm_window.setPin(True)
        >     else:
        >         hou.ui.displayMessage("Click on an object to bring up the shader.")
        
        """
        pass
        
    
    def setPreview(on):
        """
        setPreview(self, on)
        
        Check or uncheck the Preview checkbox.
        
        See hou.IPRViewer.isPreviewOn for more information.
        
        
        """
        pass
        
    
    def prim(x, y):
        """
        prim(self, x, y) -> hou.Prim or None
        
        Return the geometry primitive contributing the pixel at the
        specified location, or None if there is nothing at the pixel or if
        the pixel location is outside the image bounds
        
        Raises hou.OperationFailed if the viewer does not contain an image.
        
        
        """
        pass
        
    
    def autoSaveTime():
        """
        autoSaveTime(self) -> float
        
        Returns the time between IPR auto saves in seconds. When auto saving
        is on, a render progress image is written out at this rate.
        
        See also hou.IPRViewer.setAutoSaveTime.
        
        
        """
        pass
        
    
    def startRender():
        """
        startRender(self)
        
        Start a new render if there is no active IPR session or issue a re-
        render if there is one.
        
        
        """
        pass
        
    
    def setAutoSavePath(path):
        """
        setAutoSavePath(self, path)
        
        Sets the render progress save path.
        
        See also hou.IPRViewer.autoSavePath for more information.
        
        
        """
        pass
        
    
    def setUpdateTime(time):
        """
        setUpdateTime(self, time)
        
        Set the contents of the viewer's Update Time field.
        
        See hou.IPRViewer.updateTime for more information.
        
        
        """
        pass
        
    
    def pauseRender():
        """
        pauseRender(self)
        
        Pauses the active IPR session (if there is one).
        
        
        """
        pass
        
    
    def isRendering():
        """
        isRendering(self) -> bool
        
        Indicates whether the IPR session has an render in progress. Returns
        True even if the render is paused.
        
        
        """
        pass
        
    
    def setDelay(time):
        """
        setDelay(self, time)
        
        Set the contents of the viewer's Delay field.
        
        See hou.IPRViewer.delay for more information.
        
        
        """
        pass
        
    
    def delay():
        """
        delay(self) -> float
        
        Return the contents of the viewer's Delay field. This value
        determines how long Houdini waits between when you change a
        parameter value and when it starts re-rendering.
        
        See also hou.IPRViewer.setDelay and hou.IPRViewer.updateTime.
        
        
        """
        pass
        
    
    def resumeRender():
        """
        resumeRender(self)
        
        Resumes the active IPR session (if there is one).
        
        
        """
        pass
        
    
    def planes():
        """
        planes(self) -> tuple of str
        
        Return the names of the image planes in the rendered output.
        
        Note that the special Op_Id image plane contains the
        hou.Node.sessionId ids of the object nodes in the image. -1
        indicates that there is no object node associated with the pixel.
        Use hou.IPRViewer.objectNode to access the object corresponding to
        that id.
        
        Similarly, the Prim_Id plane contains the hou.Prim.number ids of the
        primitives in the image. Use hou.IPRViewer.prim to access the
        primitive corresponding to that id.
        
        Raises hou.OperationFailed if the viewer does not contain an image.
        
        
        """
        pass
        
    
    def ropNode():
        """
        ropNode(self) -> hou.RopNode or None
        
        Return the ROP node that is selected in the viewer, or None if
        nothing is selected.
        
        
        """
        pass
        
    
    def killRender():
        """
        killRender(self)
        
        Kills the active IPR session (if there is one).
        
        
        """
        pass
        
    
    def displayedPlane():
        """
        displayedPlane(self) -> str
        
        Return the name of the currently-displayed image plane in the
        rendered output.
        
        Note that the special Op_Id image plane contains the
        hou.Node.sessionId ids of the object nodes in the image. -1
        indicates that there is no object node associated with the pixel.
        Use hou.IPRViewer.objectNode to access the object corresponding to
        that id.
        
        Similarly, the Prim_Id plane contains the hou.Prim.number ids of the
        primitives in the image. Use hou.IPRViewer.prim to access the
        primitive corresponding to that id.
        
        Raises hou.OperationFailed if the viewer does not contain an image.
        
        
        """
        pass
        
    
    def autoSavePath():
        """
        autoSavePath(self) -> str
        
        Returns the render save path. This is the path that is used when the
        IPR viewer is set to automatically save render progress to disk.
        
        See also hou.IPRViewer.setSavePath.
        
        
        """
        pass
        
    
    def isPreviewOn():
        """
        isPreviewOn(self) -> bool
        
        Return whether or not the Preview checkbox is checked. When it is
        unchecked, the viewer will not progressively refine the image using
        IPR, and will instead use the rendering engine from the ROP node to
        render it.
        
        See also hou.IPRViewer.setPreview.
        
        
        """
        pass
        
    
    def setAutoSave(on):
        """
        setAutoSave(self, on)
        
        Set or unset the Auto Save toggle.
        
        See hou.IPRViewer.isAutoSaveOn for more information.
        
        
        """
        pass
        
    
    def isAutoSaveOn():
        """
        isAutoSaveOn(self) -> bool
        
        Returns whether or not the Auto Save toggle is selected. When turned
        on, IPR will periodically save the render progress to the auto save
        file path. The time between saves can be configured by setting the
        auto save time.
        
        See also hou.IPRViewer.setAutoSave.
        
        
        """
        pass
        
    
    def setRopNode(rop_node):
        """
        setRopNode(self, rop_node)
        
        Set the ROP node to use for rendering.
        
        
        """
        pass
        
    
    def pixels(plane_name):
        """
        pixels(self, plane_name) -> tuple of tuple of float
        
        Returns the value of all pixels in one plane of the image. This
        method returns a tuple of tuples of 1 to 4 floats, depending on the
        type of image plane. The results are in row-major order, starting at
        the bottom left corner of the IPR image.
        
        Note that the color plane is named C.
        
        Raises hou.OperationFailed if the plane name is invalid or the
        viewer does not contain an image.
        
        > >>> all_pixels = viewer.pixels("C")
        > >>> width = viewer.imageResolution()[0]
        > >>> all_pixels[width*200 + 300]
        > (0.69970703125, 0.46728515625, 0.289794921875, 1.0)
        
        """
        pass
        
    
    def isActive():
        """
        isActive(self) -> bool
        
        Indicates whether an active IPR sessions exists.
        
        
        """
        pass
        
    
    def setAutoUpdate(on):
        """
        setAutoUpdate(self, on)
        
        Check or uncheck the Auto-Update checkbox.
        
        See hou.IPRViewer.isAutoUpdateOn for more information.
        
        
        """
        pass
        
    
    def imageResolution():
        """
        imageResolution(self) -> (int, int)
        
        Return the resolution of the image.
        
        Raises hou.OperationFailed if the viewer does not contain an image.
        
        
        """
        pass
        
    
    def objectNode(x, y):
        """
        objectNode(self, x, y) -> hou.ObjNode or None
        
        Return the object node contributing the pixel at the specified
        location, or None if there is no object at the pixel or if the pixel
        location is outside the image bounds
        
        The following function returns the SOP node containing the geometry
        that contributes the pixel to the final image:
        
        > def sopNode(viewer, x, y):
        >     obj_node = viewer.objectNode(x, y)
        >     return (obj_node.renderNode() if obj_node is not None else None)
        
        Raises hou.OperationFailed if the viewer does not contain an image.
        
        
        """
        pass
        
    
    def pixel(plane_name, x, y):
        """
        pixel(self, plane_name, x, y) -> tuple of float
        
        Return the value of a pixel in one plane of the image. This method
        returns a tuple of 1 to 4 floats, depending on the type of image
        plane.
        
        Note that the color plane is named C.
        
        Raises hou.OperationFailed if the plane name is invalid, the pixel
        location is outside the image, or the viewer does not contain an
        image.
        
        You can determine the number of components in the image plane using
        the following: len(viewer.pixel(plane_name, 0, 0)).
        
        > >>> viewer.pixel("C", 300, 200)
        > (0.69970703125, 0.46728515625, 0.289794921875, 1.0)
        
        """
        pass
        
    
    def evaluatedStyleSheetPaths(x, y):
        """
        evaluatedStyleSheetPaths(self, x, y) -> tuple of str
        
        Returns a list of paths to the styles that contribute to the style
        sheet at the current pixel.
        
        
        """
        pass
        
    
    def isAutoUpdateOn():
        """
        isAutoUpdateOn(self) -> bool
        
        Return whether or not the Auto-Update checkbox is checked. When it
        is unchecked, the viewer will not refresh when objects, shaders,
        lights, etc. change. In this case, you can force a re-render by
        clicking on the Render button.
        
        See also hou.IPRViewer.setAutoUpdate.
        
        
        """
        pass
        
    
    def isPaused():
        """
        isPaused(self) -> bool
        
        Indicates whether the IPR session is paused. If there is no active
        session, this returns false.
        
        
        """
        pass
        
    
    def materialNode(x, y):
        """
        materialNode(self, x, y) -> hou.ShopNode or None
        
        Return the SHOP node contributing the pixel at the specified
        location, or None if there is nothing at the pixel, the pixel
        location is outside the image bounds, or there is no shader on the
        geometry.
        
        This method first checks the primitive corresponding to the pixel
        and returns the SHOP corresponding to its shop_materialpath
        attribute. If the primitive does not have this attribute then it
        returns the SHOP assigned to the object. If no SHOP is assigned to
        the object, it returns None.
        
        Raises hou.OperationFailed if the viewer does not contain an image.
        
        
        """
        pass
        
    
    def setAutoSaveTime(float):
        """
        setAutoSaveTime(self, float)
        
        Sets the auto save time in seconds.
        
        See also hou.IPRViewer.autoSaveTime for more information.
        
        
        """
        pass
        
    
    def evaluatedStyleSheetJSON(x, y):
        """
        evaluatedStyleSheetJSON(self, x, y) -> str
        
        Returns a JSON string describing the material style sheet at a given
        pixel. If no style sheet is active, an empty string is returned.
        
        
        """
        pass
        

def IPRViewer_swigregister():
    """None"""
    pass
    

class IndexPairPropertyTable(object):
    """
    hou.IndexPairPropertyTable
    
    Describes properties of an index pair attribute.
    
    
    """
    
    def propertyNames():
        """
        propertyNames(self) -> tuple of string
        
        Return a list of all property names.
        
        
        """
        pass
        
    
    def intListPropertyValueAtIndex(property_name, row):
        """
        intListPropertyValueAtIndex(self, property_name, row) -> tuple of int
        
        Return a list of property values for a particular integer property.
        
        Raises hou.OperationFailed if no property exists with this name.
        
        
        """
        pass
        
    
    def floatPropertyValueAtIndex(property_name, row):
        """
        floatPropertyValueAtIndex(self, property_name, row) -> float
        
        Return the property value for a particular floating point property.
        
        Raises hou.OperationFailed if no property exists with this name or
        the property is not float of size 1.
        
        
        """
        pass
        
    
    def intPropertyValueAtIndex(property_name, row):
        """
        intPropertyValueAtIndex(self, property_name, row) -> int
        
        Return the property value for a particular integer property.
        
        Raises hou.OperationFailed if no property exists with this name or
        the property is not integer of size 1.
        
        
        """
        pass
        
    
    def numIndices():
        """None"""
        pass
        
    
    def floatListPropertyValueAtIndex(property_name, row):
        """
        floatListPropertyValueAtIndex(self, property_name, row) -> tuple of
        float
        
        Return a list of property values for a particular floating point
        property.
        
        Raises hou.OperationFailed if no property exists with this name.
        
        
        """
        pass
        
    
    def stringPropertyValueAtIndex(property_name, row):
        """
        stringPropertyValueAtIndex(self, property_name, row) -> string
        
        Return the property value for a particular string property.
        
        Raises hou.OperationFailed if no property exists with this name or
        the property is not string of size 1.
        
        
        """
        pass
        
    
    def propertySize(property_name):
        """
        propertySize(self, property_name) -> int
        
        Return the number of data components in the property value.
        
        
        """
        pass
        
    
    def attrib():
        """
        attrib(self) -> hou.Attrib
        
        Return the parent index pair attribute.
        
        
        """
        pass
        
    
    def propertyDataType(property_name):
        """
        propertyDataType(self, property_name) -> hou.attribData enum value
        
        Return the property's data type (int, float or string).
        
        
        """
        pass
        
    
    def stringListPropertyValueAtIndex(property_name, row):
        """
        stringListPropertyValueAtIndex(self, property_name, row) -> tuple of
        string
        
        Return a list of property values for a particular string property.
        
        Raises hou.OperationFailed if no property exists with this name.
        
        
        """
        pass
        

def IndexPairPropertyTable_swigregister():
    """None"""
    pass
    

class IndirectInput(NetworkMovableItem):
    """
    hou.IndirectInput
    
    An abstract base class for a network item that can be used as an input
    to nodes in the same network, but which is not a node itself.
    
    There are two specific forms of an indirect input. The
    hou.SubnetIndirectInput provides a way to connect nodes outside a sub-
    network to nodes inside the sub-network. The hou.NetworkDot allows
    connections to be routed through a network along any path.
    
    
    """
    
    def outputs():
        """None"""
        pass
        
    
    def useColorFromOutput():
        """None"""
        pass
        
    
    def inputOutputIndex():
        """None"""
        pass
        
    
    def setColorDefault():
        """None"""
        pass
        
    
    def inputItem():
        """
        inputItem(self) -> hou.NetworkMovableItem
        
        Returns the item connected directly to the input side of this
        indirect input. This may be a node, indirect input, or None if
        nothing is connected. Note that the returned item may not be inside
        the same parent network as this object if it is a
        hou.SubnetIndirectInput.
        
        
        """
        pass
        
    
    def outputConnections():
        """None"""
        pass
        
    
    def setSymbolicColorName():
        """None"""
        pass
        
    
    def setUseColorFromOutput():
        """None"""
        pass
        
    
    def symbolicColorName():
        """None"""
        pass
        
    
    def input():
        """None"""
        pass
        
    
    def inputItemOutputIndex():
        """
        inputItemOutputIndex(self) -> int
        
        Returns the index of the output connection on the network item
        connected directly to the input side of this object. Returns 0 if
        nothing is connected. This value will only be non-zero if a hou.Node
        is connected to this object since all other network items only has a
        single output connector.
        
        
        """
        pass
        

def IndirectInput_swigregister():
    """None"""
    pass
    

class InitScriptFailed(Error):
    """
    hou.InitScriptFailed
    
    """
    
    def description():
        """
        description(self) -> str
        
        Return a description of the class of exception. The description is
        not related to the exception instance.
        
        
        """
        pass
        
    
    def exceptionTypeName():
        """
        exceptionTypeName(self) -> str
        
        Return the name of the exception type. Instances of different
        subclasses of hou.Error will return different names. Instances of
        the base class will return "Error".
        
        You can also use str(e.__class__) to get the name of the subclass.
        
        
        """
        pass
        

def InitScriptFailed_swigregister():
    """None"""
    pass
    

class IntParmTemplate(ParmTemplate):
    """
    hou.IntParmTemplate
    
    Describes a parameter tuple containing integer values.
    
    Note that integer parameters may also be menu parameters. Integer
    parameters with menus are conceptually the same as parameters derived
    from hou.MenuParmTemplate.
    
    
    """
    
    def setDefaultExpression(tuple_of_default_expressions):
        """
        setDefaultExpression(self, tuple_of_default_expressions)
        
        Set the default expression for new parameter instances to a sequence
        of strings.
        
        See the hou.IntParmTemplate.defaultExpression method for more
        information. Note that if the number of strings in the sequence is
        different from the number of components in the parm template, any
        extra values will be discarded and any missing expressions will
        become the empty string.
        
        
        """
        pass
        
    
    def menuItems():
        """
        menuItems(self) -> tuple of str
        
        Return the tuple of internal menu names. If this integer does not
        use a menu, returns an empty tuple.
        
        These internal menu names are not displayed in the UI, but they can
        be passed to hou.Parm.set.
        
        
        """
        pass
        
    
    def setDefaultExpressionLanguage(tuple_of_default_expression_languages):
        """
        setDefaultExpressionLanguage(self,
        tuple_of_default_expression_languages)
        
        Set the default expression language for new parameter instances to a
        sequence of hou.scriptLanguage values.
        
        See the defaultExpressionLanguage method for more information. Note
        that if the number of hou.scriptLanguage values in the sequence is
        different from the number of components in the parm template, any
        extra values will be discarded and any missing expression languages
        will become hou.scriptLanguage.Hscript.
        
        
        """
        pass
        
    
    def setItemGeneratorScriptLanguage(language):
        """
        setItemGeneratorScriptLanguage(self, language)
        
        Set the script language used to generate menu items to a
        hou.scriptLanguage enum value.
        
        See the itemGeneratorScriptLanguage method for more information.
        
        
        """
        pass
        
    
    def minValue():
        """
        minValue(self) -> int
        
        Return the minimum value of the parameter.
        
        See also the minIsStrict method.
        
        
        """
        pass
        
    
    def menuLabels():
        """
        menuLabels(self) -> tuple of str
        
        Return the tuple of menu labels displayed in the UI.
        
        
        """
        pass
        
    
    def setMinIsStrict(on):
        """
        setMinIsStrict(self, on)
        
        Set whether the minimum value is strictly enforced.
        
        See the minIsStrict method for more information.
        
        
        """
        pass
        
    
    def defaultValue():
        """
        defaultValue(self) -> tuple of int
        
        Return the default value for new parameter instances.
        
        For example, suppose this parm template is named "divisions", the
        naming scheme is XYZW, it has 3 components, and the default value is
        (10, 20, 30). The corresponding parm tuple instance on a node would
        be named "divisions" and would contain parameters "divisionsx",
        "divisionsy", and "divisionsz". When the node is created,
        "divisionsx" would be 10, "divisionsy" would be 20, and "divisionsz"
        would be 30.
        
        
        """
        pass
        
    
    def setItemGeneratorScript(item_generator_script):
        """
        setItemGeneratorScript(self, item_generator_script)
        
        Set the script used to generate menu items.
        
        See the itemGeneratorScript method for more information.
        
        
        """
        pass
        
    
    def setMinValue(min_value):
        """
        setMinValue(self, min_value)
        
        Set the minimum value of the parameter.
        
        See the minValue method for more information.
        
        
        """
        pass
        
    
    def defaultExpressionLanguage():
        """
        defaultExpressionLanguage(self) -> tuple of hou.scriptLanguage
        
        Return the default expression language for new parameter instances.
        
        The default expression language only applies if the default
        expression is set. If the default expression of a component is not
        set, then the expression language is set to
        hou.scriptLanguage.Hscript.
        
        
        """
        pass
        
    
    def setMenuItems(menu_items):
        """
        setMenuItems(self, menu_items)
        
        Set the internal menu names to the given sequence of strings.
        
        See the menuItems method for more information.
        
        If the new number of menu items is less than the old number, the
        menu labels will be shortened and the default value will be modified
        if it is out of range.
        
        
        """
        pass
        
    
    def iconNames():
        """
        iconNames(self) -> tuple of str
        
        Return the tuple of icons corresponding to the menu items. If there
        are no icons, returns a tuple of empty strings.
        
        These icons are used when this parm template uses a menu.
        
        
        """
        pass
        
    
    def setMenuLabels():
        """None"""
        pass
        
    
    def minIsStrict():
        """
        minIsStrict(self) -> bool
        
        Returns whether the minimum value is strictly enforced.
        
        If a minimum value is not strictly enforced, the slider will not let
        you change the value below the minimum, but you can set the value to
        be lower than the minimum by typing it in, changing it via
        hou.Parm.setValue, or using the ladder handle.
        
        If it is strictly enforced and you try to change it below the
        minimum value using any mechanism, Houdini will set it to the
        minimum value.
        
        See also the minValue method.
        
        
        """
        pass
        
    
    def setMenuUseToken(on):
        """
        setMenuUseToken(self, on)
        
        Set whether the parameter is set to the token value instead of the
        index.
        
        See also the menuUseToken method.
        
        
        """
        pass
        
    
    def setDefaultValue(tuple_of_default_values):
        """
        setDefaultValue(self, tuple_of_default_values)
        
        Set the default value for new parameter instances to a sequence of
        ints.
        
        See the defaultValue method for more information. Note that if the
        number of ints in the sequence is different from the number of
        components in the parm template, any extra values will be discarded
        and any missing values will become zeros.
        
        
        """
        pass
        
    
    def maxValue():
        """
        maxValue(self) -> int
        
        Return the minimum value of the parameter.
        
        See also the minIsStrict method.
        
        
        """
        pass
        
    
    def itemGeneratorScript():
        """
        itemGeneratorScriptLanguage(self) -> hou.scriptLanguage enum value
        
        Return the script used to generate menu items, or an empty string if
        there is no such script.
        
        
        """
        pass
        
    
    def setIconNames(icon_names):
        """
        setIconNames(self, icon_names)
        
        Set the icon names to the given sequence of strings.
        
        
        """
        pass
        
    
    def setMenuType(menu_type):
        """
        setMenuType(self, menu_type)
        
        Set the type of menu to a hou.menuType enum value.
        
        See the menuType method for more information.
        
        
        """
        pass
        
    
    def setMaxIsStrict(on):
        """
        setMaxIsStrict(self, on)
        
        Set whether the maximum value is strictly enforced.
        
        See the maxIsStrict method for more information.
        
        
        """
        pass
        
    
    def defaultExpression():
        """
        defaultExpression(self) -> tuple of strings
        
        Return the default expression for new parameter instances.
        
        The default expression takes precedence over the default value. If a
        component has no default expression (i.e. an empty string), then the
        default value is used for new parameter instances.
        
        Note that the default expression language is needed to interpret the
        meaning of the default expression.
        
        For example, suppose this parm template is named "divisions", the
        naming scheme is XYZW, it has 3 components, the default value is
        (10, 20, 30), the default expression is ("$F", "hou.frame()", "")
        and the default expression language is (hou.scriptLanguage.Hscript,
        hou.scriptLanguage.Python, hou.scriptLanguage.Hscript). Then the
        corresponding parm tuple instance on a node would be named
        "divisions" and would contain parameters "divisionsx", "divisionsy",
        "divisionsz". When the node is created, "divisionsx" would have a
        default Hscript expression of "$F", "divisionsy" would have a
        default Python expression of "hou.frame()", and "divisionsz" would
        have a default value of 30.
        
        
        """
        pass
        
    
    def menuUseToken():
        """
        menuUseToken(self) -> bool
        
        Return whether the parameter is set to the token value instead of
        the index.
        
        See also the setMenuUseToken method.
        
        
        """
        pass
        
    
    def itemGeneratorScriptLanguage():
        """None"""
        pass
        
    
    def setMaxValue(max_value):
        """
        setMaxValue(self, max_value)
        
        Set the maximum value of the parameter.
        
        See the maxValue method for more information.
        
        
        """
        pass
        
    
    def menuType():
        """
        menuType(self) -> hou.menuType enum value
        
        Return the type of menu. See hou.menuType for more information.
        
        
        """
        pass
        
    
    def maxIsStrict():
        """
        maxIsStrict(self) -> bool
        
        Return whether the maximum value is strictly enforced.
        
        See the minIsStrict method for more information.
        
        
        """
        pass
        

def IntParmTemplate_swigregister():
    """None"""
    pass
    

class InterruptableOperation(object):
    """
    hou.InterruptableOperation
    
    Use this class to turn any Python code block into an interruptable
    operation.
    
    
    """
    
    def updateProgress(percentage=-1.0):
        """
        updateProgress(self, percentage=-1.0)
        
        Update the progress percentage of the operation. At the same time,
        check if the operation was interrupted by the user.
        
        
        percentage
        A fractional number between 0.0 and 1.0. A value of 0.0 means
        that no progress has been made while 1.0 means that the
        operation is complete. A negative percentage indicates that the
        progress percentage is not available.
        
        Raises hou.OperationInterrupted if the user has chosen to interrupt
        the operation.
        
        Raises hou.OperationFailed if the interruptable operation object was
        constructed outside of a with statement.
        
        
        """
        pass
        
    
    def updateLongProgress(percentage=-1.0, long_op_status=None):
        """
        updateLongProgress(self, percentage=-1.0, long_op_status=None)
        
        Update the progress percentage and status of the long, or high-
        level, operation. At the same time, check if the operation was
        interrupted by the user.
        
        
        percentage
        A fractional number between 0.0 and 1.0. A value of 0.0 means
        that no progress has been made while 1.0 means that the
        operation is complete. A negative percentage indicates that the
        progress percentage is not available.
        
        long_op_status
        Text describing the current status of the long operation. The
        status will overwrite the text in the 2nd progress bar of the
        interrupt dialog. To keep the previous text in the progress bar,
        set this parameter to None.
        
        Raises hou.OperationInterrupted if the user has chosen to interrupt
        the operation.
        
        Raises hou.OperationFailed if the interruptable operation object was
        constructed outside of a with statement.
        
        
        """
        pass
        

def InterruptableOperation_swigregister():
    """None"""
    pass
    

class InvalidInput(Error):
    """
    hou.InvalidInput
    
    Exception that is raised when you try to set a node's input to something
    invalid.
    
    
    """
    
    def description():
        """
        description(self) -> str
        
        Return a description of the class of exception. The description is
        not related to the exception instance.
        
        
        """
        pass
        
    
    def exceptionTypeName():
        """
        exceptionTypeName(self) -> str
        
        Return the name of the exception type. Instances of different
        subclasses of hou.Error will return different names. Instances of
        the base class will return "Error".
        
        You can also use str(e.__class__) to get the name of the subclass.
        
        
        """
        pass
        

def InvalidInput_swigregister():
    """None"""
    pass
    

class OperationFailed(Error):
    """
    hou.OperationFailed
    
    """
    
    def description():
        """
        description(self) -> str
        
        Return a description of the class of exception. The description is
        not related to the exception instance.
        
        
        """
        pass
        
    
    def exceptionTypeName():
        """
        exceptionTypeName(self) -> str
        
        Return the name of the exception type. Instances of different
        subclasses of hou.Error will return different names. Instances of
        the base class will return "Error".
        
        You can also use str(e.__class__) to get the name of the subclass.
        
        
        """
        pass
        

class InvalidNodeType(Error):
    """
    hou.InvalidNodeType
    
    Exception that is raised when you try to call a method on a Node that
    isn't supported by that type of node.
    
    For example, if you ask a non-subnet node for its indirect inputs,
    hou.Node.indirectInputs raises an instance of this exception.
    
    
    """
    
    def description():
        """
        description(self) -> str
        
        Return a description of the class of exception. The description is
        not related to the exception instance.
        
        
        """
        pass
        
    
    def exceptionTypeName():
        """
        exceptionTypeName(self) -> str
        
        Return the name of the exception type. Instances of different
        subclasses of hou.Error will return different names. Instances of
        the base class will return "Error".
        
        You can also use str(e.__class__) to get the name of the subclass.
        
        
        """
        pass
        

def InvalidNodeType_swigregister():
    """None"""
    pass
    

class InvalidSize(Error):
    """
    hou.InvalidSize
    
    Exception that is raised when you pass a sequence of the wrong length to
    a function.
    
    
    """
    
    def description():
        """
        description(self) -> str
        
        Return a description of the class of exception. The description is
        not related to the exception instance.
        
        
        """
        pass
        
    
    def exceptionTypeName():
        """
        exceptionTypeName(self) -> str
        
        Return the name of the exception type. Instances of different
        subclasses of hou.Error will return different names. Instances of
        the base class will return "Error".
        
        You can also use str(e.__class__) to get the name of the subclass.
        
        
        """
        pass
        

def InvalidSize_swigregister():
    """None"""
    pass
    

class Keyframe(BaseKeyframe):
    """
    hou.Keyframe
    
    Class representing the default keyframe type, a numerical keyframe.
    
    REPLACES
    
    * chkey
    
    * chkeyls
    
    
    """
    
    def slope():
        """
        slope(self) -> double
        
        Returns the slope leaving the keyframe.
        
        This method raises hou.KeyframeValueNotSet if the slope has not been
        set.
        
        
        """
        pass
        
    
    def useValue():
        """None"""
        pass
        
    
    def interpretAccelAsRatio(on):
        """
        interpretAccelAsRatio(self, on)
        
        Sets whether Houdini should interpret the acceleration values
        entering and leaving the keyframe as a single ratio. When set to
        True, the ratio of the in-acceleration to out-acceleration is always
        maintained. If, for example, the in-acceleration is made to be twice
        as large using the Animation Editor, then the out-acceleration will
        automatically be adjusted to be twice as large as well. This is the
        default behavior for Houdini keyframes.
        
        
        """
        pass
        
    
    def setInAccel(in_accel):
        """
        setInAccel(self, in_accel)
        
        Sets the acceleration entering the keyframe. Sets the acceleration
        leaving the keyframe, if not already set. Unties the acceleration.
        
        
        """
        pass
        
    
    def evaluatedType():
        """
        evaluatedType(self) -> hou.parmData enum value
        
        Return the data type of the keyframe's evaluated value. For
        keyframes storing numerical values this method returns
        hou.parmData.Float.
        
        
        """
        pass
        
    
    def setInSlopeAuto(on):
        """
        setInSlopeAuto(self, on)
        
        Sets the slope entering the keyframe to automatic.
        
        
        """
        pass
        
    
    def isValueUsed():
        """None"""
        pass
        
    
    def isAccelUsed():
        """None"""
        pass
        
    
    def setAccel(accel):
        """
        setAccel(self, accel)
        
        Sets the acceleration leaving the keyframe.
        
        
        """
        pass
        
    
    def isValueTied():
        """
        isValueTied(self) -> bool
        
        Returns True if the value entering the keyframe has not been set.
        
        
        """
        pass
        
    
    def isValueSet():
        """
        isValueSet(self) -> bool
        
        Returns True if the value entering or leaving the keyframe has been
        set.
        
        
        """
        pass
        
    
    def isAccelTied():
        """
        isAccelTied(self) -> bool
        
        Returns True if the acceleration entering the keyframe has not been
        set.
        
        
        """
        pass
        
    
    def asJSON(self, brief=False, save_keys_in_frames=False):
        """
        asJSON(self, brief=False, save_keys_in_frames=False) -> dict
        
        Returns a JSON dictionary that represents the keyframe. The
        dictionary includes the frame time, value/expression, and the slope
        and acceleration parameters. If the brief parameter is set to True a
        smaller set of key/value pairs are included in the dictionary to
        reduce space usage. If the save_keys_in_frames parameter is True the
        dictionary uses a frame number instead of a time value.
        
        See also the fromJSON method.
        
        """
        pass
        
    
    def isAccelSet():
        """
        isAccelSet(self) -> bool
        
        Returns True if the acceleration entering or leaving the keyframe
        has been set.
        
        
        """
        pass
        
    
    def inSlope():
        """
        inSlope(self) -> double
        
        Returns the slope entering the keyframe.
        
        This method raises hou.KeyframeValueNotSet if the slope has not been
        set or the slope is tied.
        
        
        """
        pass
        
    
    def isSlopeUsed():
        """None"""
        pass
        
    
    def setValue(value):
        """
        setValue(self, value)
        
        Sets the value leaving the keyframe.
        
        
        """
        pass
        
    
    def isAccelInterpretedAsRatio():
        """
        isAccelInterpretedAsRatio(self) -> bool
        
        Returns True if the acceleration values entering and leaving the
        keyframe are interpreted as a ratio by Houdini.
        
        
        """
        pass
        
    
    def isSlopeSet():
        """
        isSlopeSet(self) -> bool
        
        Returns True if the slope entering or leaving the keyframe has been
        set.
        
        
        """
        pass
        
    
    def unsetInAccel():
        """
        unsetInAccel(self)
        
        Unsets the acceleration entering the keyframe and tie the
        acceleration.
        
        
        """
        pass
        
    
    def useAccel():
        """None"""
        pass
        
    
    def accel():
        """
        accel(self) -> double
        
        Returns the acceleration leaving the keyframe.
        
        This function raises hou.KeyframeValueNotSet if the acceleration has
        not been set.
        
        
        """
        pass
        
    
    def useSlope():
        """None"""
        pass
        
    
    def setInSlope(in_slope):
        """
        setInSlope(self, in_slope)
        
        Sets the slope entering the keyframe. Sets the slope leaving the
        keyframe, if not already set. Unties the slope.
        
        
        """
        pass
        
    
    def isInSlopeAuto():
        """
        isInSlopeAuto(self) -> bool
        
        Returns True if the slope entering the keyframe is set to automatic.
        
        
        """
        pass
        
    
    def isSlopeAuto():
        """
        isSlopeAuto(self) -> bool
        
        Returns True if the slope leaving the keyframe is set to automatic.
        
        
        """
        pass
        
    
    def inValue():
        """
        inValue(self) -> double
        
        Returns the value entering the keyframe.
        
        This method raises hou.KeyframeValueNotSet if the value has not been
        set or the value is tied.
        
        
        """
        pass
        
    
    def fromJSON(self, keyframe_dict):
        """
        fromJSON(self, keyframe_dict)
        
        Sets the keyframe time, value and parameters using the key/value
        pairs from a JSON dictionary.
        
        See also the asJSON method.
        
        """
        pass
        
    
    def isSlopeTied():
        """
        isSlopeTied(self) -> bool
        
        Returns True if the slope entering the keyframe has not been set.
        
        
        """
        pass
        
    
    def unsetInSlope():
        """
        unsetInSlope(self)
        
        Unsets the slope entering the keyframe and tie the slope.
        
        
        """
        pass
        
    
    def setSlope(slope):
        """
        setSlope(self, slope)
        
        Sets the slope leaving the keyframe.
        
        
        """
        pass
        
    
    def value():
        """
        value(self) -> double
        
        Returns the value leaving the keyframe.
        
        This method raises hou.KeyframeValueNotSet if the value has not been
        set.
        
        
        """
        pass
        
    
    def unsetInValue():
        """
        unsetInValue(self)
        
        Unsets the value entering the keyframe and tie the values.
        
        
        """
        pass
        
    
    def setInValue(in_value):
        """
        setInValue(self, in_value)
        
        Sets the value entering the keyframe. Sets the value leaving the
        keyframe, if not already set. Unties the value.
        
        
        """
        pass
        
    
    def setSlopeAuto(on):
        """
        setSlopeAuto(self, on)
        
        Sets the slope leaving the keyframe to automatic.
        
        
        """
        pass
        
    
    def inAccel():
        """
        inAccel(self) -> double
        
        Returns the acceleration entering the keyframe.
        
        This method raises hou.KeyframeValueNotSet if the acceleration has
        not been set or it is tied.
        
        
        """
        pass
        

class KeyframeValueNotSet(Error):
    """
    hou.KeyframeValueNotSet
    
    """
    
    def description():
        """
        description(self) -> str
        
        Return a description of the class of exception. The description is
        not related to the exception instance.
        
        
        """
        pass
        
    
    def exceptionTypeName():
        """
        exceptionTypeName(self) -> str
        
        Return the name of the exception type. Instances of different
        subclasses of hou.Error will return different names. Instances of
        the base class will return "Error".
        
        You can also use str(e.__class__) to get the name of the subclass.
        
        
        """
        pass
        

def KeyframeValueNotSet_swigregister():
    """None"""
    pass
    

def Keyframe_swigregister():
    """None"""
    pass
    

class LabelParmTemplate(ParmTemplate):
    """
    hou.LabelParmTemplate
    
    Describes a label parameter. Unlike most other parameters, labels do not
    store parameter values.
    
    
    """
    
    def setColumnLabels(column_labels):
        """
        setColumnLabels(column_labels)
        
        Set the column labels to a sequence of strings.
        
        The parameter editor in the <Type Properties Dialog> always has at
        least one column label, so if you supply an empty sequence there
        will be one column label that is an empty string.
        
        See the columnLabels method for more information.
        
        
        """
        pass
        
    
    def columnLabels():
        """
        columnLabels() -> tuple of str
        
        Return the tuple of strings of column labels. Normally, label parm
        templates do not have any column labels. However, they may have
        these extra labels that are displayed in addition to the main label.
        
        Note that the number of components in a label parm template
        corresponds to the number of column labels.
        
        
        """
        pass
        

def LabelParmTemplate_swigregister():
    """None"""
    pass
    

class LoadWarning(Error):
    """
    hou.LoadWarning
    
    Exception class for when loading a hip file in Houdini generates
    warnings.
    
    
    """
    
    def description():
        """
        description(self) -> str
        
        Return a description of the class of exception. The description is
        not related to the exception instance.
        
        
        """
        pass
        
    
    def exceptionTypeName():
        """
        exceptionTypeName(self) -> str
        
        Return the name of the exception type. Instances of different
        subclasses of hou.Error will return different names. Instances of
        the base class will return "Error".
        
        You can also use str(e.__class__) to get the name of the subclass.
        
        
        """
        pass
        

def LoadWarning_swigregister():
    """None"""
    pass
    

class LopNetwork(Node):
    """
    hou.LopNetwork
    
    Represents a lighting node.
    
    
    """
    
    def selection():
        """
        selection(self) -> tuple of str
        
        Return a tuple of strings representing all the scene graph locations
        currently selected in the LOP Network parent of this LOP node. This
        is the same selection that will be showing in the Scene Graph Tree
        pane and the LOP viewport.
        
        
        """
        pass
        
    
    def setSelectionRule(name, rule):
        """
        setSelectionRule(self, name, rule)
        
        Stores a named selection rule on the LOP Network that owns this LOP
        node. The rule parameter must be a hou.LopSelectionRule or None. Use
        None to remove a single named rule from the LOP Network.
        
        The selection rule name can be a slash-separated path, in which case
        the selection rule will appear in the Scene Graph Tree pane as part
        of a nested hierarchy. This in no way affects the operation of the
        rule, serving only as a way of organizing sets of rules.
        
        
        """
        pass
        
    
    def selectionCurrentPrim():
        """
        selectionCurrentPrim(self) -> str
        
        Return a string with the path to the scene graph primitive that
        should be displayed in the Scene Graph Details pane. Set this value
        with the hou.LopNetwork.setSelection method.
        
        
        """
        pass
        
    
    def namedViewportOverrides():
        """
        namedViewportOverrides(self) -> tuple of str
        
        Returns a list of the named session overrides saved on the LOP
        Network. The names returned from this method can be passed to the
        loadNamedViewportOverrides method to load a particular set of
        overrides saved with the saveNamedViewportOverrides method.
        
        
        """
        pass
        
    
    def viewportLoadMasks():
        """
        viewportLoadMasks(self) -> hou.LopViewportLoadMasks
        
        Returns the load masking configuration for the viewport currently
        set on the LOP Network. This controls payload loading, stage
        population masking, and layer muting on any viewport pointed at this
        LOP Network.
        
        
        """
        pass
        
    
    def selectionRules():
        """
        selectionRules(self) -> dict of str to hou.LopSelectionRule
        
        Return a dictionary mapping string names to hou.LopSelectionRule
        objects that match the selection rules stored on the LOP Network
        that owns this LOP node.
        
        
        """
        pass
        
    
    def viewportOverrides(lop, output_index, =, 0, layer_index, =, 0):
        """
        viewportOverrides(self, lop, output_index = 0, layer_index = 0) ->
        hou.LopViewportOverrides
        
        Return a hou.LopViewportOverrides object that allows editing of the
        current session-only modifications which should be applied to any
        scene being viewed in a Scene Graph Tree pane or a Scene Viewer
        pane.
        
        The lop must be a hou.LopNode object. The cooked stage from this LOP
        Node is used to perform the requested edit operations in the
        returned hou.LopViewportOverrides object. The output_index controls
        which output of this LOP node will be used to author the stage
        presented through the hou.LopViewportOverrides.stage method. The
        layer_index parameter controls which specific session sublayer is to
        be modified.
        
        
        """
        pass
        
    
    def setDebugFlag(on):
        """
        setDebugFlag(self, on)
        
        Turns the node's debug flag on or off. The debug flag on a LOP node
        is used to force the node to create its own USD Layer and apply its
        edits in that new layer. This makes it easier to track which scene
        graph modifications were made by which LOP node. Setting this flag
        will also affect the performance of the LOP Network since
        composition of the USD stage takes longer if there are more layers.
        
        Raises hou.PermissionError if the node is unwritable.
        
        
        """
        pass
        
    
    def namedViewportLoadMasks():
        """
        namedViewportLoadMasks(self) -> tuple of str
        
        Returns a list of the named load masking configurations saved on the
        LOP Network. The names returned from this method can be passed to
        the loadNamedViewportLoadMasks method to load a particular load
        masking configuration saved with the saveNamedViewportLoadMasks
        method.
        
        
        """
        pass
        
    
    def setSelection(selection, layerid, =, None, currentprim, =, None):
        """
        setSelection(self, selection, layerid = None, currentprim = None)
        
        Accepts a tuple of strings holding the scene graph locations which
        should become the selection in the LOP Network parent of this LOP
        node. This selection will be reflected in the Scene Graph Tree pane
        and the LOP viewport.
        
        The optional layerid parameter can be a string which is the layer
        identifier of a specific layer that should be displayed in the Scene
        Graph Details pane. Similarly the currentprim string can be supplied
        to have the Scene Graph Details pane show the information for a
        primitive at a specific path. The currentprim is usually in the
        selection list, but it doesn't need to be. Passing None for layerid
        or currentprim leave these values on the LOP Network unchanged.
        
        
        """
        pass
        
    
    def selectionLayerId():
        """
        selectionLayerId(self) -> str
        
        Return a string with the layer identifier of the specific USD layer
        that should be displayed in the Scene Graph Details pane. Set this
        value with the hou.LopNetwork.setSelection method.
        
        
        """
        pass
        
    
    def clearSelectionRules():
        """
        clearSelectionRules(self)
        
        Deletes all selection rules stored on the LOP Network that owns this
        LOP node.
        
        
        """
        pass
        
    
    def saveNamedViewportLoadMasks(name):
        """
        saveNamedViewportLoadMasks(self, name)
        
        Saves the supplied load masking configuration to the LOP Network
        under the specified name. This configuration will be saved to the
        hip file, and can be restored with the loadNamedViewportLoadMasks
        method.
        
        
        """
        pass
        
    
    def saveNamedViewportOverrides(name):
        """
        saveNamedViewportOverrides(self, name)
        
        Saves the current set of session overrides to the LOP Network under
        the specified name. This set of overrides will be saved to the hip
        file, and can be restored with the loadNamedViewportOverrides
        method.
        
        
        """
        pass
        
    
    def isDebugFlagSet():
        """
        isDebugFlagSet(self) -> bool
        
        Returns True if the node's debug flag is turned on. Returns False
        otherwise.
        
        
        """
        pass
        
    
    def setViewportLoadMasks(payload_config):
        """
        setViewportLoadMasks(self, payload_config)
        
        Sets a new load masking configuration on the LOP Network.
        
        
        """
        pass
        
    
    def loadNamedViewportOverrides(name):
        """
        loadNamedViewportOverrides(self, name)
        
        Loads the session overrides saved under the specified name on the
        LOP Network. This set of overrides will be applied to any viewport
        pointed at this LOP Network. These named session override sets can
        be created with the saveNamedViewportOverrides method.
        
        
        """
        pass
        
    
    def loadNamedViewportLoadMasks(name):
        """
        loadNamedViewportLoadMasks(self, name) -> hou.LopViewportLoadMasks
        
        Returns the load masking configuration saved under the specified
        name on the LOP Network. Raises a hou.OperationFailed exception if
        there is no load masking configuration stored under the specified
        name.
        
        
        """
        pass
        
    
    def displayNode():
        """
        displayNode(self) -> Node
        
        Return the LOP node inside this network with its display flag on.
        Otherwise, return None.
        
        
        """
        pass
        

def LopNetwork_swigregister():
    """None"""
    pass
    

class LopNode(Node):
    """
    hou.LopNode
    
    Represents a lighting node.
    
    
    """
    
    def lastModifiedPrims():
        """
        lastModifiedPrims(self) -> tuple of str
        
        Returns the paths of the USD primitives modified by this node.
        
        
        """
        pass
        
    
    def activeLayer():
        """
        activeLayer(self) -> pxr.Sdf.Layer
        
        Returns a pxr.Sdf.Layer object representing the USD layer that has
        been modified by this node.
        
        
        """
        pass
        
    
    def loadMasks():
        """
        loadMasks(self) -> hou.LopViewportLoadMasks
        
        Returns the load masking configuration cooked into the stage at this
        LOP node. This object controls stage population masking and layer
        muting. These masks can be set using the Load Masks LOP. These load
        masks will affect the primitives available on the stage when cooking
        this node or nodes below it.
        
        
        """
        pass
        
    
    def sourceLayerCount():
        """
        sourceLayerCount(self) -> int
        
        Returns the number of source layers that are used to build the stage
        at the output of this node. The result from this method will be one
        greater than the maximum value that can be passed to the sourceLayer
        method.
        
        
        """
        pass
        
    
    def setDisplayFlag(on):
        """
        setDisplayFlag(self, on)
        
        Turn this node's display flag on or off.
        
        
        """
        pass
        
    
    def editableStage():
        """
        editableStage(self) -> pxr.Usd.Stage
        
        Returns a pxr.Usd.Stage object with permission to edit that
        represents the USD stage input to a Python LOP.
        
        
        """
        pass
        
    
    def isBypassed():
        """
        isBypassed(self) -> bool
        
        Returns whether this node's bypass flag is on.
        
        
        """
        pass
        
    
    def setDebugFlag(on):
        """
        setDebugFlag(self, on)
        
        Turns the node's debug flag on or off. The debug flag on a LOP node
        is used to force the node to create its own USD Layer and apply its
        edits in that new layer. This makes it easier to track which scene
        graph modifications were made by which LOP node. Setting this flag
        will also affect the performance of the LOP Network since
        composition of the USD stage takes longer if there are more layers.
        
        Raises hou.PermissionError if the node is unwritable.
        
        
        """
        pass
        
    
    def setLastModifiedPrims(primpaths):
        """
        setLastModifiedPrims(self, primpaths)
        
        When used in a Python based LOP node, this method sets the value
        that will be returned by subsequent calls to lastModifiedPrims. The
        primpaths parameter must be a tuple or list of strings.
        
        
        """
        pass
        
    
    def inputPrims(inputidx):
        """
        inputPrims(self, inputidx) -> tuple of str
        
        Returns the paths of the USD primitives modified by the specified
        input of this node. This method is roughly equivalent to:
        
        > lopnode.inputs()[inputidx].lastModifiedPrims()
        
        """
        pass
        
    
    def isDisplayFlagSet():
        """
        isDisplayFlagSet(self) -> bool
        
        Returns whether this node's display flag is on.
        
        
        """
        pass
        
    
    def network():
        """
        network(self) -> hou.LopNetwork
        
        Return the LOP Network that contains this LOP Node.
        
        
        """
        pass
        
    
    def isDebugFlagSet():
        """
        isDebugFlagSet(self) -> bool
        
        Returns True if the node's debug flag is turned on. Returns False
        otherwise.
        
        
        """
        pass
        
    
    def displayNode():
        """
        displayNode(self) -> Node
        
        If this is a subnet LOP, return the LOP node inside the subnet with
        its display flag on. Otherwise, return None.
        
        
        """
        pass
        
    
    def bypass(on):
        """
        bypass(self, on)
        
        Turns this node's bypass flag on or off, making this node have no
        effect.
        
        
        """
        pass
        
    
    def sourceLayer(layerindex):
        """
        sourceLayer(self, layerindex) -> pxr.Sdf.Layer
        
        Return a pxr.Sdf.Layer object representing the specific requested
        USD layer that is used to build the stage that is the output of this
        node.
        
        
        """
        pass
        
    
    def stage(apply_network_overrides=True):
        """
        stage(self, apply_network_overrides=True) -> pxr.Usd.Stage
        
        Returns a pxr.Usd.Stage object representing the USD stage output
        from this node. Set apply_network_overrides to True to return a
        stage with its session layer set with any temporary activation or
        visibility settings configured in the scene graph tree. Set it to
        False to return the stage with an empty session layer.
        
        
        """
        pass
        
    
    def editableLayer():
        """
        editableLayer(self) -> pxr.Sdf.Layer
        
        Returns a pxr.Sdf.Layer object with permission to edit that
        represents the active layer in a Python LOP.
        
        
        """
        pass
        

def LopNode_swigregister():
    """None"""
    pass
    

class LopSelectionRule(object):
    """
    hou.LopSelectionRule
    
    Stores a set of rules that define how to make a selection of scene graph
    primitives.
    
    
    """
    
    def collectionAwarePaths(lopnode):
        """
        collectionAwarePaths(self, lopnode) -> tuple of str
        
        Calculates the scene graph primitive selection using the scene graph
        from the provided Hom:hou.LopNode object.
        
        Returns the full paths to every scene graph primitive or collection
        matching the selection pattern. Unlike the expandedPaths method,
        collections are not expanded to explicitly list their contents as
        primitives. Instead the full path of the collection itself is
        returned.
        
        If the primitive pattern contains any exclusions the included
        collections cannot be accurately tracked, so the results of this
        method will be the same as for expandedPaths.
        
        
        """
        pass
        
    
    def setPathPattern(pattern):
        """
        setPathPattern(self, pattern)
        
        Sets the path pattern string used in this selection rule.
        
        
        """
        pass
        
    
    def pathPattern():
        """
        pathPattern(self) -> str
        
        Return the path pattern string used in this selection rule.
        
        
        """
        pass
        
    
    def expandedPaths(lopnode):
        """
        expandedPaths(self, lopnode) -> tuple of str
        
        Calculates the scene graph primitive selection using the scene graph
        from the provided Hom:hou.LopNode object.
        
        Returns the full paths to every scene graph primitive matching the
        selection rules. All collections in the path pattern are expanded to
        list their included prims explicitly.
        
        
        """
        pass
        

def LopSelectionRule_swigregister():
    """None"""
    pass
    

class LopViewportLoadMasks(object):
    """
    hou.LopViewportLoadMasks
    
    Stores a description of which payloads on the USD stage should be loaded
    into the viewport.
    
    
    """
    
    def populatePaths():
        """
        populatePaths(self) -> tuple of str
        
        Return the list of all paths which should be populated on the stage.
        Descendants of explicitly named primitives will also populate on the
        stage.
        
        
        """
        pass
        
    
    def loadPaths():
        """
        loadPaths(self) -> tuple of str
        
        Return a list of all scene graph branches which will load their
        payloads in the viewport. Descendants of explicitly named primitives
        will also load their payloads.
        
        
        """
        pass
        
    
    def addPopulatePath(path):
        """
        addPopulatePath(self, path)
        
        Adds a single path to the list of paths to populate. If the path is
        already in the list of paths, this method does nothing.
        
        
        """
        pass
        
    
    def removeMuteLayer(identifier):
        """
        removeMuteLayer(self, identifier)
        
        Removes a single layer identifier from the list of muted layer
        identifiers. If the identifier is not being muted, this method does
        nothing.
        
        
        """
        pass
        
    
    def removePopulatePath(path):
        """
        removePopulatePath(self, path)
        
        Removes a single path from the list of paths to populate . If the
        path is not in the list of paths, this method does nothing.
        
        
        """
        pass
        
    
    def isPathPopulated():
        """None"""
        pass
        
    
    def setMuteLayers(identifiers):
        """
        setMuteLayers(self, identifiers)
        
        Set the list of layer identifiers that should be muted.
        
        
        """
        pass
        
    
    def loadAll():
        """None"""
        pass
        
    
    def addMuteLayer(identifier):
        """
        addMuteLayer(self, identifier)
        
        Adds a single layer identifier to the list of muted layer
        identifiers. If the identifier is already being muted, this method
        does nothing.
        
        
        """
        pass
        
    
    def addLoadPath(path):
        """
        addLoadPath(self, path)
        
        Adds a single path to the list of scene graph paths which will load
        their payloads inthe viewport. If the path is already in the list,
        this method does nothing.
        
        
        """
        pass
        
    
    def setPopulateAll():
        """
        setPopulateAll(self)
        
        Configures the stage mask to include the entire scene graph. This
        clears the current list of paths to populate because it is not
        needed. Calling any method which manipulates the list of paths to
        populate will set this flag back to False.
        
        
        """
        pass
        
    
    def populateAll():
        """
        populateAll(self) -> bool
        
        Returns True if the stage mask is configured to include the entire
        scene graph. If True, the explicit list of paths has no meaning.
        
        
        """
        pass
        
    
    def setLoadPaths(paths):
        """
        setLoadPaths(self, paths)
        
        Set the list of scene graph paths which should load their payloads
        in the viewport.
        
        
        """
        pass
        
    
    def setLoadAll():
        """
        setLoadAll(self)
        
        Set the flag indicating that all payloads should be loaded by
        default. Calling any method which manipulates the list of paths to
        be loaded will set this flag back to False.
        
        
        """
        pass
        
    
    def setPopulatePaths(paths):
        """
        setPopulatePaths(self, paths)
        
        Set the list of paths which should be populated on the stage.
        
        
        """
        pass
        
    
    def muteLayers():
        """
        muteLayers(self) -> tuple of str
        
        Return the list of all muted layer identifiers.
        
        
        """
        pass
        
    
    def isPathLoaded(path, exact_match, =, True):
        """
        isPathLoaded(self, path, exact_match = True) -> bool
        
        Return True if the specified scene graph path is explicitly named in
        the list of paths to load. If exact_match is False, this method also
        returns true if any ancestor of the supplied path is in the set of
        paths to load.
        
        
        """
        pass
        
    
    def removeLoadPath(path):
        """
        removeLoadPath(self, path)
        
        Removes a single path from the list of scene graph paths which will
        load their payloads in the viewport. If the path is not in the list,
        this method does nothing.
        
        
        """
        pass
        
    
    def isLayerMuted(identifier):
        """
        isLayerMuted(self, identifier) -> bool
        
        Return True if the specified layer identifier should be ignored when
        composing the stage.
        
        
        """
        pass
        

def LopViewportLoadMasks_swigregister():
    """None"""
    pass
    

class LopViewportOverrides(object):
    """
    hou.LopViewportOverrides
    
    Used to edit the current session overlay layer that is applied to the
    current LOP node's scene graph.
    
    This object is a context manager. You can create one using
    hou.LopNetwork.viewportOverrides. At the end of the with block, the
    notification of the session edits is propagated to viewer panes.
    
    
    """
    
    def layer():
        """
        layer(self) -> pxr.Sdf.Layer
        
        Return the pxr.Sdf.Layer object that contains all the current
        session edits to the scene graph. This object can be modified using
        the pxr.Sdf.Layer API to make further session modifications to the
        scene graph.
        
        
        """
        pass
        
    
    def setActive(prims, active):
        """
        setActive(self, prims, active)
        
        Change the active state of USD primitives by editing the session
        layer of a LOP Network. Deactivated primitives do not appear in the
        viewport, and cannot be expanded in the scene graph tree. The LOP
        Network to edit is determined by looking at the LOP node used to
        create this session editor object.
        
        
        prims
        A hou.LopSelectionRule object that specifies which USD
        primitives should be affected.
        
        active
        A boolean value indicating the new activation state of the USD
        primitives.
        
        
        """
        pass
        
    
    def setDrawMode(prims, drawmode):
        """
        setDrawMode(self, prims, drawmode)
        
        Change the draw mode of USD primitives by editing the session layer
        of a LOP Network. The draw mode of a primitive is only respected if
        the primitive is part of a valid, contiguous USD model hierarchy.
        The LOP Network to edit is determined by looking at the LOP node
        used to create this session editor object.
        
        
        prims
        A hou.LopSelectionRule object that specifies which USD
        primitives should be affected.
        
        drawmode
        A string value indicating the new draw mode for the USD
        primitives. Only primitives that are part of a valid USD model
        hierarchy can have their draw mode changed. The allowed values
        for this string are default (draw the full geometry), origin
        (draw a set of axes at the origin of the primitive), bounds
        (draw a bounding box around the primitive), and cards (draw
        three axis-aligned cards that fill the primitive's bounding
        box).
        
        
        """
        pass
        
    
    def setVisible(prims, visible):
        """
        setVisible(self, prims, visible)
        
        Change the visibility of USD primitives by editing the session layer
        of a LOP Network. Invisible primitives are not drawn in the
        viewport, but still appear in the scene graph tree. The LOP Network
        to edit is determined by looking at the LOP node used to create this
        session editor object.
        
        
        prims
        A hou.LopSelectionRule object that specifies which USD
        primitives should be affected.
        
        visible
        A boolean value indicating whether the USD primitives should be
        visible.
        
        
        """
        pass
        
    
    def stage():
        """
        stage(self) -> pxr.Sdf.Stage
        
        Return the pxr.Usd.Stage object that contains all the current
        session edits to the scene graph. This object can be modified using
        the pxr.Usd.Stage API to make further session modifications to the
        scene graph.
        
        
        """
        pass
        

def LopViewportOverrides_swigregister():
    """None"""
    pass
    

class MatchDefinitionError(Error):
    """
    hou.MatchDefinitionError
    
    """
    
    def description():
        """
        description(self) -> str
        
        Return a description of the class of exception. The description is
        not related to the exception instance.
        
        
        """
        pass
        
    
    def exceptionTypeName():
        """
        exceptionTypeName(self) -> str
        
        Return the name of the exception type. Instances of different
        subclasses of hou.Error will return different names. Instances of
        the base class will return "Error".
        
        You can also use str(e.__class__) to get the name of the subclass.
        
        
        """
        pass
        

def MatchDefinitionError_swigregister():
    """None"""
    pass
    

class Matrix2(object):
    """
    hou.Matrix2
    
    A 2x2 matrix of floating point values.
    
    
    """
    
    def setToIdentity():
        """
        setToIdentity(self)
        
        Set this matrix to the multiplicative identity, having 1's in the
        diagonal.
        
        The matrix will contain the values [[1, 0], [0, 1]]. Note that you
        can construct a new matrix with these values using hou.Matrix2(1).
        
        
        """
        pass
        
    
    def asTupleOfTuples():
        """
        asTupleOfTuples(self) -> tuple of tuple of float
        
        Return the contents of the matrix as a tuple of tuples of 2 floats.
        
        
        """
        pass
        
    
    def determinant():
        """
        determinant(self) -> double
        
        Return the determinant of the matrix.
        
        See Wikipedia's determinant page.
        
        
        """
        pass
        
    
    def inverted():
        """
        inverted(self) -> hou.Matrix2
        
        Return the inverse of this matrix.
        
        Raises hou.OperationFailed if the matrix is not invertible.
        Otherwise, (self * self.inverted()).isAlmostEqual(hou.Matrix2(1)) is
        True.
        
        See Wikipedia's invertible matrix page for more information.
        
        
        """
        pass
        
    
    def at(row, col):
        """
        at(self, row, col) -> double
        
        Return the value of the matrix at the given row and column.
        
        Raises IndexError if the row or column are not between 0 and 1,
        inclusive. Note that negative indices will not index from the end.
        
        
        """
        pass
        
    
    def setTo(tuple):
        """
        setTo(self, tuple)
        
        Set this matrix's contents. The sequence may contain either 4 floats
        or 2 sequences, each with 2 floats.
        
        See hou.Matrix2.__init__ for examples of suitable parameter values.
        
        
        """
        pass
        
    
    def isAlmostEqual(matrix2, tolerance=0.00001):
        """
        isAlmostEqual(self, matrix2, tolerance=0.00001) -> bool
        
        Returns whether this matrix is equal to another, within a tolerance.
        
        
        """
        pass
        
    
    def transposed():
        """
        transposed(self) -> hou.Matrix2
        
        Return the transpose of this matrix. The result is such that
        self.at(i, j) == self.transposed().at(j, i) for 0 <= i,j <= 1.
        
        See Wikipedia's transpose page for more information.
        
        
        """
        pass
        
    
    def setToZero():
        """
        setToZero(self)
        
        Set this matrix to contain all zeros.
        
        Note that you can construct a new matrix with all zeros with
        hou.Matrix2().
        
        
        """
        pass
        
    
    def preMult(matrix2):
        """
        preMult(self, matrix2) -> hou.Matrix2
        
        Returns matrix2 * self. Note that __mul__ returns self * matrix2,
        which is a different result because matrix multiplication is not
        commutative.
        
        
        """
        pass
        
    
    def _asVoidPointer():
        """None"""
        pass
        
    
    def setAt(row, col, value):
        """
        setAt(self, row, col, value)
        
        Set the value of the matrix at the given row and column.
        
        Raises IndexError if the row or column are not between 0 and 1,
        inclusive. Note that negative indices will not index from the end.
        
        
        """
        pass
        
    
    def asTuple():
        """
        asTuple(self) -> tuple of float
        
        Return the contents of the matrix as a tuple of 4 floats.
        
        
        """
        pass
        

def Matrix2_swigregister():
    """None"""
    pass
    

class Matrix3(object):
    """
    hou.Matrix3
    
    A 3x3 matrix of floating point values.
    
    3x3 matrices are typically used in Houdini to represent a 3D rotation
    (with a possible scale). Most places in Houdini use hou.Matrix4, which
    can store generation 3D transformations (including translations).
    
    Note that you can construct a general transformation Matrix4 from a
    Matrix3 by writing hou.Matrix4(matrix3).
    
    
    """
    
    def setToIdentity():
        """
        setToIdentity(self)
        
        Set this matrix to the multiplicative identity, having 1's in the
        diagonal.
        
        The matrix will contain the values [[1, 0, 0], [0, 1, 0], [0, 0,
        1]]. Note that you can construct a new matrix with these values
        using hou.Matrix3(1).
        
        
        """
        pass
        
    
    def asTupleOfTuples():
        """
        asTupleOfTuples(self) -> tuple of tuple of float
        
        Return the contents of the matrix as a tuple of tuples of 3 floats.
        
        
        """
        pass
        
    
    def determinant():
        """
        determinant(self) -> double
        
        Return the determinant of the matrix.
        
        See Wikipedia's determinant page.
        
        
        """
        pass
        
    
    def inverted():
        """
        inverted(self) -> hou.Matrix3
        
        Return the inverse of this matrix.
        
        Raises hou.OperationFailed if the matrix is not invertible.
        Otherwise, (self * self.inverted()).isAlmostEqual(hou.Matrix3(1)) is
        True.
        
        See Wikipedia's invertible matrix page for more information.
        
        
        """
        pass
        
    
    def at(row, col):
        """
        at(self, row, col) -> double
        
        Return the value of the matrix at the given row and column.
        
        Raises IndexError if the row or column are not between 0 and 2,
        inclusive. Note that negative indices will not index from the end.
        
        
        """
        pass
        
    
    def setTo(tuple):
        """
        setTo(self, tuple)
        
        Set this matrix's contents. The sequence may contain either 9 floats
        or 3 sequences, each with 3 floats.
        
        See hou.Matrix3.__init__ for examples of suitable parameter values.
        
        
        """
        pass
        
    
    def extractRotates(rotate_order="xyz"):
        """
        extractRotates(self, rotate_order="xyz") -> hou.Vector3
        
        Return a Vector3 of Euler angles, in degrees, representing the
        rotation component of this matrix. Rotating about the coordinate
        axes in the specified order by these amounts will yield the rotation
        contained in this matrix.
        
        
        rotate_order
        A string containing a permutation of the letters x, y, and z
        that determines the order in which rotations are performed about
        the coordinate axes.
        
        Raises hou.OperationFailed if the matrix does not represent a valid
        rotation matrix (e.g. it is singular) or the rotate order is not a
        permutation of the string 'xyz'.
        
        See also hou.Matrix4.explode and hou.Matrix4.extractRotates.
        
        
        """
        pass
        
    
    def transposed():
        """
        transposed(self) -> hou.Matrix3
        
        Return the transpose of this matrix. The result is such that
        self.at(i, j) == self.transposed().at(j, i) for 0 <= i,j <= 2.
        
        See Wikipedia's transpose page for more information.
        
        
        """
        pass
        
    
    def setToZero():
        """
        setToZero(self)
        
        Set this matrix to contain all zeros.
        
        Note that you can construct a new matrix with all zeros with
        hou.Matrix3().
        
        
        """
        pass
        
    
    def preMult(matrix3):
        """
        preMult(self, matrix3) -> hou.Matrix3
        
        Returns matrix3 * self. Note that __mul__ returns self * matrix3,
        which is a different result because matrix multiplication is not
        commutative.
        
        
        """
        pass
        
    
    def _asVoidPointer():
        """None"""
        pass
        
    
    def setAt(row, col, value):
        """
        setAt(self, row, col, value)
        
        Set the value of the matrix at the given row and column.
        
        Raises IndexError if the row or column are not between 0 and 2,
        inclusive. Note that negative indices will not index from the end.
        
        
        """
        pass
        
    
    def asTuple():
        """
        asTuple(self) -> tuple of float
        
        Return the contents of the matrix as a tuple of 9 floats.
        
        
        """
        pass
        
    
    def isAlmostEqual(matrix3, tolerance=0.00001):
        """
        isAlmostEqual(self, matrix3, tolerance=0.00001) -> bool
        
        Returns whether this matrix is equal to another, within a tolerance.
        
        
        """
        pass
        

def Matrix3_swigregister():
    """None"""
    pass
    

class Matrix4(object):
    """
    hou.Matrix4
    
    A 4x4 matrix of floating point values.
    
    4x4 matrices are typically used in Houdini to represent a 3D
    transformation (e.g. some combination of rotation, scaling, shearing,
    and translation). A single matrix compactly represents a transformation,
    and is much easier to deal with than multiple translate, rotate, scale,
    shear, transformation order, and rotation order values.
    
    Note that Houdini's matrices are stored in row-major format, and vectors
    that are multiplied with matrices are treated as row vectors. So, if p
    is a hou.Vector4 representing a point and M is a Matrix4, you write p*M,
    *not* M*p. Similarly, p*M1*M2 will first transform p by M1, and then
    transform it by M2.
    
    
    NOTE
    Most mathematical notations treat vectors and points as column
    vectors instead of row vectors. They will often use A*B*C (or simply
    ABC) to refer to a combined transform that first applies C's
    transform, then B's, and then applies A's. However, the convention
    is different in Houdini. To represent the equivalent matrix
    expression in Houdini, you need to concatenate the transforms in the
    reverse order. So, you would instead write C'*B'*A', where C', B',
    A' are the transpose of C, B, A respectively.
    
    You can multiply Vector3s or Vector4s by Matrix4s. If you multiply a
    Vector3, it is the same as multiplying a Vector4 where the fourth
    component is 1 (see hou.Vector3.__mul__).
    
    To transform a normal (as opposed to a point or vector), you need to
    multiply by the inverse transpose of the matrix. For example, suppose:
    
    
    p
    is a hou.Vector3 object representing a position (or a hou.Vector4
    with v[4]==1)
    
    v
    is a hou.Vector4 object representing a vector (a direction with a
    length but no fixed location in space), with v[3]==0
    
    n
    is a hou.Vector4 object representing a normal, with v[3]==0
    
    m
    is a Matrix4 object representing a transform matrix
    
    Then you would write:
    
    > p * m # to transform the point
    > v * m # to transform the vector
    > n * m.inverted().transposed() # to transform the normal
    > # (note that m.inverted().transposed() is mathematically equivalent to m.transposed().inverted())
    
    Here is a concrete example:
    
    > >>> m = hou.hmath.buildTranslate((1, 1, 2))
    > >>> m
    > <hou.Matrix4 [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [1, 1, 2, 1]]>
    > >>> p = hou.Vector3(1, 2, 3)
    > >>> p * m
    > <hou.Vector3 [2, 3, 5]>
    
    Both VEX and the UT_DMatrix4 class in the Houdini Development Kit (HDK)
    also store matrices in row-major format.
    
    RELATED
    
    * hou.hmath
    
    * hou.Matrix3
    
    * hou.Quaternion
    
    * hou.Vector3
    
    * hou.Vector4
    
    
    """
    
    def asTupleOfTuples():
        """
        asTupleOfTuples(self) -> tuple of tuple of float
        
        Return the contents of the matrix as a tuple of tuples of 4 floats.
        
        
        """
        pass
        
    
    def inverted():
        """
        inverted(self) -> hou.Matrix4
        
        Return the inverse of this matrix.
        
        Raises hou.OperationFailed if the matrix is not invertible.
        Otherwise, (self *
        self.inverted()).isAlmostEqual(hou.hmath.identityTransform()) is
        True.
        
        See Wikipedia's invertible matrix page for more information.
        
        
        """
        pass
        
    
    def extractRotationMatrix3():
        """
        extractRotationMatrix3(self) -> hou.Matrix3
        
        Extracts the 3x3 rotation matrix from this matrix, assuming it is a
        transformation matrix. If it fails to extract the rotation, for
        example if scaling is zero on one axis, it returns the identity
        matrix instead.
        
        
        """
        pass
        
    
    def at(row, col):
        """
        at(self, row, col) -> float
        
        Return the value of the matrix at the given row and column.
        
        Raises IndexError if the row or column are not between 0 and 3,
        inclusive. Note that negative indices will not index from the end.
        
        
        """
        pass
        
    
    def setTo(sequence):
        """
        setTo(self, sequence)
        
        Set this matrix's contents. The sequence may contain either 16
        floats or 4 sequences, each with 4 floats.
        
        See hou.Matrix4.__init__ for examples of suitable parameter values.
        
        
        """
        pass
        
    
    def extractRotates(transform_order='srt', rotate_order='xyz', pivot=hou.Vector3():
        """
        extractRotates(self, transform_order='srt', rotate_order='xyz',
        pivot=hou.Vector3(), pivot_rotate=hou.Vector3()) -> hou.Vector3
        
        A shortcut for self.explode(transform_order, rotate_order, pivot,
        pivot_rotate)['rotate']. See hou.Matrix4.explode for more
        information.
        
        
        """
        pass
        
    
    def setToZero():
        """
        setToZero(self)
        
        Set this matrix to contain all zeros.
        
        Note that you can construct a new matrix with all zeros with
        hou.Matrix4().
        
        
        """
        pass
        
    
    def _asVoidPointer():
        """None"""
        pass
        
    
    def asTuple():
        """
        asTuple(self) -> tuple of float
        
        Return the contents of the matrix as a tuple of 16 floats.
        
        
        """
        pass
        
    
    def setToIdentity():
        """
        setToIdentity(self)
        
        Set this matrix to the multiplicative identity, having 1's in the
        diagonal.
        
        The matrix will contain the values [[1, 0, 0, 0], [0, 1, 0, 0], [0,
        0, 1, 0], [0, 0, 0, 1]]. Note that you can construct a new matrix
        with these values using hou.hmath.identityTransform or
        hou.Matrix4(1).
        
        
        """
        pass
        
    
    def determinant():
        """
        determinant(self) -> float
        
        Return the determinant of the matrix.
        
        See Wikipedia's determinant page.
        
        
        """
        pass
        
    
    def setToOrthographic():
        """None"""
        pass
        
    
    def isAlmostEqual(matrix4, tolerance=0.00001):
        """
        isAlmostEqual(self, matrix4, tolerance=0.00001) -> bool
        
        Return whether this matrix is equal to another, within a tolerance.
        
        
        """
        pass
        
    
    def extractTranslates(transform_order='srt', pivot_rotate=hou.Vector3():
        """
        extractTranslates(self, transform_order='srt',
        pivot_rotate=hou.Vector3()) -> hou.Vector3
        
        A shortcut for self.explode(transform_order, hou.Vector3(),
        pivot_rotate)['translate']. See hou.Matrix4.explode for more
        information.
        
        > >>> matrix = hou.hmath.buildTranslate(1, 0, 0) * hou.hmath.buildRotate(0, 0, 45)
        > >>> matrix.extractTranslates('trs')
        > <hou.Vector3 [4, 0, 0]>
        > >>> matrix.extractTranslates('srt')
        > <hou.Vector3 [0.707107, 0.707107, 0]>
        
        """
        pass
        
    
    def extractScales(transform_order='srt', pivot=hou.Vector3():
        """
        extractScales(self, transform_order='srt', pivot=hou.Vector3(),
        pivot_rotate=hou.Vector3()) -> hou.Vector3
        
        A shortcut for self.explode(transform_order, rotate_order, pivot,
        pivot_rotate)['scale']. See hou.Matrix4.explode for more
        information.
        
        
        """
        pass
        
    
    def extractShears(transform_order='srt', pivot=hou.Vector3():
        """
        extractShears(self, transform_order='srt', pivot=hou.Vector3(),
        pivot_rotate=hou.Vector3()) -> hou.Vector3
        
        A shortcut for self.explode(transform_order, rotate_order, pivot,
        pivot_rotate)['shear']. See hou.Matrix4.explode for more
        information.
        
        
        """
        pass
        
    
    def transposed():
        """
        transposed(self) -> hou.Matrix4
        
        Return the transpose of this matrix. The result is such that
        self.at(i, j) == self.transposed().at(j, i) for 0 <= i,j <= 3.
        
        See Wikipedia's transpose page for more information.
        
        
        """
        pass
        
    
    def setToPerspective(zoom, orthowidth=1, image_aspect=1, pixel_aspect=1, clip_near=0, clip_far=1, window_xmin=0, window_xmax=1, window_ymin=0, window_ymax=1):
        """
        setToOrthographic(self, zoom, orthowidth=1, image_aspect=1,
        pixel_aspect=1, clip_near=0, clip_far=1, window_xmin=0, window_xmax=1,
        window_ymin=0, window_ymax=1)
        
        Set this matrix to an orthographic projection matrix with the given
        parameters.
        
        Sometimes the zoom is expressed in terms of focal and aperture. In
        this case: zoom = focal/aperture. Sometimes the image_aspect is
        expressed in terms of xres and yres. In this case: image_aspect =
        xres / yres.
        
        
        """
        pass
        
    
    def preMult(matrix4):
        """
        preMult(self, matrix4) -> hou.Matrix4
        
        Returns matrix4 * self. Note that __mul__ returns self * matrix4,
        which is a different result because matrix multiplication is not
        commutative.
        
        
        """
        pass
        
    
    def explode(transform_order='srt', rotate_order='xyz', pivot=hou.Vector3():
        """
        explode(self, transform_order='srt', rotate_order='xyz',
        pivot=hou.Vector3(), pivot_rotate=hou.Vector3()) -> dict of str to
        hou.Vector3
        
        Return a dictionary with keys 'rotate', 'scale', 'translate', and
        'shear' whose values are hou.Vector3 objects. When applied in the
        specified order, the corresponding rotations, scales (and shears),
        and translations will give this matrix.
        
        The rotation is returned as a set of Euler angles, in degrees. See
        Wikipedia's Euler angles page for more information.
        
        
        transform_order
        A string containing a permutation of the letters s, r, and t.
        The rotate, scale, and translate results are dependent on the
        order in which you perform those operations, and this string
        specifies that order.
        
        For example, imagine a transformation where you first translate
        in x by one unit, then you rotate in z by 45 degrees. With a
        transform order of 'trs' (translate, rotate, scale), the
        translate component is (1, 0, 0). However, this same
        transformation could be constructed, for example, by first
        scaling, then rotating, and then translating. For this
        transformation order, the translate component would be (1.0 /
        math.sqrt(2), 1.0 / math.sqrt(2), 0).
        
        rotate_order
        A string containing a permutation of the letters x, y, and z
        that determines the order in which rotations are performed about
        the coordinate axes.
        
        pivot
        A Vector3 containing a position about which rotations and scales
        are performed. By default, this parameter is set to the origin.
        
        pivot_rotate
        A Vector3 containing the Euler angles about the x, y, and z
        axes, in degrees, that specifies the base rotation about the
        pivot. These angles are always processed in 'xyz' order.
        
        Raises hou.OperationFailed if the matrix does not represent a valid
        transform matrix (e.g. it is singular), the transform order is not a
        permutation of the string 'srt', or the rotate order is not a
        permutation of the string 'xyz'.
        
        See hou.hmath.buildRotateAboutAxis for an example of how to convert
        Euler angles into an axis and rotation.
        
        See hou.ObjNode.setParmTransform for an example. This method is the
        inverse of hou.hmath.buildTransform. See also the other functions in
        hou.hmath that build transformation matrices.
        
        
        """
        pass
        
    
    def setAt(row, col, value):
        """
        setAt(self, row, col, value)
        
        Set the value of the matrix at the given row and column.
        
        Raises IndexError if the row or column are not between 0 and 3,
        inclusive. Note that negative indices will not index from the end.
        
        
        """
        pass
        

def Matrix4_swigregister():
    """None"""
    pass
    

class MenuParmTemplate(ParmTemplate):
    """
    hou.MenuParmTemplate
    
    Describes a menu parameter containing evaluating to integer values. Note
    that StringParmTemplates may also have menus.
    
    REPLACES
    
    * opmenu
    
    
    """
    
    def setDefaultExpression(tuple_of_default_expressions):
        """
        setDefaultExpression(self, tuple_of_default_expressions)
        
        Set the default expression, which when evaluated, returns the index
        of the default menu item.
        
        If default_expression is the empty string, then the default
        expression is unset.
        
        
        """
        pass
        
    
    def menuItems():
        """
        menuItems(self) -> tuple of str
        
        Return the tuple of internal menu names.
        
        These internal menu names are not displayed in the UI, but they can
        be passed to hou.Parm.set and will be returned by
        hou.Parm.evalAsString for menu parameters.
        
        
        """
        pass
        
    
    def setDefaultExpressionLanguage(tuple_of_default_expression_languages):
        """
        setDefaultExpressionLanguage(self,
        tuple_of_default_expression_languages)
        
        Set the default expression language.
        
        See the defaultExpressionLanguage method for more information.
        
        
        """
        pass
        
    
    def setItemGeneratorScriptLanguage(language):
        """
        setItemGeneratorScriptLanguage(self, language)
        
        Set the script language used to generate menu items to a
        hou.scriptLanguage enum value.
        
        See the itemGeneratorScriptLanguage method for more information.
        
        
        """
        pass
        
    
    def defaultExpressionLanguage():
        """
        defaultExpressionLanguage(self) -> tuple of hou.scriptLanguage
        
        Return the default expression language.
        
        The default expression language only applies if the default
        expression is set. If the default expression is not set, then the
        expression language is set to hou.scriptLanguage.Hscript.
        
        
        """
        pass
        
    
    def menuLabels():
        """
        menuLabels(self) -> tuple of str
        
        Return the tuple of menu labels displayed in the UI.
        
        
        """
        pass
        
    
    def setMenuLabels(menu_labels):
        """
        setMenuLabels(self, menu_labels)
        
        Set the menu labels displayed in the UI to the given sequence of
        strings.
        
        If the number of menu labels is less than the number of menu items,
        Houdini uses the internal menu item names for the missing labels. If
        the number of labels is more than the number of menu items, Houdini
        discards the extra labels.
        
        If you want to change both the menu items and menu labels, be sure
        to change the menu items first.
        
        
        """
        pass
        
    
    def defaultValue():
        """
        defaultValue(self) -> int
        
        Return the index of the default menu item.
        
        See also the defaultValueAsString method.
        
        
        """
        pass
        
    
    def setItemGeneratorScript(item_generator_script):
        """
        setItemGeneratorScript(self, item_generator_script)
        
        Set the script used to generate menu items.
        
        See the itemGeneratorScript method for more information.
        
        
        """
        pass
        
    
    def setAsButtonStrip():
        """
        setAsButtonStrip(self)
        
        Set the parameter to use a Button Strip widget.
        
        See also the setAsMenu, setAsIconStrip methods.
        
        
        """
        pass
        
    
    def setMenuItems(menu_items):
        """
        setMenuItems(self, menu_items)
        
        Set the internal menu names to the given sequence of strings.
        
        See the menuItems method for more information.
        
        If the new number of menu items is less than the old number, the
        menu labels will be shortened and the default value will be modified
        if it is out of range.
        
        
        """
        pass
        
    
    def iconNames():
        """
        iconNames(self) -> tuple of str
        
        Return the tuple of icons corresponding to the menu items. If there
        are no icons, returns a tuple of empty strings.
        
        
        """
        pass
        
    
    def defaultValueAsString():
        """None"""
        pass
        
    
    def isButtonStrip():
        """
        isButtonStrip(self) -> bool
        
        Return whether the parameter is set to use the button strip widget.
        
        
        """
        pass
        
    
    def setMenuUseToken(on):
        """
        setMenuUseToken(self, on)
        
        Set whether the parameter is set to the token value instead of the
        index.
        
        See also the menuUseToken method.
        
        
        """
        pass
        
    
    def setDefaultValue(tuple_of_default_values):
        """
        setDefaultValue(self, tuple_of_default_values)
        
        Set the index of the default menu item.
        
        Note that if this index is out of range, it will be adjusted.
        
        
        """
        pass
        
    
    def itemGeneratorScript():
        """
        itemGeneratorScriptLanguage(self) -> hou.scriptLanguage enum value
        
        Return the programming language for the script that generates menu
        items.
        
        
        """
        pass
        
    
    def isMenu():
        """
        isMenu(self) -> bool
        
        Return whether the parameter is set to use the drop down menu
        widget.
        
        
        """
        pass
        
    
    def setAsMenu():
        """
        setAsMenu(self)
        
        Turn back the parameter to a default menu drop down.
        
        See also the setAsButtonStrip, setAsIconStrip methods.
        
        
        """
        pass
        
    
    def setIconNames(icon_names):
        """
        setIconNames(self, icon_names)
        
        Set the icon names to the given sequence of strings.
        
        
        """
        pass
        
    
    def isIconStrip():
        """
        isIconStrip(self) -> bool
        
        Return whether the parameter is set to use the icon strip widget.
        
        
        """
        pass
        
    
    def setMenuType(menu_type):
        """
        setMenuType(self, menu_type)
        
        Set the type of menu to a hou.menuType enum value.
        
        See the menuType method for more information.
        
        
        """
        pass
        
    
    def defaultExpression():
        """
        defaultExpression(self) -> string
        
        Return the expression, which when evaluated, returns the index of
        the default menu item.
        
        The default expression takes precedence over the default value. If
        the default expression is not set (i.e. an empty string), then the
        default value is used instead.
        
        Note that the default expression language is needed to interpret the
        meaning of the default expression.
        
        
        """
        pass
        
    
    def setAsIconStrip():
        """
        setAsIconStrip(self)
        
        Set the parameter to use a Icon Strip widget.
        
        See also the setAsMenu, setAsButtonStrip methods.
        
        
        """
        pass
        
    
    def menuUseToken():
        """
        menuUseToken(self) -> bool
        
        Return whether the parameter is set to the token value instead of
        the index.
        
        See also the setMenuUseToken method.
        
        
        """
        pass
        
    
    def itemGeneratorScriptLanguage():
        """None"""
        pass
        
    
    def menuType():
        """
        menuType(self) -> hou.menuType enum value
        
        Return the type of menu. Note that some menu types only apply to
        string parameters with menus, so the meaningful menu types for
        MenuParmTemplates are hou.menuType.Normal (for standard menus) and
        hou.menuType.Mini for menus that only display a dropdown arrow. See
        hou.menuType for more information.
        
        
        """
        pass
        

def MenuParmTemplate_swigregister():
    """None"""
    pass
    

class NameConflict(Error):
    """
    hou.NameConflict
    
    Exception raised when a name conflict is detected during an operation.
    
    
    """
    
    def description():
        """
        description(self) -> str
        
        Return a description of the class of exception. The description is
        not related to the exception instance.
        
        
        """
        pass
        
    
    def exceptionTypeName():
        """
        exceptionTypeName(self) -> str
        
        Return the name of the exception type. Instances of different
        subclasses of hou.Error will return different names. Instances of
        the base class will return "Error".
        
        You can also use str(e.__class__) to get the name of the subclass.
        
        
        """
        pass
        

def NameConflict_swigregister():
    """None"""
    pass
    

class NetworkAnimValue(object):
    """
    hou.NetworkAnimValue
    
    A value to adjust the appearance of a network editor without changing
    the underlying node data.
    
    The hou.NetworkEditor pane allows network items to be moved or resized
    by user interactions without actually changing the node positions or
    sizes. This is accomplished by associating each NetworkAnimValue with a
    network item through the hou.NetworkEditor.setAdjustments method.
    NetworkAnimValues can either represent a single value, or they can
    represent an animation from one value to another. The actual animation
    is displayed automatically by the network editor.
    
    For example, to following code would animate the position of a couple of
    nodes:
    
    > >>> editor = hou.ui.paneTabOfType(hou.paneTabType.NetworkEditor)
    > >>> n1 = hou.node('/obj/geo1')
    > >>> pos1 = n1.position()
    > >>> newpos1 = pos1 + hou.Vector2(5, 5)
    > >>> anim1 = hou.NetworkAnimValue(1.0, pos1, newpos1)
    > >>> n2 = hou.node('/obj/geo2')
    > >>> pos2 = n2.position()
    > >>> newpos2 = pos2 + hou.Vector2(5, 5)
    > >>> anim2 = hou.NetworkAnimValue(1.0, pos2, newpos2)
    > >>> editor.setAdjustments([n1, n2], [anim1, anim2], auto_remove=True)
    > >>> n1.setPosition(newpos1)
    > >>> n2.setPosition(newpos2)
    
    Note that the new positions are set on the nodes immediately. But the
    animation starts them at their original positions, and makes it look
    like they move slowly to their new positions. Also note that the
    auto_remove parameter in the call to setAdjustments() has been set to
    True. This is because we are using the adjustments only to animate the
    nodes to their new positions, which have already been set. Once the
    animation is complete, the adjustments can be thrown away. Without this
    parameter, the adjustments would remain on the network editor until the
    next call the setAdjustments.
    
    
    """

def NetworkAnimValue_swigregister():
    """None"""
    pass
    

class NetworkBox(NetworkMovableItem):
    """
    hou.NetworkBox
    
    Represents a network box.
    
    To create a network box, use the hou.Node.createNetworkBox method on the
    node inside which you want to create the box. To get an existing network
    box, use the hou.Node.findNetworkBox method on the node containing the
    network box. To get a list of all network boxes in a network, use the
    hou.Node.networkBoxes method on the containing node.
    
    REPLACES
    
    * nbcolor
    
    * nbget
    
    * nblocate
    
    * nbls
    
    * nblsop
    
    * nbname
    
    * nbop
    
    * nbrm
    
    * nbset
    
    * nbsize
    
    * opscript
    
    
    """
    
    def comment():
        """
        comment(self) -> str
        
        Returns the comment for this network box.
        
        
        """
        pass
        
    
    def setAutoFit(auto_fit):
        """
        setAutoFit(self, auto_fit)
        
        Set the value of the auto fit flag on this network box. The default
        value is True which causes the network box to resize itself when
        nodes that belong to the network box are moved outside the bounds of
        the box. Setting this values to False prevents this automatic
        resizing. The Network View will draw the network box around it's
        contents in any case. The default setting of True is primarily
        useful for backward compatibility with the old network editor which
        relies on this automatic resizing to draw the network box properly.
        
        
        """
        pass
        
    
    def removeSubnetIndirectInput(indirect):
        """
        removeSubnetIndirectInput(self, indirect)
        
        Removes the given indirect input from the network box. This method
        if deprecated. Use hou.NetworkBox.removeItem instead.
        
        
        """
        pass
        
    
    def removeAllItems():
        """
        removeAllItems(self)
        
        Removes all items from the network box.
        
        
        """
        pass
        
    
    def setComment(comment):
        """
        setComment(self, comment)
        
        Set the comment string for this network box. This comment is visible
        in the network editor and can be used to describe the purpose of the
        box.
        
        
        """
        pass
        
    
    def restoredSize():
        """
        restoredSize(self) -> hou.Vector2
        
        Return the size of this item's tile in the network editor graph if
        it is not minimized. Returned as a Vector2.
        
        
        """
        pass
        
    
    def minimizedSize():
        """
        minimizedSize(self) -> hou.Vector2
        
        Return the size of this item's tile in the network editor graph if
        it is minimized. Returned as a Vector2.
        
        
        """
        pass
        
    
    def addStickyNote(stickynote):
        """
        addStickyNote(self, stickynote)
        
        Adds a hou.StickyNote to the network box. This method is deprecated.
        Use hou.NetworkBox.addItem instead.
        
        
        """
        pass
        
    
    def removeNode(node):
        """
        removeNode(self, node)
        
        Removes the given node from the network box. This method if
        deprecated. Use hou.NetworkBox.removeItem instead.
        
        
        """
        pass
        
    
    def setMinimized(on):
        """
        setMinimized(self, on)
        
        Minimizes or restores the network box.
        
        
        """
        pass
        
    
    def addNetworkBox(netbox):
        """
        addNetworkBox(self, netbox)
        
        Adds a hou.NetworkDot to the network box. This method is deprecated.
        Use hou.NetworkBox.addItem instead.
        
        
        """
        pass
        
    
    def removeStickyNote(stickynote):
        """
        removeStickyNote(self, stickynote)
        
        Removes the given sticky note from the network box. This method if
        deprecated. Use hou.NetworkBox.removeItem instead.
        
        
        """
        pass
        
    
    def destroy(destroy_contents=False):
        """
        destroy(self, destroy_contents=False)
        
        Remove and delete the network box, optionally deleting the nodes it
        contains.
        
        
        """
        pass
        
    
    def nodes(recurse=True):
        """
        nodes(self, recurse=True) -> tuple of hou.Node
        
        Returns the nodes inside the network box.
        
        
        recurse
        If True, recurses down into nested network boxes.
        
        
        """
        pass
        
    
    def fitAroundContents():
        """
        fitAroundContents(self)
        
        Resizes the network box to fit its contents.
        
        
        """
        pass
        
    
    def setBounds(bounds):
        """
        setBounds(self, bounds)
        
        Sets the size and position of this sticky note to the given
        hou.BoundingRect bounds argument. Equivalent to calling setSize then
        setPosition.
        
        
        """
        pass
        
    
    def stickyNotes(recurse=True):
        """
        stickyNotes(self, recurse=True) -> tuple of hou.StickyNote
        
        Returns the sticky notes inside the network box.
        
        
        recurse
        If True, recurses down into nested network boxes.
        
        
        """
        pass
        
    
    def addNode(node):
        """
        addNode(self, node)
        
        Adds a hou.Node to the network box. This method is deprecated. Use
        hou.NetworkBox.addItem instead.
        
        
        """
        pass
        
    
    def addItem(item):
        """
        addItem(self, item)
        
        Adds a hou.NetworkMovableItem of any kind to the network box.
        
        
        """
        pass
        
    
    def subnetIndirectInputs(recurse=True):
        """
        subnetIndirectInputs(self, recurse=True) -> tuple of
        hou.SubnetIndirectInput
        
        Returns the subnet indirect inputs inside the network box.
        
        
        recurse
        If True, recurses down into nested network boxes.
        
        
        """
        pass
        
    
    def removeItem(item):
        """
        removeItem(self, item)
        
        Removes the given item from the network box.
        
        
        """
        pass
        
    
    def removeNetworkBox(netbox):
        """
        removeNetworkBox(self, netbox)
        
        Removes the given network box from the network box. This method if
        deprecated. Use hou.NetworkBox.removeItem instead.
        
        
        """
        pass
        
    
    def networkBoxes(recurse=True):
        """
        networkBoxes(self, recurse=True) -> tuple of hou.NetworkBox
        
        Returns the network boxes inside the network box.
        
        
        recurse
        If True, recurses down into nested network boxes.
        
        
        """
        pass
        
    
    def resize(vector2):
        """
        resize(self, vector2)
        
        Resizes a network box by the increments in the given hou.Vector2.
        Use setSize() to set the box's absolute size.
        
        
        """
        pass
        
    
    def removeAllNodes():
        """
        removeAllNodes(self)
        
        Removes all nodes from the network box. This method if deprecated.
        Use hou.NetworkBox.removaAllItems or hou.NetworkBox.removeItems
        instead.
        
        
        """
        pass
        
    
    def isMinimized():
        """
        isMinimized(self) -> bool
        
        Returns whether the network box is minimized.
        
        
        """
        pass
        
    
    def items(recurse=True):
        """
        items(self, recurse=True) -> tuple of hou.NetworkMovableItem
        
        Returns the items of any type inside the network box.
        
        
        recurse
        If True, recurses down into nested network boxes.
        
        
        """
        pass
        
    
    def autoFit():
        """
        autoFit(self) -> bool
        
        Returns the value of the auto fit flag on this network box.
        
        
        """
        pass
        
    
    def asCode(brief=False, recurse=False, save_box_contents=False, save_channels_only=False, save_creation_commands=False, save_keys_in_frames=False, save_parm_values_only=False, save_spare_parms=False, function_name=None):
        """
        asCode(self, brief=False, recurse=False, save_box_contents=False,
        save_channels_only=False, save_creation_commands=False,
        save_keys_in_frames=False, save_parm_values_only=False,
        save_spare_parms=False, function_name=None) -> string
        
        Prints the Python code necessary to recreate a network box.
        
        See hou.Node.asCode for information on the keyword arguments.
        
        
        """
        pass
        
    
    def addSubnetIndirectInput(indirect):
        """
        addSubnetIndirectInput(self, indirect)
        
        Adds a hou.SubnetIndirectInput to the network box. This method is
        deprecated. Use hou.NetworkBox.addItem instead.
        
        
        """
        pass
        
    
    def setSize(size):
        """
        setSize(self, size)
        
        Sets the size of this network box to the given hou.Vector2 size
        parameter. Use resize() to set the box's size relative to its
        current size.
        
        
        """
        pass
        

def NetworkBox_swigregister():
    """None"""
    pass
    

class NetworkDot(IndirectInput):
    """
    hou.NetworkDot
    
    A small dot in a network that allows wires to be routed along specific
    paths without affecting the data passing through them.
    
    Network dots are allowed to have a single input, but may have many
    outputs. They can be moved around to force a wire connecting two nodes
    to follow a specific path. They can also be used as "scaffolding" for a
    set of nodes that you want to be able to quickly add or remove in a
    larger network.
    
    New dots are created by calling hou.Node.createNetworkDot on the node
    that will contain the dot. A list of all existing dots in a network can
    be generated by calling hou.Node.networkDots.
    
    
    """
    
    def isPinned():
        """
        isPinned(self) -> bool
        
        Returns the pinned state of this dot. See hou.NetworkDot.setPinned
        for a more detailed discussion of the meaning of a pinned dot.
        
        
        """
        pass
        
    
    def insertInput(self, input_index, item_to_become_input, output_index=0):
        """
        insertInput(self, input_index, item_to_become_input, output_index=0)
        
        Connects a network item to the input of this dot, exactly like the
        two parameter form of setInput. But this method name and signature
        matches the signature of hou.Node.insertInput, which allows code to
        run on either a network dot or a node. The value of the input_index
        is ignored.
        
        """
        pass
        
    
    def setInput(input_index, item_to_become_input, output_index=0):
        """
        setInput(self, input_index, item_to_become_input, output_index=0)
        
        Connects a network item to the input of this dot, exactly like the
        two parameter form of this function. But this second signature
        matches the signature of hou.Node.setInput, which allows code to run
        on either a network dot or a node. The value of the input_index is
        ignored.
        
        
        """
        pass
        
    
    def inputConnections():
        """
        inputConnections(self) -> tuple of hou.NodeConnection
        
        Returns a tuple of hou.NodeConnection objects for the connection
        coming into this dot. The tuple will have a length of one if
        anything is connected to the input of this dot. Returns an empty
        tuple if nothing is connected.
        
        
        """
        pass
        
    
    def destroy():
        """
        destroy(self)
        
        Delete this dot. Connections in and out of the dot are automatically
        re-established such that the behavior of the network will be
        unchanged by the removal of this dot.
        
        
        """
        pass
        
    
    def setPinned(pinned):
        """
        setPinned(self, pinned)
        
        Sets the boolean pinned state of this dot. Pinned dots are not
        functionally different from unpinned dots, but are treated
        differently by the network editor. A pinned dot remains even if its
        input and output connections are removed. An unpinned dot will be
        deleted automatically by the network editor if its input or last
        output is cut.
        
        The following code is a greatly simplified version of the code for
        automatically deleting unconnected dots, which will delete any dots
        that are not pinned and that don't have an input connection:
        
        > >>> net = hou.node('/obj')
        > >>> net.createNetworkDot().setPinned(False)
        > >>> net.createNetworkDot().setPinned(True)
        > >>> net.networkDots()
        > (<hou.NetworkDot dot1 in /obj>, <hou.NetworkDot dot2 in /obj>)
        > >>> for dot in net.networkDots():
        > ...   if not dot.isPinned():
        > ...     if dot.inputItem() is None:
        > ...       dot.destroy()
        > ...
        > >>> net.networkDots()
        > (<hou.NetworkDot dot2 in /obj>,)
        
        """
        pass
        

def NetworkDot_swigregister():
    """None"""
    pass
    

class NetworkEditor(PathBasedPaneTab):
    """
    hou.NetworkEditor
    
    Represents a Network Editor panetab.
    
    
    """
    
    def frameSelection(self):
        """
        frameSelection(self)
        
        Centers the nodes within the network editor to show the current
        selection and zooms to its extents. This method wraps a call to
        hou.NetworkEditor.setVisibleBounds.
        
        """
        pass
        
    
    def setTooltip(tooltip):
        """
        setTooltip(self, tooltip)
        
        Sets the tooltip string that should be shown under the mouse if it
        remains stationary for a short time. This string should generally be
        set to correspond to the network item currently under the mouse
        cursor. Because it appears after a delay, it is okay to make this
        text more verbose than the prompt text passed to setPromptText().
        
        
        """
        pass
        
    
    def setPreSelectedItems(items):
        """
        setPreSelectedItems(self, items)
        
        When box selecting items in the network, it is useful to be able to
        see what will be selected if the mouse button is released. These
        items are drawn to the overlay layer of the network editor canvas in
        a light blue color with transparency. The network items passed as a
        tuple to this method are the ones that get drawn with this pre-
        selection highlight.
        
        
        """
        pass
        
    
    def setPref(pref, value):
        """
        setPref(self, pref, value)
        
        Sets the preference named pref to value. The value is always a
        string, and must be converted to or from a number, enum, or other
        format as appropriate. If the preference specified by pref is a
        global preference, all network editors will automatically update
        with the new value. Otherwise the change will only affect this
        network editor.
        
        
        """
        pass
        
    
    def posFromScreen(pos):
        """
        posFromScreen(self, pos) -> hou.Vector2
        
        Given a position value pos as a hou.Vector2, expressed in screen
        units (pixels), return the equivalent position in network units. The
        result will depend on both the current zoom level and view position
        of the network editor.
        
        
        """
        pass
        
    
    def autoAddToNetbox(self, node):
        """
        autoAddToNetbox(self, node)
        
        This method is deprecated in the new network editor and does
        nothing.
        
        """
        pass
        
    
    def autoPlaceNodes(self):
        """
        autoPlaceNodes(self) -> bool
        
        This method is deprecated in the new network editor and always
        returns False.
        
        """
        pass
        
    
    def lengthFromScreen(len):
        """
        lengthFromScreen(self, len) -> float
        
        Given a length value len, expressed in screen units (pixels), return
        the equivalent length in network units. The result will depend on
        the current zoom level of the network editor.
        
        
        """
        pass
        
    
    def setListMode(self, on):
        """
        setListMode(self, on)
        
        Set the network editor to enter list mode if on is True and to exit
        list mode if on is False.
        
        """
        pass
        
    
    def setDropTargetItem(item, name, index):
        """
        setDropTargetItem(self, item, name, index)
        
        When the user is performing a drag and drop operation within the
        network editor, it is important that they receive some feedback
        about where the thing they are dragging will be dropped if they let
        go of the mouse button. This indication is provided by highlighting
        the drop target in the UI. This method allows the current drop
        target to be specified in python code. Usually the item, name, and
        index will be values returned in one of the tuples from the
        networkItemsInBox method.
        
        
        """
        pass
        
    
    def setCursorMap(cursors):
        """
        setCursorMap(self, cursors)
        
        Tells the network editor which mouse cursor to use based on what UI
        widget is under the mouse. This configuration is specified as a
        dictionary mapping a tuple to a string. The string is the name of
        the cursor, which can be any of the cursor file names from the
        $HFS/houdini/config/Cursors directory. Each tuple consists of a
        string and an integer. The string is the name of the UI widget, and
        the integer represents the specific index value within that UI
        widget.
        
        The following code sets the network editor to show a "connect"
        cursor for all node inputs and outputs:
        
        > >>> editor = hou.ui.paneTabOfType(hou.paneTabType.NetworkEditor)
        > >>> editor.setCursorMap({
        > ... ('input', -1): 'wire',
        > ... ('output', -1): 'wire'
        > ... })
        
        The following code sets the network editor to show an appropriate
        resize icon based on the specific section of the sticky note border
        under the mouse:
        
        > >>> editor = hou.ui.paneTabOfType(hou.paneTabType.NetworkEditor)
        > >>> editor.setCursorMap({
        > ... ('stickynoteborder', 0): 'arrowSWNE',
        > ... ('stickynoteborder', 1): 'arrowLeftRight',
        > ... ('stickynoteborder', 2): 'arrowNWSE',
        > ... ('stickynoteborder', 3): 'arrowUpDown',
        > ... ('stickynoteborder', 4): 'arrowSWNE',
        > ... ('stickynoteborder', 5): 'arrowLeftRight',
        > ... ('stickynoteborder', 6): 'arrowNWSE',
        > ... ('stickynoteborder', 7): 'arrowUpDown'
        > ... })
        
        """
        pass
        
    
    def prompt():
        """
        prompt(self) -> str
        
        Return the current prompt string. This is the value that was last
        passed to the setPromptText() method.
        
        
        """
        pass
        
    
    def isVolatileKeyDown(key):
        """
        isVolatileKeyDown(self, key) -> bool
        
        Return True if the specified keyboard key is currently pressed. This
        allows the current state of a volatile key to be tested without
        seeing the "keydown" event triggered when the user pressed the key.
        Calling this method with a key that has not been registered through
        the setVolatileKeys method will always return False even if the key
        is currently pressed. The key string is of the form returned by the
        hou.ui.hotkeys method, which is a combination of the symbol on the
        key, and any modifier keys involved, such as "Ctrl+Shift+G".
        
        
        """
        pass
        
    
    def badges():
        """
        badges(self) -> tuple of tuple of str
        
        Return descriptions of the optional node badges that can be shown in
        the network editor. Each tuple contained in the returned value
        contains three strings describing the badge. The first is the
        preference value that controls whether the badge is hidden, or
        appears as a small or large icon. The second string is a description
        of the badge. The third string is the name of the badge icon. These
        values can be used to present an interface for configuring the
        badges.
        
        
        """
        pass
        
    
    def scheduleTimerEvent(seconds):
        """
        scheduleTimerEvent(self, seconds) -> int
        
        Requests that a timer event be sent to the network editor after
        seconds has elapsed. The returned integer id is included in the
        triggered event to differentiate between timers if more than one is
        scheduled at a time.
        
        
        """
        pass
        
    
    def cursorPosition(confine_to_view=True):
        """
        cursorPosition(self, confine_to_view=True) -> hou.Vector2
        
        Return the current mouse cursor position expressed in network view
        coordinates. If confine_to_view is True, the returned value will be
        clipped to the area of the network currently visible in the network
        editor.
        
        Here is an example of moving a node underneath the mouse cursor:
        
        > # Get the network editor.
        > net_editor = hou.ui.paneTabOfType(hou.paneTabType.NetworkEditor)
        >
        > # Get the node.
        > node = hou.node("/obj/myNode")
        >
        > # Set the node's new position.
        > node.setPosition(net_editor.cursorPosition())
        
        """
        pass
        
    
    def nodeShapes():
        """
        nodeShapes(self) -> tuple of str
        
        Return a list of all valid node shape names. These are the values
        that can be set into the user data of a node to control the shape of
        a specific node. They are also the shape names that can be used as
        defaults for node types.
        
        This code sets a node to a random shape:
        
        > >>> import random
        > >>> editor = hou.ui.paneTabOfType(hou.paneTabType.NetworkEditor)
        > >>> shapes = editor.nodeShapes()
        > >>> hou.node('/obj/geo1').setUserData('nodeshape', random.choice(shapes))
        
        """
        pass
        
    
    def decorationInteractive():
        """
        decorationInteractive(self) -> bool
        
        Return whether the currently decorated item is interactive. This is
        just the interactive value passed into the last call to
        setDecoratedItem.
        
        
        """
        pass
        
    
    def reloadNodeShapes():
        """
        reloadNodeShapes(self) -> tuple of str
        
        Forces all node shape files to be reloaded. This may cause new
        shapes to become available, or existing shapes to be removed.
        Returns a tuple of strings that indicate the name of each loaded
        node shape, and any error messages generated while parsing each
        shape. Use nodeShapes() to get a simple list of all successfully
        loaded shapes after calling this method.
        
        
        """
        pass
        
    
    def decoratedItem():
        """
        decoratedItem(self) -> hou.NetworkItem
        
        Return the currently set decorated item. This is just the item value
        passed into the last call to setDecoratedItem.
        
        
        """
        pass
        
    
    def textBadges():
        """
        textBadges(self) -> tuple of tuple of str
        
        Return descriptions of the optional node text that can be shown in
        the network editor. Each tuple contained in the returned value
        contains three strings describing the text. The first is the
        preference value that controls whether the text is hidden, or
        appears as truncated or full text. The second string is a
        description of the text. The third string is the name of an icon
        that can be used to represent the meaning of the text. These values
        can be used to present an interface for configuring the text.
        
        
        """
        pass
        
    
    def sizeToScreen(size):
        """
        sizeToScreen(self, size) -> hou.Vector2
        
        Given a box size value size as a hou.Vector2, expressed in network
        units, return the equivalent size in screen units (pixels). This is
        equivalent to making two separate calls to lengthToScreen() for the
        width and height. The result will depend on the current zoom level
        of the network editor.
        
        
        """
        pass
        
    
    def setDecoratedItem(item, interactive):
        """
        setDecoratedItem(self, item, interactive)
        
        This method is similar to setDropTargetItem in that it tells the
        network editor to highlight a particular item when drawing it. In
        the case of the decorated item, however, only the network item needs
        to be provided. The result of setting a node as the decorated item
        is to bring up the node ring. Network dots may also be the decorated
        item, in which case the input and output connectors for the dot are
        shown. The interactive boolean flag indicates whether the user is
        allowed to interact with the decorations. If not, the node ring is
        drawn faded, and its buttons cannot be clicked. This non-interactive
        mode corresponds to having the Control key pressed while moving the
        mouse around the network editor.
        
        
        """
        pass
        
    
    def listMode(self):
        """
        listMode(self) -> bool
        
        Return True if the network editor is in list mode and False
        otherwise.
        
        """
        pass
        
    
    def openNoteEditor(stickynote, select_all, =, False):
        """
        openNoteEditor(self, stickynote, select_all = False) -> int
        
        Opens an input field for editing the text of the sticky note
        specified in the stickynote parameter. Returns an integer id which
        is passed to the network editor as part of an event indicating when
        the user finishes editing the text.
        
        If select_all is set to True, the editor is opened with all text
        selected.
        
        
        """
        pass
        
    
    def openTabMenu(key=None, auto_place=False, branch=False, src_item=None, src_connector_index=-1, dest_item=None, dest_connector_index=-1, node_position=None, src_items=[], src_indexes=[], dest_items=[], dest_indexes=[]):
        """
        openTabMenu(self, key=None, auto_place=False, branch=False,
        src_item=None, src_connector_index=-1, dest_item=None,
        dest_connector_index=-1, node_position=None, src_items=[],
        src_indexes=[], dest_items=[], dest_indexes=[])
        
        Opens the tab menu in the network editor. When the user chooses a
        tool from the tab menu, the parameters passed to this function
        determine the context information that will be sent to the tool
        script. Generally, most tools treat these parameters in a consistent
        way as described below.
        
        
        key
        The key used (if any) to open the menu. This same key pressed
        with the menu up will cause the menu to close.
        
        auto_place
        Set to True to make the tab menu turn on auto placement when a
        tool is chosen from the menu. The new node will be placed at a
        position determined automatically by the tab menu based on the
        source and destination nodes.
        
        branch
        Set to True to cause the new node to create a new branch instead
        of inserting the new node between the source and destination
        nodes.
        
        src_item
        The node, dot, or subnet indirect input that will be connected
        to the input of the new node created by the tab menu.
        
        src_item_connector_index
        The output index of the node that will be connected to the input
        of the new node created by the tab menu.
        
        dest_item
        The node or dot that will be connected to the output of the new
        node created by the tab menu.
        
        dest_connector_index
        The input index of the node or dot that will be connected to the
        output of the new node created by the tab menu.
        
        node_position
        The location to use for the new node created by the tab menu.
        
        src_items
        A list of nodes, dot, or subnet indirect inputs that will be
        connected to the input of the new node created by the tab menu.
        This parameter (and all other list-based source and destination
        paramaters) take precedence over the single item parameters if
        both are specified.
        
        src_item_connector_indexes
        A list of output indexes of the nodes that will be connected to
        the input of the new node created by the tab menu.
        
        dest_items
        A list of nodes or dots that will be connected to the output of
        the new node created by the tab menu.
        
        dest_connector_indexes
        A list of input indexes of the nodes or dots that will be
        connected to the output of the new node created by the tab menu.
        
        
        """
        pass
        
    
    def openVopEffectsMenu(node, input_index):
        """
        openVopEffectsMenu(self, node, input_index)
        
        Brings up the VOP node effects menu for the hou.VopNode specified in
        the node parameter, at the input specified by the input_index
        parameter.
        
        
        """
        pass
        
    
    def setCursorPosition(pos):
        """
        setCursorPosition(self, pos)
        
        Moves the mouse cursor to the position specified by the hou.Vector2
        pos parameter.
        
        
        """
        pass
        
    
    def getPref(pref):
        """
        getPref(self, pref) -> str
        
        Return the value of the preference named pref. This preference may
        be a global or local preference. The returned value is always a
        string which can be interpreted as a number or other data structure
        as appropriate for the specific preference.
        
        
        """
        pass
        
    
    def setPrompt(prompt):
        """
        setPrompt(self, prompt)
        
        Sets the prompt text that appears at the bottom of the network
        editor. This string should generally be set to correspond to the
        network item currently under the mouse cursor. This text should be
        fairly brief. More detailed information can be put into the tooltip
        through the setTooltip() method.
        
        
        """
        pass
        
    
    def getPrefs():
        """
        getPrefs(self) -> dict of str to str
        
        Return all global and local preferences for this network editor as a
        python dictionary mapping preference name strings to value strings.
        
        
        """
        pass
        
    
    def setDefaultCursor(cursor_name):
        """
        setDefaultCursor(self, cursor_name)
        
        Tells the network editor which mouse cursor to use when none of the
        UI mentioned in the dictionary sent to setCursorMap() is under the
        mouse.
        
        
        """
        pass
        
    
    def openCommentEditor(item, select_all, =, False):
        """
        openCommentEditor(self, item, select_all = False) -> int
        
        Opens an input field for editing the comment of the network box
        specified in the item parameter. Returns an integer id which is
        passed to the network editor as part of an event indicating when the
        user finishes editing the text.
        
        If select_all is set to True, the editor is opened with all text
        selected.
        
        
        """
        pass
        
    
    def itemOutputPos(item, output_index, adjusted=True):
        """
        itemOutputPos(self, item, output_index, adjusted=True) -> hou.Vector2
        
        Return the center point of the output connector of the hou.Node,
        hou.NetworkDot, or hou.SubnetIndirectInput specified by item. The
        output_index parameter specifies the specific output of interest.
        For network dots and subnet indirect inputs, this value must be
        zero. If the adjusted parameter is set to True, any adjustments to
        this item's size and position set in the most recent call to
        setAdjustments() will be taken into account. If False, these
        adjustments will be ignored.
        
        
        """
        pass
        
    
    def selectPosition(self, input_node=None, output_index=0, output_node=None, input_index=0):
        """
        selectPosition(self, input_node=None, output_index=0, output_node=None,
        input_index=0) -> hou.Vector2
        
        This method wraps a call to hou.NetworkEditor.pushEventContext, with
        the event context set to 'nodegraphselectpos', and appropriate
        context data to give behavior similar to the old network editor.
        
        Prompt the user to select a position in the network editor for a new
        node to be placed. The network editor visualizes the position with a
        dotted outline of a node placeholder. The user can then move the
        mouse to change the position and [LMB] to confirm. The user can also
        press [Esc] instead to cancel the selection.
        
        You can optionally pass in hou.Node objects to the input_node and
        output_node arguments to visualize the node placeholder with
        connections to the specified input and output nodes.
        
        Return a hou.Vector2 containing the x,y coordinates of the selected
        position.
        
        Raise hou.OperationInterrupted if the user canceled the selection.
        Raise hou.OperationFailed if the network editor is in list mode.
        
        This method can be useful for scripts that create new nodes and
        prompts for node positions. Here is an example:
        
        >
        > # Get the input and output nodes that the new node will connect to.
        > input_node = hou.node("/obj/myInput")
        > output_node = hou.node("/obj/myOutput")
        >
        > # Set the new node to connect to the first output of the input node
        > # and the second input of the output node.
        > output_index = 0
        > input_index = 1
        >
        > # Get the network editor.
        > network_editor = hou.ui.curDesktop().paneTabOfType(
        >     hou.paneTabType.NetworkEditor)
        >
        > # Prompt the user to select a position for the new node.
        > position = network_editor.selectPosition(
        >     input_node, output_index, output_node, input_index)
        >
        > # Create the new node.
        > new_node = hou.node("/obj").createNode("geo")
        >
        > # Position the new node and wire it to the input and output nodes.
        > new_node.move(position)
        > new_node.setInput(0, input_node, output_index)
        > output_node.setInput(input_index, new_node, 0)
        """
        pass
        
    
    def insertIntoUnderlyingConnections(self, node, x, y):
        """
        insertIntoUnderlyingConnections(self, node, x, y)
        
        This method is deprecated in the new network editor and does
        nothing.
        
        """
        pass
        
    
    def redraw():
        """
        redraw(self)
        
        Forces the network editor to redraw. This may be necessary in cases
        where your code updates aspects of your Houdini session which
        indirectly affect the drawing of the network editor (such as
        changing default node shapes and colors). Direct changes to the
        network (such as changing the shape or color of a specific node)
        should automatically cause the network editor to redraw. Only use
        this function when you see that a redraw is not being triggered
        automatically by the your code.
        
        
        """
        pass
        
    
    def cursorMap():
        """
        cursorMap(self) -> dict of (str, int) to str
        
        Return the current mouse cursor configuration. This will just be the
        dictionary passed into the last call to setCursorMap.
        
        
        """
        pass
        
    
    def autoScrollNodes(self):
        """
        autoScrollNodes(self) -> bool
        
        This method is deprecated in the new network editor and always
        returns False.
        
        """
        pass
        
    
    def defaultCursor():
        """
        defaultCursor(self) -> str
        
        Return the default mouse cursor set by the last call to
        setDefaultCursor().
        
        
        """
        pass
        
    
    def allVisibleRects(ignore_items):
        """
        allVisibleRects(self, ignore_items) -> tuple of (hou.NetworkMovableItem,
        hou.BoundingRect)
        
        This method is equivalent to calling itemRect() for every network
        item that is currently visible in the network editor. Getting these
        results in a single method call is significantly faster, and
        eliminates the need to test each item for visibility. This method is
        used for finding items to snap against when moving nodes. The
        ignore_items parameter is a tuple of hou.NetworkMovableItem objects
        that should not be returned in the result tuple.
        
        
        """
        pass
        
    
    def overviewPosFromScreen(pos):
        """
        overviewPosFromScreen(self, pos) -> hou.Vector2
        
        Given a position value pos as a hou.Vector2, expressed in screen
        units (pixels) within the overview gadget, return the equivalent
        position in network units. This method returns a value that assumes
        the overview area is visible, even if it is not. If the provided
        position is outside the overview area, this method returns a value
        that assumes the overview gadget extends as far as required to reach
        the specified coordinates.
        
        
        """
        pass
        
    
    def itemInputDir(item, input_index):
        """
        itemInputDir(self, item, input_index) -> hou.Vector2
        
        Return a normalized vector indicating the direction at which the
        wire connected to the specified input should emerge from its
        connector. The item parameter may be a hou.Node or hou.NetworkDot.
        The input_index specifies which input is of interest. This value
        must be zero if the item is a network dot.
        
        
        """
        pass
        
    
    def networkItemsInBox(pos1, pos2, for_drop=False, for_select=False):
        """
        networkItemsInBox(self, pos1, pos2, for_drop=False, for_select=False) ->
        tuple of (hou.NetworkItem, str, int)
        
        Return any network items inside the bounding box defined by the
        hou.Vector2 points pos1 and pos2. These points are specified in
        screen space, which makes it easy to call this function given a
        mouse position.
        
        The returned tuple of triples are sorted in increasing distance from
        the center of the specified bounding box. Each triple consists of a
        network item (which may be a node, sticky note, wire, etc.), a
        string which describes the part of the UI for that item that was
        found in the box, and an optional index value which differentiates
        between different instances of the same item/name combination. For
        example, if the connector for input 2 of the node geo1 was the only
        thing inside the provided box, the return value would be:
        
        > >>> editor = hou.ui.paneTabOfType(hou.paneTabType.NetworkEditor)
        > >>> editor.networkItemsInBox(pos1, pos2)
        > ((<hou.ObjNode of type subnet at /obj/subnet1>, 'input', 2),)
        
        One of for_drop or for_select may be set to True to use a different
        criteria for deciding what a valid target is. By default, any UI
        widget that highlights with the mouse over it will be returned by
        this method. Setting for_drop to True will return only UI widgets
        that can be drop targets. Setting for_select to True will only
        return UI widgets that result in the item being selected when box
        picking.
        
        
        """
        pass
        
    
    def itemOutputDir(item, output_index):
        """
        itemOutputDir(self, item, output_index) -> hou.Vector2
        
        Return a normalized vector indicating the direction at which the
        wire connected to the specified output should emerge from its
        connector. The item parameter may be a hou.Node, hou.NetworkDot, or
        hou.SubnetIndirectInput. The output_index specifies which output is
        of interest. This value must be zero if the item is a network dot or
        subnet indirect input.
        
        
        """
        pass
        
    
    def setVolatileKeys(keys):
        """
        setVolatileKeys(self, keys)
        
        The keys parameter specifies a tuple of keyboard keys that should be
        processed as volatile keys. This means they generate a "keydown"
        event when the key is pressed, and a "keyup" event when the key is
        released. All other keys simply send a "keyhit" event after the key
        is released, with no notification when the key is first pressed. The
        key strings are of the form returned by the hou.ui.hotkeys method,
        which is a combination of the symbol on the key, and any modifier
        keys involved, such as "Ctrl+Shift+G".
        
        
        """
        pass
        
    
    def backgroundImages():
        """
        backgroundImages(self) -> tuple of hou.NetworkImage
        
        Return the descriptors for the current set of background images
        being displayed in the network editor. This will be the tuple passed
        into the last call to setBackgroundImages.
        
        
        """
        pass
        
    
    def setPrefs(prefs):
        """
        setPrefs(self, prefs)
        
        Sets a number of preference values with a single method call. The
        prefs parameter must be a python dictionary mapping preference name
        strings to value strings. The preferences may be local or global,
        but this method is most often used for saving and loading the local
        preferences for a single network editor.
        
        
        """
        pass
        
    
    def isPosInside(pos):
        """
        isPosInside(self, pos) -> bool
        
        Return True if the hou.Vector2 passed as the pos parameter is inside
        the network view. The values in pos are mouse coordinates expressed
        relative to the network editor pane.
        
        
        """
        pass
        
    
    def visibleBounds():
        """
        visibleBounds(self) -> hou.BoundingRect
        
        Return the network space bounds of the network editor viewing area.
        
        
        """
        pass
        
    
    def modifyPositionForNode(self, vector2, node):
        """
        modifyPositionForNode(self, vector2, node) -> Vector2
        
        This method is deprecated in the new network editor, and simply
        returns the position passed into the function.
        
        """
        pass
        
    
    def registerPref(pref, value, global):
        """
        registerPref(self, pref, value, global)
        
        Registers a preference with the name pref, and default value value.
        If global is True, this preference is treated as a global preference
        that is applied to all network editors and saved in
        $HOUDINI_USER_PREF_DIR/networkeditor.pref. Otherwise the preference
        is considered local to each network editor, and will be saved to the
        desk file with each network editor instance.
        
        Registering a preference is required to ensure the preference is
        saved when it is not a preference used internally by the network
        editor. The preference that enables snapping, or the one to enable
        dropping a node onto an existing wire are examples of preferences
        that are only used by the python event handling code, and so must be
        explicitly registered. This registration should be done in response
        to the network editor initialization event which is sent once to
        each network editor when it is first created.
        
        
        """
        pass
        
    
    def isShowingConnectors():
        """
        isShowingConnectors(self) -> bool
        
        Return True if the network editor zoom level is high enough that
        input and output connectors are visible. This can be useful in
        network editor event handlers that expect the user to click on a
        connector. If the connectors are not visible, some alternative
        interaction is required.
        
        
        """
        pass
        
    
    def preSelectedItems():
        """
        preSelectedItems(self) -> tuple of hou.NetworkItem
        
        Return the currently pre-selected items. These are just the values
        passed into the last call to setPreSelectedItems.
        
        
        """
        pass
        
    
    def overviewPosToScreen(pos):
        """
        overviewPosToScreen(self, pos) -> hou.Vector2
        
        Given a position value pos as a hou.Vector2, expressed in network
        units, return the equivalent position in screen units (pixels)
        within the overview gadget in the network editor. This method
        returns a value that assumes the overview area is visible, even if
        it is not.
        
        
        """
        pass
        
    
    def sizeFromScreen(size):
        """
        sizeFromScreen(self, size) -> hou.Vector2
        
        Given a box size value size as a hou.Vector2, expressed in screen
        units (pixels), return the equivalent size in network units. This is
        equivalent to making two separate calls to lengthFromScreen() for
        the width and height. The result will depend on the current zoom
        level of the network editor.
        
        
        """
        pass
        
    
    def dropTargetItem():
        """
        dropTargetItem(self) -> (hou.NetworkItem, str, int)
        
        Return the currently set drop target item information. These are
        just the values passed into the last call to setDropTargetItem.
        
        
        """
        pass
        
    
    def setFootprints(footprints):
        """
        setFootprints(self, footprints)
        
        Configure the footprint rings that the network editor should
        display. The footprints parameter must be a tuple of
        hou.NetworkFootprint objects. See that class for more information.
        
        
        """
        pass
        
    
    def tooltip():
        """
        tooltip(self) -> str
        
        Return the current tooltip string. This is the value that was last
        passed to the setTooltip() method.
        
        
        """
        pass
        
    
    def setBackgroundImages(images):
        """
        setBackgroundImages(self, images)
        
        Configures the background images to be displayed in the network
        editor. The network editor saves and loads the image descriptions
        into the user data for each network, which allows a different set of
        background images for each network. The images are specified as a
        tuple of hou.NetworkImage objects. See the documentation of that
        class for more information.
        
        
        """
        pass
        
    
    def locatingEnabled():
        """
        locatingEnabled(self) -> bool
        
        Return True if the network editor will highlight UI elements under
        the mouse, and allow clicking on those UI elements.
        
        
        """
        pass
        
    
    def itemInputPos(item, input_index, adjusted=True):
        """
        itemInputPos(self, item, input_index, adjusted=True) -> hou.Vector2
        
        Return the center point of the input connector of the hou.Node or
        hou.NetworkDot specified by item. The input_index parameter
        specifies the specific input of interest. For network dots, this
        value must be zero. If the adjusted parameter is set to True, any
        adjustments to this item's size and position set in the most recent
        call to setAdjustments() will be taken into account. If False, these
        adjustments will be ignored.
        
        
        """
        pass
        
    
    def closeTextEditor(id, apply_changes, =, True):
        """
        closeTextEditor(self, id, apply_changes = True)
        
        Immediately closes and commits any changes made to input fields
        opened with the openNameEditor(), openCommentEditor(), or
        openNoteEditor() methods. The id parameter is the value returned by
        the method that opened the editor. Set the apply_changes parameter
        to False if the changes made to the input field should not be
        applied.
        
        
        """
        pass
        
    
    def lengthToScreen(len):
        """
        lengthToScreen(self, len) -> float
        
        Given a length value len, expressed in network units, return the
        equivalent length in screen units (pixels). The result will depend
        on the current zoom level of the network editor.
        
        
        """
        pass
        
    
    def networkBoxPendingRemovals():
        """
        networkBoxPendingRemovals(self) -> tuple of hou.NetworkMovableItem
        
        Return the items currently pending remove from their network box.
        These are just the values passed into the last call to
        setNetworkBoxPendingRemovals.
        
        
        """
        pass
        
    
    def screenBounds():
        """
        screenBounds(self) -> hou.BoundingRect
        
        Return the screen space bounds of the network editor viewing area.
        This does not include the menu bar, toolbar, or other UI elements.
        Only the area where the network contents are displayed is returned.
        The bounds are relative to the network area itself, so the lower
        left corner of the returned bounding box will always be (0, 0).
        
        
        """
        pass
        
    
    def setOverlayShapes(shapes):
        """
        setOverlayShapes(self, shapes)
        
        The shapes parameter specifies a tuple of hou.NetworkShape objects
        which will be drawn into the overlay layer of the network editor
        canvas. See documentation of the network shape class and its
        subclasses for more information.
        
        
        """
        pass
        
    
    def setVisibleBounds(bounds, transition_time=0.0, max_scale=0.0, set_center_when_scale_rejected=False):
        """
        setVisibleBounds(self, bounds, transition_time=0.0, max_scale=0.0,
        set_center_when_scale_rejected=False)
        
        Sets the visible bounds of the network editor viewing area,
        expressed in network space coordinates. This method will never alter
        the screen space size or location of the network editor. If the area
        specified by the bounds parameter has a different aspect ratio from
        the actual network editor, this method will automatically adjust the
        bounds to ensure that the area specified is fully visible.
        
        
        bounds
        A hou.BoundingRect specifying the area that should be visible in
        the network editor.
        
        transition_time
        The amount of time, in seconds, over which the network editor
        will animate the transition from the current visible bounds to
        the new visible bounds.
        
        max_scale
        If set to a non-zero value, this parameter controls the maximum
        zoom level that will be allowed. The default maximum scale used
        by the network editor code is 100.
        
        set_centered_when_scale_rejected
        If set to True, but the new zoom level is determined to be the
        same as the previous zoom, no change is made to the bounds at
        all. This prevents a bounds change, that was intended as a pure
        zoom, from inadvertently panning the view if the zoom doesn't
        actually change.
        
        
        """
        pass
        
    
    def setLocatingEnabled(enabled):
        """
        setLocatingEnabled(self, enabled)
        
        Enables or disables highlighting of UI elements under the mouse in
        the network editor. When disabled, mouse events sent to the network
        editor event processing code will never specify a located or
        selected UI element. In some modes (such as when in a viewing state
        where mouse events only modify the view) it is desirable to disable
        this behavior.
        
        
        """
        pass
        
    
    def footprints():
        """
        footprints(self) -> tuple of hou.NetworkFootprint
        
        Return the current footprint configuration as a tuple of
        hou.NetworkFootprint objects. These are just the values passed into
        the last call to setFootprints.
        
        
        """
        pass
        
    
    def overviewVisibleIfAutomatic():
        """
        overviewVisibleIfAutomatic(self) -> bool
        
        Return a boolean indicating whether or not the overview gadget would
        currently be visible if it was configured to display automatically.
        In other words, this method returns True if any part of the network
        is currently outside the visible bounds of the editor.
        
        
        """
        pass
        
    
    def eventContextData():
        """None"""
        pass
        
    
    def handleCurrentKeyboardEvent(resend=False):
        """
        handleCurrentKeyboardEvent(self, resend=False)
        
        Requests that the network editor handle the current keyboard event.
        This method only makes sense when handling a keyboard event.
        
        If the resend parameter is set to True, the keyboard event is sent
        to the network editor's python handling code a second time rather
        than the network editor handling the keyboard event itself. This is
        useful if the network editor is in a state or mode that does not
        know how to handle a key, but which the state recognizes as one that
        should exit the current state, and possibly trigger some other
        python event handling code. This parameter is used in the state for
        selecting the position of a new node if the Tab key is pressed
        (which exits the positions selection state, and triggers a new Tab
        menu instead).
        
        If this method is not called when handling a keyboard event, the
        network editor assumes that the python event handling code has
        handled the keyboard event.
        
        
        """
        pass
        
    
    def openNodeMenu(node, =, None, items, =, []):
        """
        openNodeMenu(self, node = None, items = [])
        
        Brings up a node context menu under the current mouse position. The
        two parameters contol which node(s) will be affected by the menu
        option chosen by the user. If a hou.Node object is specified in the
        node parameter, the menu operation will affect that node, and, if
        that node is currently selected, all other selected network items
        will also be affected. If the items parameter is passed a non-empty
        list of hou.NetworkMovableItem objects, those items and only those
        items will be affected by the menu, regardless of the current
        selection.
        
        If the chosen menu item only operates on a single node, the original
        node parameter value or the last hou.Node object in the items list
        will be affected. If the selected menu item can affect multiple
        nodes, all nodes will be affected. And in the few cases where
        network items other than nodes may be altered by a menu item, all
        items (nodes or otherwise) will be affected.
        
        
        """
        pass
        
    
    def flashMessage(image, message, duration):
        """
        flashMessage(self, image, message, duration)
        
        Causes a message to appear briefly in the upper left corner of the
        network editor, then fade away. The image parameter specifies an
        icon or image file that should be displayed along with the text
        specified in the message parameter. Either of these parameters may
        be None if only an image or only text is desired. The duration
        parameter specifies the time in seconds before the message should
        fade away.
        
        
        """
        pass
        
    
    def popEventContext():
        """None"""
        pass
        
    
    def setDragSourceData(items):
        """
        setDragSourceData(self, items)
        
        Controls the network items that are put into the drag and drop
        buffer. The values in this buffer are only used when dragging items
        out of the network editor (such as when the user drags a node from
        the network editor onto a textport, or a parameter dialog.
        
        
        """
        pass
        
    
    def setShapes(shapes):
        """
        setShapes(self, shapes)
        
        The shapes parameter specifies a tuple of hou.NetworkShape objects
        which will be drawn into the network editor. See documentation of
        the network shape class and its subclasses for more information.
        
        
        """
        pass
        
    
    def homeToSelection(self):
        """
        homeToSelection(self)
        
        Centers the nodes within the network editor to show the current
        selection. This method wraps a call to
        hou.NetworkEditor.setVisibleBounds.
        
        """
        pass
        
    
    def setNetworkBoxPendingRemovals(items):
        """
        setNetworkBoxPendingRemovals(self, items)
        
        When moving items around the network, network boxes automatically
        resize to contain their child items as they move. To indicate that
        items will be removed from their network box, pass them as a tuple
        to this method. Doing so will cause their network box containers to
        not resize to fit the items as they move.
        
        
        """
        pass
        
    
    def setAdjustments(items, adjustments, auto_remove=False):
        """
        setAdjustments(self, items, adjustments, auto_remove=False)
        
        Configures temporary adjustments to the sizes and locations of
        network items in the editor. The items parameter is a tuple of
        hou.NetworkMovableItem objects. The adjustments parameter is a tuple
        of hou.NetworkAnimValue objects to associate with each network item
        in the items tuple. See the documentation of that class for more
        information about specifying adjustments.
        
        The auto_remove parameter may be set to True to indicate that the
        network editor should automatically delete the adjustments once the
        animation on them has completed. This is useful for animations
        performed at the end of a user action, where the following events do
        not relate to the changes being made, and so it is easier not to
        have to manage the reset of the adjustment values explicitly in the
        future.
        
        
        """
        pass
        
    
    def overviewVisible():
        """
        overviewVisible(self) -> bool
        
        Return a boolean indicating whether or not the overview gadget is
        currently visible. This result reflects the true state of the
        overview gadget even if the overview is configured to display
        automatically.
        
        
        """
        pass
        
    
    def itemRect(item, adjusted=True):
        """
        itemRect(self, item, adjusted=True) -> hou.BoundingRect
        
        Return the bounding rectangle of the hou.NetworkMovableItem
        specified by the item parameter. If the adjusted parameter is set to
        True, any adjustments to this item's size and position set in the
        most recent call to setAdjustments() will be taken into account. If
        False, these adjustments will be ignored. Note that for nodes, only
        the node body is taken into account, not the node name, badges, or
        other decorations.
        
        
        """
        pass
        
    
    def pushEventContext():
        """
        eventContextData(self) -> dict
        
        Accesses the context data passed into the most recent call to the
        hou.NetworkEditor.pushEventContext method. If no calls have been
        made to this method, there is still a python dict available to store
        any global information that may be used by the network editor event
        handling code. As an example, the current view bounds for each
        network visited by the editor are stored as part of this context
        data dictionary.
        
        
        """
        pass
        
    
    def openVopOutputInfoMenu(node, output_index):
        """
        openVopOutputInfoMenu(self, node, output_index)
        
        Brings up the VOP node output info menu for the hou.VopNode
        specified in the node parameter, at the output specified by the
        output_index parameter. This menu is used to control the behavior of
        the VOP node when the Debug or Bypass flags are enabled.
        
        
        """
        pass
        
    
    def openNameEditor(item, select_all, =, False):
        """
        openNameEditor(self, item, select_all = False) -> int
        
        Opens an input field for editing the name of the node specified in
        the item parameter. Returns an integer id which is passed to the
        network editor as part of an event indicating when the user finishes
        editing the text.
        
        If select_all is set to True, the editor is opened with all text
        selected.
        
        
        """
        pass
        
    
    def posToScreen(pos):
        """
        posToScreen(self, pos) -> hou.Vector2
        
        Given a position value pos as a hou.Vector2, expressed in network
        units, return the equivalent position in screen units (pixels). The
        result will depend on both the current zoom level and view position
        of the network editor.
        
        
        """
        pass
        

def NetworkEditor_swigregister():
    """None"""
    pass
    

class NetworkFootprint(object):
    """
    hou.NetworkFootprint
    
    Describes the conditions under which a footprint ring should be
    displayed for a node in a network editor pane.
    
    A footprint in the network editor is a ring drawn behind the node in the
    network editor, such as the blue "display flag" ring around the wave1
    node and the orange "output flag" ring around the wave2 node:
    
    
    This class describes to the network editor which nodes should be drawn
    with a footprint, and the color and position of that footprint. A tuple
    of these objects is passed to the hou.NetworkEditor.setFootprints
    method. This tuple should be updated every time the current network
    changes to a new node type category.
    
    The default footprint setup for SOP nodes is the following:
    
    > >>> editor = hou.ui.paneTabOfType(hou.paneTabType.NetworkEditor)
    > >>> editor.setFootprints([
    >         hou.NetworkFootprint(
    >             hou.nodeFlag.Display,
    >             hou.ui.colorFromName('GraphDisplayHighlight'), 1, True
    >         ),
    >         hou.NetworkFootprint(
    >             hou.nodeFlag.Render,
    >             hou.ui.colorFromName('GraphRenderHighlight'), 0, True
    >         ),
    >         hou.NetworkFootprint(
    >             hou.nodeFlag.Template,
    >             hou.ui.colorFromName('GraphTemplateHighlight'), 2, True
    >         ),
    >         hou.NetworkFootprint(
    >             hou.nodeFlag.Footprint,
    >             hou.ui.colorFromName('GraphTemplateHighlight'), 2, True
    >         ),
    >         hou.NetworkFootprint(
    >             'output',
    >             hou.ui.colorFromName('GraphOutputHighlight'), 1, True
    >         )
    >     ])
    
    """

def NetworkFootprint_swigregister():
    """None"""
    pass
    

class NetworkImage(object):
    """
    hou.NetworkImage
    
    Describes a background image that can be displayed in a network editor
    pane.
    
    The network editor pane can display any number of images in the
    background behind the nodes of the network. These background images are
    described using this class, and set in the network editor using the
    hou.NetworkEditor.setBackgroundImages method.
    
    This code sets a single background image in the network editor:
    
    >
    > editor = hou.ui.paneTabOfType(hou.paneTabType.NetworkEditor)
    > image = hou.NetworkImage()
    > image.setPath('$HFS/houdini/pic/Mandril.pic')
    > image.setRect(hou.BoundingRect(0, 0, 5, 5))
    > editor.setBackgroundImages([image])
    
    The network editor pane provides a mode for creating and editing
    background images directly in the pane. The resulting image layout is
    saved into the user data for the current network so that the image
    arrangement is automatically saved and restored with the hip file.
    
    
    """
    
    def setBrightness(brightness):
        """
        setBrightness(self, brightness)
        
        Sets the brightness adjustment for displaying this image in the
        network editor. This value should range from 0 to 1. Values less
        than 1 cause the image to be blended with the background of the
        network editor. An image with a brightness of 0 will appear as the
        background color, not black as is normally indicated by a brightness
        value of 0.
        
        
        """
        pass
        
    
    def setRelativeToPath(path):
        """
        setRelativeToPath(self, path)
        
        Images can be tied to network items such as nodes, network boxes, or
        sticky notes. This method sets the path to the network item to which
        this image is tied. Passing in an empty string indicates the
        location is not relative to any network item.
        
        
        """
        pass
        
    
    def path():
        """
        path(self) -> str
        
        Return the path to the image file.
        
        
        """
        pass
        
    
    def rect():
        """
        rect(self) -> hou.BoundingRect
        
        Returns the bounding rectangle that defines the size and position of
        the image within the network. If the relativeToPath() value is set,
        then the rectangle is translated by the position of the network item
        to which this image is tied.
        
        
        """
        pass
        
    
    def brightness():
        """
        brightness(self) -> float
        
        Return the brightness adjustment for displaying this image in the
        network editor. This value should range from 0 to 1. Values less
        than 1 cause the image to be blended with the background of the
        network editor. An image with a brightness of 0 will appear as the
        background color, not black as is normally indicated by a brightness
        value of 0.
        
        
        """
        pass
        
    
    def relativeToPath():
        """
        relativeToPath(self) -> str
        
        Images can be tied to network items such as nodes, network boxes, or
        sticky notes. This method returns the path to the network item to
        which this image is tied (or an empty string if its location is not
        relative to any network item).
        
        
        """
        pass
        
    
    def setPath(path):
        """
        setPath(self, path)
        
        Sets the path to the image file.
        
        
        """
        pass
        
    
    def setRect(rect):
        """
        setRect(self, rect)
        
        Sets the bounding rectangle that defines the size and position of
        the image within the network. If the relativeToPath() value is set,
        then the rectangle will be translated by the position of the network
        item to which this image is tied.
        
        
        """
        pass
        

def NetworkImage_swigregister():
    """None"""
    pass
    

class NetworkItem(object):
    """
    hou.NetworkItem
    
    The base class for all visible elements within a network.
    
    This class has no methods, and only exists as a base class for
    hou.NetworkMovableItem and Hou.NodeConnection, both of which are visible
    in the network editor, but which have no real meaningful base class. By
    providing a common base class, items of these two types can be passed in
    or returned from hou.NetworkEditor functions.
    
    
    """
    
    def networkItemType():
        """None"""
        pass
        

def NetworkItem_swigregister():
    """None"""
    pass
    

class NetworkMovableItem(NetworkItem):
    """
    hou.NetworkMovableItem
    
    The base class for all visible elements within a network, such as Nodes,
    Network Boxes, and Sticky Notes.
    
    Each movable item has a position, color, and other attributes that allow
    for common interactions in the network editor. All movable items will
    have a parent network (except the node represented by hou.node('/')),
    and may be contained by a hou.NetworkBox. Not all movable items have a
    name, but all have a numeric session id, which is a unique number within
    a given Houdini session for a given subclass of NetworkMovableItem.
    
    
    """
    
    def shiftPosition(self, vector2):
        """
        shiftPosition(self, vector2)
        
        Equivalent to calling hou.NetworkMovableItem.move.
        
        """
        pass
        
    
    def parentNetworkBox():
        """
        parentNetworkBox(self) -> hou.NetworkBox or None
        
        Returns the parent network box which contains this item, or None if
        it is not inside a network box.
        
        
        """
        pass
        
    
    def setName(name, unique_name=False):
        """
        setName(self, name, unique_name=False)
        
        Set the name of this node. Raises hou.OperationFailed if the new
        name contains characters other than letters, numbers, periods,
        dashes, or underscores. Raises hou.OperationFailed if the node could
        not be renamed (for example, another node already exists with the
        name, the node is the root node or top-level manager (e.g. /obj), or
        the node is inside a locked asset). If the unique_name parameter is
        set to True, the supplied name may be changed to ensure that it
        doesn't match the name of any existing node.
        
        
        """
        pass
        
    
    def parent():
        """
        parent(self) -> hou.Node
        
        Return the node that contains this item.
        
        Note that this method returns None if the item is the root node
        (i.e. /).
        
        > >>> hou.node("/obj/box_object1").parent()
        > <hou.Node at /obj>
        > >>> print hou.node("/").parent()
        > None
        
        """
        pass
        
    
    def color():
        """
        color(self) -> hou.Color
        
        Return the color of this item's tile in the network editor.
        
        
        """
        pass
        
    
    def move(vector2):
        """
        move(self, vector2)
        
        Moves this item's tile in the network editor graph by the increments
        in the given hou.Vector2.
        
        To position a item absolutely, use setPosition().
        
        To get the item's current graph position, use position().
        
        Raises hou.InvalidInput if the item cannot move to the position
        specified.
        
        
        """
        pass
        
    
    def isPicked(self):
        """
        isPicked(self) -> bool
        
        Equivalent to calling hou.NetworkMovableItem.isSelected.
        
        """
        pass
        
    
    def setPicked(self, on):
        """
        setPicked(self, on)
        
        Equivalent to calling hou.NetworkMovableItem.setSelected with
        default values for all optional parameters.
        
        """
        pass
        
    
    def path():
        """
        path(self) -> str
        
        Return the full path (i.e. starting with /) of this node in the
        network.
        
        
        """
        pass
        
    
    def setPosition(vector2):
        """
        setPosition(self, vector2)
        
        Sets the position of this item's tile in the network editor graph.
        Raises hou.InvalidInput if the item cannot have the given position.
        
        
        """
        pass
        
    
    def size():
        """
        size(self) -> hou.Vector2
        
        Return the size of this item's tile in the network editor graph as a
        Vector2.
        
        
        """
        pass
        
    
    def setSelected(on, clear_all_selected=False, show_asset_if_selected=False):
        """
        setSelected(self, on, clear_all_selected=False,
        show_asset_if_selected=False)
        
        Select or deselect this item, optionally deselecting all other
        selected items in this network. If show_asset_if_selected is True,
        and this item is a Node, then the panes will show the top-level
        asset of the selected item instead.
        
        
        """
        pass
        
    
    def setColor(color):
        """
        setColor(self, color)
        
        Sets the color of this item's tile in the network editor to the
        given hou.Color.
        
        
        """
        pass
        
    
    def digitsInName():
        """
        digitsInName(self) -> int
        
        Return the value of the last set of digits inside the node's name,
        or 0 if there are no digits.
        
        For example, the result is 102 for a node named geo102, and 34 for a
        node named light12to34.
        
        
        """
        pass
        
    
    def name():
        """
        name(self) -> str
        
        Return this node's name. See also hou.NetworkMovableItem.path.
        
        
        """
        pass
        
    
    def relativePathTo(base_node):
        """
        relativePathTo(self, base_node) -> str
        
        Return a relative path to another node object from this node.
        
        > >>> box1 = hou.node("/obj/box_object1/box1")
        > >>> sphere1 = hou.node("/obj/sphere_object1/sphere1")
        > >>> box1.relativePathTo(sphere1)
        > '../../sphere_object1/sphere1'
        > >>> hou.node("/obj").relativePathTo(box1)
        > 'box_object1/box1'
        > >>> box1.relativePathTo(box1)
        > '.'
        
        """
        pass
        
    
    def isSelected():
        """
        isSelected(self) -> bool
        
        Return whether this item is selected.
        
        See also hou.selectedNodes.
        
        
        """
        pass
        
    
    def sessionId():
        """
        sessionId(self)
        
        Returns an integer value that uniquely identifies this item in a
        given Houdini session. This id is only guaranteed to be unique in a
        single Houdini process. It is useful as a quick and easy way to save
        a restore a reference to an item. It is also only unique for a
        specific item subclass. So there may be a Node with the same session
        id as a NetworkBox.
        
        See hou.nodeBySessionId to turn a session id back into a node, or
        hou.networkBoxBySessionId to turn a session id back into a network
        box, or more generally, hou.itemBySessionId to turn a session id
        combined with an enum value indicating the item subclass into an
        item of that type.
        
        
        """
        pass
        
    
    def position():
        """
        position(self) -> hou.Vector2
        
        Return the position of this item's tile in the network editor graph
        as a Vector2. See also move() and setPosition().
        
        
        """
        pass
        

def NetworkMovableItem_swigregister():
    """None"""
    pass
    

class NetworkShape(object):
    """
    hou.NetworkShape
    
    The base class for extra shapes that can be drawn into a network editor.
    
    The network editor pane can be instructed to draw additional shapes to
    either the main canvas, or to the overlay area of the pane (drawn on top
    of the actual network). Each element that is drawn is described as a
    subclass of this NetworkShape base class, then passed to the network
    editor through either the hou.NetworkEditor.setShapes or
    hou.NetworkEditor.setOverlayShapes methods.
    
    
    """

class NetworkShapeBox(NetworkShape):
    """
    hou.NetworkShapeBox
    
    Describes a rectangular area that can be drawn into a network editor.
    
    This subclass of hou.NetworkShape describes a rectangle that can be
    drawn into a network editor pane.
    
    
    """

def NetworkShapeBox_swigregister():
    """None"""
    pass
    

class NetworkShapeConnection(NetworkShape):
    """
    hou.NetworkShapeConnection
    
    Describes a wire that can be drawn into a network editor.
    
    This subclass of hou.NetworkShape describes a wire that can be drawn
    into a network editor pane. This wire is drawn using the same wire style
    set on the current network.
    
    
    """

def NetworkShapeConnection_swigregister():
    """None"""
    pass
    

class NetworkShapeLine(NetworkShape):
    """
    hou.NetworkShapeLine
    
    Describes a line that can be drawn into a network editor.
    
    This subclass of hou.NetworkShape describes a line that can be drawn
    into a network editor pane.
    
    
    """

def NetworkShapeLine_swigregister():
    """None"""
    pass
    

class NetworkShapeNodeShape(NetworkShape):
    """
    hou.NetworkShapeNodeShape
    
    Describes a node shape that can be drawn into a network editor.
    
    This subclass of hou.NetworkShape describes a node shape that can be
    drawn into a network editor pane. This can draw any of the node shapes
    available to the nodes in the network through the Shape Palette.
    
    
    """

def NetworkShapeNodeShape_swigregister():
    """None"""
    pass
    

def NetworkShape_swigregister():
    """None"""
    pass
    

class Node(NetworkMovableItem):
    """
    hou.Node
    
    The base class for all nodes in Houdini (objects, SOPs, COPs, etc.) An
    instance of this class corresponds to exactly one instance of a node in
    Houdini.
    
    Each node has a unique path that defines its location in the tree of
    nodes. The node path hierarchy is similar to the hierarchy of folders
    and files in a file system. Some nodes, called networks, may contain
    other nodes inside them, much like a file folder would, while other
    nodes may not. For example, an object node instance and a SOP subnetwork
    node instance may contain SOP nodes, but a box SOP instance may not.
    
    
    TIP
    Be careful not to confuse nodes with node types. A node is an
    instance of a node type. For example suppose /obj/geo1/box1 is a box
    SOP. It has its own unique name (box1) and its own copies of
    parameter values. It is an instance of the box SOP node type. This
    node type defines what parameters are common to all box SOP node
    instances, as well as the algorithm that each BOX SOP performs. The
    class that represents a node type is hou.NodeType.
    
    You cannot create instances of hou.Node using hou.Node.__init__.
    Instead, you look up Node objects corresponding to existing Houdini
    nodes with hou.node(). To create a new Houdini node instance inside
    another node, use hou.Node.createNode. To delete a Houdini node, use
    hou.Node.destroy.
    
    Note that a Node object internally stores a reference to the
    corresponding Houdini node, and that their lifetimes are different. If a
    Python node object is deleted because its reference count in Python goes
    to zero, the Houdini node will be unaffected. On the other hand, if you
    have a Node object in a Python variable and the Houdini node is deleted,
    the Python variable will still exist, and Python will not crash.
    Instead, if you later call a method on that Python Node object, Houdini
    will raise a hou.ObjectWasDeleted exception.
    
    Be careful not to confuse this class with the function hou.node.
    
    
    """
    
    def copyItemsToClipboard(items):
        """
        copyItemsToClipboard(self, items)
        
        Given a sequence of child items (nodes, network boxes, sticky notes,
        etc), save them to the clipboard so they can be pasted into this or
        another network.
        
        
        items
        A sequence of hou.NetworkMovableItems that are children of this
        node.
        
        Raises hou.OperationFailed if any of the nodes or network boxes are
        node children of this node. Raises hou.PermissionError if you do not
        have permission to read the contents of this node.
        
        
        """
        pass
        
    
    def cookCodeGeneratorNode(check_parent=False):
        """
        cookCodeGeneratorNode(self, check_parent=False) -> hou.Node
        
        Return the node itself or a network node that contains this node and
        can generate compiled cook code. For example, the generator node for
        a VOP node could be the SHOP node or SOP node that contains it for
        example.
        
        Return None if this node cannot generate code and is not contained
        in a code generating node either either.
        
        
        """
        pass
        
    
    def evalParm(parm_path):
        """
        evalParm(self, parm_path) -> int, float, or str
        
        Evaluates the specified parameter and returns the result.
        
        
        """
        pass
        
    
    def selectNextVisibleWorkItem():
        """
        selectNextVisibleWorkItem()
        
        If a work item is selected, selects the next visible work item
        
        
        """
        pass
        
    
    def clearParmAliases():
        """
        clearParmAliases(self)
        
        Removes all alias names from parameters on the node.
        
        
        """
        pass
        
    
    def inputAncestors(include_ref_inputs=True, follow_subnets=False):
        """
        inputAncestors(self, include_ref_inputs=True, follow_subnets=False) ->
        tuple of hou.Node
        
        Return a tuple of all input ancestors of this node. If
        include_ref_inputs is False, then reference inputs are not
        traversed. If follow_subnets is True, then instead of treating
        subnetwork nodes as a single node, we also traverse its children
        starting with its display node.
        
        See also the inputs() method.
        
        
        """
        pass
        
    
    def supportsMultiCookCodeContexts():
        """
        supportsMultiCookCodeContexts(self) -> bool
        
        Return True if this node can generate compiled cook code for
        multiple contexts (i.e. surface context, displacement context, etc.)
        and False otherwise.
        
        Raises hou.OperationFailed if this node cannot generate compiled
        code.
        
        
        """
        pass
        
    
    def selectPreviousVisibleWorkItem():
        """None"""
        pass
        
    
    def parmsReferencingThis():
        """
        parmsReferencingThis(self) -> tuple of hou.Parm
        
        Return a list of the parameters that reference this node.
        
        
        """
        pass
        
    
    def setParmExpressions(self, parm_dict, language=None, replace_expressions=True):
        """
        setParmExpressions(self, parm_dict, language=None,
        replace_expressions=True)
        
        Given a dictionary mapping parm names to expression strings, set
        each of the corresponding parms on this node to the given expression
        string in the dictionary.
        
        See hou.Parm.setExpression for a description of the language and
        replace_expressions parms.
        
        The following example expressions set the tx and sy parameters at
        once:
        
        > >>> node = hou.node("/obj").createNode("geo")
        > >>> node.setParmExpressions({"tx": 'ch("ty")', "sy": "sin($F)"})
        
        Raises hou.OperationFailed if any of the parameter names are not
        valid.
        
        See also the setParms method.
        
        """
        pass
        
    
    def iterStickyNotes():
        """None"""
        pass
        
    
    def childTypeCategory():
        """
        childTypeCategory(self) -> hou.NodeTypeCategory
        
        Return the hou.NodeTypeCategory corresponding to the children of
        this node. For example, if this node is a geometry object, the
        children are SOPs. If it is an object subnet, the children are
        objects.
        
        
        """
        pass
        
    
    def children():
        """
        children(self) -> tuple of hou.Node
        
        Return a list of nodes that are children of this node. Using the
        file system analogy, a node's children are like the contents of a
        folder/directory.
        
        To find the number of children nodes, use len(node.children()).
        
        The order of the children in the result is the same as the user
        defined ordering in Houdini. To see this order, switch the network
        view pane into list mode, and ensure that the list order is set to
        user defined. To reorder nodes, drag and drop them in the list.
        
        > def pc(node):
        >     '''Print the names of the children of a particular node.  This function
        >        can be handy when working interactively in the Python shell.'''
        >     for child in node.children():
        >         print child.name()
        >
        > def ls():
        >     '''Print the names of the nodes under the current node.'''
        >     pc(hou.pwd())
        
        The following expression evaluates to a list of children of a
        particular node type:
        
        > [c for c in node.children() if c.type() == node_type]
        
        """
        pass
        
    
    def isInsideLockedHDA():
        """
        isInsideLockedHDA(self) -> bool
        
        Return whether this node is inside a locked digital asset. If this
        node is not inside a locked HDA, the node may deviate from the HDA
        definition.
        
        
        """
        pass
        
    
    def createOrMoveVisualizer(output_index):
        """
        createOrMoveVisualizer(self, output_index)
        
        Creates a node for visualizing the data from a particular output of
        this node. If a visualizer node already exists in the current
        network, it is moved and connected to the specified output_index.
        This method is only implemented for SOP and VOP nodes. Other node
        types do nothing when this method is called.
        
        
        """
        pass
        
    
    def addSpareParmTuple(self, parm_template, in_folder=():
        """
        addSpareParmTuple(self, parm_template, in_folder=(),
        create_missing_folders=False) -> hou.ParmTuple
        
        Add a spare parameter tuple to the end of the parameters on the
        node. If in_folder is not an empty sequence, this method adds the
        parameters to the end of the parameters in a particular folder.
        
        
        parm_template
        A hou.ParmTemplate subclass instance that specifies the type of
        parameter tuple, the default value, range, etc.
        
        in_folder
        A sequence of folder names specifying which folder will hold the
        parameter. If this parameter is an empty sequence (e.g. ()),
        Houdini will not put the parameter inside a folder. If it is,
        for example, ("Misc", "Controls"), Houdini puts it inside the
        "Controls" folder that's inside the "Misc" folder. If it is, for
        example, ("Misc",), Houdini puts it inside the "Misc" folder.
        
        create_missing_folders
        If True, and the folder location specified by in_folder does not
        exist, this method creates the missing containing folders.
        
        Note that this method can add a single folder by passing a
        hou.FolderParmTemplate for parm_template.
        
        See also the removeSpareParmTuple() and addSpareParmFolder()
        methods.
        
        This method is deprecated in favor of setParmTemplateGroup.
        
        """
        pass
        
    
    def copyTo(self, destination_node):
        """
        copyTo(destination_node) -> hou.Node
        
        Copy this node to a new place in the node hierarchy. The new node is
        placed inside the given destination node. This method returns the
        new node.
        
        Raises hou.OperationFailed if the destination node cannot contain
        the new node. Raises hou.PermissionError if the destination node is
        inside a locked asset.
        
        """
        pass
        
    
    def setCachedUserData(name, value):
        """
        setCachedUserData(self, name, value)
        
        Add/set a named value on this node instance. Unlike setUserData,
        values set using this method are not saved with the hip file.
        
        name: A unique name (key) for the user-defined data. By using
        different names, you can attach multiple pieces of user-defined data
        to a node. value: The value to store. Unlike setUserData, this value
        may be any Python object.
        
        This name/value pair is not stored with the hip file. It is useful
        for nodes implemented in Python that want to save temporary values
        between cooks, to avoid recomputing them on subsequent cooks.
        
        The following example illustrates how to set, access, and delete
        cached user-defined data:
        
        > >>> n = hou.node("/obj").createNode("geo")
        > >>> n.setCachedUserData("my data", [1, 2, {"a": "b", "c": "d"}])
        > >>> n.cachedUserData("my data")
        > [1, 2, {'a': 'b', 'c': 'd'}]
        > >>> n.cachedUserDataDict()
        > {'my data': [1, 2, {'a': 'b', 'c': 'd'}]}
        > >>> n.destroyCachedUserData("my data")
        > >>> n.cachedUserDataDict()
        > {}
        > >>> print n.cachedUserData("my data")
        > None
        
        See per-node user-defined data for more information and examples.
        
        
        """
        pass
        
    
    def removeSpareParmTuple(self, parm_tuple):
        """
        removeSpareParmTuple(self, parm_tuple)
        
        Removes the specified spare parameter tuple.
        
        See also addSpareParmTuple().
        
        This method is deprecated in favor of setParmTemplateGroup.
        
        """
        pass
        
    
    def copyItems(items, channel_reference_originals, =, False, relative_references, =, True, connect_outputs_to_multi_inputs, =, True):
        """
        copyItems(self, items, channel_reference_originals = False,
        relative_references = True, connect_outputs_to_multi_inputs = True) ->
        tuple of hou.NetworkMovableItem
        
        Create copies of all specified items in this network. The items do
        not need to be children of this network, but all items must be
        contained in the same parent network.
        
        If channel_reference_originals is True, the parameters of all new
        nodes are set to channel reference the original nodes. If a copied
        node is a sub-network, only the top level node establishes channel
        references to the original. Child nodes inside the sub-network will
        be simple copies of the original child nodes. The
        relative_references parameter controls whether the channel
        references use relative or absolute paths to the source nodes.
        
        If connect_outputs_to_multi_inputs is True, and any items being
        copied have outputs connected to a multi-input node (like a Merge),
        then the new item copies will also be connected to the multi-input
        node. Normally copied nodes do not have any outputs to nodes outside
        the copied set.
        
        Returns a tuple of all the new network items.
        
        Raises hou.OperationFailed if this node cannot contain children.
        Raises hou.PermissionError if this node is inside a locked asset.
        
        
        """
        pass
        
    
    def findNodesThatProcessedObject():
        """None"""
        pass
        
    
    def nodes(node_path_tuple):
        """
        nodes(self, node_path_tuple) -> tuple of hou.Node or None
        
        This is like node() but takes multiple paths and returns multiple
        Node objects. This is the equivalent of:
        
        > nodes = [self.node(path) for path in paths]
        
        """
        pass
        
    
    def numOrderedInputs():
        """
        numOrderedInputs(self) -> int
        
        Some nodes can have a small number of dedicated inputs with specific
        meanings, followed by an arbitrary number of additional inputs,
        where gaps are not permitted between the inputs (these are referred
        to as unordered inputs). This is common in DOP nodes such as the
        Multiple Solver DOP. This function returns the number of dedicated
        (or ordered) inputs that occur before the unordered inputs begin.
        This function will only return non-zero values if the
        hou.NodeType.hasUnorderedInputs function for this node's
        hou.Node.type object returns True.
        
        
        """
        pass
        
    
    def createNode(node_type_name, node_name=None, run_init_scripts=True, load_contents=True, exact_type_name=False):
        """
        createNode(self, node_type_name, node_name=None, run_init_scripts=True,
        load_contents=True, exact_type_name=False) -> hou.Node
        
        Create a new node of type node_type_name as a child of this node.
        
        
        node_name
        The name of the new node. If not specified, Houdini appends a
        number to the node type name, incrementing that number until a
        unique node name is found. If you specify a name and a node
        already exists with that name, Houdini will append a number to
        create a unique name.
        
        run_init_scripts
        If True, the initialization script associated with the node type
        will be run on the new node.
        
        load_contents
        If True, any subnet contents will be loaded for custom subnet
        operators.
        
        exact_type_name
        If True, the node's type name will be exactly as specified in
        the node_type_name. Otherwise, a preferred operator type that
        matches the given node_type_name may be used. For example, the
        given "hda" may match a newer version "hda::2.0", or if there
        are two available operators "namespaceA::hda" and
        "namespaceB::hda", and the "namespaceB" has precedence, then the
        created node will be of type "namespaceB::hda".
        
        Raises hou.OperationFailed if this node cannot contain children.
        Raises hou.PermissionError if this node is inside a locked asset.
        
        > >>> obj = hou.node("/obj")
        >
        > # Let Houdini choose a name based on the node type name.
        > >>> obj.createNode("geo")
        > <hou.ObjNode of type geo at /obj/geo1>
        >
        > # Let Houdini choose a unique name.
        > >>> obj.createNode("geo")
        > <hou.ObjNode of type geo at /obj/geo2>
        >
        > # Give the node a specific name.
        > >>> obj.createNode("geo", "foo")
        > <hou.ObjNode of type geo at /obj/foo>
        >
        > # Let Houdini create a unique name from our suggested name.  Also, don't
        > # run the geometry object init scripts so the contents are empty.
        > >>> obj.createNode("geo", "geo1", run_init_scripts=False)
        > <hou.ObjNode of type geo at /obj/geo3>
        > >>> obj.node("geo1").children()
        > (<hou.SopNode of type file at /obj/geo1/file1>,)
        > >>> obj.node("geo3").children()
        > ()
        
        """
        pass
        
    
    def outputConnectors():
        """
        outputConnectors(self) -> tuple of tuple of hou.NodeConnection
        
        Return a a tuple of tuples of hou.NodeConnection objects. The length
        of the result tuple is equal to the number of output connectors on
        this node. Each subtuple contains all the connections going out of
        that connector, and is empty if nothing is wired to that connector.
        
        > >>> split = hou.node("/obj").createNode("dopnet").createNode("split")
        > >>> split.parent().createNode("rbdsolver").setFirstInput(split)
        > >>> split.parent().createNode("gravity").setFirstInput(split, 1)
        > >>> split.parent().createNode("merge").setFirstInput(split, 1)
        > >>> split.outputConnectors()
        > ((<hou.NodeConnection from split1 output 0 to rbdsolver1 input 0>,), (<hou.NodeConnection from split1 output 1 to gravity2 input 0>, <hou.NodeConnection from split1 output 1 to merge1 input 0>), (), ())
        
        See also hou.NodeConnection and hou.Node.outputConnections.
        
        
        """
        pass
        
    
    def addSpareParmFolder(self, folder_name, in_folder=():
        """
        addSpareParmFolder(self, folder_name, in_folder=(), parm_name=None,
        create_missing_folders=False)
        
        Adds a folder to the spare parameters.
        
        Note that all the folders in a set correspond to one parameter. If
        this is the first folder to go in the set, parm_name will be used as
        the parameter name. Otherwise, parm_name will be ignored and the
        parameter name of the first folder in the set is used.
        
        If this is the first folder in the set and parm_name is None, it
        will default to 'sparefolder0'. If parm_name is already in use, a
        unique name will be automatically generated.
        
        If create_missing_folders is True, this method will create the
        folders in in_folder that don't exist. So, this method can be used
        to add spare folders and a spare parameter at the same time.
        
        Note that you can add folders by passing a hou.FolderParmTemplate to
        the addSpareParmTuple method, so this method is deprecated. Note
        also that addSpareParmTuple is deprecated in favor of
        setParmTemplateGroup.
        
        See also the removeSpareParmFolder and addSpareParmTuple methods.
        
        This method is deprecated in favor of setParmTemplateGroup.
        
        """
        pass
        
    
    def indirectInputs():
        """
        indirectInputs(self) -> tuple of hou.SubnetIndirectInput
        
        Return the hou.SubnetIndirectInput objects of a subnet.
        
        Raises hou.InvalidNodeType if this node is not a subnetwork.
        
        
        """
        pass
        
    
    def inputConnectors():
        """
        inputConnectors(self) -> tuple of tuple of hou.NodeConnection
        
        Return a tuple of tuples of hou.NodeConnection objects. The length
        of the result tuple is equal to the maximum number of inputs that
        can be connected to this node. Each subtuple contains exactly one
        node connection if something is wired into the connector; otherwise
        it is the empty tuple.
        
        See also hou.NodeConnection and hou.Node.inputConnections.
        
        
        """
        pass
        
    
    def modificationTime(self):
        """
        modificationTime(self) -> datetime.datetime
        
        Return the date and time when the node was last modified.
        
        """
        pass
        
    
    def findNetworkBoxes(pattern):
        """
        findNetworkBoxes(self, pattern) -> tuple of hou.NetworkBox
        
        Return a list of network boxes inside this node whose names match a
        pattern.
        
        
        """
        pass
        
    
    def setParmTemplateGroup():
        """None"""
        pass
        
    
    def outputConnections():
        """
        outputConnections(self) -> tuple of hou.NodeConnection
        
        Return a tuple of NodeConnection objects for the connections going
        out of the bottom of this node. If nothing is wired into the output
        of this node, return an empty tuple.
        
        To get a list of the connected nodes themselves, use
        hou.Node.outputs.
        
        Note that this method is a shortcut for: reduce(lambda a, b: a+b,
        self.outputConnectors(), ()). Since most nodes have only one output
        connector, though, this method is usually equivalent to
        self.outputConnectors()[0].
        
        > >>> box = hou.node("/obj").createNode("geo").createNode("box")
        > >>> box.parent().createNode("xform").setFirstInput(box)
        > >>> box.parent().createNode("subdivide").setFirstInput(box)
        > >>> box.outputConnections()
        > (<hou.NodeConnection from box1 output 0 to xform1 output 0>, <hou.NodeConnection from box1 output 0 to subdivide1 input 0>)
        
        See also hou.node.outputConnectors.
        
        
        """
        pass
        
    
    def loadParmClip(self):
        """auto-insert ocstring: HOM_Node::loadParmClip"""
        pass
        
    
    def setDisplayDescriptiveNameFlag():
        """None"""
        pass
        
    
    def runInitScripts():
        """
        runInitScripts(self)
        
        Runs the initialization script associated with this node's type.
        
        
        """
        pass
        
    
    def cook(force=False, frame_range=():
        """
        cook(self, force=False, frame_range=())
        
        Asks or forces the node to re-cook.
        
        
        frame_range
        The frames at which to cook the object. This should be a tuple
        of 2 or 3 ints giving the start frame, end frame, and optionally
        a frame increment, in that order. If you supply a two-tuple
        (start, end), the increment is 1.
        
        
        """
        pass
        
    
    def createOutputNode(self, node_type_name, node_name=None, run_init_scripts=True, load_contents=True, bool, exact_type_name=False):
        """
        createOutputNode(self, node_type_name, node_name=None,
        run_init_scripts=True, load_contents=True, bool exact_type_name=False)
        
        Create a new node and connect its first input to this node's (first)
        output. Return the new node.
        
        See the createNode method for more information on the parameters.
        
        See also the createInputNode method.
        
        """
        pass
        
    
    def isGenericFlagSet(flag):
        """
        isGenericFlagSet(self, flag) -> bool
        
        Returns the value of the specific flag.
        
        flag must be a hou.nodeFlag value.
        
        
        """
        pass
        
    
    def hdaModule():
        """
        hm(self) -> hou.HDAModule
        
        This method is a shortcut for self.hdaModule().
        
        See also hou.phm.
        
        
        """
        pass
        
    
    def copyNetworkBox(network_box_to_copy, new_name=None, channel_reference_original=False):
        """
        copyNetworkBox(self, network_box_to_copy, new_name=None,
        channel_reference_original=False) -> hou.NetworkBox
        
        Copies a network box and returns the copy.
        
        If new_name is given, the network box will be copied to a new
        network box named new_name (a different name will be generated if
        there is already a network box with that name).
        
        If channel_reference_original is True, all operators created by the
        copy will have their animatable parameters set to reference the
        original operators.
        
        Raises hou.OperationFailed if this node is not a network or if the
        node child type does not match the network box's node type.
        
        
        """
        pass
        
    
    def isNetwork():
        """
        isNetwork(self) -> bool
        
        Return True if this node is a network, in other words a node that
        may contain child nodes. Otherwise return False which indicates that
        several other methods such as hou.Node.createNode will raise
        hou.OperationFailed if they are called.
        
        
        """
        pass
        
    
    def setEditableInputString():
        """None"""
        pass
        
    
    def parmsInFolder(folder_names):
        """
        parmsInFolder(self, folder_names) -> tuple of hou.Parm
        
        Return a list of parameters in a folder on this node. Returns all
        parameters in the folder and its subfolders (if any).
        
        
        folder_names
        A sequence of folder name strings. For example, to get a list of
        the parameters in the Shading folder of the Render folder, use
        ("Render", "Shading"). Note that by folder name, we mean the
        label used in the parameter dialog, not the internal parameter
        name.
        
        If this sequence is empty, the method returns all parameters on
        the node, the same as if you called parms().
        
        Raises hou.OperationFailed if the folder specified by folder_names
        does not exist.
        
        For example, suppose a node had a Render folder that contained a
        Shading subfolder. Then this line of code would return the
        parameters in the Render folder:
        
        > # Note the trailing comma after "Render" to tell Python that "Render" is
        > # contained in a tuple/sequence as opposed to just a single string with
        > # parentheses around it.
        > >>> node.parmsInFolder(("Render", ))
        
        And this line of code would return the parameters in the Shading
        subfolder.
        
        > >>> node.parmsInFolder(("Render", "Shading"))
        
        See also hou.Parm.containingFolders and
        hou.Parm.containingFolderSetParmTuples
        
        
        """
        pass
        
    
    def removeEventCallback(event_types, callback):
        """
        removeEventCallback(self, event_types, callback)
        
        Given a callback that was previously added on this node and a
        sequence of hou.nodeEventType enumerated values, remove those event
        types from the set of event types for the callback. If the remaining
        set of event types is empty, the callback will be removed entirely
        from this node.
        
        Raises hou.OperationFailed if the callback had not been previously
        added.
        
        See hou.Node.addEventCallback for more information.
        
        
        """
        pass
        
    
    def parmClipData(self, start=None, end=None, binary=True, use_blosc_compression=True, sample_rate=0, scoped_only=False):
        """
        parmClipData(start=None, end=None, binary=True,
        use_blosc_compression=True, sample_rate=0, scoped_only=False) -> str
        
        Returns the clip data for the parameters of this node. This method
        is similar to hou.Node.saveParmClip, except that it returns the clip
        data (file contents) instead of saving the animation to a clip file.
        
        <start>, <end>, <sample_rate>, and <scoped_only> behave the same as
        in hou.Node.saveParmClip.
        
        If <binary> is True, return binary clip data, otherwise return plain
        text (ASCII) clip data.
        
        If <use_blosc_compression> is True, blosc compress the binary clip
        data. This cannot be used for plain text (ASCII) clip data.
        
        Raises a hou.OperationFailed exception if none of the parameters of
        this tuple have animation.
        
        Raises a hou.InvalidInput exception if start >= end. If specifying
        only <start>, ensure that the specified value is less than the
        global end frame. Likewise, if specifying only <end>, ensure it is
        larger than the global start frame.
        
        Raises a hou.InvalidInput exception if binary = False and
        use_blosc_compression = True.
        
        """
        pass
        
    
    def parmTuplesInFolder(folder_names):
        """
        parmTuplesInFolder(self, folder_names) -> tuple of hou.ParmTuple
        
        Return a list of the parameter tuples in a folder on this node. This
        method is similar to parmsInFolder(), except it returns a list of
        hou.ParmTuple instead of hou.Parm. See parmsInFolder() above for
        information about the arguments.
        
        See also hou.Parm.containingFolders and
        hou.Parm.containingFolderSetParmTuples
        
        
        """
        pass
        
    
    def item(item_path):
        """
        item(self, item_path) -> hou.NetworkMovableItem or None
        
        Return the network item at the given path, or None if no such item
        exists. If you pass in a relative path (i.e. the path does not start
        with /), searches are performed relative to this node.
        
        If the path is an absolute path (i.e. it starts with /), this method
        is a shortcut for hou.item(node_path). Otherwise, it is a shortcut
        for hou.item(self.path() + "/" + item_path). See also hou.item.
        
        Note that the return value may be an instance of a subclass of
        NetworkMovableItem. For example, if the item being found is an
        object node, the return value will be a hou.ObjNode instance. If the
        item is a network box, the return value will be a hou.NetworkBox
        instance.
        
        
        """
        pass
        
    
    def allParms(self):
        """
        allParms(self) -> generator of hou.Parm
        
        Recursively return a sequence of all the parameters on all of the
        nodes contained in this node including this node.
        
        This method is a generator and does not return a tuple.
        
        Here is an example of printing out the parameter paths for all nodes
        under /obj:
        
        > root_node = hou.node("/obj")
        > for parm in root_node.allParms():
        >     print parm.path()
        """
        pass
        
    
    def numItems():
        """None"""
        pass
        
    
    def setInput(input_index, item_to_become_input, output_index=0):
        """
        setInput(self, input_index, item_to_become_input, output_index=0)
        
        If item_to_become_input is not None, connect the output connector of
        another node to an input connector of this node. Otherwise,
        disconnect anything connected to the input connector.
        
        
        input_index
        The index of this node's input connector.
        
        item_to_become_input
        If None this method disconnects everything from the input
        connector. If a hou.Node or a hou.SubnetIndirectInput, this
        method connects its output to this node's input connector.
        
        output_index
        The index of the other node's output connector.
        
        Raises hou.InvalidInput if output_index is invalid. Raises
        hou.OperationFailed if item_to_become_input is not in the same
        network as this node. Raises hou.PermissionError if the node is
        inside a locked asset.
        
        
        """
        pass
        
    
    def creatorState():
        """
        creatorState(self) -> str
        
        This returns the name of the viewport tool that was used to be
        created. This name is not set by default and is usually the empty
        string.
        
        
        """
        pass
        
    
    def globParms(pattern, ignore_case=False, search_label=False, single_pattern=False):
        """
        globParms(self, pattern, ignore_case=False, search_label=False,
        single_pattern=False) -> tuple of hou.Parm
        
        Return a tuple of parameters matching the pattern.
        
        The pattern may contain multiple pieces, separated by spaces. An
        asterisk (*) in a pattern piece will match any character. By
        default, Houdini will add the parameters from each pattern piece to
        those already matched. However, if the pattern piece begins with a
        caret (^), Houdini will remove the matches for that piece from the
        result.
        
        By default the pattern match is case-sensitive. Set ignore_case to
        True for case-insensitive pattern matching. Note that case
        insensitivity only applies when matching node and parameter names.
        It does not apply when matching group, network box or bundle names.
        
        By default, only parameters with names matching the pattern are
        returned. Set search_label to True to also return parameters with
        labels matching the pattern.
        
        If single_pattern is True, the pattern will be treated as one
        pattern even if there are spaces in the pattern.
        
        This method returns an empty tuple if you pass in an empty pattern.
        
        
        """
        pass
        
    
    def saveCookCodeToFile(file_name, skip_header=False, context_name=None):
        """
        saveCookCodeToFile(self, file_name, skip_header=False,
        context_name=None)
        
        Saves VEX/RSL source code to a disk file (on nodes that support
        this).
        
        
        file_name
        The file path in which to save the generated code.
        
        skip_header
        If True, the method does not write a header comment at the
        beginning of the file containing the file name and node path
        from which the code was generated and a time stamp.
        
        context_name
        A string containing name of the shader context for the code.
        This option applies to nodes such as the Material Shader Builder
        which can generate code for multiple context types.
        
        For example, a Material network might contain both surface and
        displacement shaders, so you must specify which type of shader
        code to generate:
        
        > node("/shop/vopmaterial1").saveCookCodeToFile("myfile.vfl", context_name="surface")
        
        On single-context nodes this argument is ignored.
        
        For VEX materials, possible values are surface, displacement,
        light, shadow, fog, image3d, photon, or cvex.
        
        For RSL materials, possible values are surface, displacement,
        light, volume, or imager.
        
        
        """
        pass
        
    
    def editableInputString():
        """None"""
        pass
        
    
    def node(node_path):
        """
        node(self, node_path) -> hou.Node or None
        
        Return the node at the given path, or None if no such node exists.
        If you pass in a relative path (i.e. the path does not start with
        /), searches are performed relative to this node.
        
        For example, to get the parent node of a node in the the variable n,
        use n.node(".."). To get a child node named geo5, use
        n.node("geo5"). To get a sibling node named light3, use
        n.node("../light3").
        
        Note that the return value may be an instance of a subclass of Node.
        For example, if the node being found is an object node, the return
        value will be a hou.ObjNode instance.
        
        If the path is an absolute path (i.e. it starts with /), this method
        is a shortcut for hou.node(node_path). Otherwise, it is a shortcut
        for hou.node(self.path() + "/" + node_path). See also hou.node_.
        
        
        """
        pass
        
    
    def isEditable():
        """
        isEditable(self) -> bool
        
        Return True if the node is editable. This is similar to the
        hou.Node.isEditableInsideLockedHDA method except that it will return
        True for nodes that are not inside a locked HDA. This function is
        the simplest way to determine if most node modifications (changing
        inputs, changing parameters, changing flags) will be allowed on the
        node.
        
        
        """
        pass
        
    
    def creator():
        """
        isBuiltExplicitly(self) -> bool
        
        Return whether this node was built explicitly (defaults to True).
        Most nodes are built explicitly, but some are implicitly created by
        Houdini. For example, if you select geometry from multiple SOPs and
        then perform an operation, Houdini will put down an implicit merge
        SOP before performing that operation. When reselecting geometry in
        SOPs, Houdini will automatically delete any SOPs that were created
        implicitly.
        
        
        """
        pass
        
    
    def isFlagReadable(flag):
        """
        isFlagReadable(self, flag) -> bool
        
        Return True if the specified flag is readable and False otherwise.
        
        flag must be a hou.nodeFlag value.
        
        
        """
        pass
        
    
    def setNextInput(item_to_become_input, output_index=0, unordered_only=False):
        """
        setNextInput(self, item_to_become_input, output_index=0,
        unordered_only=False)
        
        Connect the output connector from another node into the first
        unconnected input connector or a multi-input connector of this node.
        If a node has some ordered inputs followed by a multi-input
        connector, the unordered_only parameter can be used to force the
        input to connect to the unordered multi-input connection instead of
        any of the ordered input which may not be connected.
        
        This method is roughly equivalent to:
        
        > for input_index, conectors in enumerate(self.inputConnectors()):
        >     if len(connectors) == 0:
        >         self.setInput(input_index, item_to_become_input, output_index)
        >     raise hou.InvalidInput("All inputs are connected")
        
        Raises hou.InvalidInput if all inputs are connected. See
        hou.Node.setInput for more information.
        
        
        """
        pass
        
    
    def replaceSpareParmTuple(self, parm_tuple_name, parm_template):
        """
        replaceSpareParmTuple(self, parm_tuple_name, parm_template)
        
        Replace an existing spare parameter tuple with a new one. The old
        parameter tuple is removed and the new one is added in its place.
        
        
        parm_tuple_name
        The name of the spare parameter tuple to replace. Raises
        hou.OperationFailed if no parameter tuple exists with this name,
        or if it is the name of a non-spare parameter.
        
        parm_template
        A hou.ParmTemplate describing the new parameter tuple.
        
        The new parameter tuple may or may not have the same name as the old
        one. By providing a parameter tuple with the same name, you can
        modify an existing spare parameter tuple.
        
        Note that you cannot replace non-spare parameter tuples. However,
        you can change the visibility of non-spare parameters using
        hou.ParmTuple.hide.
        
        To change a parameter for all instances of digital asset, use
        hou.HDADefinition.replaceParmTuple.
        
        This method is deprecated in favor of setParmTemplateGroup.
        
        """
        pass
        
    
    def loadChildrenFromFile(self, file_name, ignore_load_warnings=False):
        """
        loadChildrenFromFile(self, file_name, ignore_load_warnings=False)
        
        Calls hou.Node.loadItemsFromFile. Provided for backward
        compatibility. New code should call loadItemsFromFile directly.
        
        """
        pass
        
    
    def pasteItemsFromClipboard(position, =, None):
        """
        pasteItemsFromClipboard(self, position = None)
        
        Load the contents of a file saved with hou.Node.copyItemsToClipboard
        into the contents of this node. If the position parameter is given
        as a tuple of two float values (or equivalent, like a hou.Vector2),
        the pasted items are moved such that they are centered around the
        provided position.
        
        Raises hou.OperationFailed if this node is not a network, or if
        there are errors loading the items from the clipboard. Raises
        hou.PermissionError if this node is a locked instance of a digital
        asset.
        
        
        """
        pass
        
    
    def findStickyNotes(pattern):
        """
        findStickyNotes(self, pattern) -> tuple of hou.StickyNote
        
        Return a list of sticky notes inside this node whose names match a
        pattern.
        
        
        """
        pass
        
    
    def setCurrent(on, clear_all_selected=False):
        """
        setCurrent(self, on, clear_all_selected=False)
        
        Set or unset this node as the last selected one.
        
        Each network (i.e. node containing children) stores its own list of
        selected nodes, and the last selected node has special meaning. For
        example, it is the node displayed in unpinned parameter panes.
        
        If on is True, this node will become the last selected node. If it
        is False and this node was the last selected one, it will be
        unselected and the second-last selected node will become the last
        selected node.
        
        If clear_all_selected is true, Houdini will unselect every node in
        this network before performing the operation.
        
        See also hou.Node.setSelected and hou.selectedNodes.
        
        
        """
        pass
        
    
    def moveToGoodPosition(relative_to_inputs=True, move_inputs=True, move_outputs=True, move_unconnected=True):
        """
        moveToGoodPosition(self, relative_to_inputs=True, move_inputs=True,
        move_outputs=True, move_unconnected=True) -> hou.Vector2
        
        Moves a node to a well-spaced position near its inputs or outputs
        and returns the new position of the node.
        
        
        """
        pass
        
    
    def findOrCreateMotionEffectsNetwork(create=True):
        """
        findOrCreateMotionEffectsNetwork(self, create=True) ->
        hou.chopNetNodeTypeCategory
        
        Return a CHOP network node suitable for storing Motion Effects. By
        default, if the node doesn't exist, it will be created.
        
        See also hou.Parm.storeAsClip and hou.Node.motionEffectsNetworkPath.
        
        
        """
        pass
        
    
    def selectedChildren(include_hidden=False, include_hidden_support_nodes=False):
        """
        selectedChildren(self, include_hidden=False,
        include_hidden_support_nodes=False) -> tuple of hou.Node
        
        Return a tuple containing the children of this node that are
        selected. Note that the last selected node has special meaning, and
        can also be retrieved with hou.Node.isCurrent.
        
        
        include_hidden
        If False, hidden nodes are not included in the result, even if
        they are selected.
        
        include_hidden_support_nodes
        If True, include in the returned tuple any hidden nodes that
        exist solely to support nodes that are actually selected. This
        specifically refers to VOP Parameter nodes, but may include
        other support nodes as well.
        
        The following example will print the names of all selected objects
        in /obj:
        
        > for n in hou.node("/obj").selectedChildren():
        >     print n.name()
        
        To find the total number of selected children nodes, use
        len(node.selectedChildren()).
        
        
        """
        pass
        
    
    def errors():
        """
        errors(self) -> tuple of str
        
        Return the text of any errors from the last cook of this node, or an
        empty tuple if there were no errors.
        
        
        """
        pass
        
    
    def hide(on):
        """
        hide(self, on)
        
        Hide or show a node in the network editor. See hou.Node.isHidden for
        more information about hidden nodes.
        
        
        """
        pass
        
    
    def addEventCallback(event_types, callback):
        """
        addEventCallback(self, event_types, callback)
        
        Registers a Python callback that Houdini will call whenever a
        particular action, or event, occurs on _this particular node
        instance_.
        
        Callbacks only persist for the current session. For example, they
        are not saved to the .hip file. If you want persistent callbacks in
        every session, you can add them in code in 456.py (runs when the
        user opens a .hip file). See where to add Python scripting for more
        information.
        
        
        event_types
        A sequence of hou.nodeEventType enumeration values describing
        the event types that will cause Houdini to call the callback
        function.
        
        callback
        A callable Python object, such as a function or bound method.
        Houdini will call this function whenever one of the event types
        in event_types occurs.
        
        Houdini calls the function with an event_type keyword argument
        containing the hou.nodeEventType value corresponding to the
        event that triggered the callback.
        
        Houdini will pass additional keyword arguments depending on the
        event type. For example, in a callback for the ParmTupleChanged
        event, Houdini will pass a parm_tuple keyword argument
        containing a hou.ParmTuple reference to the parameter that
        changed. See hou.nodeEventType for the extra arguments (if any)
        passed for each event type.
        
        You can add **kwargs to the argument list to accept all keyword
        arguments, to allow the same callback to be used for different
        events, or to be safe from future changes:
        
        > def event_callback(event_type, **kwargs):
        >     ...
        
        NOTE
        If you try to add the exact same callback function more than
        once, Houdini will still only call the function only once in
        response to an event. However, it may be useful to "add" the
        same function if you want to register it with different
        event_types.
        
        Raises hou.OperationFailed if the event_types list argument is
        empty.
        
        The following example shows to set up a function that's called
        whenever a certain node's name changes:
        
        >
        > def name_changed(node, event_type, **kwargs):
        >     print("The geometry object is now named", node.name())
        >
        > hou.node("/obj/geo1").addEventCallback((hou.nodeEventType.NameChanged, ), name_changed)
        
        See also hou.Node.removeEventCallback and
        hou.Node.removeAllEventCallbacks.
        
        
        """
        pass
        
    
    def isLockedHDA():
        """
        isLockedHDA(self) -> bool
        
        If this node is an instance of a digital asset, return whether or
        not it is locked. Otherwise, return False.
        
        To differentiate between unlocked digital assets and nodes that are
        not instances of digital assets, check if the node's type has a
        definition:
        
        > def isUnlockedAsset(node):
        >     return not node.isLockedHDA() and node.type().definition() is not None
        
        See hou.HDADefinition.updateFromNode for an example of how to save
        and lock all unlocked digital asset instances.
        
        
        """
        pass
        
    
    def inputLabels():
        """
        inputLabels(self) -> tuple of str
        
        Returns a tuple of all input labels for this node. Labels for input
        connectors that are hidden are also included.
        
        
        """
        pass
        
    
    def canCreateDigitalAsset():
        """
        canCreateDigitalAsset(self) -> bool
        
        Return True if hou.Node.createDigitalAsset can succeed.
        
        
        """
        pass
        
    
    def infoTree(verbose=False, debug=False, output_index=0):
        """
        infoTree(self, verbose=False, debug=False, output_index=0) ->
        hou.NodeInfoTree
        
        Returns a tree structure containing information about the node and
        its most recently cooked data. The contents of the tree vary widely
        depending on the node type, and the nature of its cooked data. This
        tree of data is used to generate the node information window
        contents.
        
        
        verbose
        Setting verbose to True will cause some additional information
        to be generated. In particular data that is expensive to
        calculate, or which will generate a large amount of information
        tends to be generated only if this option is turned on.
        
        debug
        Setting debug to True will, in a few cases, cause additional
        information to be displayed which generally will be most useful
        when debugging the internal operation of Houdini. For example,
        geometry attributes will display their "data ids", which can be
        helpful when tracking down errors in SOPs written with the HDK.
        
        output_index
        Specifies which of the node's outputs to return information for.
        
        
        """
        pass
        
    
    def removeAllEventCallbacks():
        """
        removeAllEventCallbacks(self)
        
        Remove all event callbacks for all event types from this node.
        
        See hou.Node.addEventCallback for more information.
        
        
        """
        pass
        
    
    def findNetworkBox(name):
        """
        findNetworkBox(self, name) -> hou.NetworkBox
        
        Return a network box with the given name inside this node, or None
        if no network box with the given name exists.
        
        
        """
        pass
        
    
    def networkDots():
        """
        networkDots(self) -> tuple of hou.NetworkDot
        
        Returns a tuple of all dots in this network.
        
        
        """
        pass
        
    
    def extractAndDelete():
        """
        extractAndDelete(self) -> tuple of hou.NetworkMovableItem
        
        Move the children of this subnet node to become siblings of this
        node, and then delete this node. The method is the opposite of
        collapseIntoSubnet(). Returns a tuple containing all extracted
        items.
        
        Raises hou.InvalidNodeType if this node is not a subnetwork.
        
        
        """
        pass
        
    
    def dataBlock(key):
        """
        dataBlock(self, key) -> str
        
        Returns the data block stored under the given key. This method will
        only work if the specified data block is has a type that can be
        represented by a python object. Otherwise None is returned.
        
        Raises hou.ValueError if the provided key is not associated with any
        data block on this node.
        
        
        """
        pass
        
    
    def createStickyNote(name=None):
        """
        createStickyNote(self, name=None) -> hou.StickyNote
        
        Creates a sticky note inside this network. Raises
        hou.OperationFailed if this node is not a network.
        
        If you don't specify a name, Houdini gives the note a default name.
        
        
        """
        pass
        
    
    def isBuiltExplicitly():
        """None"""
        pass
        
    
    def userData(name):
        """
        userData(self, name) -> str or None
        
        Return the user-defined data with this name, or None if no data with
        this name exists.
        
        See hou.Node.setUserData for more information.
        
        This method can be implemented as follows:
        
        > def userData(self, name):
        >     return self.userDataDict().get(name)
        
        """
        pass
        
    
    def expressionLanguage():
        """
        expressionLanguage(self) -> hou.exprLanguage enum value
        
        Return the node's default expression language.
        
        When you enter an expression in a parameter that does not already
        contain an expression, the node's expression language is used to
        determine how that expression should be evaluated. You can change a
        node's expression language in the parameter dialog in the GUI.
        
        Changing the node's expression language will not change the language
        in parameters already containing expressions (i.e. parameters with
        keyframes).
        
        Note that if a parameter already contains an expression and you
        change that expression in the GUI, the expression language will not
        change, regardless of the value of the node's expression language.
        To change the language of an existing expression in a parameter from
        Python, use hou.Parm.setExpression, as in
        parm.setExpression(parm.expression(), language).
        
        
        """
        pass
        
    
    def stickyNotes():
        """
        iterStickyNotes(self) -> generator of hou.StickyNote
        
        Return a generator that iterates through all the sticky notes inside
        this node.
        
        
        """
        pass
        
    
    def deleteItems(items):
        """
        deleteItems(self, items)
        
        Destroys all the items in the provided tuple of
        hou.NetworkMovableItem objects. This is significantly more efficient
        than looping over the items and calling destroy() on each one. It
        also safely handles cases where one object may not be allowed to be
        deleted unless another object is also deleted.
        
        Raises hou.OperationFailed if one or more of the provided items is
        not a child of this node. Raises hou.PermissionError if this node is
        or is inside a locked digital asset.
        
        
        """
        pass
        
    
    def parmTuples():
        """
        parmTuples(self) -> tuple of hou.ParmTuple
        
        Return a list of all parameter tuples on this node.
        
        This method is similar to parms(), except it returns a list of
        hou.ParmTuple instead of hou.Parm.
        
        
        """
        pass
        
    
    def matchCurrentDefinition():
        """
        matchCurrentDefinition(self)
        
        If this node is an unlocked digital asset, change its contents to
        match what is stored in the definition and lock it. The parameter
        values are unchanged.
        
        If this node is locked or is not a digital asset, this method has no
        effect.
        
        See also hou.Node.matchesCurrentDefinition and hou.Node.isLocked.
        
        
        """
        pass
        
    
    def appendComment(comment):
        """
        appendComment(self, comment)
        
        Appends the given text to the comment associated with this node.
        
        
        """
        pass
        
    
    def cookCodeLanguage():
        """
        cookCodeLanguage(self) -> str
        
        Return the language of the generated cook code (i.e. VEX, RSL).
        
        Raises hou.OperationFailed if this node cannot generate compiled
        code.
        
        
        """
        pass
        
    
    def cachedUserData(name):
        """
        cachedUserData(self, name) -> str or None
        
        Return the user-defined cached data with this name, or None if no
        data with this name exists.
        
        See hou.Node.setCachedUserData for more information.
        
        This method can be implemented as follows:
        
        > def cachedUserData(self, name):
        >     return self.cachedUserDataDict().get(name)
        
        Note that None is a valid value for a key, so the most reliable way
        to check if a key is valid is to check if it is in the result of
        cachedUserDataDict:
        
        > >>> n = hou.node("/obj").createNode("geo")
        > >>> n.cachedUserDataDict()
        > {}
        > >>> print n.cachedUserData("foo")
        > None
        > >>> "foo" in n.cachedUserDataDict()
        > False
        > >>> n.setCachedUserData("foo", None)
        > >>> n.cachedUserDataDict()
        > {'foo': None}
        > >>> print n.cachedUserData("foo")
        > None
        > >>> "foo" in n.cachedUserDataDict()
        > True
        
        """
        pass
        
    
    def isCurrent():
        """
        isCurrent(self) -> bool
        
        Return a boolean to indicate of the node is the last selected node
        in its network.
        
        Each network (i.e. node containing children) stores its own list of
        selected nodes, and the last selected node has special meaning. For
        example, it is the node displayed in unpinned parameter panes.
        
        See also hou.selectedNodes to get a tuple of all the selected nodes
        in all networks in Houdini. The last node in this list also has
        special meaning in Houdini, and corresponds to the global current
        node.
        
        
        """
        pass
        
    
    def setDeleteScript(script_text, language=hou.scriptLanguage.Python):
        """
        setDeleteScript(self, script_text, language=hou.scriptLanguage.Python)
        
        Sets the script that will run when this node is deleted.
        
        
        """
        pass
        
    
    def _setParmClipData():
        """None"""
        pass
        
    
    def loadItemsFromFile(file_name, ignore_load_warnings=False):
        """
        loadItemsFromFile(self, file_name, ignore_load_warnings=False)
        
        Load the contents of a file (saved with hou.Node.saveItemsToFile)
        into the contents of this node.
        
        Raises hou.OperationFailed if the file does not exist or it is not
        the correct type of file. Raises hou.PermissionError if this node is
        a locked instance of a digital asset. Raises hou.LoadWarning if the
        load succeeds but with warnings and ignore_load_warnings is False.
        
        
        """
        pass
        
    
    def setExpressionLanguage(language):
        """
        setExpressionLanguage(self, language)
        
        Set the node's default expression language. See expressionLanguage()
        for more information.
        
        
        """
        pass
        
    
    def items(item_path_tuple):
        """
        items(self, item_path_tuple) -> tuple of hou.NetworkMovableItem or None
        
        This is like item() but takes multiple paths and returns multiple
        NetworkMovableItem objects. This is the equivalent of:
        
        > items = [self.item(path) for path in paths]
        
        """
        pass
        
    
    def messages():
        """
        messages(self) -> tuple of str
        
        Return the text of any messages from the last cook of this node, or
        an empty tuple if there were no messages.
        
        
        """
        pass
        
    
    def createDigitalAsset(name=None, hda_file_name=None, description=None, min_num_inputs=0, max_num_inputs=0, compress_contents=False, comment=None, version=None, save_as_embedded=False, ignore_external_references=False, change_node_type=True, create_backup=True):
        """
        createDigitalAsset(self, name=None, hda_file_name=None,
        description=None, min_num_inputs=0, max_num_inputs=0,
        compress_contents=False, comment=None, version=None,
        save_as_embedded=False, ignore_external_references=False,
        change_node_type=True, create_backup=True) -> Node
        
        Create a digital asset from this node. You would typically call this
        method on subnet nodes.
        
        
        name
        The name of the node type that the new digital asset will
        define.
        
        hda_file_name
        The name of the hda file where Houdini will save the digital
        asset. If None Houdini will use
        $HOME/houdiniX.Y/hda/OPcustom.hda.
        
        description
        The name that will appear in the tab menu. If None, Houdini will
        use the name for the description.
        
        min_num_inputs
        The minimum number of inputs that need to be wired into
        instances of the digital asset. See
        hou.HDADefinition.minNumInputs for more information.
        
        max_num_inputs
        The number of input connectors available on instances of the
        digital asset for input connections. See
        hou.HDADefinition.minNumInputs for more information.
        
        compress_contents
        Whether or not the contents of this digital asset are compressed
        inside the hda file. See hou.HDAOptions.compressContents for
        more information.
        
        comment
        A user-defined comment string. See hou.HDADefinition.comment for
        more information.
        
        version
        A user-defined version string. See hou.HDADefinition.version for
        more information.
        
        save_as_embedded
        Whether or not the digital asset's definition will be saved with
        the hip file instead of an hda file. When this parameter is
        True, Houdini ignores the hda_file_name parameter. Setting this
        parameter to True is equivalent to setting this parameter to
        False and setting the hda_file_name parameter to "Embedded".
        
        ignore_external_references
        If True, Houdini will not generate warnings if the contents of
        this digital asset reference nodes outside the asset.
        
        change_node_type
        Normally, Houdini will change the node creating the digital
        asset into the new digital asset type. Setting this flag to
        false will cause the node to remain unchanged.
        
        create_backup
        Create a backup before modifying an existing hda file.
        
        
        """
        pass
        
    
    def __modificationTime():
        """None"""
        pass
        
    
    def asCode(brief=False, recurse=False, save_channels_only=False, save_creation_commands=True, save_keys_in_frames=False, save_outgoing_wires=False, save_parm_values_only=False, save_spare_parms=True, function_name=None):
        """
        asCode(self, brief=False, recurse=False, save_channels_only=False,
        save_creation_commands=True, save_keys_in_frames=False,
        save_outgoing_wires=False, save_parm_values_only=False,
        save_spare_parms=True, function_name=None) -> str
        
        Prints the Python code necessary to recreate a node.
        
        
        brief
        Do not set values if they are the parameter's default. Applies
        to the contents of the node if either recurse or
        save_box_contents is True.
        
        recurse
        Recursively apply to the entire operator hierarchy.
        
        save_box_contents
        Script the contents of the node.
        
        save_channels_only
        Only output channels. Applies to the contents of the node if
        either recurse or save_box_contents is True.
        
        save_creation_commands
        Generate a creation script for the node. If set to False, the
        generated script assumes that the network box already exists.
        When set to True, the script will begin by creating the network
        box.
        
        save_keys_in_frames
        Output channel and key times in samples (frames) instead of
        seconds. Applies to the contents of the node if either recurse
        or save_box_contents is True.
        
        save_parm_values_only
        Evaluate parameters, saving their values instead of the
        expressions. Applies to the contents of the node if either
        recurse or save_box_contents is True.
        
        save_spare_parms
        Save spare parameters as well. When save_creation_commands is
        True, commands for creating spare parameters will also be
        output. Applies to the contents of the node if either recurse or
        save_box_contents is True.
        
        function_name
        If a function_name is specified, the output will be wrapped in a
        Python function.
        
        
        """
        pass
        
    
    def saveItemsToFile(items, file_name, save_hda_fallbacks, =, False):
        """
        saveItemsToFile(self, items, file_name, save_hda_fallbacks = False)
        
        Given a sequence of child items (nodes, network boxes, sticky notes,
        etc), save a file containing those items. You can load this file
        using hou.Node.loadItemsFromFile.
        
        
        items
        A sequence of hou.NetworkMovableItems that are children of this
        node.
        
        file_name
        The name of the file to write the contents to. You can use any
        extension for this file name.
        
        save_hda_fallbacks
        Set to True to save simplified definitions for HDAs into the
        file along with the child nodes. Doing this allows the generated
        file to be safely loaded into any houdini session, even if the
        assets used in the file are not already loaded into the houdini
        session. Depending on the use of the generated file, this
        information is often not required and makes the files
        unnecessarily large.
        
        Raises hou.OperationFailed if any of the nodes or network boxes are
        node children of this node, or if the file could not be written to.
        Raises hou.PermissionError if you do not have permission to read the
        contents of this node.
        
        
        """
        pass
        
    
    def comment():
        """
        comment(self) -> str
        
        Return the node's comment string.
        
        
        """
        pass
        
    
    def isSubNetwork():
        """None"""
        pass
        
    
    def allNodes(self):
        """
        allNodes(self) -> generator of hou.Node
        
        Recursively return a sequence of all nodes contained in this node
        including this node. This method differs from
        hou.Node.allSubChildren in the following ways:
        
        * It includes this node in the returned sequence.
        
        * It does not guarantee a top-down or bottom-up traversal order.
        
        * The method is a generator and does not return a tuple so it is not
        safe to create or delete nodes while looping through the return
        value.
        
        Here is an example of printing out the paths for all nodes under
        /obj:
        
        > root_node = hou.node("/obj")
        > for node in root_node.allNodes():
        >     print node.path()
        """
        pass
        
    
    def setBuiltExplicitly():
        """None"""
        pass
        
    
    def cookCount():
        """
        cookCount(self) -> int
        
        Returns the number of times this node has cooked in the current
        session.
        
        
        """
        pass
        
    
    def removeSpareParms():
        """
        removeSpareParms(self)
        
        Removes all spare parameters from this node.
        
        
        """
        pass
        
    
    def references(include_children, =, True):
        """
        references(self, include_children = True) -> tuple of hou.Node
        
        Return a tuple of nodes that are referenced by this node, either
        through parameter expressions, referring to the node by name, or
        using expressions which rely on the data generated by another node.
        These reflect all the other ways (besides connecting to an input) in
        which one node may affect another.
        
        Note that the result can differ depending last cook of the nodes.
        It's recommended that you first call cook() on the node first.
        
        
        """
        pass
        
    
    def saveCompiledCookCodeToFile(file_name, context_name=None):
        """
        saveCompiledCookCodeToFile(self, file_name, context_name=None)
        
        Saves compiled VEX code to a disk file (for nodes that support
        this). See hou.Node.saveCookCodeToFile for a description of the
        arguments.
        
        
        """
        pass
        
    
    def setGenericFlag(flag, value):
        """
        setGenericFlag(self, flag, value)
        
        Sets the value of the specified flag based on the bool value
        argument.
        
        flag must be a hou.nodeFlag value.
        
        
        """
        pass
        
    
    def parms():
        """
        parms(self) -> tuple of hou.Parm
        
        Return a list of the parameters on this node.
        
        
        """
        pass
        
    
    def destroyUserData(name):
        """
        destroyUserData(self, name)
        
        Remove the user-defined data with this name.
        
        See hou.Node.setUserData for more information.
        
        Raises hou.OperationFailed if no user data with this name exists.
        
        
        """
        pass
        
    
    def parmAliases(recurse=False):
        """
        parmAliases(self, recurse=False) -> dict of hou.Parm to str
        
        Return a dictionary of parameter aliases on the node's parameters.
        The keys in the dictionary are the parameters that have aliases and
        the values are the alias names.
        
        
        recurse
        Return the parameter aliases for this node _and its children_.
        
        
        """
        pass
        
    
    def nodeGroups():
        """
        nodeGroups(self) -> tuple of hou.NodeGroup
        
        Return the list of node groups in this node.
        
        
        """
        pass
        
    
    def saveParmClip(self, file_name, start=None, end=None, sample_rate=0, scoped_only=False):
        """
        saveParmClip(self, file_name, start=None, end=None, sample_rate=0,
        scoped_only=False)
        
        Saves the animation associated with the parameters of this node to
        the clip file specified by <file_name>. The extension of <file_name>
        determines the format of the saved file.
        
        You can use one of the following extensions:
        
        * .clip: save animation as plain text (ASCII) clip file.
        
        * .bclip: save animation as a bclip (binary clip) file.
        
        * .bclip.sc: save animation as a bclip file using Blosc compression.
        
        Set <sample_rate> to a non-zero, non-negative value to specify the
        sample_rate to be used for the clip file. For example, if the
        current frame rate is 24 (hou.fps), and <sample_rate> is set to 12,
        the animation will be sampled every second frame since <sample_rate>
        is half of the current frame rate.
        
        If <start> is not None, start saving the animation from the
        specified frame (inclusive). Otherwise, the animation will be saved
        from the global start frame (inclusive).
        
        Similarly, if <end> is not None, stop saving the animation at the
        specified frame (inclusive). Otherwise, the animation will be saved
        until the global end frame (inclusive).
        
        The global start and end frame are specified in the Global Animation
        Options window.
        
        If <scoped_only> is True, only the animation associated with scoped
        parameters will be saved. If there are no scoped parameters, the
        animation associated with auto-scoped parameters will be saved.
        
        If <scoped_only> is False, animation associated with any of the
        parameters of this node will be saved.
        
        Raises a hou.OperationFailed exception if none of the parameters of
        this node have animation. If <scoped_only> is True, this exception
        can be raised if none of the scoped parameters have animation, or if
        none of the auto-scoped parameters have animation (if the node has
        no scoped parameters).
        
        Raises a hou.OperationFailed exception if there is an error saving
        the animation to file.
        
        Raises a hou.InvalidInput exception if start >= end. If specifying
        only <start>, ensure that the specified value is less than the
        global end frame. Likewise, if specifying only <end>, ensure it is
        larger than the global start frame.
        
        """
        pass
        
    
    def allowEditingOfContents(propagate=False):
        """
        allowEditingOfContents(self, propagate=False)
        
        Unlocks a digital asset so its contents can be edited.
        
        To use this function, you must have permission to modify the HDA.
        
        
        """
        pass
        
    
    def iterNetworkBoxes():
        """None"""
        pass
        
    
    def layoutChildren(items=():
        """
        layoutChildren(self, items=(), horizontal_spacing=-1.0,
        vertical_spacing=-1.0)
        
        Automatically position all or some children of this node in the
        network editor.
        
        
        items
        A sequence of child hou.NetworkMovableItem objects to position.
        This may include nodes, dots, and/or subnet inputs. If this
        sequence is empty, this method will reposition all child items
        of this node.
        
        horizontal_spacing
        A fraction of the width and height of a tile that affects the
        space between nodes with common inputs. If this parameter is -1,
        Houdini uses the default spacing.
        
        vertical_spacing
        A fraction of the width and height of a tile that affects the
        space between a node and its output nodes. If this parameter is
        -1, Houdini uses the default spacing.
        
        
        """
        pass
        
    
    def setCreatorState(state):
        """
        setCreatorState(self, state)
        
        This sets the name of the tool that created this node. If you call
        this with a name that differs from the node type name, you should
        also call setBuiltExplicitly(False).
        
        
        """
        pass
        
    
    def type():
        """
        type(self) -> hou.NodeType
        
        Return the hou.NodeType object for this node.
        
        For example, all camera node instances share the same node type.
        
        
        """
        pass
        
    
    def dataBlockKeys(blocktype):
        """
        dataBlockKeys(self, blocktype) -> tuple of str
        
        Return the names of all data blocks stored on this node that are of
        the data type specified by the blocktype parameter.
        
        Data blocks are similar to user data in that they can contain any
        extra data that may be useful to attach to a specific node. They
        differ from user data in that data blocks are designed to more
        efficiently handle large blocks of data. Data blocks can also
        contain binary data, and have a data type associated with each
        block.
        
        
        """
        pass
        
    
    def spareParms():
        """
        spareParms(self) -> tuple of hou.Parm
        
        Return a list of the spare (user-defined) parameters on this node.
        
        
        """
        pass
        
    
    def setParmClipData(self):
        """auto-insert ocstring: HOM_Node::setParmClipData"""
        pass
        
    
    def addControlParmFolder(self, folder_name=None, parm_name=None):
        """
        addControlParmFolder(self, folder_name=None, parm_name=None)
        
        Adds a control parameter folder as the front-most folder at the top-
        level. This is used to increase visibility of customized control
        parameters. If a folder of the same name already exists, no new
        folder will be created. If folder_name is None, it will be set as
        'Controls'. If parm_name is None, it will be set as 'folder'.
        
        If there are no current folders present, the existing parameters
        will be grouped together and stored into a new folder named
        'Parameters' and placed after the new control parameter folder.
        
        """
        pass
        
    
    def outputs():
        """
        outputs(self) -> tuple of hou.Node
        
        Return a tuple of the nodes connected to this node's outputs.
        
        This method is a shortcut for [connection.inputNode() for connection
        in self.outputConnections()].
        
        
        """
        pass
        
    
    def parm(parm_path):
        """
        parm(self, parm_path) -> hou.Parm or None
        
        Return the parameter at the given path, or None if the parameter
        doesn't exist.
        
        
        """
        pass
        
    
    def selectedItems(include_hidden=False, include_hidden_support_nodes=False):
        """
        selectedItems(self, include_hidden=False,
        include_hidden_support_nodes=False) -> tuple of hou.NetworkMovableItem
        
        Return a tuple containing the children of this node that are
        selected. Unlike selectedChildren, this method will also return any
        selected hou.NetworkBox, hou.SubnetIndirectInput, hou.StickyNote,
        and hou.NetworkDot objects.
        
        
        include_hidden
        If False, hidden nodes are not included in the result, even if
        they are selected. Other network item types cannot be hidden,
        and so are unaffected by the value of this parameter.
        
        include_hidden_support_nodes
        If True, include in the returned tuple any hidden nodes that
        exist solely to support nodes that are actually selected. This
        specifically refers to VOP Parameter nodes, but may include
        other support nodes as well.
        
        The following example will print the positions of all selected items
        in /obj:
        
        > for n in hou.node("/obj").selectedItems():
        >     print n.position()
        
        """
        pass
        
    
    def createNetworkDot():
        """
        createNetworkDot(self) -> hou.NetworkDot
        
        Creates a network dot inside this network. Raises
        hou.OperationFailed if this node is not a network.
        
        
        """
        pass
        
    
    def allItems():
        """
        allItems(self) -> tuple of hou.NetworkMovableItem
        
        Return a tuple containing all the children of this node. Unlike
        children, this method will also return hou.NetworkBox,
        hou.SubnetIndirectInput, hou.StickyNote, and hou.NetworkDot objects.
        
        
        """
        pass
        
    
    def deleteScript():
        """
        deleteScript(self) -> str
        
        Return the script that will run when this node is deleted.
        
        
        """
        pass
        
    
    def isEditableInsideLockedHDA():
        """
        isEditableInsideLockedHDA(self) -> bool
        
        Return True if the node is an editable node contained inside a
        locked HDA node and False otherwise. In particular this function
        will return False for a node that is not inside a locked HDA.
        
        
        """
        pass
        
    
    def isTimeDependent():
        """
        isTimeDependent(self) -> bool
        
        Return whether the node is time dependent. A time dependent node is
        re-evaluated every time the frame changes.
        
        
        """
        pass
        
    
    def hm():
        """None"""
        pass
        
    
    def _saveParmClip():
        """None"""
        pass
        
    
    def isFlagWritable(flag):
        """
        isFlagWritable(self, flag) -> bool
        
        Return True if the specified flag is writable and False otherwise.
        
        flag must be a hou.nodeFlag value.
        
        
        """
        pass
        
    
    def networkBoxes():
        """
        iterNetworkBoxes(self) -> generator of hou.NetworkBox
        
        Return a generator that iterates through all the network boxes
        inside this node.
        
        
        """
        pass
        
    
    def setDataBlock(key, block, blocktype):
        """
        setDataBlock(self, key, block, blocktype)
        
        Stores the provided data block on the node under the provided key
        name, marking it with the provided data type.
        
        Passing a block value of None will remove any data block with the
        specified key.
        
        
        """
        pass
        
    
    def createInputNode(self, input_index, node_type_name, node_name=None, run_init_scripts=True, load_contents=True, bool, exact_type_name=False):
        """
        createInputNode(self, input_index, node_type_name, node_name=None,
        run_init_scripts=True, load_contents=True, bool exact_type_name=False)
        
        Create a new node and connect it to one of this node's inputs.
        Return the new node.
        
        
        input_index
        The index of this node's input connector.
        
        node_type_name
        The name of the type of node to create. See the createNode
        method for more information.
        
        node_name
        See the createNode method for more information.
        
        run_init_scripts
        See the createNode method for more information.
        
        load_contents
        See the createNode method for more information.
        
        exact_type_name
        See the createNode method for more information.
        
        See also the createOutputNode method.
        
        """
        pass
        
    
    def cachedUserDataDict(name):
        """
        cachedUserDataDict(self, name) -> dict of str to str
        
        Return a dictionary containing all the user-defined name/string
        pairs for this node.
        
        See hou.Node.setCachedUserData for more information.
        
        
        """
        pass
        
    
    def syncNodeVersionIfNeeded(from_version):
        """
        syncNodeVersionIfNeeded(self, from_version)
        
        Synchronize the node from the specified version to the current
        version of its HDA definition. See also hou.HDADefinition.version.
        
        
        """
        pass
        
    
    def creationTime(self):
        """
        creationTime(self) -> datetime.datetime
        
        Return the date and time when the node was created.
        
        """
        pass
        
    
    def saveToCompiledVexFile():
        """None"""
        pass
        
    
    def setParms(self, parm_dict):
        """
        setParms(self, parm_dict)
        
        Given a dictionary mapping parm names to values, set each of the
        corresponding parms on this node to the given value in the
        dictionary.
        
        The following example sets the tx and sy parameters at once:
        
        > >>> node = hou.node("/obj").createNode("geo")
        > >>> node.setParms({"tx": 1, "sy": 3})
        
        Raises hou.OperationFailed if any of the parameter names are not
        valid.
        
        See also the setParmExpressions method.
        
        """
        pass
        
    
    def parmTemplateGroup():
        """None"""
        pass
        
    
    def dependents(include_children, =, True):
        """
        dependents(self, include_children = True) -> tuple of hou.Node
        
        Return a tuple of nodes that are reference this node, either through
        parameter expressions, referring to the node by name, or using
        expressions which rely on the data generated by this node. These
        reflect all the other ways (besides connecting to an input) in which
        one node may affect another.
        
        Note that the result can differ depending last cook of the nodes.
        
        
        """
        pass
        
    
    def removeSpareParmFolder(self, folder):
        """
        removeSpareParmFolder(self, folder)
        
        Removes an empty folder from the spare parameters.
        
        folder is a sequence of folder names. So, to remove the Output
        folder, use ("Output",) instead of "Output".
        
        See also addSpareParmFolder(), hou.ParmTemplateGroup.remove, and
        hou.ParmTemplateGroup.findFolder.
        
        """
        pass
        
    
    def _getArgumentAutoComplete():
        """None"""
        pass
        
    
    def isCompiled():
        """None"""
        pass
        
    
    def _parmClipData():
        """None"""
        pass
        
    
    def outputNames():
        """
        outputNames(self) -> tuple of str
        
        Returns a tuple of all output names for this node.
        
        
        """
        pass
        
    
    def isHidden():
        """
        isHidden(self)
        
        Return whether the node is hidden in the network editor. Note that
        Houdini also uses the term "exposed" to refer to nodes that are not
        hidden.
        
        If a visible node is connected to a hidden node, the network editor
        will display dashed lines for the wire going from the visible node
        to the hidden node.
        
        See also hou.Node.hide.
        
        
        """
        pass
        
    
    def motionEffectsNetworkPath():
        """
        motionEffectsNetworkPath(self) -> str
        
        Return a node path representing the location for storing clips. This
        location may or may not exist. To find or create such a network, use
        hou.Node.findOrCreateMotionEffectsNetwork.
        
        
        """
        pass
        
    
    def insertInput(input_index, item_to_become_input, output_index=0):
        """
        insertInput(self, input_index, item_to_become_input, output_index=0)
        
        Insert an input wire. In other words, for each input connector after
        input_index, shift the contents of that input connector to the next
        one, and then call hou.Node.setInput. See hou.Node.setInput for the
        meanings of the parameters.
        
        
        """
        pass
        
    
    def needsToCook(time=hou.time():
        """
        needsToCook(self, time=hou.time()) -> bool
        
        Asks if the node needs to re-cook.
        
        
        """
        pass
        
    
    def setNamedInput(input_name, item_to_become_input, output_name_or_index):
        """
        setNamedInput(self, input_name, item_to_become_input,
        output_name_or_index)
        
        Connects an output on this node (specified by either an output name
        or an output index) to the input on the item_to_become_input
        specified by input_name.
        
        
        """
        pass
        
    
    def dataBlockType(key):
        """
        dataBlockType(self, key) -> str
        
        Return the data type of the block specified by the key parameter.
        
        Raises hou.ValueError if the provided key is not associated with any
        data block on this node.
        
        
        """
        pass
        
    
    def isDisplayDescriptiveNameFlagSet():
        """
        isDisplayDescriptiveNameFlagSet(self) -> bool
        
        Return a boolean to indicate of the node should display its
        descriptive name in the network editor.
        
        
        """
        pass
        
    
    def saveCodeToFile():
        """None"""
        pass
        
    
    def subnetOutputs():
        """
        subnetOutputs(self) -> tuple of hou.Node
        
        Return the hou.Node objects that are produce the subnet's outputs.
        
        Raises hou.InvalidNodeType if this node is not a subnetwork.
        
        
        """
        pass
        
    
    def destroyCachedUserData(name):
        """
        destroyCachedUserData(self, name)
        
        Remove the user-defined cached data with this name.
        
        See hou.Node.setCachedUserData for more information.
        
        Raises hou.OperationFailed if no user data with this name exists.
        
        
        """
        pass
        
    
    def addNodeGroup(name=None):
        """
        addNodeGroup(self, name=None) -> hou.NodeGroup
        
        Add a node group to the node and return the new group.
        
        If a group of the given name already exists then this function
        simply returns the existing group without adding a new one. If the
        name of the group is None or an empty string, then a unique default
        name is automatically chosen.
        
        This function can only be called on nodes that are networks. If it
        is called on a node that is not a network, then it raises
        hou.OperationFailed.
        
        To remove a node group, use hou.NodeGroup.destroy.
        
        
        """
        pass
        
    
    def setFirstInput(item_to_become_input, output_index=0):
        """
        setFirstInput(self, item_to_become_input, output_index=0)
        
        A shortcut for self.setInput(0, item_to_become_input). See
        hou.Node.setInput for more information.
        
        
        """
        pass
        
    
    def inputNames():
        """
        inputNames(self) -> tuple of str
        
        Returns a tuple of all input names for this node. Names for input
        connectors that are hidden are also included.
        
        
        """
        pass
        
    
    def setParmsPending(self, parm_dict):
        """
        setParmsPending(self, parm_dict)
        
        Given a dictionary mapping parm names to values, sets the pending
        value of each of the corresponding parms on this node.
        
        Raises hou.OperationFailed if any of the parameter names are not
        valid.
        
        See also the setPending method.
        
        """
        pass
        
    
    def nodeGroup(name):
        """
        nodeGroup(self, name) -> hou.NodeGroup
        
        Return a node group contained by the node with the given name, or
        None if the group does not exist.
        
        
        """
        pass
        
    
    def _asVoidPointer():
        """None"""
        pass
        
    
    def findStickyNote(name):
        """
        findStickyNote(self, name) -> hou.StickyNote
        
        Return a sticky note with the given name inside this node, or None
        if no sticky note with the given name exists.
        
        
        """
        pass
        
    
    def parmTuple(parm_path):
        """
        parmTuple(self, parm_path) -> hou.ParmTuple or None
        
        Return the parm tuple at the given path, or None if it doesn't
        exist.
        
        This method is similar to parm(), except it returns a hou.ParmTuple
        instead of a hou.Parm.
        
        
        """
        pass
        
    
    def copyStickyNote(network_box_to_copy, new_name=None):
        """
        copyStickyNote(self, network_box_to_copy, new_name=None) ->
        hou.StickyNote
        
        Copies a sticky note and returns the copy.
        
        If new_name is given, the sticky note will be copied to a new sticky
        note named new_name (a different name will be generated if there is
        already a sticky note with that name).
        
        Raises hou.OperationFailed if this node is not a network or if the
        node child type does not match the sticky note's node type.
        
        
        """
        pass
        
    
    def eventCallbacks():
        """None"""
        pass
        
    
    def destroy():
        """
        destroy(self)
        
        Delete this node.
        
        If you call methods on a Node instance after it has been destroyed,
        Houdini will raise hou.ObjectWasDeleted.
        
        Raises hou.OperationFailed if you try to delete a node inside a
        locked asset.
        
        
        """
        pass
        
    
    def changeNodeType(new_node_type, keep_name=True, keep_parms=True, keep_network_contents=True, force_change_on_node_type_match=False):
        """
        changeNodeType(self, new_node_type, keep_name=True, keep_parms=True,
        keep_network_contents=True, force_change_on_node_type_match=False) ->
        hou.Node
        
        Changes the node to a new type (within the same context).
        new_node_type is the internal string name of the type you want to
        change to.
        
        Keep_name, keep_parms, and keep_network_contents indicate that the
        node should keep the same name, parameter values, and contents,
        respectively, after its type has changed.
        force_change_on_node_type_match indicates whether to perform the
        change even when is already of the specified type.
        
        
        """
        pass
        
    
    def evalParmTuple(parm_path):
        """
        evalParmTuple(self, parm_path) -> tuple of int, float, or str
        
        Evaluates the specified parameter tuple and returns the result.
        
        
        """
        pass
        
    
    def createCompiledDigitalAsset(name=None, hda_file_name=None, description=None):
        """
        createCompiledDigitalAsset(self, name=None, hda_file_name=None,
        description=None)
        
        Create a compiled digital asset from this node. You would typically
        call this method on vop network nodes, such as Material Shader
        Builder SHOP, Surface Shader Builder SHOP, or VEX Surface SHOP Type
        VOPNET. The digital asset does not have contents section, which
        means it does not have vop network inside, but instead relies on the
        saved VEX code sections to provide the shader code.
        
        After the creation of a compiled HDA, if its VEX code section is
        ever changed manually, the corresponding vex object code section can
        be recompiled using hou.HDADefinition.compileCodeSection.
        
        
        name
        The name of the node type that the new digital asset will
        define.
        
        hda_file_name
        The name of the hda file where Houdini will save the digital
        asset. If None Houdini will use
        $HOME/houdiniX.Y/hda/OPcustom.hda.
        
        description
        The name that will appear in the tab menu. If None, Houdini will
        use the name for the description.
        
        
        """
        pass
        
    
    def simulation():
        """None"""
        pass
        
    
    def outputForViewFlag():
        """
        outputForViewFlag(self) -> int
        
        Return an integer to indicate which output of the node should be
        used for display purposes.
        
        
        """
        pass
        
    
    def inputs():
        """
        inputs(self) -> tuple of hou.Node
        
        Return a tuple of the nodes connected to this node's inputs. If an
        input is connected to a hou.SubnetIndirectInput, the node connected
        to the corresponding input on the parent subnet is returned. In
        other words the presence of the indirect input is hidden. This means
        the resulting nodes may not all be siblings of the calling node.
        
        If a particular input is not connected (or is connected to an
        indirect input and the corresponding subnet parent input is not
        connected), a None value is placed in the tuple at that location.
        
        
        """
        pass
        
    
    def userDataDict(name):
        """
        userDataDict(self, name) -> dict of str to str
        
        Return a dictionary containing all the user-defined name/string
        pairs for this node.
        
        See hou.Node.setUserData for more information.
        
        
        """
        pass
        
    
    def outputIndex(output_name):
        """
        outputIndex(self, output_name)
        
        Obtains an index of a node output that has the given name.
        
        For the node categories that use input names, it returns the index
        of the output with the given name.
        
        
        """
        pass
        
    
    def warnings():
        """
        warnings(self) -> tuple of str
        
        Return the text of any warnings from the last cook of this node, or
        an empty tuple if there were no warnings.
        
        
        """
        pass
        
    
    def saveChildrenToFile(self, nodes, network_boxes, file_name):
        """
        saveChildrenToFile(self, nodes, network_boxes, file_name)
        
        Combines separate lists of nods and network boxes into a single
        sequence, and calls hou.Node.saveItemsToFile. This method is
        provided for backward compatibility. New code should call
        saveItemsToFile directly.
        
        
        nodes
        A sequence of hou.Nodes that are children of this node.
        
        network_boxes
        A sequence of hou.NetworkBoxes that are contained in this node.
        Note that the contents of the network boxes are not
        automatically saved, so it is up to you to put them in the list
        of nodes.
        
        """
        pass
        
    
    def glob(pattern, ignore_case=False):
        """
        glob(self, pattern, ignore_case=False) -> tuple of hou.Node
        
        Return a tuple of children nodes name matches the pattern.
        
        The pattern may contain multiple pieces, separated by spaces. An
        asterisk (*) in a pattern piece will match any character. By
        default, Houdini will add the nodes from each pattern piece to those
        already matched. However, if the pattern piece begins with a caret
        (^), Houdini will remove the matches for that piece from the result.
        
        By default the pattern match is case-sensitive. Set ignore_case to
        True for case-insensitive pattern matching. Note that case
        insensitivity only applies when matching node names. It does not
        apply when matching group, network box or bundle names.
        
        This method returns an empty tuple if you pass in an empty pattern.
        
        > >>> obj = hou.node("/obj")
        > >>> obj.createNode("geo", "geo1")
        > <hou.ObjNode of type geo at /obj/geo1>
        > >>> obj.createNode("geo", "geo2")
        > <hou.ObjNode of type geo at /obj/geo2>
        > >>> obj.createNode("geo", "grid")
        > <hou.ObjNode of type geo at /obj/grid>
        > >>> obj.createNode("geo", "garbage")
        > <hou.ObjNode of type geo at /obj/garbage>
        > >>> obj.createNode("geo", "box")
        > <hou.ObjNode of type geo at /obj/box>
        >
        > >>> def names(nodes):
        > ... return [node.name() for node in nodes]
        >
        > >>> names(obj.glob("g*"))
        > ['geo1', 'geo2', 'grid', 'garbage']
        > >>> names(obj.glob("ge* ga*"))
        > ['geo1', 'geo2', 'garbage']
        > >>> names(obj.glob("g* ^ga*"))
        > ['geo1', 'geo2', 'grid']
        
        See also hou.Node.recursiveGlob.
        
        
        """
        pass
        
    
    def canGenerateCookCode(check_parent=False):
        """
        canGenerateCookCode(self, check_parent=False) -> bool
        
        Return True if the node can generate compiled cook code and False
        otherwise.
        
        If check_parent is true, the parents in the ancestor hierarchy are
        tested if any of them can generate code.
        
        
        """
        pass
        
    
    def updateParmStates():
        """
        updateParmStates(self)
        
        Update the UI states, such as hidden and disabled, for each
        parameter in the node.
        
        UI states can be expressed as conditionals (i.e. Disable When) which
        require evaluation. Typically in graphical Houdini the Parameter
        Pane performs the evaluation when the node is selected in order to
        determine how the node parameters should look in the pane. However
        in non-graphical Houdini or if the Parameter Pane has not yet loaded
        the node, then the evaluation does not occur and the UI states
        remain at their defaults causing methods such as hou.Parm.isDisabled
        and hou.Parm.isHidden to return incorrect values. In these cases, it
        is recommended that hou.Node.updateParmStates is called.
        
        
        """
        pass
        
    
    def createNetworkBox(name=None):
        """
        createNetworkBox(self, name=None) -> hou.NetworkBox
        
        Creates a network box inside this network. Raises
        hou.OperationFailed if this node is not a network.
        
        If you don't specify a name, Houdini gives the box a default name.
        
        Network box names are not displayed in the network editor pane.
        Instead, a "comment" can be specified with the
        hou.NetworkBox.setComment method, and this comment will appear in
        the title bar of the network box.
        
        
        """
        pass
        
    
    def stampValue(parm_name, default_value):
        """
        stampValue(self, parm_name, default_value)
        
        Return a copy stamping floating point or string value. This node
        must be a downstream stamping operator, such as a Copy SOP, Cache
        SOP, LSystem SOP, or Copy CHOP.
        
        
        parm_name
        The name of the stamping variable.
        
        default_value
        The value that this function returns if Houdini is not currently
        performing stamping, or if parm_name is not a valid variable
        name. This value may be a float or a string.
        
        You might put the following expression in a Python parameter:
        
        > node("../copy1").stampValue("sides", 5)
        
        """
        pass
        
    
    def collapseIntoSubnet(child_nodes, subnet_name=None, subnet_type=None):
        """
        collapseIntoSubnet(self, child_nodes, subnet_name=None,
        subnet_type=None) -> hou.Node
        
        Given a sequence of children nodes of this node, collapse them into
        a subnetwork. In other words, create a subnet inside this node's
        network and move the specified children of this network inside that
        subnet.
        
        
        child_nodes
        The children nodes of this node that will go in the new subnet.
        
        subnet_name
        The name for the new subnet node, or None if you want Houdini to
        automatically choose a name.
        
        subnet_type
        The type for the new subnet node, or None if you want Houdini to
        automatically choose a primary subnetwork type, which is
        recommended.
        
        Raises hou.OperationFailed if a node inside child_nodes is not a
        child of this network, or if child_nodes is an empty sequence.
        
        This example function takes a single node and replaces it with a
        subnet, moving the node into the subnet..
        
        > def collapseSingleNodeIntoSubnet(node, subnet_name=None):
        >     node.parent().collapseIntoSubnet((node,), subnet_name=None)
        
        """
        pass
        
    
    def inputIndex(input_name):
        """
        inputIndex(self, input_name)
        
        Obtains an index of a node input that has the given name.
        
        For the node categories that use input names, it returns the index
        of the input with the given name. For VOP nodes, the name may also
        be a node parameter name that has a corresponding input.
        
        
        """
        pass
        
    
    def setUserData(name, value):
        """
        setUserData(self, name, value)
        
        Add/set a named string on this node instance.
        
        
        name
        A unique name (key) for the user-defined data. By using
        different names, you can attach multiple pieces of user-defined
        data to a node.
        
        value
        The string to store.
        
        This name/value pair is stored with the hip file and is included in
        the output from opscript and hou.Node.asCode.
        
        The following example illustrates how to set, access, and delete
        user-defined data:
        
        > >>> n = hou.node("/obj").createNode("geo")
        > >>> n.setUserData("my data", "my data value")
        > >>> n.userData("my data")
        > 'my data value'
        > >>> n.userDataDict()
        > {'my data': 'my data value'}
        > >>> n.destroyUserData("my data")
        > >>> n.userDataDict()
        > {}
        > >>> print n.userData("my data")
        > None
        
        See per-node user-defined data for more information and examples.
        
        
        TIP
        If you prefix a user data key with nodeinfo_, the key (without
        the prefix) and the value will be shown as a custom field in the
        node info popup window.
        
        
        """
        pass
        
    
    def setOutputForViewFlag(output):
        """
        setOutputForViewFlag(self, output)
        
        Sets which output should be used for display purposes on this node.
        
        
        """
        pass
        
    
    def outputLabels():
        """
        outputLabels(self) -> tuple of str
        
        Returns a tuple of all output labels for this node.
        
        
        """
        pass
        
    
    def setComment(comment):
        """
        setComment(self, comment)
        
        Sets the comment associated with this node. See also
        appendComment().
        
        
        """
        pass
        
    
    def allSubChildren(top_down=True, recurse_in_locked_nodes=True):
        """
        allSubChildren(self, top_down=True, recurse_in_locked_nodes=True) ->
        tuple of hou.Node
        
        Recursively return all sub children of this node. For example,
        hou.node("/").allSubChildren() will return all the nodes in the hip
        file.
        
        
        top_down
        If True, this function will do a top-down traversal, placing a
        node in the returned tuple before its children. If False, it
        will do a bottom-up traversal, placing children before their
        parents.
        
        recurse_in_locked_nodes
        If True, the function will recurse inside locked child nodes
        (child nodes for which the isEditable() method returns False)
        and include children of the locked child nodes in the returned
        tuple.
        
        If False, the function will not recurse inside locked children
        nodes, and children of the locked child nodes will not be
        included in the returned tuple. (The locked child nodes,
        however, will be included.)
        
        For example if <recurse_in_locked_nodes> is True and
        hou.node("/obj") contains a Simple Female node (a locked node),
        then the tuple returned by hou.node("/obj").allSubChildren()
        will include the Simple Female node and its child nodes. If
        <recurse_in_locked_nodes> is False, the returned tuple will
        contain the Simple Female node, but not its child nodes.
        
        Note that a tuple is returned, not a generator. This means that it
        is safe to delete or create nodes while looping through the return
        value.
        
        The following function deletes all children of a particular type
        that appear anywhere inside a given node:
        
        > def removeSubChildrenOfType(node, node_type):
        >     '''Recursively delete all children of a particular type.'''
        >     for child in node.allSubChildren():
        >         if child.type() == node_type:
        >             child.destroy()
        
        This code, for example, removes all the visibility SOPs anywhere
        under /obj:
        
        > >>> removeSubChildrenOfType(hou.node("/obj"), hou.sopNodeTypeCategory().nodeTypes()['visibility'])
        
        """
        pass
        
    
    def recursiveGlob(pattern, filter=hou.nodeTypeFilter.NoFilter, include_subnets=True):
        """
        recursiveGlob(self, pattern, filter=hou.nodeTypeFilter.NoFilter,
        include_subnets=True) -> tuple of hou.Node
        
        Like hou.Node.glob, return a tuple of children nodes whose name
        matches the pattern. However, any matching child will have all its
        children added, recursively. As well, the result may be filtered by
        node type.
        
        Houdini first matches children nodes against the pattern, then
        recursively adds the subchildren of matching children, and then
        applies the filter.
        
        
        pattern
        Child node names will be matched against this string pattern.
        See hou.Node.glob and hou.NodeBundle for information about the
        pattern syntax. Note that if a child node matches the pattern
        and include_subnets is True, all of its subchildren will be
        added to the result (subject to filtering), regardless of the
        pattern.
        
        filter
        A hou.nodeTypeFilter enumeration value to limit matched nodes to
        a particular type (e.g. object nodes, geometry object nodes,
        surface shader SHOPs, etc.).
        
        include_subnets
        Specifies whether the children of a matching node will also be
        returned, regardless of the pattern.
        
        The pattern and filter behavior is very similar to that used by node
        bundles in Houdini. See hou.NodeBundle for more information.
        
        Raises hou.OperationFailed if the pattern is invalid.
        
        
        """
        pass
        
    
    def __creationTime():
        """None"""
        pass
        
    
    def inputConnections():
        """
        inputConnections(self) -> tuple of hou.NodeConnection
        
        Returns a tuple of hou.NodeConnection objects for the connections
        coming into the top of this node. The tuple will have a length equal
        to the number of connections coming into the node. Returns an empty
        tuple if nothing is connected to this node.
        
        To get a list of the connected nodes themselves, use
        hou.Node.inputs. To get a list of all possible connection sites
        (whether or not anything is connected to them), use
        hou.Node.inputConnectors.
        
        > >>> cookie = hou.node("/obj").createNode("geo").createNode("cookie")
        > >>> cookie.setInput(1, cookie.parent().createNode("box"))
        > >>> cookie.inputConnections()
        > (<hou.NodeConnection from grid1 output 0 to cookie input 1>,)
        > >>> cookie.inputConnectors()
        > ((), (<hou.NodeConnection from grid1 output 0 to cookie input 1>,))
        
        See also hou.Node.inputConnectors.
        
        
        """
        pass
        
    
    def matchesCurrentDefinition():
        """
        matchesCurrentDefinition(self) -> bool
        
        Return whether the contents of the node are locked to its type
        definition.
        
        
        """
        pass
        
    
    def localVariables():
        """
        localVariables(self)
        
        Return a list of local variables that can be referenced in parameter
        expressions on this node.
        
        
        """
        pass
        
    
    def _loadParmClip():
        """None"""
        pass
        

class NodeConnection(NetworkItem):
    """
    hou.NodeConnection
    
    Represents a connection (wire) between two Nodes.
    
    OVERVIEW
    
    You can get a list of NodeConnection objects from a hou.Node
    instance using hou.Node.inputConnections and
    hou.Node.outputConnections.
    
    
    NOTE
    It is probably easier to use the hou.Node.inputs and
    hou.Node.outputs methods (which return the endpoints of a node's
    connections) to traverse the network, rather than dealing with
    the connections themselves.
    
    This object is "read-only". To create or edit connections, use
    methods on the node, such as hou.Node.setNamedInput,
    hou.Node.setInput, hou.Node.setFirstInput, hou.Node.setNextInput,
    hou.Node.createInputNode, and hou.Node.createOutputNode.
    
    INPUT AND OUTPUT MEANING
    
    The hou.NodeConnection.outputNode and hou.NodeConnection.inputNode
    are named in relation to the _nodes_, *not* the "input" and "output"
    ends of the _connector_.
    
    
    So, outputNode() returns the node whose _output_ is this connector.
    In the diagram, outputNode() on the highlighted connection would
    return node "A". inputNode() returns the node whose input is this
    connector. In the diagram, inputNode() on the highlighted connection
    would return node "C".
    
    CONNECTION INDEXES
    
    Some nodes have multiple inputs and/or multiple outputs. For
    example, most VOPs have several inputs and outputs. The Split DOP
    has multiple outputs.
    
    A node with a multi-input, such as the Merge SOP, has multiple
    "inputs" for each connection, even though in the network editor it
    is drawn with one "connection point" at the top.
    
    Inputs and outputs are always addressed by their position (index).
    
    
    
    """
    
    def outputName():
        """
        outputName(self) -> str
        
        Returns the name of the output connection on the node that the input
        side of this connections connects to.
        
        
        """
        pass
        
    
    def setSelected(selected, clear_all_selected, =, False):
        """
        setSelected(self, selected, clear_all_selected = False)
        
        Selects or de-selects this connection. If the clear_all_selected
        parameter is set to True, all other selections (both connections,
        and nodes, network boxes, etc.) will be cleared before this
        connection is selected.
        
        
        """
        pass
        
    
    def inputLabel():
        """
        inputLabel(self) -> str
        
        Returns the label of the input connection on the node that the
        output side of this connections connects to.
        
        
        """
        pass
        
    
    def inputIndex():
        """
        inputIndex(self) -> int
        
        Returns the index of the input connection on the node that the
        output side of this connections connects to.
        
        
        """
        pass
        
    
    def outputLabel():
        """
        outputLabel(self) -> str
        
        Returns the label of the output connection on the node that the
        input side of this connections connects to.
        
        
        """
        pass
        
    
    def inputNode():
        """
        inputNode(self) -> hou.Node
        
        Return the node on the input side of this connection. This is the
        node that the connection comes from, in the direction of data flow.
        If this connection goes through an indirect input, this will return
        the node connected to the parent node (or None if nothing is
        connected).
        
        
        """
        pass
        
    
    def inputItem():
        """
        inputItem(self) -> hou.NetworkMovableItem
        
        If this connection has a subnet indirect input connected to it,
        return the corresponding hou.SubnetIndirectInput object. If this
        connection has a node connected to it, return the corresponding
        hou.Node object. Otherwise, return None. This method is essentially
        equivalent to the following:
        
        > def getInputItem(node_connection):
        >     if node_connection.subnetIndirectInput() is not None:
        >         return node_connection.subnetIndirectInput()
        >     return node_connection.inputNode()
        
        """
        pass
        
    
    def inputDataType():
        """None"""
        pass
        
    
    def outputDataType():
        """None"""
        pass
        
    
    def outputIndex():
        """
        outputIndex(self) -> int
        
        Returns the index of the output connection on the node that the
        input side of this connections connects to. If this connection goes
        through an indirect input, this will return the index of the output
        connected to the parent node (or 0 if nothing is connected).
        
        
        """
        pass
        
    
    def inputName():
        """
        inputName(self) -> str
        
        Returns the name of the input connection on the node that the output
        side of this connections connects to.
        
        
        """
        pass
        
    
    def outputNode():
        """
        outputNode(self) -> hou.Node
        
        Return the node on the output side of this connection. This is the
        node that the connection goes to, in the direction of data flow. If
        this connection has a network dot as its output, this method returns
        None.
        
        
        """
        pass
        
    
    def outputItem():
        """
        outputItem(self) -> hou.NetworkMovableItem
        
        Return the node or network dot on the output side of this
        connection. This is the node or dot that the connection goes to, in
        the direction of data flow. This method should never return None.
        
        
        """
        pass
        
    
    def isSelected():
        """
        isSelected(self) -> bool
        
        Return True if this connection is selected.
        
        
        """
        pass
        
    
    def subnetIndirectInput():
        """
        subnetIndirectInput(self) -> hou.SubnetIndirectInput
        
        If this connection has a subnet indirect input connected to it
        instead of a node, return the corresponding object. Otherwise,
        return None. See hou.SubnetIndirectInput for information on subnet
        indirect inputs.
        
        
        """
        pass
        
    
    def inputItemOutputIndex():
        """
        inputItemOutputIndex(self) -> int
        
        Returns zero if this connection has a subnet indirect input
        connected to it. Otherwise return the index of the output connection
        on the node that the input side of this connections connects to. In
        combination with the inputItem method, node and subnet indirect
        inputs can be processed through a common code path for many use
        cases.
        
        
        """
        pass
        

def NodeConnection_swigregister():
    """None"""
    pass
    

class NodeError(Error):
    """
    hou.NodeError
    
    Exception class used to set errors on nodes implemented via Python.
    
    Raise instances of this class from within Python SOPs, objects, etc. to
    set an error flag on the node. See Writing Python SOPs for more
    information.
    
    RELATED
    
    * hou.NodeWarning
    
    * hou.Error
    
    
    """
    
    def description():
        """
        description(self) -> str
        
        Return a description of the class of exception. The description is
        not related to the exception instance.
        
        
        """
        pass
        
    
    def exceptionTypeName():
        """
        exceptionTypeName(self) -> str
        
        Return the name of the exception type. Instances of different
        subclasses of hou.Error will return different names. Instances of
        the base class will return "Error".
        
        You can also use str(e.__class__) to get the name of the subclass.
        
        
        """
        pass
        

def NodeError_swigregister():
    """None"""
    pass
    

class NodeGroup(object):
    """
    hou.NodeGroup
    
    Represents a node group.
    
    In Houdini, a node group contains a set of nodes from the same network.
    Each group is named, and you can edit a group's contents from the
    network view pane by selecting Tools > Show Groups from its right-mouse
    menu.
    
    A node bundle, on the other hand, may contain nodes from multiple
    networks, and corresponds to a hou.NodeBundle object. You can edit a
    node bundle from the bundle list pane.
    
    
    """
    
    def parent():
        """
        parent(self) -> hou.Node
        
        Returns the network node containing this group.
        
        
        """
        pass
        
    
    def addNode(node):
        """
        addNode(self, node)
        
        Add a hou.Node to this group.
        
        If the node is already in the group, this method does nothing. If
        the node is not in the correct network for this group, raises
        hou.OperationFailed.
        
        
        """
        pass
        
    
    def name():
        """
        name(self) -> str
        
        Returns the name of this group.
        
        
        """
        pass
        
    
    def removeNode(node):
        """
        removeNode(self, node)
        
        Remove a hou.Node from this group.
        
        Raises hou.OperationFailed if the node is not in the group.
        
        
        """
        pass
        
    
    def clear():
        """
        clear(self)
        
        Remove all nodes from this group.
        
        
        """
        pass
        
    
    def asCode(save_creation_commands=False, function_name=None):
        """
        asCode(self, save_creation_commands=False, function_name=None) -> str
        
        Returns the Python code necessary to recreate this group.
        
        
        save_creation_commands
        Generate a creation script for the node group. If set to False
        (the default), the generated script assumes that the node group
        already exists. When set to True, the script will begin by
        creating the node group.
        
        function_name
        If a function_name is specified, the output will be wrapped in a
        Python function.
        
        
        """
        pass
        
    
    def destroy():
        """
        destroy(self)
        
        Delete this group. Does not delete the nodes that were contained in
        it.
        
        
        """
        pass
        
    
    def nodes():
        """
        nodes(self) -> tuple of hou.Node
        
        Return a tuple containing the nodes in this group.
        
        
        """
        pass
        

def NodeGroup_swigregister():
    """None"""
    pass
    

class NodeInfoTree(object):
    """
    hou.NodeInfoTree
    
    A tree structure designed to contain information about nodes and the
    data they generate.
    
    This class represents a tree structure, where each branch of the tree
    can have any number of named sub-trees, as well as a two dimensional
    grid of strings. Most often this grid has two columns ("Property" and
    "Value"), with some number of rows to represent arbitrary key/value
    pairs. But the grid can also contain more complex data (such as the
    volume information in geometry data).
    
    
    """
    
    def branchOrder():
        """
        branchOrder(self) -> tuple of str
        
        Returns the "natural" order of the child branches in the dictionary
        returned by branches(). This ordering is often not very important,
        but in situations where there are a large number of branches that do
        have some sort of natural order (such as the branches for each DOP
        object returned by a DOP node) this method can help organize the
        information.
        
        This code iterates through all child branches of a node's info tree
        in their natural order, assuming an RBD simulation created from a
        default sphere and torus object:
        
        > >>> nodeinfo = hou.node('/obj/AutoDopNetwork/output').infoTree()
        > >>> dopinfo = nodeinfo.branches()['DOP Info']
        > >>> objinfo = dopinfo.branches()['Objects']
        > >>> objbranches = objinfo.branches()
        > >>> for objname in objinfo.branchOrder():
        > ...   obj = objbranches[objname]
        > ...   print objname, ':', obj.branches()
        > ...
        > torus_object1 : {'Geometry': <hou.NodeInfoTree>}
        > sphere_object1 : {'Geometry': <hou.NodeInfoTree>}
        
        """
        pass
        
    
    def infoType():
        """
        infoType(self) -> str
        
        Returns a string that can be used to describe the type of data
        stored in this tree. For example, a tree holding geometry
        information (generated either by a SOP node or a DOP node) will
        return "Geometry" from this method.
        
        
        """
        pass
        
    
    def name():
        """
        name(self) -> str
        
        Returns the name of this branch of the tree.
        
        
        """
        pass
        
    
    def rows():
        """
        rows(self) -> tuple of tuple of str
        
        Return a two dimensional grid of strings. The returned tuple
        represents the rows of the grid. The contained tuples each represent
        one row. All contained tuples will be the same length, which will be
        the length of the tuple returned by the headings() method.
        
        
        """
        pass
        
    
    def branches():
        """
        branches(self) -> dict of str to hou.NodeInfoTree
        
        Return a dictionary of all child branches. Each branch has a name,
        and is a full tree, which may have it's own branches, and so on.
        
        
        """
        pass
        
    
    def headings():
        """
        headings(self) -> tuple of str
        
        Returns the titles of the columns for the data returned by the
        rows() method. Usually this will be simply ('Property', 'Value'),
        for rows that are simply key/value pairs. But in some cases the
        headings can help interpret the returned information.
        
        
        """
        pass
        

def NodeInfoTree_swigregister():
    """None"""
    pass
    

class NodeType(object):
    """
    hou.NodeType
    
    Information common to all instances of a type of node, such as the
    parameters.
    
    For example, the Geometry object and Subdivide SOP are node types.
    /obj/geo1 and /obj/geo2, on the other hand, are Node instances of the
    Geometry object node type.
    
    A digital asset defines a node type. The nodes contained inside the
    asset's definition implement the node type's algorithm, and you can
    customize the parameters in the node type using the Type Properties
    dialog,
    
    You can get a NodeType object from a Node object with hou.Node.type. For
    example, if /obj/geo1 is a geometry object, hou.node("/obj/geo1").type()
    will return the NodeType corresponding to all geometry objects.
    
    All the node types in Houdini are organized into categories, and a node
    type is uniquely identified by its category and node type name. For
    example, objects, SOPs, POPs, etc. are node type categories. You can
    also access a NodeType object from a category with
    hou.NodeTypeCategory.nodeTypes. Similarly, you can call hou.nodeType_
    with the category and node type name.
    
    See also hou.Node and hou.NodeTypeCategory.
    
    
    """
    
    def hasPermanentUserDefaults():
        """
        hasPermanentUserDefaults(self) -> bool
        
        Returns whether a user has set permanent defaults for this node
        type.
        
        See also hou.Parm.hasTemporaryDefaults
        
        
        """
        pass
        
    
    def removeAlias(alias):
        """
        removeAlias(self, alias)
        
        Remove an alias for this node type.
        
        
        """
        pass
        
    
    def sourcePath():
        """
        sourcePath(self) -> str
        
        Return the path to the source for this node type, or "Internal" if
        it is a built-in node type. If the node was created using the HDK,
        return the path to the shared object/dll for the node type.
        
        > >>> obj_cat = hou.objNodeTypeCategory()
        > >>> hou.nodeType(obj_cat, "biped_auto_rig").sourcePath()
        > 'oplib:/Object/biped_auto_rig?Object/biped_auto_rig'
        > >>> hou.nodeType(obj_cat, "geo").sourcePath()
        > 'Internal'
        
        """
        pass
        
    
    def isGenerator():
        """
        isGenerator(self) -> bool
        
        Return if this node type has been flagged as a generator. For
        example, a grid SOP generates new geometry, while a subdivide SOP
        does not, and instead processes the geometry passed into it. See
        also hou.NodeType.minNumInputs.
        
        
        """
        pass
        
    
    def hasUnorderedInputs():
        """
        hasUnorderedInputs(self) -> bool
        
        Return whether it is impossible for this node type to have gaps in
        its connected inputs. For example, the cookie SOP has two inputs,
        and it's possible for only the second input to be connected, so this
        method would return False. However, the merge SOP cannot have any
        gaps in its inputs, so this method would return True.
        
        See also hou.Node.inputs, hou.Node.inputConnections, and
        hou.Node.inputConnectors.
        
        
        """
        pass
        
    
    def containedNodeTypes():
        """
        containedNodeTypes(self) -> tuple of str
        
        Return a tuple of all NodeType names of the contents of an HDA.
        
        
        """
        pass
        
    
    def instances():
        """
        instances(self) -> tuple of hou.Node
        
        Return a tuple of all the nodes of this type in the current scene.
        
        
        """
        pass
        
    
    def setHidden(hidden):
        """
        setHidden(self, hidden)
        
        Set whether or not this node type appears in the tab menu. See also
        hou.NodeType.hidden.
        
        
        """
        pass
        
    
    def defaultShape():
        """
        defaultShape(self) -> str
        
        Return the name of the shape used to display a node of this type in
        the network view if no shape is explicitly assigned to the node.
        
        
        """
        pass
        
    
    def defaultHelpUrl():
        """
        defaultHelpUrl(self) -> str
        
        Return a generic URL that the help system will try to resolve to the
        actual location that stores the node type documentation. The generic
        URL is in the form "operator:table/optypename" and may include
        additional information such as a namespace or a version.
        
        
        """
        pass
        
    
    def isManager(include_management_types=True):
        """
        isManager(self, include_management_types=True) -> bool
        
        Return whether this NodeType is a manager. The manager node
        instances are /obj, /out, /part, /ch, /shop, /img, and /vex.
        
        If include_management_types is set to True then this method will
        additionally return True if this node type is a management node type
        such as a SHOP network, or VOP network, etc.
        
        
        """
        pass
        
    
    def allInstalledDefinitions():
        """
        allInstalledDefinitions(self) -> tuple of hou.HDADefinition
        
        Search all installed operator type libraries and return a tuple of
        available hou.HDADefinition objects providing definitions for this
        node type.
        
        Houdini allows multiple otl files to be loaded at the same time that
        each contain definitions for the same node type. The definition in
        use is called the current definition. See also
        hou.HDADefinition.isCurrent.
        
        
        """
        pass
        
    
    def childTypeCategory():
        """None"""
        pass
        
    
    def aliases():
        """
        aliases(self) -> tuple of str
        
        Return all current aliases for this node type. See
        hou.NodeType.addAlias for an example.
        
        
        """
        pass
        
    
    def category():
        """
        category(self) -> hou.NodeTypeCategory
        
        Return the node type category for this node type. For example, for
        the geometry object, the result is the object returned by
        hou.objNodeTypeCategory.
        
        
        """
        pass
        
    
    def hasUnorderedInputs():
        """
        hasUnorderedInputs(self) -> bool
        
        Return whether it is impossible for this node type to have gaps in
        its connected inputs. For example, the cookie SOP has two inputs,
        and it's possible for only the second input to be connected, so this
        method would return False. However, the merge SOP cannot have any
        gaps in its inputs, so this method would return True.
        
        See also hou.Node.inputs, hou.Node.inputConnections, and
        hou.Node.inputConnectors.
        
        
        """
        pass
        
    
    def sourceNetwork():
        """
        sourceNetwork(self) -> hou.Node or None
        
        If this node type is a digital asset, return the Node instance whose
        contents define the digital asset. Otherwise, return None.
        
        
        """
        pass
        
    
    def isWritable():
        """
        areContentsViewable(self) -> bool
        
        Return True if the node network contained in the node type is
        viewable and False otherwise.
        
        
        """
        pass
        
    
    def defaultColor():
        """
        defaultColor(self) -> hou.Color
        
        Return the color used to display a node of this type in the network
        view if the node's hou.nodeFlag.ColorDefault flag is set.
        
        
        """
        pass
        
    
    def source():
        """
        source(self) -> hou.nodeTypeSource enum value
        
        Return a hou.nodeTypeSource enumerated value to indicate if this
        node type is implemented in VEX, RSL, or the HDK (in C++), or if it
        is a built-in node type that ships with Houdini.
        
        > >>> obj_cat = hou.objNodeTypeCategory()
        > >>> sop_cat = hou.sopNodeTypeCategory()
        > >>> hou.nodeType(obj_cat, "biped_auto_rig").source()
        > nodeTypeSource.Subnet
        > >>> hou.nodeType(sop_cat, "mountain").source()
        > nodeTypeSource.VexCode
        
        """
        pass
        
    
    def embeddedHelp():
        """
        embeddedHelp(self) -> str
        
        Return the help text embedded in this node type. Return an empty
        string if no embedded help exists.
        
        The embedded help is searched for in two different places in the
        following order:
        
        * If an HDK node, the text given by its OP_Operator::getHDKHelp()
        override
        
        * If an HDA node, the corresponding result of
        hou.HDADefinition.embeddedHelp()
        
        
        """
        pass
        
    
    def setDefaultShape(shape):
        """
        setDefaultShape(self, shape)
        
        Set the name of the shape used to display a node of this type in the
        network view if no shape is explicitly assigned to the node. Pass
        None as the shape parameter to remove the type-specific default.
        
        
        """
        pass
        
    
    def hidden():
        """
        hidden(self) -> bool
        
        Return whether or not this node type appears in the tab menu. See
        also hou.NodeType.setHidden.
        
        
        """
        pass
        
    
    def minNumInputs():
        """
        minNumInputs(self) -> int
        
        Return the minimum number of inputs that nodes of this type can
        have. If these inputs are not connected, the node will generate an
        error.
        
        
        """
        pass
        
    
    def uninstallFromPath():
        """None"""
        pass
        
    
    def areContentsViewable():
        """None"""
        pass
        
    
    def maxNumOutputs():
        """
        maxNumOutputs(self) -> int
        
        Return the maximum number of outputs that nodes of this type can
        have. Most node types have only one output, but some, like the split
        dop, can have multiple.
        
        
        """
        pass
        
    
    def parmTemplates():
        """
        parmTemplates(self) -> tuple of hou.ParmTemplate
        
        Return a tuple of parm templates for the parameters on this node
        type. Note that spare parameters on individual node instances are
        not included in this tuple, since they are independent from the node
        type.
        
        
        """
        pass
        
    
    def hasEditableInputData():
        """
        hasEditableInputData(self) -> bool
        
        Return True if nodes of this node type allow the user to associate
        data with each input to the node. The purpose of this data may vary
        from one node type to another. This data can be accessed with
        methods such as hou.Node.editableInputName and
        hou.Node.setEditableInputName.
        
        
        """
        pass
        
    
    def description():
        """
        description(self) -> str
        
        Return the description of this node type that appears in the tab
        menu. For example, for the geometry object, the description is
        "Geometry". This description is also called the operator label in
        Houdini.
        
        
        """
        pass
        
    
    def addAlias(alias):
        """
        addAlias(self, alias)
        
        Add an alias for this node type. You can use this alias when
        creating new nodes.
        
        > >>> geo_type = hou.nodeType(hou.objNodeTypeCategory(), "geo")
        > >>> geo_type.addAlias("transformable")
        > >>> geo_type.aliases()
        > ('transformable',)
        > >>> hou.node("/obj").createNode("transformable")
        > <hou.ObjNode of type geo at /obj/geo1>
        
        """
        pass
        
    
    def setDefaultColor(color):
        """
        setDefaultColor(self, color)
        
        Set the color used to display a node of this type in the network
        view if the node's hou.nodeFlag.ColorDefault flag is set. Pass None
        as the color parameter to remove the type-specific default.
        
        
        """
        pass
        
    
    def maxNumInputs():
        """
        maxNumInputs(self) -> int
        
        Return the maximum number of inputs that nodes of this type can
        have. Return 9999 if this node type can accept an unlimited number
        of inputs (e.g. the merge SOP).
        
        
        """
        pass
        
    
    def icon():
        """
        icon(self) -> str
        
        Return the name or path of the icon for this node type. Note that
        node types that ship with Houdini use a name instead of a full path,
        and Houdini uses its search path to locate the icon with that name.
        
        
        """
        pass
        
    
    def hdaModule():
        """
        hdaModule(self) -> hou.HDAModule
        
        Return the HDAModule object for this node type. If the type is not
        for a digital asset, the module is empty. Otherwise, the module
        contains the functions, constants, classes, etc. in the user-defined
        "PythonModule" section of the digital asset.
        
        You can use hou.Node.hdaModule as a shortcut to access the HDAModule
        from a node instance.
        
        See hou.HDAModule for more information.
        
        
        """
        pass
        
    
    def definition():
        """
        definition(self) -> hou.HDADefinition
        
        If this node type corresponds to a digital asset, return the
        hou.HDADefinition. Otherwise, return None.
        
        
        """
        pass
        
    
    def name():
        """
        name(self) -> str
        
        Return the name of this node type. For example, for the geometry
        object type, the name is "geo". The name and the node type category
        together uniquely identify a node type.
        
        
        """
        pass
        
    
    def namespaceOrder():
        """
        namespaceOrder(self) -> tuple of str
        
        Returns a node type name list sorted in the descending namespace
        precedence order. The node types in the list have the same base type
        as this node type. They have different namespace and/or version.
        
        Houdini uses this list when resolving an unqualified type name in
        hou.Node.createNode(); it will use the first entry in that list that
        matches the name specified in the function.
        
        > # parse the full name into components
        > >>> node_type = hou.nodeType(hou.dopNodeTypeCategory(), 'pyrosolver')
        > >>> node_type.namespaceOrder()
        > ('pyrosolver::2.0', 'pyrosolver')
        
        """
        pass
        
    
    def deprecated():
        """
        deprecated(self) -> bool
        
        Return whether or not this node type has been marked deprecated. See
        also hou.NodeType.deprecationInfo.
        
        
        """
        pass
        
    
    def managerFlag():
        """None"""
        pass
        
    
    def nameComponents():
        """
        nameComponents(self) -> tuple of str
        
        Returns a tuple of node type name components that constitute the
        full node type name. The components in the tuple appear in the
        following order: scope network type, node type namespace, node type
        core name, and version.
        
        > # parse the full name into components
        > >>> node_type = hou.nodeType(hou.dopNodeTypeCategory(), 'pyrosolver::2.0')
        > >>> node_type.nameComponents()
        > ('', '', 'pyrosolver', '2.0')
        
        """
        pass
        
    
    def parmTemplateGroup():
        """
        parmTemplateGroup(self) -> hou.ParmTemplateGroup
        
        Return the group of parm templates corresponding to this node type's
        parameter interface.
        
        See hou.ParmTemplateGroup for more information on parm template
        groups. To change the parameter interface for a node type defined by
        a digital asset, see hou.HDADefinition.setParmTemplateGroup.
        
        
        """
        pass
        
    
    def isReadable():
        """
        isReadable(self) -> bool
        
        Return True if this node type is readable and False otherwise. A
        readable node type is one that you can create node instances from.
        
        
        """
        pass
        
    
    def generatorFlag():
        """None"""
        pass
        
    
    def helpUrl():
        """
        helpUrl(self) -> str
        
        Return the URL where the node type stores the documentation, e.g., a
        file name or an HDA section path. May return an empty string if node
        type does not know where the documentation is.
        
        
        """
        pass
        
    
    def _asVoidPointer():
        """None"""
        pass
        
    
    def nameWithCategory():
        """
        nameWithCategory(self) -> str
        
        Return the name of the node type, prefixed with the name of the node
        type category. For example, for the geometry object, this function
        returns "Object/geo". The category name and type name together
        uniquely identify a node type.
        
        > >>> hou.nodeType(hou.objNodeTypeCategory(), "geo").nameWithCategory()
        > 'Object/geo'
        
        """
        pass
        
    
    def deprecationInfo():
        """
        deprecationInfo(self) -> dict of str to str or hou.NodeType
        
        If the node type has been marked deprecated, this call will return
        the deprecation information as a dictionary.
        
        The currently supported keys are:
        
        
        'version'
        The version of Houdini where this operator got deprecated. The
        form is either major.minor, or major.minor.build (e.g. 14.0 or
        14.5.122). This item is always present.
        
        'new_type'
        The new node type this node was replaced with. This can be used
        to create a system of automatic node replacement.
        
        'reason'
        This lists the reason given for the deprecation, in case there
        is no new node to replace with.
        
        
        """
        pass
        

class NodeTypeCategory(object):
    """
    hou.NodeTypeCategory
    
    Represents a category of node types, such as surface nodes (SOPs) or
    dynamics nodes (DOPs).
    
    Use hou.nodeTypeCategories to get a dict of node type category names to
    NodeTypeCategory objects. You can use hou.objNodeTypeCategory,
    hou.sopNodeTypeCategory, etc. to directly access a particular node type
    category.
    
    See also hou.NodeType and hou.Node.
    
    > # Get the names of all the node type categories.
    > >>> hou.nodeTypeCategories().keys()
    > ['Shop', 'Cop2', 'CopNet', 'ChopNet', 'Object', 'Driver',
    > 'Chop', 'Sop', 'Manager', 'Vop', 'Director', 'Dop', 'VopNet']
    
    RELATED
    
    * hou.nodeTypeCategories
    
    * hou.objNodeTypeCategory
    
    * hou.sopNodeTypeCategory
    
    * hou.dopNodeTypeCategory
    
    * hou.cop2NodeTypeCategory
    
    * hou.shopNodeTypeCategory_
    
    * hou.vopNodeTypeCategory
    
    * hou.ropNodeTypeCategory
    
    * hou.chopNodeTypeCategory
    
    * hou.cop2NetNodeTypeCategory
    
    * hou.vopNetNodeTypeCategory
    
    * hou.chopNetNodeTypeCategory
    
    * hou.managerNodeTypeCategory
    
    * hou.rootNodeTypeCategory
    
    
    """
    
    def setDefaultWireStyle():
        """None"""
        pass
        
    
    def nodeVerbs():
        """
        nodeVerbs(self) -> dict of str to hou.SopVerb
        
        Return a dict mapping verb names to node verbs in this category.
        
        Most verbs are named after their corresponding node type.
        Alternatively, given a hou.SopNode, one can use hou.SopNode.verb to
        extract the verb.
        
        
        """
        pass
        
    
    def setDefaultColor():
        """None"""
        pass
        
    
    def viewerStates(viewer_type):
        """
        viewerStates(self, viewer_type) -> tuple of hou.ViewerState
        
        
        """
        pass
        
    
    def hasSubNetworkType():
        """
        hasSubNetworkType(self) -> bool
        
        Return True if the category contains a node type that creates sub-
        network nodes.
        
        
        """
        pass
        
    
    def defaultShape():
        """None"""
        pass
        
    
    def clearDefaultColors():
        """None"""
        pass
        
    
    def nodeType(type_name):
        """
        nodeType(self, type_name) -> hou.NodeType or None
        
        Returns a single node type that matched the provided type name.
        Returns None if the type name doesn't match a node type in this
        category.
        
        
        """
        pass
        
    
    def nodeTypes():
        """
        nodeTypes(self) -> dict of str to hou.NodeType
        
        Return a dict mapping node type names to node types in this
        category.
        
        For example, if this node type category is SOPs, the keys in the
        dictionary would be "box", "sphere", "polyextrude", "subdivide",
        etc.
        
        Note that the node types in this category may not all be instances
        of the same class. For example, most node types in the SOP node type
        category are instances of hou.SopNodeType, but some, like SHOP
        networks, CHOP networks, etc. are not.
        
        > # Access the box SOP's node type.
        > hou.sopNodeTypeCategory().nodeTypes()['box']
        > def findNodeTypes(node_type_category, pattern):
        >     '''Return a list of node types in a particular node type category
        >        whose names match a pattern.'''
        >     import fnmatch
        >
        >     return [node_type
        >         for node_type_name, node_type in node_type_category.nodeTypes().items()
        >         if fnmatch.fnmatch(node_type_name, pattern)]
        
        See also hou.nodeType_.
        
        
        """
        pass
        
    
    def name():
        """
        name(self) -> str
        
        Returns the name of this node type category.
        
        
        """
        pass
        
    
    def typeName():
        """None"""
        pass
        
    
    def loadDSO(dso_path):
        """
        loadDSO(self, dso_path)
        
        Loads the HDK custom operator identified by the given file path for
        this node type category. It will use the HOUDINI_DSO_PATH
        environment variable to find it if necessary.
        
        
        """
        pass
        
    
    def _asVoidPointer():
        """None"""
        pass
        
    
    def defaultWireStyle():
        """None"""
        pass
        
    
    def defaultColor():
        """None"""
        pass
        
    
    def label():
        """
        label(self) -> str
        
        Returns the descriptive of this node type category that appears in
        network editor panes.
        
        
        """
        pass
        
    
    def clearDefaultShapes():
        """None"""
        pass
        
    
    def nodeVerb(name):
        """
        nodeVerb(self, name) -> hou.SopVerb or None
        
        Return a specific verb from the provided verb name. Returns None if
        no matching verb is found.
        
        
        """
        pass
        
    
    def setDefaultShape():
        """None"""
        pass
        

def NodeTypeCategory_swigregister():
    """None"""
    pass
    

def NodeType_swigregister():
    """None"""
    pass
    

class NodeWarning(Error):
    """
    hou.NodeWarning
    
    Exception class used to set warnings on nodes implemented via Python.
    
    Raise instances of this class from within Python SOPs, objects, etc. to
    set an warning messages on the node. See Writing Python SOPs for more
    information.
    
    RELATED
    
    * hou.NodeError
    
    * hou.Error
    
    
    """
    
    def description():
        """
        description(self) -> str
        
        Return a description of the class of exception. The description is
        not related to the exception instance.
        
        
        """
        pass
        
    
    def exceptionTypeName():
        """
        exceptionTypeName(self) -> str
        
        Return the name of the exception type. Instances of different
        subclasses of hou.Error will return different names. Instances of
        the base class will return "Error".
        
        You can also use str(e.__class__) to get the name of the subclass.
        
        
        """
        pass
        

def NodeWarning_swigregister():
    """None"""
    pass
    

def Node_swigregister():
    """None"""
    pass
    

class NotAvailable(Error):
    """
    hou.NotAvailable
    
    Exception class for when an operation attempted to use a feature that is
    not available. This class is a subclass of hou.Error.
    
    RELATED
    
    * hou.Error
    
    
    """
    
    def description():
        """
        description(self) -> str
        
        Return a description of the class of exception. The description is
        not related to the exception instance.
        
        
        """
        pass
        
    
    def exceptionTypeName():
        """
        exceptionTypeName(self) -> str
        
        Return the name of the exception type. Instances of different
        subclasses of hou.Error will return different names. Instances of
        the base class will return "Error".
        
        You can also use str(e.__class__) to get the name of the subclass.
        
        
        """
        pass
        

def NotAvailable_swigregister():
    """None"""
    pass
    

class ObjNode(Node):
    """
    hou.ObjNode
    
    An instance of an object node in the Houdini scene.
    
    Each object has a "transformation" (or "transform") encapsulating its
    position (or "translation"), rotation, and scale. For a subnet object,
    the subnet's transform is applied to the objects inside the subnet. An
    object can have additional transforms from parent objects on top of the
    transform defined by its parameters, as well as a normally hidden
    pretransform that defines the object's "rest" or "zero" position
    (normally all zeros). An object's final position/rotation/scale in world
    space is defined by (object's transform) * (pretransform) * (parent
    transform).
    
    
    TIP
    You can set an object's position/rotation/scale to certain world
    space values regardless of parent/pre-transform values with the
    hou.ObjNode.setWorldTransform method.
    
    
    NOTE
    Houdini does not support shear parameters on objects. If you try to
    set an object's parameters to a transform containing shear, Houdini
    will automatically remove the shear.
    
    
    """
    
    def origin():
        """
        origin(self) -> hou.Vector3
        
        Return the object's origin position, in world space.
        
        obj.origin() is equivalent to obj.Vector3(0, 0, 0) *
        obj.worldTransform().
        
        > # To compute the world space vector from obj1's origin to obj2's origin, you
        > # can write:
        > obj2.origin() - obj1.origin()
        >
        > # To compute the distance, in world space, between the origins of two
        > # objects, simply take the length of this vector:
        > (obj2.origin() - obj1.origin()).length()
        >
        > # If there are no rotations or scales, the vtorigin() hscript expression
        > # function will return the same result as obj2.origin() - obj1.origin().
        > # If there are rotations or scales, though, it won't.  A Python equivalent
        > # of vtorigin() is defined by:
        > def vtorigin(obj1, obj2):
        >     return (obj2.worldTransform() * obj1.worldTransform().inverted()).extractTranslates()
        
        See also the hou.ObjNode.worldTransform and
        hou.ObjNode.getTransformToNode methods.
        
        
        """
        pass
        
    
    def parmTransform():
        """
        parmTransform(self) -> hou.Matrix4
        
        Return the transform defined by the parameters on this node.
        
        This method can approximately be implemented as follows:
        
        > def parmTransform(self):
        > pivot_transform = hou.hmath.buildTransform({
        >     "translate":self.evalParmTuple("p"),
        >     "rotate":self.evalParmTuple("pr")},
        >     transform_order="srt",
        >     rotate_order="xyz")
        > return (
        >     pivot_transform.inverted() *
        >     hou.hmath.buildTransform({
        >         "translate": self.evalParmTuple("t"),
        >         "rotate": self.evalParmTuple("r"),
        >         "scale": [self.evalParm("scale") * s
        >         for s in self.evalParmTuple("s")],
        >         "shear": (0.0, 0.0, 0.0)},
        >     transform_order=self.parm("xOrd").evalAsString(),
        >     rotate_order=self.parm("rOrd").evalAsString()) *
        >     pivot_transform)
        
        See the class documentation for the relation between this transform
        and the world space transform. See also hou.ObjNode.worldTransform.
        
        NOTE: For Python Objects, the python code sets the parm transform as
        well and won't necessarily have any visible parameters. To get the
        local transform of an object (ie. the transform without any
        parenting), use hou.ObjNode.localTransform.
        
        
        """
        pass
        
    
    def getTransformToNode(obj_node):
        """
        getTransformToNode(self, obj_node) -> hou.Matrix4
        
        Return a matrix that transforms this node to line up with the other
        node.
        
        The following invariant is true: node1.worldTransform() *
        node1.getTransformToNode(node2) == node2.worldTransform().
        
        This method can be implemented as follows:
        
        > def getTransformToNode(self, obj_node):
        > self.worldTransform().inverted() * obj_node.worldTransform()
        
        To align node1 (an ObjNode object) with node2 (another ObjNode
        object), you don't need to use getTransformToNode(). You can simply
        write: node1.setWorldTransform(node2.worldTransform()).
        
        See also hou.ObjNode.origin(), hou.ObjNode.worldTransform(), and
        hou.ObjNode.setWorldTransform().
        
        
        """
        pass
        
    
    def isObjectDisplayed():
        """
        isObjectDisplayed(self) -> bool
        
        Return whether or not this object is displayed. This method takes
        into account both the display flag and the display parameter. If the
        display parameter is enabled, because the tdisplay parameter is set,
        this parameter overrides the flag.
        
        See also hou.ObjNode.isDisplayFlagSet, which returns the current
        state of the flag.
        
        
        """
        pass
        
    
    def worldTransform():
        """
        worldTransform(self) -> hou.Matrix4
        
        Return the matrix that transforms this object's geometry into world
        space.
        
        The world transform matrix contains the cumulative transforms of:
        
        * The node's pre-transform
        
        * The transform defined by the node's parameters
        
        * The transforms of parent nodes or containing networks
        
        This method can approximately be implemented as follows:
        
        > def worldTransform(self):
        > return (self.localTransform() * self.parentAndSubnetTransform())
        
        See also hou.ObjNode.setWorldTransform and
        hou.ObjNode.worldTransformAtTime.
        
        
        """
        pass
        
    
    def _parmClipData():
        """None"""
        pass
        
    
    def localTransformAtTime(time):
        """
        localTransformAtTime(self, time) -> hou.Matrix4
        
        Return, for the specified time, the matrix that transforms this
        object's geometry into the space of its input.
        
        If the object's local transform is animated, this method provides a
        way to get the transformation at a specific time.
        
        See hou.ObjNode.localTransform for more information.
        
        
        """
        pass
        
    
    def setPreTransform(matrix):
        """
        setPreTransform(self, matrix)
        
        Set this object's pretransform. See hou.ObjNode.preTransform for
        more information.
        
        
        """
        pass
        
    
    def moveParmTransformIntoPreTransform():
        """
        moveParmTransformIntoPreTransform(self)
        
        Set this object's parm transform to the identity and adjust the pre-
        transform so that the world transform does not change.
        
        This method is implemented approximately as follows:
        
        > def moveParmTransformIntoPreTransform(self):
        > self.setPreTransform(self.parmTransform() * self.preTransform())
        > self.setParmTransform(hou.hmath.identityTransform())
        
        See also hou.ObjNode.moveParmRotateIntoPreTransform,
        hou.ObjNode.moveParmScaleIntoPreTransform, and
        hou.ObjNode.moveParmTranslateIntoPreTransform. Also see
        hou.ObjNode.movePreTransformIntoParmTransform.
        
        
        """
        pass
        
    
    def movePreTransformIntoParmTransform():
        """
        movePreTransformIntoParmTransform(self)
        
        Set this object's pre-transform to the identity and adjust the parm
        transform so that the world transform does not change.
        
        This method is implemented approximately as follows:
        
        > def movePreTransformIntoParmTransform(self):
        > self.setParmTransform(self.parmTransform() * self.preTransform())
        > self.setPreTransform(hou.hmath.identityTransform())
        
        See also hou.ObjNode.movePreTransformIntoParmTransform.
        
        
        """
        pass
        
    
    def parentAndSubnetTransform():
        """
        parentAndSubnetTransform(self) -> hou.Matrix4
        
        Return the input node's world space transform (if there is an input
        connected), combined with the world space transform of the
        containing subnet object (if there is one). See the class
        documentation for more information.
        
        This method can approximately be implemented as follows:
        
        > def parentAndSubnetTransform(self):
        > if len(self.inputConnectors()[0]) != 0:
        >     return self.inputs()[0].worldTransform()
        >
        > containing_subnet = self.parent()
        > if containing_subnet.type().category() == hou.objNodeTypeCategory():
        >     return containing_subnet.worldTransform()
        >
        > return hou.hmath.identityMatrix()
        
        """
        pass
        
    
    def localTransform():
        """
        localTransform(self) -> hou.Matrix4
        
        Return the matrix that transforms this object's geometry into space
        of its input.
        
        The local transform matrix contains the cumulative transforms of:
        
        * The node's pre-transform
        
        * The transform defined by the node's transform parameters
        
        * The transform adjustment by the node's lookat and path parameters
        
        The local transform matrix, independent of the node's pre-transform,
        can be obtained as follows:
        
        > def localTransformIgnorePreTransform(self):
        > return (self.localTransform() * self.preTransform().inverted())
        
        See also hou.ObjNode.localTransformAtTime and
        hou.ObjNode.worldTransform.
        
        
        """
        pass
        
    
    def buildLookatRotation(to_node, up_vector=None):
        """
        buildLookatRotation(self, to_node, up_vector=None) -> hou.Matrix4
        
        Return a matrix that will rotate this object to look at the
        specified object.
        
        The returned hou.Matrix4 object transforms this object from its
        current position in world space so that its negative z axis points
        at the origin of the to_node object.
        
        up_vector can either be a hou.Vector3 object or None. If it is None,
        this method uses an up vector of hou.Vector3(0, 1, 0).
        
        You can extract the rotation values from the return value with
        hou.Matrix4.extractRotates. You can set an object's transform with
        hou.ObjNode.setWorldTransform.
        
        > # Set the cam1 object's transform so it points at geo1.
        > cam1 = hou.node("/obj/cam1")
        > lookat_obj = hou.node("/obj/geo1")
        > cam1.setWorldTransform(cam1.buildLookatRotation(lookat_obj))
        
        See also hou.ObjNode.setWorldTransform.
        
        
        """
        pass
        
    
    def isDisplayFlagSet():
        """
        isDisplayFlagSet(self) -> bool
        
        Return whether or not this object's display flag is turned on. Note
        that the display flag and the display parameter both determine
        whether the object is actually displayed.
        
        Use hou.ObjNode.isObjectDisplayed to determine if the object is
        actually displayed.
        
        
        """
        pass
        
    
    def setParmPivotTransform(matrix, fail_on_locked_parms=False):
        """
        setParmPivotTransform(self, matrix, fail_on_locked_parms=False)
        
        Sets the pivot transform controlled by this object's parameters.
        
        This method will adjust the pivot translate and pivot rotate values
        of this object to achieve the desired transform. It will not
        compensate for any changes this causes to the world transform of
        this object.
        
        If fail_on_locked_parms is True, and any of the pivot translate or
        pivot rotate rotate parameters of the object are locked, this method
        will raise hou.OperationFailed. If it is False and any of those
        parameters are locked, this method will change their values but
        leave them locked.
        
        See also hou.ObjNode.parmPivotTransform and
        hou.ObjNode.setParmTransform.
        
        This method can be approximately implemented as follows, ignoring
        locked parameters:
        
        > def setParmPivotTransform(self, matrix):
        > parm_values = matrix.explode(
        >     transform_order=self.parm('xOrd').evalAsString(),
        >     rotate_order=self.parm('rOrd').evalAsString(),
        >     pivot=hou.Vector3())
        >
        > for parm_name, key in ('p', 'translate'), ('pr', 'rotate'):
        >     self.parmTuple(parm_name).set(parm_values[key])
        
        See also hou.Matrix4.explode.
        
        
        """
        pass
        
    
    def renderNode():
        """
        renderNode(self) -> hou.Node or None
        
        If this object contains SOPs or DOPs, return the one that has its
        render flag on. Otherwise, return None.
        
        
        """
        pass
        
    
    def isShowingOrigin():
        """
        isShowingOrigin(self) -> bool
        
        Return whether or not this object displays its local origin gnomon
        in the viewport.
        
        Note that you can change this setting by right-clicking on the node.
        
        
        """
        pass
        
    
    def displayNode():
        """
        displayNode(self) -> hou.Node or None
        
        If this object contains SOPs or DOPs, return the one that has its
        display flag on. Otherwise, return None.
        
        
        """
        pass
        
    
    def combine(nodes):
        """
        combine(self, nodes)
        
        Combine the geometry from the given list of hou.ObjNode's into this
        object. After this operation, the old objects will be deleted.
        
        Raises hou.ObjectWasDeleted if any of the nodes no longer exist in
        Houdini. Raises TypeError if any of the nodes are not of type
        hou.ObjNode. These exceptions are raised prior to performing the
        combine operation to avoid partial results.
        
        
        """
        pass
        
    
    def _alembicGetCameraDict():
        """Return camera information."""
        pass
        
    
    def isUsingXray():
        """
        isUsingXray(self) -> bool
        
        Return whether or not this object displays its geometry in xray
        mode. Houdini displays xrayed geometry in wireframe and makes it
        visible even when it is hidden behind another surface.
        
        Note that you can change this setting by right-clicking on the node.
        
        
        """
        pass
        
    
    def moveParmRotateIntoPreTransform():
        """
        moveParmRotateIntoPreTransform(self)
        
        Set this object's rotate values to zero and adjust the pre-transform
        so that the object's world transform does not change.
        
        Suppose:
        
        * W is the world transform,
        
        * L is the parameter transform without any rotate component,
        
        * L' is the existing parm transform,
        
        * P is the desired new pre-transform,
        
        * P' is the current pre-transform,
        
        * O is the parent transform combined with the containing subnet's,
        transform
        
        Then,
        
        * W = L * P * O and W = L' * P' * O
        
        * L * P = L' * P'
        
        * P = L^ * L' * P' So, this method is implemented approximately as
        follows:
        
        > def moveParmRotateIntoPreTransform(self):
        > old_parm_transform = self.parmTransform()
        > self.parmTuple("r").set((0.0, 0.0, 0.0))
        > self.setPreTransform(
        >     self.parmTransform() * old_parm_transform * self.preTransform())
        See also hou.ObjNode.preTransform and the class documentation.
        
        
        """
        pass
        
    
    def useXray(on):
        """
        useXray(self, on)
        
        Turn this object's xray mode on or off. See also
        hou.ObjNode.isUsingXray.
        
        
        """
        pass
        
    
    def isSelectableInViewport():
        """
        isSelectableInViewport(self) -> bool
        
        Return whether or not the selectable flag is set. When it is not
        set, it is not possible to select this object or any of its geometry
        interactively in the viewport.
        
        
        """
        pass
        
    
    def material(operation, parameter):
        """
        material(self, operation, parameter)
        
        Manages object-local overrides of material parameters. This is
        basically the scripting equivalent of the Material Override menu in
        the parameter editor for objects. It allows you to create parameters
        on an object that override the equivalent values on the object's
        material.
        
        The operation argument should be one of the following strings:
        
        
        "override"
        Create parameters on the object to override _all_ material
        parameters.
        
        "select"
        Select and create object parameters to override material
        parameters.
        
        "remove"
        Removes _all_ object parameter overrides.
        
        "rmdefault"
        Removes any unchanged object parameters (that is, that are
        currently set to their default value).
        
        "sync"
        Synchronize the object parameter overrides with the parameter
        definitions on the material.
        
        "revert"
        Revert any parameter overrides on the object to their values on
        the material.
        
        "addlist"
        (Followed by a second argument containing a list of parameter
        names strings.) Creates object parameters to override the named
        parameters on the material.
        
        >
        > myobject = hou.node("/obj/obj1")
        >
        > # Add all material overrides
        > myobject.material("override")
        >
        > # Remove all material overrides
        > myobject.material("remove")
        >
        > # Add specific overrides for "baseColor" and "roughness" parameters
        > myobject.material("addlist", ["baseColor", "roughness"])
        
        """
        pass
        
    
    def parmPivotTransform():
        """
        parmPivotTransform(self) -> hou.Matrix4
        
        Return the pivot transform defined by the parameters on this node.
        
        This method can approximately be implemented as follows:
        
        > def parmPivotTransform(self):
        > pivot_transform = hou.hmath.buildTranslate(self.evalParmTuple("p"))
        > return (
        >     hou.hmath.buildTransform({
        >         "translate": self.evalParmTuple("p"),
        >         "rotate": self.evalParmTuple("pr")},
        >     transform_order="srt",
        >     rotate_order="xyz")
        
        See also hou.ObjNode.parmTransform.
        
        
        """
        pass
        
    
    def setCookTransform(matrix):
        """
        setCookTransform(self, matrix)
        
        Set the parameter transform for the Python object that's cooking.
        Call this method from objects implemented in Python to set the
        result of the cook.
        
        Note that an object implemented in Python controls the parameter
        transform (i.e. the result of hou.ObjNode.parmTransform). The world
        transform (i.e. the result of hou.ObjNode.worldTransform) is still
        affected by parent node's transforms, pre-transforms, etc.
        
        This method raises hou.OperationFailed if you call it on an object
        that is not implemented in Python or if you call it from outside
        that object's Python cook code.
        
        See the Transforms from Disk example.
        
        
        """
        pass
        
    
    def setWorldTransform(matrix, fail_on_locked_parms=False):
        """
        setWorldTransform(self, matrix, fail_on_locked_parms=False)
        
        Adjust this object's parameters to achieve the desired world
        transformation.
        
        This method will adjust the translate, rotate, and scale values of
        this object to achieve the desired final world transform. It
        accounts for the transforms of containing networks, parent
        transforms, and pre-transforms.
        
        If fail_on_locked_parms is True, and any of the translate, rotate,
        or scale parameters of the object are locked, this method raises
        hou.OperationFailed. If it is False and any of those parameters are
        locked, this method will change their values but leave them locked.
        
        Suppose:
        
        * W is the desired new world transform,
        
        * W' is the existing world transform,
        
        * L is the desired transform defined by the node's parameters,
        
        * L' is the existing parm transform,
        
        * P is the object's pre-transform,
        
        * O is the parent transform combined with the containing subnet's,
        transform
        
        Then, since W = L * P * O we have P = W * O^ * R^. So, this method
        could be implemented as follows:
        
        > def setWorldTransform(self):
        > self.setParmTransform(
        >     matrix * self.parentAndSubnetTransform().inverted() * self.preTransform().inverted(),
        >     fail_on_locked_parms)
        
        Alternately, we can derive L from W' and L' as follows:
        
        * W' = L' * P * O
        
        * so P * O = L^' * W'
        
        * and (P * O)^ = W^' * L' and
        
        * W = L * P * O
        
        * so L = W * (P * O)^
        
        * giving L = W * W'^ * L'
        
        Thus, this method could also be implemented using the current world
        and parm transforms as follows:
        
        > def setWorldTransform(self):
        > self.setParmTransform(
        >     matrix * self.worldTransform().inverted() * self.parmTransform(),
        >     fail_on_locked_parms)
        
        Note that, because parm transforms cannot contain shears, it is
        possible that the resulting world transform will not match the
        desired transform. If r is a function that removes shears from a
        transform then the new world transform will actually be L * P * O =
        r(W * O^ * P^) * P * O.
        
        See also hou.ObjNode.worldTransform and
        hou.ObjNode.setParmTransform.
        
        
        """
        pass
        
    
    def worldTransformAtTime(time):
        """
        worldTransformAtTime(self, time) -> hou.Matrix4
        
        Return, for the specified time, the matrix that transforms this
        object's geometry into world space.
        
        If the object's world transform is animated, this method provides a
        way to get the transformation at a specific time.
        
        See hou.ObjNode.worldTransform for more information.
        
        
        """
        pass
        
    
    def _saveParmClip():
        """None"""
        pass
        
    
    def setDisplayFlag(on):
        """
        setDisplayFlag(self, on)
        
        Turn the object's display flag on or off. See also
        hou.ObjNode.isDisplayFlagSet.
        
        
        """
        pass
        
    
    def setSelectableInViewport(on):
        """
        setSelectableInViewport(self, on)
        
        Set the object's selectable flag. See
        hou.ObjNode.isSelectableInViewport for more information.
        
        
        """
        pass
        
    
    def showOrigin(on):
        """
        showOrigin(self, on)
        
        Show or hide this object's local origin gnomon in the viewport. See
        also hou.ObjNode.isShowingOrigin.
        
        
        """
        pass
        
    
    def getTransformFromPointToPoint(pos3, other_node, other_pos3):
        """
        getTransformFromPointToPoint(self, pos3, other_node, other_pos3) ->
        hou.Matrix4
        
        Return the transform matrix that rotates the point pos3 (in this
        object node's transform space) to the point other_pos3 (in another
        object node's transform space).
        
        > obj1.getTransformFromPointToPoint(pos1, obj2, pos2)
        
        ...is equivalent to...
        
        > (obj1.worldTransform().inverted() *
        >     hou.hmath.buildTranslate(-pos1) *
        >     hou.hmath.buildTranslate(pos2) *
        >     obj2.worldTransform())
        
        See also the hou.ObjNode.getTransformToNode and
        hou.ObjNode.worldTransform methods, and the functions in the
        hou.hmath module.
        
        
        """
        pass
        
    
    def setParmTransform(matrix, fail_on_locked_parms=False):
        """
        setParmTransform(self, matrix, fail_on_locked_parms=False)
        
        Sets the transform controlled by this object's parameters.
        
        This method will adjust the translate, rotate, and scale values of
        this object to achieve the desired parameter, or local, transform.
        It will account for the existing pivot position, transformation
        order, and rotation order, and will leave them unchanged.
        
        Note that object nodes do not currently have shears parameters, so
        any shears in the matrix will be discarded.
        
        If fail_on_locked_parms is True, and any of the translate, rotate,
        or scale parameters of the object are locked, this method will raise
        hou.OperationFailed. If it is False and any of those parameters are
        locked, this method will change their values but leave them locked.
        
        See also hou.ObjNode.parmTransform and
        hou.ObjNode.setWorldTransform.
        
        This method can be approximately implemented as follows, ignoring
        locked parameters:
        
        > def setParmTransform(self, matrix):
        > parm_values = matrix.explode(
        >     transform_order=self.parm('xOrd').evalAsString(),
        >     rotate_order=self.parm('rOrd').evalAsString(),
        >     pivot=hou.Vector3(self.evalParmTuple('p')))
        >
        > for parm_name, key in ('t', 'translate'), ('r', 'rotate'), ('s', 'scale'):
        >     self.parmTuple(parm_name).set(parm_values[key])
        
        See also hou.Matrix4.explode.
        
        
        """
        pass
        
    
    def moveParmScaleIntoPreTransform():
        """
        moveParmScaleIntoPreTransform(self)
        
        Set this object's scale values to one and adjust the pre-transform
        so that the world transform does not change.
        
        See hou.ObjNode.moveParmRotateIntoPreTransform for more information.
        
        
        """
        pass
        
    
    def preTransform():
        """
        preTransform(self) -> hou.Matrix4
        
        Return this object's pretransform.
        
        The pre-transform allows you to apply a transform after the
        parameter transform but before input and containing object
        transforms. See the class documentation for more details.
        
        Unlike the parameter transform, the pretransform is not stored using
        any parameters on the node. Instead, Houdini stores the pretransform
        as a matrix. Because it is directly as a matrix, the pretransform
        may contain shears.
        
        
        """
        pass
        
    
    def moveParmTranslateIntoPreTransform():
        """
        moveParmTranslateIntoPreTransform(self)
        
        Set this object's translate values to zero and adjust the pre-
        transform so that the world transform does not change.
        
        See hou.ObjNode.moveParmRotateIntoPreTransform for more information.
        
        
        """
        pass
        

def ObjNode_swigregister():
    """None"""
    pass
    

class ObjectWasDeleted(Error):
    """
    hou.ObjectWasDeleted
    
    Exception class for when you use a stale variable to attempt to access
    something that was deleted in Houdini. This class is a subclass of
    hou.Error.
    
    For example, setting a variable to a Node object, deleting that node in
    Houdini, and attempting to call a method using the variable will raise
    this exception.
    
    RELATED
    
    * hou.Error
    
    
    """
    
    def description():
        """
        description(self) -> str
        
        Return a description of the class of exception. The description is
        not related to the exception instance.
        
        
        """
        pass
        
    
    def exceptionTypeName():
        """
        exceptionTypeName(self) -> str
        
        Return the name of the exception type. Instances of different
        subclasses of hou.Error will return different names. Instances of
        the base class will return "Error".
        
        You can also use str(e.__class__) to get the name of the subclass.
        
        
        """
        pass
        

def ObjectWasDeleted_swigregister():
    """None"""
    pass
    

class OperationFailed(Error):
    """
    hou.OperationFailed
    
    """
    
    def description():
        """
        description(self) -> str
        
        Return a description of the class of exception. The description is
        not related to the exception instance.
        
        
        """
        pass
        
    
    def exceptionTypeName():
        """
        exceptionTypeName(self) -> str
        
        Return the name of the exception type. Instances of different
        subclasses of hou.Error will return different names. Instances of
        the base class will return "Error".
        
        You can also use str(e.__class__) to get the name of the subclass.
        
        
        """
        pass
        

def OperationFailed_swigregister():
    """None"""
    pass
    

class OperationInterrupted(Error):
    """
    hou.OperationInterrupted
    
    """
    
    def description():
        """
        description(self) -> str
        
        Return a description of the class of exception. The description is
        not related to the exception instance.
        
        
        """
        pass
        
    
    def exceptionTypeName():
        """
        exceptionTypeName(self) -> str
        
        Return the name of the exception type. Instances of different
        subclasses of hou.Error will return different names. Instances of
        the base class will return "Error".
        
        You can also use str(e.__class__) to get the name of the subclass.
        
        
        """
        pass
        

def OperationInterrupted_swigregister():
    """None"""
    pass
    

class OrboltURLHandler(object):
    """None"""
    
    def updateProgressBar():
        """None"""
        pass
        
    
    def closeSplashScreen():
        """None"""
        pass
        

def OrboltURLHandler_swigregister():
    """None"""
    pass
    

class OrientedBoundingRect(object):
    """
    hou.OrientedBoundingRect
    
    An oriented 2D rectangular region.
    
    Computes an oriented bounding rectangle for a set of points.
    
    
    """
    
    def center():
        """
        center(self) -> hou.Vector2
        
        Returns the position of the center of the bounding rectangle.
        
        
        """
        pass
        
    
    def isAlmostEqual(brect, tolerance=0.00001):
        """
        isAlmostEqual(self, brect, tolerance=0.00001) -> bool
        
        Returns whether this bounding rectangle is equal to another, subject
        to numerical tolerances.
        
        
        """
        pass
        
    
    def sizevec():
        """
        sizevec(self) -> hou.Vector2
        
        Returns a vector describing the size of the box in the x and y axes.
        
        
        """
        pass
        
    
    def orientation():
        """
        orientation(self) -> hou.Matrix2
        
        Returns a hou.Matrix2 that defines the orientation of the bounding
        rectangle.
        
        
        """
        pass
        

def OrientedBoundingRect_swigregister():
    """None"""
    pass
    

class PackedFragment(PackedPrim):
    """
    hou.PackedFragment
    
    A packed fragment primitive.
    
    See packed primitives for more information.
    
    
    """
    
    def setEmbeddedGeometry(geo, attrib, name):
        """
        setEmbeddedGeometry(self, geo, attrib, name)
        
        Embeds into this primitive all primitives from geo with the value
        name for the primitive attribute attrib. Use read-only frozen
        geometry to share geometry between multiple packed fragment
        primitives. See hou.Geometry.freeze for more information.
        
        
        """
        pass
        

def PackedFragment_swigregister():
    """None"""
    pass
    

class PackedGeometry(PackedPrim):
    """
    hou.PackedGeometry
    
    A packed geometry primitive.
    
    See packed primitives for more information.
    
    
    """
    
    def setEmbeddedGeometry(geo):
        """
        setEmbeddedGeometry(self, geo)
        
        Embeds the provided geometry into this primitive. Use read-only
        frozen geometry to share geometry between multiple packed geometry
        primitives. See hou.Geometry.freeze for more information.
        
        
        """
        pass
        
    
    def getEmbeddedGeometry():
        """
        getEmbeddedGeometry(self) -> hou.Geometry
        
        Returns the geometry of this primitive.
        
        
        """
        pass
        

def PackedGeometry_swigregister():
    """None"""
    pass
    

class PackedPrim(Prim):
    """
    hou.PackedPrim
    
    A packed primitive.
    
    See packed primitives for more information.
    
    To set contents of the packed primitive, use the
    hou.Prim.setIntrinsicValue method:
    
    > prim = myGeometry.createPacked("PackedDisk")
    > prim.setIntrinsicValue("unexpandedfilename", "defgeo.bgeo")
    
    To get the list of available "intrinsic attributes" you can set:
    
    * View a packed primitive of the type you want in the geometry
    spreadsheet and turn on display of intrinsic attributes.
    
    _or_
    
    * In a Houdini tools command line, type ginfo -IP to see a list of all
    intrinsic attributes on all packed primitive types.
    
    
    """
    
    def fullTransform():
        """
        fullTransform(self) -> hou.Matrix4
        
        Returns the full 4x4 transform for this primitive's geometry. This
        includes translations due to points and any transforms inside the
        primitive (for example, transforms inside an Alembic file).
        
        
        """
        pass
        
    
    def setTransform(m4):
        """
        setTransform(self, m4)
        
        Sets this primitive's local transform. This sets the local 3x3
        transform _and_ the translation of the point. This does not affect
        any transforms inside the primitive (for example, transforms inside
        an Alembic file).
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable.
        
        
        m4
        A hou.Matrix4 object containing the full transform.
        
        
        """
        pass
        
    
    def vertex(index):
        """
        vertex(self, index) -> hou.Vertex
        
        A shortcut for self.vertices()[index]. You probably don't need to
        call this method.
        
        This method supports negative indices to index from the end, just
        like self.vertices()[index] would. Also, like Python's indexing
        operator, it will raise IndexError when the index is out of range.
        
        
        """
        pass
        
    
    def transform():
        """
        transform(self) -> hou.Matrix3
        
        Returns the local 3x3 transform associated with this primitive. The
        transform doesn't include the local point transform or any
        transforms inside the primitive (for example, transforms inside an
        Alembic file).
        
        
        """
        pass
        

def PackedPrim_swigregister():
    """None"""
    pass
    

class Pane(object):
    """
    hou.Pane
    
    A rectangular area of the desktop that contains one or more pane tabs.
    
    Desktops (and floating panels) are composed of one or more panes.
    Initially a desktop contains one pane, and more panes are added to it by
    splitting existing panes in two, either horizontally or vertically.
    
    See hou.Desktop for more information about panes and pane tabs. See
    hou.FloatingPanel for more information about floating panels.
    
    
    """
    
    def floatingPanel():
        """None"""
        pass
        
    
    def isSplitMaximized():
        """
        isSplitMaximized(self) -> bool
        
        Return the true if the Pane is maximized on the split. A split can't
        be minimized and maximized at the same time. In its default state, a
        split is not minimized and not maximized.
        
        
        """
        pass
        
    
    def setIsSplitMaximized(on):
        """
        setIsSplitMaximized(self, on) -> bool
        
        Set the maximized state of a split.
        
        
        """
        pass
        
    
    def tabs():
        """
        tabs(self) -> tuple of hou.PaneTab
        
        Return the pane tabs in this pane.
        
        
        """
        pass
        
    
    def getSplitParent():
        """
        getSplitParent(self) -> hou.Pane or None
        
        Return the parent split pane if the Pane is nested under a split.
        
        
        """
        pass
        
    
    def tabOfType(type, index=0):
        """
        tabOfType(self, type, index=0) -> hou.PaneTab or None
        
        Find and return a pane tab with the desired type, or None if no such
        tab exists in the pane.
        
        If there are multiple tabs in the pane with the desired type, then
        the first found tab is returned. Use index to return the other tabs.
        For example, use index=0 to return the first found tab, use index=1
        to return the second found tab, etc.
        
        See also hou.ui.paneTabOfType.
        
        
        """
        pass
        
    
    def currentTab():
        """
        currentTab(self) -> hou.PaneTab
        
        Return the currently focused pane tab.
        
        See also hou.PaneTab.setIsCurrentTab.
        
        
        """
        pass
        
    
    def isMaximized():
        """
        isMaximized(self) -> bool
        
        Return True if this pane is maximized.
        
        
        """
        pass
        
    
    def createTab(type):
        """
        createTab(self, type) -> hou.PaneTab
        
        Create a new pane tab with the desired type and return it. The new
        pane tab will be current (i.e. it will be the pane tab that's open).
        
        
        """
        pass
        
    
    def isSplit():
        """
        isSplit(self) -> bool
        
        Return True if the pane is a split.
        
        
        """
        pass
        
    
    def isSplitMinimized():
        """
        isSplitMinimized(self) -> bool
        
        Return the true if the Pane is minimized on the split. A split can't
        be minimized and maximized at the same time. In its default state, a
        split is not minimized and not maximized.
        
        
        """
        pass
        
    
    def id():
        """None"""
        pass
        
    
    def getSplitDirection(selfdir):
        """
        getSplitDirection(self,dir) -> double
        
        Return the split direction of the parent split.
        
        
        """
        pass
        
    
    def splitSwap():
        """
        splitSwap(self)
        
        Swap the left and right panes of an horizontal split Pane. Swap the
        top and bottom panes of a vertical split Pane.
        
        
        """
        pass
        
    
    def getSplitFraction(selffraction):
        """
        getSplitFraction(self,fraction) -> double
        
        Return the split fraction of the parent split.
        
        
        """
        pass
        
    
    def getSplitChild(selfindex):
        """
        getSplitChild(self,index) -> hou.Pane or None
        
        Return the split child Pane at index if the Pane is a split.
        
        
        """
        pass
        
    
    def splitHorizontally():
        """
        splitHorizontally(self) -> hou.Pane
        
        Split the pane, adding a new pane to the right, and return the new
        pane. The new pane will have a single tab whose type is the same as
        the type of this pane's current tab.
        
        See also hou.Pane.splitVertically.
        
        
        """
        pass
        
    
    def desktop():
        """
        desktop(self) -> hou.Desktop or None
        
        Return the desktop in which this pane exists, or None if it is in a
        floating panel that's not attached to the desktop.
        
        
        """
        pass
        
    
    def splitVertically():
        """
        splitVertically(self) -> hou.Pane
        
        Split the pane, adding a new pane to the bottom, and return the new
        pane. The new pane will have a single tab whose type is the same as
        the type of this pane's current tab.
        
        See also hou.Pane.splitHorizontally.
        
        
        """
        pass
        
    
    def splitRotate():
        """
        splitRotate(self)
        
        Turn an horizontal split Pane into a vertical split Pane.
        
        
        """
        pass
        
    
    def setIsMaximized(on):
        """
        setIsMaximized(self, on)
        
        Set the maximized state of this pane.
        
        
        """
        pass
        
    
    def setSplitDirection(selfdir):
        """
        setSplitDirection(self,dir)
        
        Set the split direction of the parent split.
        
        
        """
        pass
        
    
    def setSplitFraction(selffraction):
        """
        setSplitFraction(self,fraction)
        
        Set the split fraction of the parent split.
        
        
        """
        pass
        

class PaneTab(object):
    """
    hou.PaneTab
    
    One of the tabs inside a desktop pane.
    
    Each pane type is of a particular type (e.g. scene viewer, network view,
    parameters, etc.). A pane may contain multiple tabs and displays the
    contents of one tab at a time.
    
    See hou.Desktop for more information about panes and pane tabs.
    
    
    """
    
    def isCurrentTab():
        """
        isCurrentTab(self) -> bool
        
        Return whether this tab is the selected tab in the containing pane.
        
        
        """
        pass
        
    
    def floatingPanel():
        """
        floatingPanel(self) -> hou.FloatingPanel or None
        
        Return the floating panel that contains this pane tab or None if the
        pane tab is not in a floating panel.
        
        
        """
        pass
        
    
    def _pressButton():
        """None"""
        pass
        
    
    def setName(name):
        """
        setName(self, name)
        
        Set the name of this pane tab. A pane tab name may contain spaces.
        
        Note that this name is the internal name of the tab, and is
        different from the label displayed in the interface.
        
        
        """
        pass
        
    
    def clone():
        """
        clone(self) -> hou.PaneTab
        
        Create a floating copy of the pane tab and return the cloned pane
        tab. The new pane tab is in a new floating panel.
        
        
        """
        pass
        
    
    def isFloating():
        """
        isFloating(self) -> bool
        
        Return whether this pane tab is in a floating panel.
        
        This method can be approximately implemented as follows:
        
        > def isFloating(self):
        >     return self.pane() is None or self.pane().floatingPanel() is not None
        
        """
        pass
        
    
    def _setValue():
        """None"""
        pass
        
    
    def setPin(pin):
        """
        setPin(self, pin)
        
        If pin is True, set the link group membership to
        hou.paneLinkType.Pinned. Otherwise, set it to
        hou.paneLinkType.FollowSelection. This method can be implemented
        using hou.PaneTab.setLinkGroup as follows:
        
        > def setPin(self, pin):
        >     if pin:
        >         self.setLinkGroup(hou.paneLinkType.Pinned)
        >     else:
        >         self.setLinkGroup(hou.paneLinkType.FollowSelection)
        
        See also hou.PaneTab.setLinkGroup.
        
        
        """
        pass
        
    
    def _getValue():
        """None"""
        pass
        
    
    def pane():
        """
        pane(self) -> hou.Pane or None
        
        Return the pane in the desktop that contains this pane tab. Note
        that pane tabs in regular floating panels are always in a pane,
        since regular floating panels contain one or more panes.
        
        However, some floating panels have their content stripped down to
        only contain one particular pane tab type, and do not display the
        user interface to add more pane tabs, split the pane, etc. This
        method returns None for these stripped down floating panels.
        
        
        """
        pass
        
    
    def linkGroup():
        """
        linkGroup(self) -> hou.paneLinkType enum value
        
        Return the link group that this pane tab belongs to.
        
        See also hou.PaneTab.isPin.
        
        
        """
        pass
        
    
    def close():
        """
        close(self)
        
        Close the pane tab.
        
        
        """
        pass
        
    
    def setType(type):
        """
        setType(self, type) -> hou.PaneTab
        
        Create a new pane tab of the given type, replace this tab with it,
        and return the new pane tab. Use the returned pane tab afterward;
        references to this tab become invalid.
        
        
        """
        pass
        
    
    def setIsCurrentTab():
        """
        setIsCurrentTab(self)
        
        Set this tab as the selected tab in the containing pane.
        
        
        """
        pass
        
    
    def name():
        """
        name(self) -> str
        
        Return the name of this tab.
        
        
        """
        pass
        
    
    def setLinkGroup(group):
        """
        setLinkGroup(self, group)
        
        Set the link group membership of this pane tab.
        
        
        """
        pass
        
    
    def _getValueNames():
        """None"""
        pass
        
    
    def isPin():
        """
        isPin(self) -> bool
        
        Return whether this pane tab is pinned. This method is equivalent to
        (self.linkGroup() == hou.paneLinkType.Pinned)
        
        See also hou.PaneTab.linkGroup.
        
        
        """
        pass
        
    
    def size():
        """
        contentSize() -> tuple of int
        
        Return a 2-tuple containing the pane tab's content area width and
        height.
        
        The width and height do not include the network navigation control
        area (if any), pane tab borders or tab area.
        
        
        """
        pass
        
    
    def type():
        """
        type(self) -> hou.paneTabType enum value
        
        Return the type of this tab (i.e. whether it is a scene viewer,
        parameter editor, network editor, etc.).
        
        
        """
        pass
        
    
    def contentSize():
        """None"""
        pass
        

def PaneTab_swigregister():
    """None"""
    pass
    

def Pane_swigregister():
    """None"""
    pass
    

class Parm(object):
    """
    hou.Parm
    
    A parameter in a node. Each parameter has a unique name within its node
    and exists inside a parameter tuple.
    
    REPLACES
    
    * chadd
    
    * chalias
    
    * chautoscope
    
    * chkey
    
    * chkeyget
    
    * chkeyls
    
    * chlock
    
    * chrefit
    
    * chreverse
    
    * chrm
    
    * chround
    
    * chscope
    
    * chstretch
    
    * opparm
    
    * opscript
    
    * ch()
    
    * chf()
    
    * chs()
    
    * chsraw()
    
    * cht()
    
    
    """
    
    def setAutoSelect(on):
        """
        setAutoSelect(self, on)
        
        Changes the autoselect property of the parameter. If this property
        is on, this parameter defines the default selection state when it is
        displayed in the animation editor.
        
        
        """
        pass
        
    
    def _setClipData():
        """None"""
        pass
        
    
    def evalAsString():
        """
        evalAsString(self) -> str
        
        Evaluates this parameter at the current frame and returns the result
        as a string.
        
        If you want the string contents of the parameter before variable
        expansion and expression evaluation then call
        hou.Parm.unexpandedString.
        
        Raises hou.TypeError if the value cannot be converted to a string.
        
        
        """
        pass
        
    
    def setClipData(self):
        """auto-insert ocstring: HOM_Parm::setClipData"""
        pass
        
    
    def menuItems():
        """
        menuItems(self) -> tuple of str
        
        Returns a list of all possible menu items (for a menu parameter).
        Raises hou.OperationFailed if this parameter is not a menu.
        
        
        """
        pass
        
    
    def _loadClip():
        """None"""
        pass
        
    
    def isMultiParmInstance():
        """
        isMultiParmInstance(self) -> bool
        
        Return whether this parameter is an instance of a multi parm. For
        example, the pt0x, pt1x, pt2x, etc. parameters in an add SOP are
        instances of a multiparm.
        
        
        """
        pass
        
    
    def evalAsFloatAtFrame(frame):
        """
        evalAsFloatAtFrame(self, frame) -> float
        
        Evaluates this parameter at a certain frame and returns the result
        as a float.
        
        Raises hou.TypeError if the value cannot be converted to a float.
        
        
        """
        pass
        
    
    def set(self, value, language=None, follow_parm_reference=True):
        """
        set(self, value, language=None, follow_parm_reference=True)
        
        Sets the parameter value at the current frame.
        
        
        value
        A float, integer, or string to set the parameter value to.
        
        Pass in a hou.Ramp object, as the parameter value, to set the
        value of a ramp parameter. The ramp object's type needs to match
        the target ramp's type.
        
        Pass in a hou.Geometry object, as the parameter value, to set
        the value of a geometry data parameter.
        
        Pass in a hou.Parm object to create a channel reference from
        this parameter to the specified parameter.
        
        language
        This option only applies when setting to a hou.Parm value.
        Specifies the expression language to use when creating a channel
        reference from this parameter to the given parameter. Set this
        option to an hou.exprLanguage object or None to choose the
        default language.
        
        follow_parm_reference
        This option only applies when setting to a hou.Parm value. When
        this option is set to True then this method will follow channel
        references and create a channel reference from the referenced
        parameter to the given parameter.
        
        If this parameter currently contains a channel reference to another
        parameter, then this method will follow channel references and
        change the value of the referenced parameter. If this is not the
        desired behavior, then first delete the channel reference with
        hou.Parm.deleteAllKeyframes. Alternatively if you are setting the
        value to another parameter and do not want to follow existing
        channel references then set the optional follow_parm_reference
        argument to False.
        
        Raises hou.TypeError if the type of value does not match the type of
        this parameter. Raises hou.PermissionError if this parameter is not
        writable.
        
        See also hou.Node.setParms.
        
        """
        pass
        
    
    def setScope(on):
        """
        setScope(self, on)
        
        Changes the scope property of this parameter's channel, which
        affects whether it is loaded in the animation editor.
        
        
        """
        pass
        
    
    def parmsReferencingThis():
        """
        parmsReferencingThis(self) -> tuple of hou.Parm
        
        Return a tuple of all the parameters in the scene that have channel
        references to this parameter.
        
        
        """
        pass
        
    
    def menuLabels():
        """
        menuLabels(self) -> tuple of str
        
        Returns a list of labels for all possible menu items (for a menu
        parameter). Raises hou.OperationFailed if this parameter is not a
        menu.
        
        
        """
        pass
        
    
    def evalAsFloat():
        """
        evalAsFloat(self) -> float
        
        Evaluates this parameter at the current frame and returns the result
        as a float.
        
        Raises hou.TypeError if the value cannot be converted to a float.
        
        
        """
        pass
        
    
    def evalAsGeometryAtFrame(frame):
        """
        evalAsGeometryAtFrame(self, frame) -> hou.Geometry
        
        Evaluates this parameter at a certain frame and returns the result
        as a geometry.
        
        Raises hou.TypeError if the parameter is not a geometry.
        
        
        """
        pass
        
    
    def rawValue():
        """
        rawValue(self) -> str
        
        Returns the parameter's raw text value without evaluation or
        expansion. If the parameter has an expression then the expression is
        returned otherwise the parameter's plain text value is returned.
        
        
        """
        pass
        
    
    def evalAsRampAtFrame(frame):
        """
        evalAsRampAtFrame(self, frame) -> hou.Ramp
        
        Evaluates this parameter at a certain frame and returns the result
        as a ramp.
        
        Raises hou.TypeError if the parameter is not a ramp.
        
        
        """
        pass
        
    
    def isDisabled():
        """
        isDisabled(self) -> bool
        
        Returns the disable state of the parameter, ignoring the lock state.
        This can be used to read the result of a disable-when conditional.
        
        It is recommended that hou.Node.updateParmStates is called before
        executing this method either in non-graphical Houdini or when the
        owner node has not yet been loaded into the Parameter Pane.
        
        
        """
        pass
        
    
    def removeMultiParmInstance(index):
        """
        removeMultiParmInstance(self, index)
        
        Removes the multi parm instance at the given index.
        
        
        """
        pass
        
    
    def containingFolderSetParmTuples():
        """
        containingFolderSetParmTuples(self) -> tuple of hou.ParmTuple
        
        Return a tuple of ParmTuples corresponding to the folders containing
        this parameter.
        
        For example, if this parameter is in the Shading folder and the
        Shading folder is inside the Render folder, this method will return
        a tuple containing the Render parm tuple and the Shading parm tuple.
        Any parm tuples returned will be folder sets.
        
        If this parameter is not inside a folder, an empty tuple is
        returned.
        
        See also the containingFolders() method, and hou.Node.parmsInFolder
        and hou.Node.parmTuplesInFolder.
        
        
        """
        pass
        
    
    def componentIndex():
        """
        componentIndex(self) -> int
        
        Returns the component index of this parameter.
        
        For example, the translation parameter along the x-axis, "tx", would
        return a component index of 0, while the translation parameter along
        the y-axis, "ty" would return a component index of 1.
        
        
        """
        pass
        
    
    def isAtDefault(compare_temporary_defaults=True, compare_expressions=False):
        """
        isAtDefault(self, compare_temporary_defaults=True,
        compare_expressions=False) -> bool
        
        Returns whether the parameter is currently at its default.
        
        compare_temporary_defaults: When <compare_temporary_defaults> is
        True, isDefault also checks
        
        compare_expressions: When <compare_Expressions> is True, isDefault
        compares the actual
        
        See also the revertToDefaults() and
        revertToAndRestorePermanentDefaults()methods.
        
        
        """
        pass
        
    
    def multiParmInstanceIndices():
        """
        multiParmInstanceIndices(self) -> tuple of int
        
        If this parameter is a multi-parameter instance, then return a tuple
        of indices of where the parameter appears in the multi-parameter
        block and any nested blocks. Indices for outer multi-parameter
        blocks are listed first.
        
        For example if this parameter appears as the fourth instance in the
        multi-parameter block then (3,) is returned.
        
        As another example if this parameter appears as the third instance
        in the multi-parameter block and the block itself appears as the
        first instance of an outer multi-parameter block then (0, 2) is
        returned.
        
        
        """
        pass
        
    
    def isHidden():
        """
        isHidden(self) -> bool
        
        Returns the hidden state of the parameter. This can be used to read
        the result of a hide-when conditional.
        
        It is recommended that hou.Node.updateParmStates is called before
        executing this method either in non-graphical Houdini or when the
        owner node has not yet been loaded into the Parameter Pane.
        
        
        """
        pass
        
    
    def parentMultiParm():
        """
        parentMultiParm(self) -> hou.Parm
        
        Return the parent multi-parameter if this parameter is a multi-
        parameter instance and None otherwise.
        
        
        """
        pass
        
    
    def evalAsRamp():
        """
        evalAsRamp(self) -> hou.Ramp
        
        Evaluates this parameter at the current frame and returns the result
        as a ramp.
        
        Raises hou.TypeError if the parameter is not a ramp.
        
        
        """
        pass
        
    
    def evalAtTime(time):
        """
        evalAtTime(self, time) -> int, float, or str
        
        Evalute this parameter at a given time and return the result as an
        integer, float or string.
        
        See also evalAtFrame.
        
        
        """
        pass
        
    
    def isAutoscoped():
        """
        isAutoscoped(self) -> bool
        
        Returns whether this parameter's autoscope property is on.
        
        
        """
        pass
        
    
    def evalAsNodes():
        """
        evalAsNodes(self) -> tuple of hou.Node
        
        Evaluates this parameter at the current frame and returns the result
        as a tuple of hou.Node.
        
        Raises hou.TypeError if the value cannot be converted to a hou.Node.
        
        
        """
        pass
        
    
    def tuple():
        """
        tuple(self) -> hou.ParmTuple
        
        Returns the hou.ParmTuple associated with this parameter.
        
        For example, calling this method on the Parm object for the
        translation parameter "tx", would return a ParmTuple that contains
        Parm objects for the three translation parameters "tx", "ty" and
        "tz". If no tuple is associated with the parameter, then the
        parameter itself is returned in a tuple of size 1.
        
        
        """
        pass
        
    
    def deleteKeyframeAtFrame(frame):
        """
        deleteKeyframeAtFrame(self, frame)
        
        Removes a keyframe from this parameter at the given frame.
        
        This function will raise a hou.ObjectWasDeleted exception if it is
        invoked on a parameter that does not exist in Houdini.
        
        This function will raise a hou.PermissionError exception if writing
        to the specified parameter is impossible.
        
        This function will raise a hou.OperationFailed exception the
        parameter doesn't have a keyframe at the given frame.
        
        See also hou.Parm.deleteAllKeyframes.
        
        
        """
        pass
        
    
    def keyframesInRange(start_frame, end_frame):
        """
        keyframesInRange(self, start_frame, end_frame) -> tuple of
        hou.BaseKeyframe
        
        Returns a tuple of keyframes on this parameter that fall in the
        range start_frame to end_frame, inclusive. If no keyframes are found
        an empty tuple is returned.
        
        
        """
        pass
        
    
    def containingFolders():
        """
        containingFolders(self) -> tuple of str
        
        Returns a tuple of strings corresponding to the names of the folders
        containing this parameter.
        
        For example, if this parameter is in the Shading folder and the
        Shading folder is inside the Render folder, this method will return
        ("Render", "Shading"). Note that by folder name, we mean the label
        used in the parameter dialog, not the internal parameter name.
        
        Returns an empty tuple if this parameter is not inside a folder.
        
        Note that calling this method on many parameters may be slow. For a
        faster alternative, see hou.Node.parmsInFolder.
        
        See also the containingFolderSetParmTuples method, and
        hou.Node.parmTuplesInFolder.
        
        
        """
        pass
        
    
    def unexpandedString():
        """
        unexpandedString(self) -> str
        
        Returns the contents of the parameter before dollar sign and back-
        tick expansion.
        
        Examples of unexpanded strings would be "image$F.pic",
        "$HIP/split.hda", or "chs('../font1/text')". If you were to call
        eval() on them, Houdini would perform variable expansion and back-
        tick expression evaluation, so you would get back something like
        "image1.pic" instead of "image$F.pic".
        
        Because only string parameters will attempt to do dollar sign and
        string expansion, this method will raise hou.OperationFailed if
        called from a non-string parameter.
        
        Suppose a string parameter contains keyframes. In this situation,
        Houdini will not attempt to do string expansion on the parameter's
        value, so calling this method will raise hou.OperationFailed.
        Instead of calling this method, you can call expression() to access
        the first Keyframe's expression. If there are multiple keyframes,
        you can call keyframes() to get a list of hou.StringKeyframe objects
        and call expression() on those objects to retrieve the expression.
        
        
        """
        pass
        
    
    def evalAsNodesAtFrame(frame):
        """
        evalAsNodesAtFrame(self, frame) -> tuple of hou.Node
        
        Evaluates this parameter at a certain frame and returns the result
        as a tuple of hou.Node.
        
        Raises hou.TypeError if the value cannot be converted to a hou.Node.
        
        
        """
        pass
        
    
    def evalAsIntAtFrame(frame):
        """
        evalAsIntAtFrame(self, frame) -> int
        
        Evaluates this parameter at a certain frame and returns the result
        as an integer.
        
        Raises hou.TypeError if the value cannot be converted to an integer.
        
        
        """
        pass
        
    
    def setKeyframe(keyframe):
        """
        setKeyframe(self, keyframe)
        
        Sets a keyframe on this parameter.
        
        Raises hou.TypeError if keyframe is not of type hou.BaseKeyframe.
        Raises hou.PermissionError if this parameter is not writable.
        
        
        """
        pass
        
    
    def containingFolderIndices():
        """
        containingFolderIndices(self) -> tuple of int
        
        Return a tuple of indices corresponding to the folders containing
        this parameter. Each index refers to a folder in the corresponding
        folder set parameter.
        
        This method can be implemented as follows:
        
        > def containingFolderIndices(self):
        > return tuple(
        >     list(folder_set_parm_tuple.parmTemplate().folderNames()).index(
        >     folder_name)
        >     for folder_set_parm_tuple, folder_name in zip(
        >     parm.containingFolderSetParmTuples(), parm.containingFolders()))
        
        This example makes a parameter visible in the parameter pane by
        opening all the folders containing it.
        
        > def makeParmVisible(parm):
        > for folder_set_parm_tuple, folder_index in zip(
        >     parm.containingFolderSetParmTuples(),
        >     parm.containingFolderIndices()):
        >     folder_set_parm_tuple[0].set(folder_index)
        
        """
        pass
        
    
    def setExpression(expression, language=None, replace_expression=True):
        """
        setExpression(self, expression, language=None, replace_expression=True)
        
        Sets this parameter's expression.
        
        expression: A string containing the expression that will go inside
        the parameter.
        
        language: Either a hou.exprLanguage enumeration value or None.
        
        If language is None and the parameter does not already contain an
        expression, the language will be the node's expression language.
        (See hou.Node.expressionLanguage.) Otherwise, if language is None
        and the parameter already has an expression, the expression language
        will not change.
        
        replace_expression: This parameter only has effect if the parameter
        already contains keyframes. If it is True, Houdini will replace the
        keyframe before the current time with one containing the new
        expression. Otherwise, it will always add a keyframe at the current
        time. Note that this behavior matches what happens when you edit an
        expression from Houdini's parameter dialog.
        
        Unlike hou.Parm.set, this method does not follow channel references.
        That is, if this parameter is referencing another parameter and you
        call setExpression(), it change the channel reference expression
        into the specified expression.
        
        If the parameter does not already contain any keyframes, this method
        is roughly equivalent to setting a keyframe at frame 1, where the
        keyframe's expression and language are the ones specified.
        
        This method can be approximately implemented as follows:
        
        > def setExpression(self, expression, language=None, replace_expression=None)
        > if self.template().type() == hou.parmTemplateType.String:
        >     k = hou.StringKeyframe()
        > else:
        >     k = hou.Keyframe()
        >
        > k.setExpression(expression, language)
        >
        > if len(self.keyframes()):
        >     if replace_expression:
        >     k.setTime(self.effectiveKeyframeAtFrame(hou.frame()).time())
        >     else:
        >     k.setTime(hou.time())
        > else
        >     k.setTime(0.0)
        >
        > self.setKeyframe(k)
        
        See also the expression, expressionLanguage, and setKeyframe
        methods, hou.Node.expressionLanguage, and hou.Node.setExpressions.
        
        
        """
        pass
        
    
    def getReferencedParm():
        """
        getReferencedParm(self) -> hou.Parm
        
        Returns the referenced parameter. If no parameter is referenced,
        returns this parameter.
        
        
        """
        pass
        
    
    def keyframeExtrapolation():
        """None"""
        pass
        
    
    def evalAsInt():
        """
        evalAsInt(self) -> int
        
        Evaluates this parameter at the current frame and returns the result
        as an integer.
        
        Raises hou.TypeError if the value cannot be converted to an integer.
        
        
        """
        pass
        
    
    def name():
        """
        name(self) -> str
        
        Returns this parameter's name.
        
        
        """
        pass
        
    
    def deleteAllKeyframes():
        """
        deleteAllKeyframes(self)
        
        Removes all keyframes from this parameter.
        
        This has no effect if there are no keyframes to delete. The value of
        the parameter after all keyframes are removed will be the one it
        evaluated to at the current frame.
        
        This function will raise a hou.ObjectWasDeleted exception if it is
        invoked on a parameter that does not exist in Houdini.
        
        This function will raise a hou.PermissionError exception if writing
        to the specified parameter is impossible.
        
        See also hou.Parm.deleteKeyframeAtFrame and
        hou.ParmTuple.deleteAllKeyframes.
        
        
        """
        pass
        
    
    def revertToAndRestorePermanentDefaults():
        """
        revertToAndRestorePermanentDefaults(self)
        
        Changes the value back to the default that ships with Houdini, and
        restores that default.
        
        See also the revertToDefaults() method, and
        hou.ParmTuple.revertToAndRestorePermanentDefaults
        
        
        """
        pass
        
    
    def clipData(self, start=None, end=None, binary=True, use_blosc_compression=True, sample_rate=0):
        """
        clipData(start=None, end=None, binary=True, use_blosc_compression=True,
        sample_rate=0) -> str
        
        Returns the clip data for this parameter. This method is similar to
        hou.Parm.saveClip, except that it returns the clip data (file
        contents) instead of saving the animation to a clip file.
        
        <start>, <end>, and <sample_rate> behave the same as in
        hou.Parm.saveClip.
        
        If <binary> is True, return binary clip data, otherwise return plain
        text (ASCII) clip data.
        
        If <use_blosc_compression> is True, blosc compress the binary clip
        data. This cannot be used for plain text (ASCII) clip data.
        
        Raises a hou.OperationFailed exception if the parameter does not
        have animation.
        
        Raises a hou.InvalidInput exception if start >= end. If specifying
        only <start>, ensure that the specified value is less than the
        global end frame. Likewise, if specifying only <end>, ensure it is
        larger than the global start frame.
        
        Raises a hou.InvalidInput exception if binary = False and
        use_blosc_compression = True.
        
        """
        pass
        
    
    def setKeyframes(keyframes):
        """
        setKeyframes(self, keyframes)
        
        Sets multiple keyframe on this parameter. Calling this method is
        more efficient than calling hou.Parm.setKeyframe several times
        because it sends out only one update event to Houdini for the entire
        batch of keyframes that are set.
        
        keyframes must be a tuple or list of hou.BaseKeyframe objects.
        
        Raises hou.PermissionError if this parameter is not writable.
        
        
        """
        pass
        
    
    def isSpare():
        """
        isSpare(self) -> bool
        
        Returns whether this parameter is a "spare" (user-defined)
        parameter.
        
        
        """
        pass
        
    
    def evalAsJSONMapAtFrame(frame):
        """
        evalAsJSONMapAtFrame(self, frame) -> hou.JSONMap
        
        Evaluates this parameter at a certain frame and returns the result
        as a JSON map structure (i.e. Python dictionary).
        
        Raises hou.TypeError or hou.OperationFailed if the parameter is not
        a JSON map data parameter.
        
        
        """
        pass
        
    
    def setSelect(on):
        """
        setSelect(self, on)
        
        Changes the select property of this parameter's channel, which
        affects whether it is selected in the animation editor.
        
        
        """
        pass
        
    
    def evalAtFrame(frame):
        """
        evalAtFrame(self, frame) -> int, float, or str
        
        Evalute this parameter at a given frame and return the result as an
        integer, float or string.
        
        See also evalAtTime.
        
        
        """
        pass
        
    
    def loadClip(self):
        """auto-insert ocstring: HOM_Parm::loadClip"""
        pass
        
    
    def setAutoscope(on):
        """
        setAutoscope(self, on)
        
        Changes the autoscope property of the parameter. If this property is
        on, this parameter is automatically scoped when the object is
        selected.
        
        
        """
        pass
        
    
    def _set():
        """None"""
        pass
        
    
    def hasTemporaryDefaults():
        """
        hasTemporaryDefaults(self) -> bool
        
        Returns whether a default has been explicitly set on the parameter.
        
        See also the revertToDefaults() and
        revertToAndRestorePermanentDefaults()methods.
        
        
        """
        pass
        
    
    def _clipData():
        """None"""
        pass
        
    
    def lock(on):
        """
        lock(self, on)
        
        Locks (lock(True)) or unlocks (lock(False)) this parameter (this is,
        makes the value uneditable).
        
        Raises hou.PermissionError if this parameter is part of a locked
        digital asset.
        
        
        """
        pass
        
    
    def keyframes():
        """
        keyframes(self) -> tuple of hou.BaseKeyframe
        
        Returns the keyframes on this parameter.
        
        
        """
        pass
        
    
    def setPending(value):
        """
        setPending(self, value)
        
        Sets the parameter value at the current frame and marks it as
        pending if the parameter is keyed.
        
        Raises hou.TypeError if the type of value does not match this
        parameter's type. Raises hou.PermissionError if this parameter is
        not writable.
        
        
        """
        pass
        
    
    def parmTemplate():
        """
        parmTemplate(self) -> hou.ParmTemplate
        
        Returns the template for this parameter.
        
        
        """
        pass
        
    
    def keyframesAfter():
        """None"""
        pass
        
    
    def isScoped():
        """
        isSelected(self) -> bool
        
        Returns whether this parameter's channel is selected. If it is
        selected, then it is selected in the animation editor.
        
        
        """
        pass
        
    
    def keyframesRefit(refit, refit_tol, refit_preserve_extrema, refit_bezier, resample, resample_rate, resample_tol, range, range_start, range_end, bake_chop):
        """
        keyframesRefit(self, refit, refit_tol, refit_preserve_extrema,
        refit_bezier, resample, resample_rate, resample_tol, range, range_start,
        range_end, bake_chop)
        
        Performs a refitting operation with resampling and range controls.
        
        
        refit
        If set to true, a cubic refitting will be performed with the
        supplied refit options. If set to false, the refitting is
        skipped and only the resampling or range operation will be
        performed.
        
        refit_tol
        Refit Tolerance in absolute value.
        
        refit_preserve_extrema
        Preserves the keys that are local minima or maxima.
        
        refit_bezier
        If True, the new keyframes will be set to use bezier() segments.
        If False, the new keyframes will be set to use cubic() segments.
        
        resample
        If True, a resampling operation is performed prior to the
        refitting. If False, the channel is used as is.
        
        resample_rate
        Resample rate in frames. If set to 1.0, a keyframe will be added
        at every frame.
        
        resample_tol
        Resample Tolerance in frames. If set to 1.0, the resampling
        won't happen if a frame exists within one frame.
        
        range
        If True, the range_start and range_end arguments are used. It's
        useful when baking cycles when using cycle/cycle offset or
        oscillate channel extrapolation. If False, the channel range
        will be used based on the first and last keyframes.
        
        range_start
        Start frame of the range.
        
        range_end
        End frame of the range.
        
        bake_chop
        A hou.parmBakeChop enumeration value.
        
        
        """
        pass
        
    
    def hide(on):
        """
        hide(self, on)
        
        Sets the UI hidden state of this parameter in its node. Calling this
        method has the same effect as changing the Invisible checkbox on the
        Edit Parameter Interface dialog, or hiding the parameter with a
        hide-when conditional.
        
        However, changing the UI state with this function is transient and
        does not affect node parameter templates, which means that the new
        state is not saved to .hip file and can be restored when refreshing
        the node to its spare parameter templates.
        
        To permanently change the UI state of a parameter on a node, please
        use hou.ParmTemplate.hide instead:
        
        > parms = hou.node('/obj/node').parmTemplateGroup()
        > p = parms.find('lookatpath')
        > p.hide(True)
        > parms.replace('lookatpath', p)
        > hou.node('/obj/node').setParmTemplateGroup(parms)
        
        """
        pass
        
    
    def keyframesBefore(frame):
        """
        keyframesBefore(self, frame) -> tuple of hou.BaseKeyframe
        
        Returns a tuple of keyframes on this paramter that occur at or
        before frame. If no keyframes are found an empty tuple is returned.
        
        
        """
        pass
        
    
    def alias():
        """
        alias(self) -> str
        
        Returns the parameter's channel alias name. Returns an empty string
        if no such name exists.
        
        
        """
        pass
        
    
    def _saveClip():
        """None"""
        pass
        
    
    def multiParmInstances():
        """
        multiParmInstances(self) -> tuple of hou.Parm
        
        If this parameter corresponds to the number of instances for a
        multiparm, return all the parameters corresponding to all instances
        of this multiparm.
        
        Returns an empty tuple if this parameter is not for a multiparm.
        
        
        """
        pass
        
    
    def isSelected():
        """None"""
        pass
        
    
    def isLocked():
        """
        isLocked(self) -> bool
        
        Returns whether this parameter is locked (uneditable).
        
        
        """
        pass
        
    
    def pressButton(arguments={}):
        """
        pressButton(self, arguments={})
        
        Emulates clicking a button parameter to trigger its callback script.
        Raises hou.OperationFailed if the callback script could not be run.
        An optional dictionary of arguments can be passed to the callback
        script. Raises hou.TypeError if a n argument value type is
        unsupported.
        
        
        NOTE
        This can be called on any type parameter to trigger its callback
        script, it is not limited to only button parameters.
        
        
        arguments
        An optional dictionary of arguments for the callback script. The
        dictionary is merged with the keyword values passed to the
        callback. The arguments values are single values of the
        following types: int, bool, float, str.
        
        
        """
        pass
        
    
    def createClip(parent_node, name, create_new, apply_immediately, current_value_only, create_locked, set_value_to_default):
        """
        createClip(self, parent_node, name, create_new, apply_immediately,
        current_value_only, create_locked, set_value_to_default) -> hou.ChopNode
        
        Creates a Channel CHOP representing this parameter. The Channel CHOP
        is created with the given name as a child of the given parent node.
        The parent_node is typically created via
        hou.Node.findOrCreateMotionEffectsNetwork.
        
        create_new: Always create a new Channel CHOP. If set to False, then
        if a Channel CHOP already exists with the same name, it will be re-
        used. If the parameter already exists on the Channel CHOP, the older
        parameter will be removed first.
        
        apply_immediately: If set to True, then the export flag on the
        Channel CHOP will be set.
        
        current_value_only: If set to True, then only the current value of
        the parameter will be stored.
        
        create_locked: If set to True, then the parameters are locked on
        creation.
        
        set_value_to_default: If set to True, then the parameters are
        reverted to their default values on creation
        
        See also hou.Node.findOrCreateMotionEffectsNetwork.
        
        
        """
        pass
        
    
    def node():
        """
        node(self) -> hou.Node
        
        Returns the node on which this parameter exists.
        
        
        """
        pass
        
    
    def expressionLanguage():
        """
        expressionLanguage(self) -> hou.exprLanguage enum value
        
        Returns the parameter's expression's language.
        
        If the parameter does not contain an expression, this method will
        raise hou.OperationFailed. Also, if the parameter contains more than
        one keyframe then it could contain multiple different expressions,
        so it also raises hou.OperationFailed in that case.
        
        To change the expression language, use hou.Parm.setExpression and
        explicitly specify the language:
        parm.setExpression(parm.expression(), language).
        
        This method is roughly equivalent to...
        
        > parm.keyframes()[0].expressionLanguage()
        
        See also the expression(), setExpression(), keyframes(), and
        setExpressionLanguage() methods.
        
        
        """
        pass
        
    
    def isAutoSelected():
        """
        isAutoSelected(self) -> bool
        
        Returns whether this parameter's autoselect property is on.
        
        
        """
        pass
        
    
    def description():
        """
        description(self) -> str
        
        Returns this parameter's label.
        
        
        """
        pass
        
    
    def evalAsStringAtFrame(frame):
        """
        evalAsStringAtFrame(self, frame) -> str
        
        Evaluates this parameter at a certain frame and returns the result
        as a string.
        
        If you want the string contents of the parameter before variable
        expansion and expression evaluation then call
        hou.Parm.unexpandedString.
        
        Raises hou.TypeError if the value cannot be converted to a string.
        
        
        """
        pass
        
    
    def evalAsNodeAtFrame(frame):
        """
        evalAsNodeAtFrame(self, frame) -> hou.Node
        
        Evaluates this parameter at a certain frame and returns the result
        as a hou.Node.
        
        Raises hou.TypeError if the value cannot be converted to a hou.Node.
        
        
        """
        pass
        
    
    def evalAsGeometry():
        """
        evalAsGeometry(self) -> hou.Geometry
        
        Evaluates this parameter at the current frame and returns the result
        as a geometry.
        
        Raises hou.TypeError if the parameter is not a geometry.
        
        
        """
        pass
        
    
    def copyToParmClipboard():
        """
        copyToParmClipboard(self)
        
        Copies this to the parameter clipboard. See also
        hou.parmClipboardContents.
        
        
        """
        pass
        
    
    def appendClip(chop_node, apply_immediately, current_value_only, create_locked, set_value_to_default):
        """
        appendClip(self, chop_node, apply_immediately, current_value_only,
        create_locked, set_value_to_default)
        
        Appends this parameter to the specified Channel CHOP.
        
        apply_immediately: If set to True, then the export flag on the
        Channel CHOP will be set.
        
        current_value_only: If set to True, then only the current value of
        the parameter will be stored.
        
        create_locked: If set to True, then the parameters are locked on
        creation.
        
        set_value_to_default: If set to True, then the parameters are
        reverted to their default values on creation
        
        
        """
        pass
        
    
    def disable(on):
        """
        disable(self, on)
        
        Sets the UI disable state of this parameter in its node. This is not
        the same as locking a parameter, as the underlying value can still
        be modified. It's closer to what a disable-when conditional does,
        when a parameter is disabled automatically by it.
        
        
        """
        pass
        
    
    def insertMultiParmInstance(index):
        """
        insertMultiParmInstance(self, index)
        
        Insert a new multi parm instance before the given index. To append a
        new multi parm instance, set the index to be the current number of
        instances. The current number can be queried by calling evalAsInt on
        the this parameter.
        
        
        """
        pass
        
    
    def eval():
        """
        eval(self) -> int, float, or str
        
        Evaluates this parameter at the current frame and returns the
        result. See also the evalAtFrame and evalAtTime methods.
        
        
        """
        pass
        
    
    def path():
        """
        path(self) -> str
        
        Returns the full path to this parameter.
        
        
        """
        pass
        
    
    def evalAsJSONMap():
        """
        evalAsJSONMap(self) -> dict of str to str
        
        Evaluates this parameter at the current frame and returns the result
        as a JSON map structure (i.e. Python dictionary).
        
        Raises hou.TypeError or hou.OperationFailed if the parameter is not
        a JSON map data parameter.
        
        
        """
        pass
        
    
    def setAlias(alias_name):
        """
        setAlias(self, alias_name)
        
        Gives the parameter another name by which it can be referenced in
        channels. You can pass in an empty string to remove an existing
        alias name.
        
        
        """
        pass
        
    
    def setFromParm(src):
        """
        setFromParm(self, src)
        
        Copies the value of an entire parameter, including channels, from
        the provided src parameter.
        
        
        """
        pass
        
    
    def evalAsNode():
        """
        evalAsNode(self) -> hou.Node
        
        Evaluates this parameter at the current frame and returns the result
        as a hou.Node.
        
        Raises hou.TypeError if the value cannot be converted to a hou.Node.
        
        
        """
        pass
        
    
    def isConstrained():
        """
        isConstrained(self) -> bool
        
        Returns True if the Parm's parent node is an OBJ that is cooked and
        has constraints.
        
        
        """
        pass
        
    
    def revertToDefaults():
        """
        revertToDefaults(self)
        
        Change the value back to the default(s). See also the
        revertToAndRestoreFactoryDefaults() method.
        
        
        """
        pass
        
    
    def overrideTrack():
        """
        overrideTrack(self) -> hou.Track or None
        
        Returns the CHOP track overriding this parameter, if any.
        
        
        """
        pass
        
    
    def asCode(brief=False, save_values=True, save_keyframes=True, save_keys_in_frames=False, save_flag_values=True, save_aliases=True, function_name=None):
        """
        asCode(self, brief=False, save_values=True, save_keyframes=True,
        save_keys_in_frames=False, save_flag_values=True, save_aliases=True,
        function_name=None) -> str
        
        Returns a script of Python statements that can be executed to set
        the parameter tuple's values, flags and other properties. To run the
        script, use either Python's exec or execfile functions.
        
        
        brief
        When <brief> is True, the output script omits commands for
        setting values and flags that are set to the factory defaults.
        The script also omits keyframe commands that set unused values,
        slopes and accelerations. The value of <brief> must be either
        True or False. save_values: When <save_values> is True, asCode
        outputs commands for setting the parameter tuple's values. The
        value of <save_values> must be either True or False.
        
        save_keyframes
        When <save_keyframes> is True, asCode outputs commands for
        creating the parameter tuple's keyframes (if any). The value of
        <save_keyframes> must be either True or False.
        
        save_keys_in_frames
        When <save_keys_in_frames> is True, asCode outputs commands for
        setting channel and key times in samples (frames) instead of
        seconds. This parameter has no effect if <save_keyframes> is set
        to False. The value of <save_keys_in_frames> must be either True
        or False.
        
        save_flag_values
        When <save_flag_values> is True, asCode outputs commands for
        setting the parameter tuple's flag values. The value of
        <save_flag_values> must be either True or False.
        
        save_aliases
        When <save_aliases> is True, asCode outputs commands for setting
        the parameter tuple's channel aliases. The value of
        <save_aliases> must be either True or False.
        
        function_name
        If <function_name> is specified, then the output script is
        wrapped in a Python function definition with the given name.
        <function_name> must be a non-zero length string consisting of
        only alphanumeric and underscore characters. Any invalid
        characters are internally converted to underscores.
        
        The wrapper function takes in a single argument which must be a
        reference to an existing node parameter tuple. For symmetry, the
        function also returns the parameter tuple reference.
        
        Here is an example of saving the output to a file and then loading
        it back into Houdini:
        
        > # Get a reference to the target parameter tuple.
        > pt = hou.parmTuple("/obj/geo1/t")
        >
        > # Execute asCode and write the output script to file.
        > script = pt.asCode()
        > f = open("set_parm_tuple_properties.py", "w")
        > f.write(script)
        > f.close()
        >
        > # Execute the script.  This will set the values, flag values
        > # and other properties on /obj/geo1's t parameter tuple.  It will
        > # also store a reference to the t parameter tuple into a variable
        > # named 'hou_parm_tuple'.
        > execfile("set_parm_tuple_properties.py")
        
        Here is an example of saving the output into a function and then
        calling it in Houdini:
        
        > # Get a reference to the target parameter tuple.
        > node = hou.parmTuple("/obj/geo1/t")
        >
        > # Execute asCode and write the function definition to file.
        > func = p.asCode(function_name="setParmTupleProperties")
        > f = open("parmtuplelib.py", "w")
        > f.write(func)
        > f.close()
        >
        > # Call the function definition to set the properties on another
        > # parameter tuple.
        > import parmtuplelib
        > hou_parm_tuple = parmtuplelib.setParmTupleProperties(node.parm("t"))
        
        """
        pass
        
    
    def setKeyframeExtrapolation(before, extrapol):
        """
        setKeyframeExtrapolation(self, before, extrapol)
        
        Sets a extrapolation on this parameter for time before the first
        keyframe or after the last keyframe. Extrapolation defines how a
        parm value is evaluated outside the keyframe range.
        
        
        before
        If set to true, the extrapolation for evaluations before the
        first keyframe will be set. If set to false, the extrapolation
        for evaluations after the last keyframe will be set.
        
        extrapol
        A hou.parmExtrapolate enumeration value.
        
        This function will raise a hou.ObjectWasDeleted exception if it is
        invoked on a parameter that does not exist in Houdini.
        
        This function will raise a hou.PermissionError exception if writing
        to the specified parameter is impossible.
        
        This function will raise a hou.OperationFailed exception the
        parameter doesn't have a valid animation channel.
        
        
        """
        pass
        
    
    def isTimeDependent():
        """
        isTimeDependent(self) -> bool
        
        Returns whether this parameter is _time dependent_, that is, its
        value changes depending on the point on the timeline at which it's
        evaluated. For example the parameter has an expression containing
        the $F (current frame number) variable.
        
        
        """
        pass
        
    
    def isVisible():
        """
        isVisible(self) -> bool
        
        Returns whether or not this parameter would be visible in the
        parameter dialog for this node. It checks both the parameter's
        template, and the hidden state of the parameter. This is equivalent
        to the following code (but runs faster because it avoids creating
        the hou.ParmTemplate):
        
        > >>> p = hou.parm('/obj/geo1/tx')
        > >>> not p.isHidden() and not p.parmTemplate().isHidden()
        > True
        
        """
        pass
        
    
    def saveClip(self, file_name, start=None, end=None, sample_rate=0):
        """
        saveClip(self, file_name, start=None, end=None, sample_rate=0)
        
        Saves the animation associated with this parameter to the clip file
        specified by <file_name>. The extension of <file_name> determines
        the format of the saved file.
        
        You can use one of the following extensions:
        
        * .clip: save animation as plain text (ASCII) clip file.
        
        * .bclip: save animation as a bclip (binary clip) file.
        
        * .bclip.sc: save animation as a bclip file using Blosc compression.
        
        Set <sample_rate> to a non-zero, non-negative value to specify the
        sample_rate to be used for the clip file. For example, if the
        current frame rate is 24 (hou.fps), and <sample_rate> is set to 12,
        the animation will be sampled every second frame since <sample_rate>
        is half of the current frame rate.
        
        If <start> is not None, start saving the animation from the
        specified frame (inclusive). Otherwise, the animation will be saved
        from the global start frame (inclusive).
        
        Similarly, if <end> is not None, stop saving the animation at the
        specified frame (inclusive). Otherwise, the animation will be saved
        until the global end frame (inclusive).
        
        The global start and end frame are specified in the Global Animation
        Options window.
        
        Raises a hou.OperationFailed exception if the parameter does not
        have animation.
        
        Raises a hou.OperationFailed exception if there is an error saving
        the animation to file.
        
        Raises a hou.InvalidInput exception if start >= end. If specifying
        only <start>, ensure that the specified value is less than the
        global end frame. Likewise, if specifying only <end>, ensure it is
        larger than the global start frame.
        
        """
        pass
        
    
    def expression():
        """
        expression(self) -> str
        
        Returns this parameter's expression.
        
        For example, a parameter might contain the Python expression frame()
        * 2. In this case hou.Parm.eval at frame 2 would return the value 4,
        while calling expression() would return the string frame() * 2.
        
        If the parameter does not contain an expression, this method will
        raise hou.OperationFailed. Also, if the parameter contains more than
        one keyframe then it could contain multiple different expressions,
        so it also raises hou.OperationFailed in that case.
        
        This method is roughly equivalent to...
        
        > parm.keyframes()[0].expression()
        
        See also the setExpression(), expressionLanguage(), keyframes(), and
        eval() methods.
        
        
        """
        pass
        

class ParmTemplate(object):
    """
    hou.ParmTemplate
    
    Describes a parameter tuple (its name, type, etc.). This is base class
    for all parameter templates.
    
    ParmTemplates are most often used when describing a parameter in a
    digital asset definition's parameter interface or when describing an
    individual node's parameter layout (including its spare parameters). A
    ParmTemplate describes a parameter and the type of data it holds, but it
    does not store the current value of a parameter; only hou.Parm objects
    inside hou.ParmTuple objects actually store parameter values. You can
    think of a hou.ParmTuple as an instance of a ParmTemplate. For example,
    the "t" parm tuple on geometry objects can be described by a
    hou.FloatParmTemplate -- it has a label of "Transform", a data type of
    hou.parmData.Float, 3 components, a naming scheme of
    hou.parmNamingScheme.XYZW, etc. Each geometry object node has a
    hou.ParmTuple named "t" that uses this ParmTemplate.
    
    Note that ParmTemplate objects are just data containers, and they have
    no live relationship with objects in Houdini. For example, a hou.Node
    object corresponds directly to a node in Houdini, and if the node is
    renamed in Houdini hou.Node.name will return the new name.
    ParmTemplates, on the other hand, do not have a live relationship.
    Creating a ParmTemplate based on a spare parameter or asset definition
    parameter will simply copy the information into the ParmTemplate object,
    and modifying the object will not affect the spare parameter/asset
    parameter.
    
    Note also that ParmTemplate objects are always instances of a subclass
    of this class, so you cannot construct an instance of this class
    directly.
    
    To manipulate the parameters of a digital asset, you can retrieve the
    asset's current set of ParmTemplates into a hou.ParmTemplateGroup using
    hou.HDADefinition.parmTemplateGroup. You can then modify the group,
    adding parameters to it and replacing parameters in it, and save the
    group back to the asset definition with
    hou.HDADefinition.setParmTemplateGroup. Similarly, you can change a
    node's parameter layout with hou.Node.parmTemplateGroup and
    hou.Node.setParmTemplateGroup.
    
    You can also ask a hou.ParmTuple for its ParmTemplate in order to find
    out information about the parameter, such as allowed ranges of values,
    the label displayed to the user in the parameter pane, the parameter's
    popup help, etc.
    
    
    """
    
    def scriptCallbackLanguage():
        """
        scriptCallbackLanguage(self) -> hou.scriptLanguage enum value
        
        Return the language of the script that Houdini runs when this
        parameter changes.
        
        Note that Houdini uses the tags dictionary to store the script
        callback information.
        
        See also the scriptCallback method.
        
        
        """
        pass
        
    
    def help():
        """
        help(self) -> str
        
        Return the help that Houdini displays when you hover over the
        parameter label in the parameter pane.
        
        
        """
        pass
        
    
    def isLabelHidden():
        """
        isLabelHidden(self) -> bool
        
        Return whether the label for this parameter is hidden in the
        parameter pane.
        
        
        """
        pass
        
    
    def setLabel(label):
        """
        setLabel(self, label)
        
        Change the name of the label that is displayed in the parameter
        pane.
        
        
        """
        pass
        
    
    def setDisableWhen(disable_when):
        """
        setDisableWhen(self, disable_when)
        
        This method is deprecated in favor of the setConditional method.
        
        
        """
        pass
        
    
    def joinsWithNext():
        """
        joinsWithNext(self) -> bool
        
        Return whether this parameter is displayed on the same line as the
        next parameter in the parameter pane.
        
        
        """
        pass
        
    
    def hide(on):
        """
        hide(self, on)
        
        Marks this parameter as visible or invisible in the parameter pane.
        
        Note that hidden parameters still exist, and can be evaluated,
        channel-referenced, etc. They simply will not be displayed in the
        parameter pane.
        
        
        """
        pass
        
    
    def setLook(look):
        """
        setLook(self, look)
        
        Set the look of this parameter to a hou.parmLook enum value.
        
        See the look method for more information.
        
        
        """
        pass
        
    
    def scriptCallback():
        """
        scriptCallback(self) -> str
        
        Return the contents of the script that Houdini runs when this
        parameter changes. This script is most commonly used in
        hou.ButtonParmTemplate objects to respond to the button being
        pressed.
        
        Note that Houdini uses the tags dictionary to store the script
        callback information.
        
        
        """
        pass
        
    
    def label():
        """
        label(self) -> string
        
        Return the name of the parameter tuple that is displayed in the
        parameter pane.
        
        
        """
        pass
        
    
    def type():
        """
        type(self) -> hou.parmTemplateType enum value
        
        Return the enumerated value identifying the type of this parameter.
        
        Remember that ParmTemplate objects are always instances of a
        subclass of this class. The following table shows the mapping
        between hou.parmTemplateType enumeration values and ParmTemplate
        subclasses:
        
        
        Enumerated Value
        ParmTemplate Subclass
        
        hou.parmTemplateType.Int
        hou.IntParmTemplate
        
        hou.parmTemplateType.Float
        hou.FloatParmTemplate
        
        hou.parmTemplateType.String
        hou.StringParmTemplate
        
        hou.parmTemplateType.Toggle
        hou.ToggleParmTemplate
        
        hou.parmTemplateType.Menu
        hou.MenuParmTemplate
        
        hou.parmTemplateType.Button
        hou.ButtonParmTemplate
        
        hou.parmTemplateType.FolderSet
        hou.FolderSetParmTemplate
        
        hou.parmTemplateType.Folder
        hou.FolderParmTemplate
        
        hou.parmTemplateType.Separator
        hou.SeparatorParmTemplate
        
        hou.parmTemplateType.Label
        hou.LabelParmTemplate
        
        hou.parmTemplateType.Ramp
        hou.RampParmTemplate
        
        
        """
        pass
        
    
    def namingScheme():
        """
        namingScheme(self) -> hou.parmNamingScheme enum value
        
        Return the naming scheme used to name parameters inside the parm
        tuple for this ParmTemplate.
        
        For example, if the naming scheme is hou.parmNamingScheme.XYZW and
        the parm template is named "foo" and has 3 components, the
        parameters will be named "foox", "fooy", and "fooz". On the other
        hand, if the naming scheme was hou.parmNamingScheme.Base1, the
        parameters would be named "foo1", "foo2", and "foo3".
        
        Note that when the parm template only has 1 component, the parm name
        is the same as the parm tuple name.
        
        See hou.parmNamingScheme for more information.
        
        
        """
        pass
        
    
    def numComponents():
        """
        numComponents(self) -> int
        
        Return the number of values stored inside hou.ParmTuple instances of
        this ParmTemplate.
        
        For example, if this parm template has 3 components, there will be 3
        parameter fields displayed in the parameter pane and there will be 3
        hou.Parm objects inside a hou.ParmTuple based off this parm
        template.
        
        
        """
        pass
        
    
    def setName(name):
        """
        setName(self, name)
        
        Change the internal name of this parm template. Remember that
        ParmTemplates just store data, so the name change will not have any
        effect unless this parm template is later used to modify a parameter
        layout in Houdini.
        
        
        """
        pass
        
    
    def tags():
        """
        tags(self) -> dict of string to string
        
        Return a dictionary of extra data stored in the parm template.
        
        Houdini uses this dictionary to attach arbitrary data to parm
        templates. The keys in this dictionary vary depending on the
        ParmTemplate type and its use.
        
        
        """
        pass
        
    
    def dataType():
        """
        dataType(self) -> hou.parmData enum value
        
        Return the data type stored in hou.Parm instances inside
        hou.ParmTuple instances corresponding to this ParmTemplate.
        
        For example, suppose this parm tuple is a hou.FloatParmTemplate with
        3 components. The corresponding hou.ParmTuple will have 3 hou.Parm
        objects inside it, and each will store a floating point value. In
        this example, this method would return hou.parmData.Float.
        
        
        """
        pass
        
    
    def clone():
        """
        clone(self) -> hou.ParmTemplate
        
        Return a copy of this parm template.
        
        This method can be called on an instance of a ParmTemplate subclass
        and an instance of the subclass is properly returned.
        
        
        """
        pass
        
    
    def setJoinWithNext(on):
        """
        setJoinWithNext(self, on)
        
        Sets whether this parameter is displayed on the same line as the
        next parameter in the parameter pane.
        
        
        """
        pass
        
    
    def setScriptCallback(script_callback):
        """
        setScriptCallback(self, script_callback)
        
        Set the callback script to the given string. This script runs in
        response to a parameter change.
        
        See the scriptCallback method for more information.
        
        
        """
        pass
        
    
    def setTags(tags):
        """
        setTags(self, tags)
        
        Set the dictionary of extra data stored in this parm template.
        
        See the tags method for more information.
        
        
        """
        pass
        
    
    def setNamingScheme(naming_scheme):
        """
        setNamingScheme(self, naming_scheme)
        
        Set the naming scheme used to name parameters inside the parm tuple
        for this ParmTemplate to a hou.parmNamingScheme enum value.
        
        See the namingScheme method for more information.
        
        
        """
        pass
        
    
    def look():
        """
        look(self) -> hou.parmLook enum value
        
        Return the look of this parameter in the parameter pane. For
        example, a tuple of 3 floats can be displayed as a 3D vector or as
        an RGB color.
        
        See hou.parmLook for more information.
        
        
        """
        pass
        
    
    def hideLabel(on):
        """
        hideLabel(self, on)
        
        Hide or show the label for this parameter in the parameter pane.
        
        
        """
        pass
        
    
    def name():
        """
        name(self) -> string
        
        Return the internal name of the parm template. This is the name that
        hou.ParmTuple objects created from this parm template will have.
        
        Note that the names of hou.Parm objects inside ParmTuples based off
        this ParmTemplate are determined by this name, the number of
        components in this parm template, and the naming scheme. See the
        namingScheme method for more information.
        
        
        """
        pass
        
    
    def setHelp(help):
        """
        setHelp(self, help)
        
        Set the help that Houdini displays when you hover over the parameter
        label in the parameter pane.
        
        
        """
        pass
        
    
    def isHidden():
        """
        isHidden(self) -> bool
        
        Return whether this parameter is hidden in the parameter pane.
        
        
        """
        pass
        
    
    def setScriptCallbackLanguage(script_callback_language):
        """
        setScriptCallbackLanguage(self, script_callback_language)
        
        Set the script callback language to a hou.scriptLanguage enum value.
        
        See the scriptCallbackLanguage method for more information.
        
        
        """
        pass
        
    
    def setConditional(type, conditional):
        """
        setConditional(self, type, conditional)
        
        Set a conditional string of the given hou.parmCondType type for this
        parameter. This string consists of rules on how this parameter's
        display behaves when other parameters change.
        
        See the Conditionals section of the <Operator Type Properties
        window> help for more information on this string.
        
        
        """
        pass
        
    
    def joinWithNext():
        """
        joinWithNext(self) -> bool
        
        This method is deprecated in favor of the joinsWithNext method.
        
        
        """
        pass
        
    
    def asCode(function_name=None, variable_name=None):
        """
        asCode(self, function_name=None, variable_name=None) -> str
        
        Return a string containing Python statements that can be executed to
        recreate the parameter template. To run the string, use Python's
        compile, or execfile functions or the exec statement.
        
        
        function_name
        If <function_name> is specified, then the code returned creates
        a Python function with the given name. <function_name> must be a
        non-zero length string consisting of only alphanumeric and
        underscore characters. Any invalid characters are internally
        converted to underscores.
        
        The function returns a reference to the newly created parameter
        template object.
        
        variable_name
        The name of a Python variable that the result code will assign
        to. If None, Houdini uses the variable name "hou_parm_template".
        
        Here is an example of saving the output to a file and then loading
        it back into Houdini:
        
        > # Get a reference to the target parameter template.
        > node = hou.node("/obj/geo1")
        > parm_template = node.parm("tx").parmTemplate()
        >
        > # Execute asCode and write the output script to a file.
        > code = parm_template.asCode()
        > source_file = open("create_parm_template.py", "w")
        > source_file.write(code)
        > source_file.close()
        >
        > # Execute the script.  The new parameter template will be stored
        > # in the 'hou_parm_template' variable.
        > execfile("create_parm_template.py")
        >
        > # Add a spare parameter to the node using the saved parameter
        > # template.
        > node.addSpareParmTuple(hou_parm_template)
        
        Here is an example of saving the output into a function in a file
        and then calling it from Houdini:
        
        > # Get a reference to the target parameter template.
        > node = hou.node("/obj/geo1")
        > parm_template = node.parm("tx").parmTemplate()
        >
        > # Execute asCode and write the function definition to a file.
        > code = parm_template.asCode(function_name="createParmTemplate")
        > source_file = open("parmtemplatelib.py", "w")
        > source_file.write(code)
        > source_file.close()
        >
        > # Call the function definition.
        > import parmtemplatelib
        > hou_parm_template = parmtemplatelib.createParmTemplate()
        >
        > # Add a spare parameter to the node using the saved parameter
        > # template.
        > node.addSpareParmTuple(hou_parm_template)
        
        """
        pass
        
    
    def disableWhen():
        """
        disableWhen(self) -> str
        
        This method is deprecated in favor of the conditionals method.
        
        
        """
        pass
        
    
    def setNumComponents(num_components):
        """
        setNumComponents(self, num_components) -> int
        
        Set the number of values stored inside hou.ParmTuple instances of
        this ParmTemplate.
        
        Note that some ParmTemplate subclasses only support one component,
        so calling this method with a value other than 1 may raise a
        hou.OperationFailed exception. Also, changing the number of
        components may automatically change the size of the tuple of default
        values for some ParmTemplate subclasses.
        
        
        """
        pass
        
    
    def conditionals():
        """
        conditionals(self) -> dict of [Hom:hou.parmCondType] enum value to
        string
        
        Returns the set of conditionals currently affecting this parameter.
        
        See the Conditionals section of the <Operator Type Properties
        window> help for more information on this string.
        
        
        """
        pass
        

class ParmTemplateGroup(object):
    """
    hou.ParmTemplateGroup
    
    A group of parameter templates used to represent the parameter layout of
    a node or the parameters in a digital asset definition.
    
    This class stores a group of hou.ParmTemplate objects. You can create an
    empty group, create a group from a sequence of parm templates, or create
    a group from the parameter definitions of a digital asset or from a
    particular node's current parameter layout. Similarly, you can set an
    asset's parameters or a node's parameter interface to the contents of a
    parameter group.
    
    You can get an asset's parm templates with
    hou.HDADefinition.parmTemplateGroup and set them with
    hou.HDADefinition.setParmTemplateGroup. Similarly, you can get an
    individual node's parameter definition with hou.Node.parmTemplateGroup
    and set it with hou.Node.setParmTemplateGroup. When setting a node's
    parameter interface, any parms that are not in the node's type's set of
    parms will be added as spare parameters. Similarly, if parameters in the
    node's type are not present in the group, they will be automatically
    added at the end and made invisible. Also, if they exist but the types,
    labels, looks, naming schemes, etc are different, Houdini will discard
    all changes you attempt to make to these reserved parameters except for
    visibility settings.
    
    Note that ParmTemplateGroups store their own copy of the parm templates.
    Asking for the parm templates in a group will return a copy of the parm
    templates; modifying those copies will not change the contents of the
    group. For example, to change a parameter in a group you cannot simply
    call find and modify the hou.ParmTemplate it returned. Instead, you must
    call replace.
    
    It is important to understand the difference between folder parm
    templates and folder set parm templates when using ParmTemplateGroups.
    Folder sets correspond directly to hou.ParmTuple objects -- there is one
    parm tuple (that contains one parm) for each set of folders, and
    changing the value of that parm changes which folder is displayed.
    Individual Folders, on the other hand, do not directly correspond to
    hou.ParmTuple objects, but they are used in Houdini's <Type Properties>
    dialog and they make it easy to add individual folders and control which
    parameters are inside a folder. Unlike a hou.FolderSetParmTemplate, a
    hou.FolderParmTemplate stores the set of parm templates inside that
    folder. When a node or definition's parameters are set to the contents
    of a parm template group, the folder sets are determined and the parm
    tuple name for the set is the name of the first folder in that set. The
    names of the other folders in the set are not used.
    
    ParmTemplateGroups use folder parm templates instead of folder set parm
    templates. Attempting to add a FolderSetParmTemplate to a group will
    raise hou.OperationFailed. Asking a parm tuple for its parm template, on
    the other hand, may return a folder set but will never return a folder.
    Previously, folder parameter templates and parm template groups did not
    exist, so the only way to add folders were with special methods like
    hou.HDADefinition.addParmFolder and hou.Node.addSpareParmFolder. Now
    that that they exist, you may create folders by passing folder parm
    templates to hou.HDADefinition.addParmTuple and
    hou.Node.addSpareParmTuple. However, using parm template groups is
    preferred over calling these methods.
    
    Note that folder parm templates are also used to represent multiparm
    blocks, much like the <Type Properties> dialog does. The folder parm
    template's hou.folderType determines whether it is a folder or a
    multiparm block. Unlike folder parm templates, which do not correspond
    directly to parameter instances, a multiparm parm template does
    correspond to an integer parameter that controls the number of instances
    of the multiparm.
    
    
    """
    
    def entryAtIndices(indices):
        """
        entryAtIndices(self, indices) -> hou.ParmTemplate
        
        Given a sequence of integer indices return a copy of the
        hou.ParmTemplate object at that location. The indices are of the
        format returned by findIndices.
        
        Like the hou.ParmTemplate.find and hou.ParmTemplate.entries methods,
        this method returns a copy of the parm template stored inside this
        group. Modifying the copied parm template will not affect the
        contents of this group. Use replace to change a parm template.
        
        Raises hou.OperationFailed if the indices are invalid, including
        when the indices sequence is empty.
        
        This method could be implemented as follows:
        
        > def entryAtIndices(self, indices):
        >     if len(indices) == 0:
        >         raise hou.OperationFailed("Invalid indices")
        >     parm_template = self.entries()[indices[0]]
        >
        >     # If there are multiple indices then we should have just looked up
        >     # a folder parm template.
        >     for index in indices[1:]:
        >         parm_template = parm_template.parmTemplates()[index]
        >     return parm_template
        
        """
        pass
        
    
    def setToDialogScript(dialog_script):
        """
        setToDialogScript(dialog_script)
        
        Set the contents of this group to match the parameters defined by
        the given dialog script string.
        
        Raises hou.OperationFailed if there is an error in the dialog script
        contents.
        
        
        """
        pass
        
    
    def addParmTemplate(parm_template):
        """
        addParmTemplate(self, parm_template)
        
        This method is simply an alias for the append method.
        
        It makes it easier to treat parm template groups and
        hou.FolderParmTemplate objects uniformly, since
        hou.FolderParmTemplate has an addParmTemplate method.
        
        
        """
        pass
        
    
    def entriesWithoutFolders():
        """
        entriesWithoutFolders(self) -> tuple of hou.ParmTemplate
        
        Return a tuple containing all the non-folder parm templates inside
        this group. The output is the flattened set of parm templates in the
        group, and includes the non-folder parms inside folders.
        
        Like entries, this method returns a copy of the parm templates
        inside this group.
        
        Note that this function does not return parm templates for entries
        inside multiparm blocks.
        
        Also see the entries method for the example function
        allParmTemplates.
        
        
        """
        pass
        
    
    def replace(name_or_parm_template_or_indices, parm_template):
        """
        replace(self, name_or_parm_template_or_indices, parm_template)
        
        Replace a parm template inside this group with another parm
        template.
        
        
        name_or_parm_template_or_indices
        Either the name of the parm template being replaced, a copy of
        the parm template, or a tuple of integer indices that identify
        the parm template and any containing folders.
        
        This method changes the contents of this group. Note that it stores
        a copy of the parm template in the group, so future changes to the
        parm template passed in will not affect the group.
        
        See the find method for a simple example of how to use this method.
        
        Note that parm templates for reserved parameters (for example, the
        transform parameters in object-level digital assets) can be replaced
        in the parm template group, but all aspects of reserved parameters
        except for their visibility and join settings will be restored to
        their defaults when you save this group to a node or asset
        definition.
        
        Raises hou.OperationFailed if the parm template doesn't exist.
        
        
        """
        pass
        
    
    def sourceNodeType():
        """
        sourceNodeType(self) -> hou.NodeType or None
        
        Return the node type that the parameter template group was generated
        from. If the group was not generated from a node type, then return
        None.
        
        Raises hou.ObjectWasDeleted if the source node type has been
        destroyed.
        
        
        """
        pass
        
    
    def find(name):
        """
        find(self, name) -> hou.ParmTemplate or None
        
        Search in this group for a parm template whose name matches the
        specified one. Return a copy of the parm template or None if no
        match was found.
        
        Note that this function returns a copy of the parm template stored
        in this group. Modifying the copy will not affect the parameters in
        this group. The following example shows how to use the find and
        replace methods to modify the "pos" parm template in the group:
        
        > >>> parm_template = group.find("pos")
        > >>> parm_template.setLabel("Position")
        > >>> parm_template.replace("pos", parm_template)
        
        If you created the group from existing parameters, folder parm
        templates in the same folder set will share the same name, so
        searching for a folder using this method may return the first folder
        in the folder set. To instead search for a folder by its folder
        label, use findFolder.
        
        Note that, in general, the group does not prevent you from adding
        two parameters with the same name. In this case, searching for a
        parameter with this name will return the first one. Note, though,
        that when when setting this group to a node or asset definition's
        parms, either the duplicate parameters will be renamed on an
        exception will be raised. See the rename_conflicting_parms parameter
        to hou.HDADefinition.setParmTemplateGroup for more information.
        
        
        """
        pass
        
    
    def append(parm_template):
        """
        append(self, parm_template)
        
        Add a parm template after all existing parm templates, outside of
        any folder.
        
        See also appendToFolder.
        
        
        """
        pass
        
    
    def findFolder(label_or_labels):
        """
        findFolder(self, label_or_labels) -> hou.FolderParmTemplate or None
        
        Search in this group for a folder parm template with the given
        label. Return a copy of the hou.FolderParmTemplate or None if the
        folder wasn't found.
        
        
        label_or_labels
        Either a string containing the folder's label or a tuple of
        strings containing the labels of containing folders as well as
        the folder's label.
        
        Note that a folder parm template's label is what appears in the
        interface in the parameter dialog. The folder parm template's name
        is used to determine the name of the parm tuple for the folder set,
        if the folder is the first in the folder set. See the documentation
        for this class for more information.
        
        
        """
        pass
        
    
    def containingFolderIndices(name_or_parm_template_or_indices):
        """
        containingFolderIndices(self, name_or_parm_template_or_indices) -> tuple
        of int
        
        Return the indices of the folder in this group containing a given
        parm template. Return an empty tuple if no match was found.
        
        See replace for a description of the parameter and findIndices for a
        description of the return value.
        
        Raises hou.OperationFailed if the parameter is not inside the group
        or is not inside a folder.
        
        
        """
        pass
        
    
    def findIndicesForFolder(label_or_labels):
        """
        findIndicesForFolder(self, label_or_labels) -> tuple of int
        
        Search in this group for a folder parm template with the given
        label. Return an empty tuple if no match was found.
        
        See findFolder for a description of the parameter and findIndices
        for a description of the return value.
        
        Note that this method does not accept a parm template. However, if
        you have a folder parm template and want to find its indices, simply
        call findIndices on the folder parm template.
        
        
        """
        pass
        
    
    def asDialogScript(rename_conflicting_parms=False, full_info=False):
        """
        asDialogScript(rename_conflicting_parms=False, full_info=False)
        
        Return a string containing the dialog script file contents
        corresponding to this parm template group.
        
        Houdini saves parameter definitions in this format when saving
        digital asset definitions (in the DialogScript section of the
        digital asset) and when saving parameter layouts of nodes.
        
        The default behavior for reserved parameters is to output baseparm
        tokens for reserved parameters so that it is resistant to changes in
        their definition. To change this, use full_info=True.
        
        
        """
        pass
        
    
    def findIndices(name_or_parm_template):
        """
        findIndices(self, name_or_parm_template) -> tuple of int
        
        Search in this group for a parm template and return a tuple of
        integers corresponding to the indices of the parm in the group.
        Return an empty tuple if no match was found.
        
        
        name_or_parm_template
        Either the name of the parm template or another hou.ParmTemplate
        object to compare against when searching for a match.
        
        If the parm template was found and it is not inside any folders, the
        result tuple will contain a single integer with the index of the
        parm template. Otherwise, the first entry will be the index of a
        folder inside the group, the next will be an index of a folder
        inside that folder, and so on until the last index is an index of a
        parm template inside a folder.
        
        See also findIndicesForFolder.
        
        
        """
        pass
        
    
    def insertAfter(name_or_parm_template_or_indices, parm_template):
        """
        insertAfter(self, name_or_parm_template_or_indices, parm_template)
        
        Insert a parm template inside this group after an existing one. The
        new parm template will be in the same folder as the existing one.
        
        See replace for a description of the name/ parm template/indices
        parameter.
        
        Use appendToFolder to add an entry to a empty folder. Use append to
        add an entry to an empty parm template group.
        
        
        """
        pass
        
    
    def isHidden(name_or_parm_template_or_indices):
        """
        isHidden(self, name_or_parm_template_or_indices) -> bool
        
        Return whether the given parameter is itself hidden or lies inside a
        hidden folder.
        
        See replace for a description of the name/parm template/indices
        parameter.
        
        Note that if the parameter is inside a hidden folder but the
        parameter is not marked as hidden, calling hou.ParmTemplate.isHidden
        on the parm template will return False, while this method will
        return True.
        
        
        """
        pass
        
    
    def parmTemplates():
        """
        parmTemplates(self) -> tuple of hou.ParmTemplate
        
        This method is simply an alias for the entries method.
        
        It makes it easier to search down through a parm template group for
        items nested in folders, since the hou.FolderParmTemplate class also
        has a method named parmTemplates. The following example shows how to
        look up the labels for a folder parameter given its indices:
        
        > def folderLabels(parm_template_group, indices):
        >     container = parm_template_group
        >     result = []
        >     for index in indices:
        >         container = container.parmTemplates()[index]
        >         result.append(container.label())
        >     return result
        
        """
        pass
        
    
    def insertBefore(name_or_parm_template_or_indices, parm_template):
        """
        insertBefore(self, name_or_parm_template_or_indices, parm_template)
        
        Insert a parm template inside this group before an existing one. The
        new parm template will be in the same folder as the existing one.
        
        See replace for a description of the name/parm template/indices
        parameter.
        
        Use appendToFolder to add an entry to a empty folder. Use append to
        add an entry to an empty parm template group.
        
        
        """
        pass
        
    
    def entries():
        """
        entries(self) -> tuple of hou.ParmTemplate
        
        Return a tuple containing copies of the parm templates inside this
        group.
        
        Note that folders are returned as hou.FolderParmTemplate objects,
        and each folder parm template contains the parm templates inside it.
        Use hou.FolderParmTemplate.parmTemplates to access the elements in a
        folder.
        
        The following example creates a function named allParmTemplates that
        returns a single sequence of parm templates, including folders, for
        all parm templates in the group:
        
        > def allParmTemplates(group_or_folder):
        >     for parm_template in group_or_folder.parmTemplates():
        >         yield parm_template
        >
        >     # Note that we don't want to return parm templates inside multiparm
        >     # blocks, so we verify that the folder parm template is actually
        >     # for a folder.
        >         if (parm_template.type() == hou.parmTemplateType.Folder and
        >         parm_template.isActualFolder()):
        >             for sub_parm_template in allParmTemplates(parm_template):
        >                 yield sub_parm_template
        
        See also the parmTemplates method.
        
        
        """
        pass
        
    
    def hide(name_or_parm_template_or_indices, on):
        """
        hide(self, name_or_parm_template_or_indices, on)
        
        Hide a parameter by making it invisible. The parameter still exists
        in the group, but parameter dialogs will not display it.
        
        See replace for a description of the name/parm template/indices
        parameter.
        
        This method could be implemented as follows:
        
        > def hide(self, name_or_parm_template_or_indices, on):
        >     parm_template = self.find(name_or_parm_template_or_indices)
        >     parm_template.hide(on)
        >     self.replace(name_or_parm_template_or_indices, parm_template)
        
        See also hideFolder and hou.ParmTemplate.hide.
        
        
        """
        pass
        
    
    def isFolderHidden(label_or_labels):
        """
        isFolderHidden(self, label_or_labels) -> bool
        
        Return whether a folder or one of its containing folders is hidden.
        
        Note that if a folder is inside a hidden folder but this folder is
        not marked as hidden, calling hou.ParmTemplate.isHidden on the
        folder parm template will return False, while this method will
        return True.
        
        You may pass in either a string containing a single folder name or a
        sequence of strings to identify a nested folder. For example, the
        sequence ("Render", "Dicing") identifies the Dicing folder inside
        the Render folder. The folder is hidden if on is True and unhidden
        if it is False.
        
        
        """
        pass
        
    
    def sourceNode():
        """
        sourceNode(self) -> hou.Node or None
        
        Return the node that the parameter template group was generated
        from. If the group was not generated from a node, then return None.
        
        Raises hou.ObjectWasDeleted if the source node has been destroyed.
        
        
        """
        pass
        
    
    def appendToFolder(label_or_labels_or_parm_template_or_indices, parm_template):
        """
        appendToFolder(self, label_or_labels_or_parm_template_or_indices,
        parm_template)
        
        Add a parm template to the bottom of an existing folder.
        
        Note that you cannot add to a folder by simply looking up the folder
        parm template and calling hou.FolderParmTemplate.addParmTemplate on
        it, because asking for a folder will return a deep copy. The parm
        templates inside the copied folder will be separate from those
        inside this group, and modifying the folder will not affect the
        group. Consider the following example:
        
        > >>> folder = group.findFolder("Transform")
        > # "folder" now has its own copy of the parms inside it.
        > >>> folder.addParmTemplate(new_parm_template)
        > # "folder"'s parm templates are updated, but the group's parm templates are
        > # unchanged.
        >
        > >>> group.appendToFolder(folder, new_parm_template)
        > # The group is modified.  "folder"'s contents are unchanged.
        
        """
        pass
        
    
    def clear():
        """
        clear(self)
        
        Remove all parm templates from this group.
        
        
        """
        pass
        
    
    def remove(name_or_parm_template_or_indices):
        """
        remove(self, name_or_parm_template_or_indices)
        
        Remove a parm template from the group. Note that if you remove a
        folder, all of the parm templates in the folder are also removed.
        
        See replace for a description of the name/parm template/indices
        parameter.
        
        Raises hou.OperationFailed if the parm template could not be found.
        
        
        """
        pass
        
    
    def asCode(function_name=None, variable_name=None):
        """
        asCode(self, function_name=None, variable_name=None)
        
        Return Python code that will recreate this group.
        
        
        function_name
        If not None, the returned code will create a Python function.
        
        variable_name
        The name of the variable that will be assigned the newly-created
        parm template group.
        
        
        """
        pass
        
    
    def containingFolder(name_or_parm_template):
        """
        containingFolder(self, name_or_parm_template) -> hou.FolderParmTemplate
        
        Return a copy of the hou.FolderParmTemplate in this group containing
        a parm template.
        
        
        name_or_parm_template
        Either the name of the parm template or another hou.ParmTemplate
        object to compare against when searching for a match.
        
        Raises hou.OperationFailed if the parameter is not inside the group
        or is not inside a folder.
        
        
        """
        pass
        
    
    def hideFolder(label_or_labels, on):
        """
        hideFolder(self, label_or_labels, on)
        
        Hide a folder and all the parameters in it.
        
        You may pass in either a string containing a single folder name or a
        sequence of strings to identify a nested folder. For example, the
        sequence ("Render", "Dicing") identifies the Dicing folder inside
        the Render folder. The folder is hidden if on is True and unhidden
        if it is False.
        
        The following example hides the Transform parameter in a geometry
        object:
        
        > >>> group = geo_node.parmTemplateGroup()
        > >>> group.hideFolder("Transform", True)
        > >>> geo_node.setParmTemplateGroup(group)
        
        The following example hides the Dicing folder inside the Render
        folder on a geometry object:
        
        > >>> group = geo_node.parmTemplateGroup()
        > >>> group.hideFolder(("Render", "Dicing"), True)
        > >>> geo_node.setParmTemplateGroup(group)
        
        This method could be implemented as follows:
        
        > def hideFolder(self, label_or_labels, on):
        >     self.hide(self.findFolder(label_or_labels), on)
        
        See also hide.
        
        
        """
        pass
        

def ParmTemplateGroup_swigregister():
    """None"""
    pass
    

def ParmTemplate_swigregister():
    """None"""
    pass
    

class ParmTuple(object):
    """
    hou.ParmTuple
    
    A tuple of one or more node parameters. Each parameter tuple has a
    unique name within its node.
    
    The ParmTuple class behaves like a Python sequence, so you can index
    into it using square brackets, iterate over it, call len on it, etc. The
    elements inside the parameter tuple are hou.Parm objects.
    
    A parameter tuple's name may only contain letters, numbers, and
    underscores. For example, objects contain a parameter tuple named "t"
    that contains three integer parameters. The names of the parameters
    inside the tuple are determined from the parameter tuple's name and its
    naming scheme. For example, the "t" parameter uses the XYZW naming
    scheme, so the three parameters inside it are named "tx", "ty", and
    "tz". Note that if the parameter tuple only contains one parameter, the
    tuple and the parameter inside it may have the same name.
    
    In addition to a name, a parameter tuple also has a label that is
    displayed to the user in the parameter dialog. For example, the "t"
    parameter's label is "Translate". The label may contain spaces and
    punctuation characters.
    
    Each parameter in a tuple stores a value. Different instances of parm
    tuples in different nodes will store their own set of parameter values.
    The value in a parameter may be animated, in which case the parameter
    evaluates to a different result depending on the current time on the
    playbar. See hou.Keyframe for more information about animated
    parameters.
    
    Each hou.NodeType has a set of parameter tuple descriptions associated
    with it, and each instance of a hou.Node has a corresponding set of
    parameter tuple instances. The parameter tuples store specific values
    that are saved with the node. The descriptions of the parameter tuples,
    however, are represented by a hou.ParmTemplate. A parameter template
    describes the type, default values, ranges, etc. of a parameter tuple.
    
    See also hou.parmTuple_ and hou.Node.parmTuple.
    
    
    """
    
    def _setClipData():
        """None"""
        pass
        
    
    def evalAsRamps():
        """
        evalAsRamps(self) -> hou.Ramp
        
        Evaluates this parameter tuple at the current frame and returns the
        result as a tuple containing a hou.Ramp object.
        
        Raises hou.TypeError if this is not a ramp parameter.
        
        
        """
        pass
        
    
    def help():
        """None"""
        pass
        
    
    def lock(bool_values):
        """
        lock(self, bool_values)
        
        Lock or unlock all the parameters in this tuple. Houdini displays
        locked parameters as disabled and does not let you change their
        values.
        
        
        bool_values
        Either a single True or False value to be applied to all
        components of this parameter or a sequence of them where each
        value corresponds to a single component. Where an element of
        bool_values is True, that component will be locked (uneditable),
        and where an element is False, the corresponding component will
        be unlocked (editable).
        
        For example, the parameter tuple for "translation" contains Parm
        objects for translation along each of the axes, "tx", "ty" and "tz".
        If lock is called with the following tuple of boolean values, (True,
        True, False), then the parameter "tx" and "ty" will be locked and
        made non-editable, while "tz" will be unlocked and made editable.
        
        Raises hou.InvalidSize if bool_values has a different length than
        this parameter tuple. Raises hou.PermissionError if any of the
        parameters in this parameter tuple are not writable.
        
        
        """
        pass
        
    
    def parentMultiParm():
        """
        parentMultiParm(self) -> hou.Parm
        
        Return the parent multi-parameter if this parameter is a multi-
        parameter instance and None otherwise.
        
        
        """
        pass
        
    
    def setAutoscope(bool_values):
        """
        setAutoscope(self, bool_values)
        
        Changes the autoscope property of components of this parameter
        tuple.
        
        
        bool_values
        A sequence of True or False values, where each value corresponds
        to a component of this parameter. Where an element of
        bool_values is True, that component will be autoscope.
        
        For example, the parameter tuple for "translation" contains Parm
        objects for translation along each of the axes, "tx", "ty" and "tz".
        If setAutoscope is called with the following tuple of boolean
        values, (True, True, False), then the parameter "tx" and "ty" will
        be automatically scoped, while "tz" will not.
        
        Raises hou.InvalidSize if values has a different length than this
        parameter tuple. Raises hou.PermissionError if any of the parameters
        in this parameter tuple are not writable.
        
        
        """
        pass
        
    
    def _loadClip():
        """None"""
        pass
        
    
    def isMultiParmInstance():
        """
        isMultiParmInstance(self) -> bool
        
        Return whether this parameter is an instance of a multi parm. For
        example, the pt0, pt1, pt2, etc. parameter tuples in an add SOP are
        instances of a multiparm.
        
        
        """
        pass
        
    
    def setPending(values):
        """
        setPending(self, values)
        
        Sets the value of a parameter in the tuple at the current frame and
        marks it as pending if the parameter is keyed.
        
        
        values
        A sequence of floats or strings, corresponding to the components
        of this parameter tuple.
        
        For example, the parameter tuple for "translation" contains Parm
        objects for translation along each of the axes, "tx", "ty" and "tz".
        If set is called with following tuple of floats, (2.5, 4.0, 5.5),
        then the parameter "tx" with be set to 2.5, "ty" will be set to 4.0
        and "tz" will be set to 5.5.
        
        Raises hou.InvalidSize if values has a different length than this
        parameter tuple. Raises hou.PermissionError if any of the parameters
        in this parameter tuple are not writable.
        
        
        """
        pass
        
    
    def parmTemplate():
        """
        parmTemplate(self) -> hou.ParmTemplate
        
        Return this parameter tuple's template.
        
        Note that a folder parameter will have a hou.FolderSetParmTemplate
        template and a multiparm parameter will have a
        hou.FolderParmTemplate template.
        
        
        """
        pass
        
    
    def evalAsGeometries():
        """
        evalAsGeometries(self) -> tuple of hou.Geometry
        
        Evaluates this parameter tuple at the current frame and returns the
        result as a tuple containing a hou.Geometry object.
        
        Raises hou.TypeError if a value cannot be converted to a
        hou.Geometry.
        
        
        """
        pass
        
    
    def multiParmInstances():
        """
        multiParmInstances(self) -> tuple of hou.ParmTuple
        
        If this parameter corresponds to the number of instances for a
        multiparm, return all the parameter tuples corresponding to all
        instances of this multiparm.
        
        Returns an empty tuple if this parameter is not for a multiparm.
        
        
        """
        pass
        
    
    def _clipData():
        """None"""
        pass
        
    
    def hide(on):
        """
        hide(self, on)
        
        Sets the UI hidden state of this parameter tuple in its node.
        Calling this method is equivalent to changing the Invisible checkbox
        on the Edit Parameter Interface dialog, or hiding the parameter with
        a hide-when conditional.
        
        To hide a folder, use hou.Node.setParmTemplateGroup. This method
        cannot be used to hide a folder because a parm tuple corresponds to
        a set of folders, not an individual folder.
        
        To change the visibility of all new instances of the node type
        defined by a digital asset, use
        hou.HDADefinition.setParmTemplateGroup as in the following example:
        
        > def showParmTupleInDefinition(parm_tuple, visible):
        >     '''parm_tuple is a hou.ParmTuple on an instance of the digital asset.'''
        >     definition = parm_tuple.node().type().definition()
        >     parm_template_group = definition.parmTemplateGroup()
        >     parm_template = parm_template_group.find(parm_tuple.name())
        >     parm_template.hide(not visible)
        >     parm_template_group.replace(parm_tuple.name(), parm_template)
        >     definition.setParmTemplateGroup(parm_template_group)
        
        """
        pass
        
    
    def evalAsStrings():
        """
        evalAsStrings(self) -> tuple of str
        
        Evaluates this parameter tuple at the current frame and returns the
        result as a tuple of strings.
        
        Raises hou.TypeError if a value cannot be converted to a string.
        
        
        """
        pass
        
    
    def isDisabled():
        """
        isDisabled(self) -> bool
        
        Returns the disable state of the parameter tuple, ignoring the lock
        state. This can be used to read the result of a disable-when
        conditional.
        
        It is recommended that hou.Node.updateParmStates is called before
        executing this method either in non-graphical Houdini or when the
        owner node has not yet been loaded into the Parameter Pane.
        
        
        """
        pass
        
    
    def copyToParmClipboard():
        """
        copyToParmClipboard(self)
        
        Copies this to the parameter clipboard. See also
        hou.parmClipboardContents.
        
        
        """
        pass
        
    
    def evalAsStringsAtFrame(frame):
        """
        evalAsStringsAtFrame(self, frame) -> tuple of str
        
        Evaluates the parameter tuple at a frame and returns the result as a
        tuple of strings.
        
        Raises hou.TypeError if a value cannot be converted to a string.
        
        
        """
        pass
        
    
    def setClipData(self):
        """auto-insert ocstring: HOM_ParmTuple::setClipData"""
        pass
        
    
    def deleteAllKeyframes():
        """
        deleteAllKeyframes(self)
        
        Remove all the keyframes from this parameter tuple.
        
        This method be approximately implemented as follows:
        
        > def deleteAllKeyframes(self):
        > for parm in self:
        >     parm.deleteAllKeyframes()
        
        See also hou.Parm.deleteAllKeyframes.
        
        
        """
        pass
        
    
    def isAtDefault(compare_temporary_defaults=True, compare_expressions=False):
        """
        isAtDefault(self, compare_temporary_defaults=True,
        compare_expressions=False) -> bool
        
        Returns whether the parameter tuple is currently at its defaults.
        
        compare_temporary_defaults: When <compare_temporary_defaults> is
        True, isDefault also checks
        
        compare_expressions: When <compare_Expressions> is True, isDefault
        compares the actual
        
        See also the revertToDefaults() and
        revertToAndRestorePermanentDefaults()methods.
        
        
        """
        pass
        
    
    def set(self, values, language=None, follow_parm_references=True):
        """
        set(self, values, language=None, follow_parm_references=True)
        
        Sets the values of the parameters in the tuple at the current frame.
        
        
        values
        A sequence of floats, integers or strings, corresponding to the
        components of this parameter tuple.
        
        For example, the parameter tuple for "translation" contains
        hou.Parm objects for translation along each of the axes, "tx",
        "ty" and "tz". If set is called with the following tuple of
        floats, (2.5, 4.0, 5.5), then the parameter "tx" with be set to
        2.5, "ty" will be set to 4.0 and "tz" will be set to 5.5.
        
        You can also pass in a hou.ParmTuple object for this argument to
        create channel references from the parameters in this tuple to
        the parameters in the passed-in tuple. If this tuple has more
        parameters than the passed-in tuple then no work is performed on
        the extra parameters. If the passed-in tuple has more parameters
        than this tuple then the the extra parameters are ignored.
        
        language
        This option only applies when setting to a hou.ParmTuple value.
        Specifies the expression language to use when creating channel
        references from this parameter tuple to the given parameter
        tuple. Set this option to an hou.exprLanguage object or None to
        choose the default language.
        
        follow_parm_references
        This option only applies when setting to a hou.ParmTuple value.
        When this option is set to True then this method will follow
        channel references and create channel references from the
        referenced parameter tuple to the given parameter tuple.
        
        If this parameter tuple currently contains channel references to
        another parameter tuple, then this method will follow channel
        references and change the value of the referenced parameter tuple.
        If this is not the desired behavior, then first delete the channel
        reference with hou.ParmTuple.deleteAllKeyframes. Alternatively if
        you are setting the value to another parameter tuple and do not want
        to follow existing channel references then set the optional
        follow_parm_references argument to False.
        
        Raises hou.InvalidSize if values has a different length than this
        parameter tuple. Raises hou.PermissionError if any of the parameters
        in this parameter tuple are not writable.
        
        """
        pass
        
    
    def evalAsIntsAtFrame(frame):
        """
        evalAsIntsAtFrame(self, frame) -> tuple of int
        
        Evaluates this parameter tuple at a certain frame and returns the
        result as a tuple of integers.
        
        Raises hou.TypeError if a value cannot be converted to an integer.
        
        
        """
        pass
        
    
    def isHidden():
        """
        isHidden(self) -> bool
        
        Returns the hidden state of the parameter tuple. This can be used to
        read the result of a hide-when conditional.
        
        It is recommended that hou.Node.updateParmStates is called before
        executing this method either in non-graphical Houdini or when the
        owner node has not yet been loaded into the Parameter Pane.
        
        
        """
        pass
        
    
    def node():
        """
        node(self) -> hou.Node
        
        Return the node containing this parameter tuple.
        
        
        """
        pass
        
    
    def evalAtTime(time):
        """
        evalAtTime(self, time) -> tuple of int, float, str, or hou.Ramp
        
        Evalute the parameter tuple at a given time and return the result as
        a tuple of integers, floats, strings, or a Ramp object, depending on
        the type of the parameter.
        
        See also evalAtFrame.
        
        
        """
        pass
        
    
    def description():
        """
        description(self) -> str
        
        Return this parameter tuple's label that is displayed in the
        parameter dialog.
        
        
        """
        pass
        
    
    def evalAsGeometriesAtFrame(frame):
        """
        evalAsGeometriesAtFrame(self, frame) -> tuple of hou.Geometry
        
        Evaluates this parameter tuple at a certain frame and returns the
        result as a tuple containing a hou.Geometry object.
        
        Raises hou.TypeError if a value cannot be converted to a
        hou.Geometry.
        
        
        """
        pass
        
    
    def disable(on):
        """
        disable(self, on)
        
        Sets the UI disable state of this parameter tuple in its node. This
        is not the same as locking a parameter, as the underlying value can
        still be modified. It's closer to what a disable-when conditional
        does, when a parameter is disabled automatically by it.
        
        
        """
        pass
        
    
    def evalAsFloats():
        """
        evalAsFloats(self) -> tuple of float
        
        Evaluates this parameter tuple at the current frame and returns the
        result as a tuple of floats.
        
        Raises hou.TypeError if a value cannot be converted to a float.
        
        
        """
        pass
        
    
    def appendClip(chop_node, apply_immediately, current_value_only, create_locked, set_value_to_default):
        """
        appendClip(self, chop_node, apply_immediately, current_value_only,
        create_locked, set_value_to_default)
        
        Appends this parameter to the specified Channel CHOP.
        
        apply_immediately: If set to True, then the export flag on the
        Channel CHOP will be set.
        
        current_value_only: If set to True, then only the current value of
        the parameter will be stored.
        
        create_locked: If set to True, then the parameters are locked on
        creation.
        
        set_value_to_default: If set to True, then the parameters are
        reverted to their default values on creation
        
        
        """
        pass
        
    
    def evalAsFloatsAtFrame(frame):
        """
        evalAsFloatsAtFrame(self, frame) -> tuple of float
        
        Evaluates this parameter tuple at a certain frame and returns the
        result as a tuple of floats.
        
        Raises hou.TypeError if a value cannot be converted to a float.
        
        
        """
        pass
        
    
    def evalAsRampsAtFrame(frame):
        """
        evalAsRampsAtFrame(self, frame) -> hou.Ramp
        
        Evaluates this parameter tuple at a certain frame and returns the
        result as a tuple containing a hou.Ramp object.
        
        Raises hou.TypeError if this is not a ramp parameter.
        
        
        """
        pass
        
    
    def eval():
        """
        eval(self) -> tuple of int, float, str, or hou.Ramp
        
        Evalute this parameter tuple at the current frame and returns the
        result as a tuple of integers, floats or strings, or a hou.Ramp
        object, depending on the type of the parameter.
        
        See also the evalAtFrame and evalAtTime methods.
        
        
        """
        pass
        
    
    def _saveClip():
        """None"""
        pass
        
    
    def name():
        """
        name(self) -> str
        
        Return the name of this parameter tuple. Note that the parameter
        tuple's name and its naming scheme determine the names of the
        parameters inside it.
        
        > >>> node = hou.node("/obj").createNode("geo")
        > >>> node.parmTuple("t").parmTemplate().namingScheme()
        > parmNamingScheme.XYZW
        > >>> [parm.name() for parm in node.parmTuple("t")]
        > ['tx', 'ty', 'tz']
        >
        > >>> parm_tuple = node.parent().createNode("cam").parmTuple("dcolor")
        > >>> parm_tuple.parmTemplate().namingScheme()
        > parmNamingScheme.RGBA
        > >>> [parm.name() for parm in parm_tuple]
        > ['dcolorr', 'dcolorg', 'dcolorb']
        
        """
        pass
        
    
    def multiParmInstanceIndices():
        """None"""
        pass
        
    
    def isConstrained():
        """None"""
        pass
        
    
    def createClip(parent_node, name, create_new, apply_immediately, current_value_only, create_locked, set_value_to_default):
        """
        createClip(self, parent_node, name, create_new, apply_immediately,
        current_value_only, create_locked, set_value_to_default) -> hou.ChopNode
        
        Creates a Channel CHOP representing this parameter. The Channel CHOP
        is created with the given name as a child of the given parent node.
        The parent_node is typically created via
        hou.Node.findOrCreateMotionEffectsNetwork.
        
        create_new: Always create a new Channel CHOP. If set to False, then
        if a Channel CHOP already exists with the same name, it will be re-
        used. If the parameter already exists on the Channel CHOP, the older
        parameter will be removed first.
        
        apply_immediately: If set to True, then the export flag on the
        Channel CHOP will be set.
        
        current_value_only: If set to True, then only the current value of
        the parameter will be stored.
        
        create_locked: If set to True, then the parameters are locked on
        creation.
        
        set_value_to_default: If set to True, then the parameters are
        reverted to their default values on creation
        
        See also hou.Node.findOrCreateMotionEffectsNetwork.
        
        
        """
        pass
        
    
    def clipData(self, start=None, end=None, binary=True, use_blosc_compression=True, sample_rate=0):
        """
        clipData(start=None, end=None, binary=True, use_blosc_compression=True,
        sample_rate=0) -> str
        
        Returns the clip data for the parameters of this tuple. This method
        is similar to hou.ParmTuple.saveClip, except that it returns the
        clip data (file contents) instead of saving the animation to a clip
        file.
        
        <start>, <end>, and <sample_rate> behave the same as in
        hou.ParmTuple.saveClip.
        
        If <binary> is True, return binary clip data, otherwise return plain
        text (ASCII) clip data.
        
        If <use_blosc_compression> is True, blosc compress the binary clip
        data. This cannot be used for plain text (ASCII) clip data.
        
        Raises a hou.OperationFailed exception if none of the parameters of
        this tuple have animation.
        
        Raises a hou.InvalidInput exception if start >= end. If specifying
        only <start>, ensure that the specified value is less than the
        global end frame. Likewise, if specifying only <end>, ensure it is
        larger than the global start frame.
        
        Raises a hou.InvalidInput exception if binary = False and
        use_blosc_compression = True.
        
        """
        pass
        
    
    def revertToDefaults():
        """
        revertToDefaults(self)
        
        Changes the value back to the default(s). See also the
        revertToAndRestoreFactoryDefaults() method.
        
        
        """
        pass
        
    
    def isSpare():
        """
        isSpare(self) -> bool
        
        Returns whether the parameter is a "spare" (user-defined) parameter.
        
        
        """
        pass
        
    
    def _set():
        """None"""
        pass
        
    
    def asCode():
        """None"""
        pass
        
    
    def evalAsInts():
        """
        evalAsInts(self) -> tuple of int
        
        Evaluates this parameter tuple at the current frame and returns the
        result as a tuple of integers.
        
        Raises hou.TypeError if a value cannot be converted to an integer.
        
        
        """
        pass
        
    
    def evalAtFrame(frame):
        """
        evalAtFrame(self, frame) -> tuple of int, float, str, or hou.Ramp
        
        Evalute the parameter tuple at a given frame and return the result
        as a tuple of integers, floats, strings, or a Ramp object, depending
        on the type of the parameter.
        
        See also evalAtTime.
        
        
        """
        pass
        
    
    def loadClip(self):
        """auto-insert ocstring: HOM_ParmTuple::loadClip"""
        pass
        
    
    def revertToAndRestorePermanentDefaults():
        """
        revertToAndRestorePermanentDefaults(self)
        
        Changes the value back to the defaults that ship with Houdini, and
        restore those defaults.
        
        See also the revertToDefaults() method.
        
        
        """
        pass
        
    
    def saveClip(self, file_name, start=None, end=None, sample_rate=0):
        """
        saveClip(self, file_name, start=None, end=None, sample_rate=0)
        
        Saves the animation associated with the parameters of this tuple to
        the clip file specified by <file_name>. The extension of <file_name>
        determines the format of the saved file.
        
        You can use one of the following extensions:
        
        * .clip: save animation as plain text (ASCII) clip file.
        
        * .bclip: save animation as a bclip (binary clip) file.
        
        * .bclip.sc: save animation as a bclip file using Blosc compression.
        
        Set <sample_rate> to a non-zero, non-negative value to specify the
        sample_rate to be used for the clip file. For example, if the
        current frame rate is 24 (hou.fps), and <sample_rate> is set to 12,
        the animation will be sampled every second frame since <sample_rate>
        is half of the current frame rate.
        
        If <start> is not None, start saving the animation from the
        specified frame (inclusive). Otherwise, the animation will be saved
        from the global start frame (inclusive).
        
        Similarly, if <end> is not None, stop saving the animation at the
        specified frame (inclusive). Otherwise, the animation will be saved
        until the global end frame (inclusive).
        
        The global start and end frame are specified in the Global Animation
        Options window.
        
        Raises a hou.OperationFailed exception if none of the parameters of
        this tuple have animation.
        
        Raises a hou.OperationFailed exception if there is an error saving
        the animation to file.
        
        Raises a hou.InvalidInput exception if start >= end. If specifying
        only <start>, ensure that the specified value is less than the
        global end frame. Likewise, if specifying only <end>, ensure it is
        larger than the global start frame.
        
        """
        pass
        
    
    def helpUrl():
        """None"""
        pass
        
    
    def _asVoidPointer():
        """None"""
        pass
        

def ParmTuple_swigregister():
    """None"""
    pass
    

def Parm_swigregister():
    """None"""
    pass
    

class PathBasedPaneTab(PaneTab):
    """
    hou.PathBasedPaneTab
    
    REPLACES
    
    * bookmark
    
    * pane
    
    * mousepath()
    
    
    """
    
    def setCurrentNode(node, pick_node, =, True):
        """
        setCurrentNode(self, node, pick_node = True)
        
        
        """
        pass
        
    
    def currentNode():
        """
        currentNode(self) -> Node
        
        
        """
        pass
        
    
    def cd(path):
        """
        cd(self, path)
        
        
        """
        pass
        
    
    def pwd():
        """
        pwd(self) -> Node
        
        
        """
        pass
        
    
    def setPwd(node):
        """
        setPwd(self, node)
        
        
        """
        pass
        

def PathBasedPaneTab_swigregister():
    """None"""
    pass
    

class PerfMonEvent(object):
    """
    hou.PerfMonEvent
    
    Represents an event that is recorded by the performance monitor and used
    to generate time and memory growth statistics for profiles.
    
    Note that all methods in this class may raise an hou.OperationFailed
    exception if the event was not actually recorded in the Performance
    Monitor. This can happen if hou.perfMon.startEvent or
    hou.perfMon.startCookEvent was called when the Performance Monitor was
    not recording.
    
    
    NOTE
    The stopTime(), memory() and time() methods have been removed.
    Memory and time values are now returned by the stop() method.
    
    RELATED
    
    * hou.perfMon
    
    * hou.PerfMonProfile
    
    * hou.PerfMonRecordOptions
    
    * Performance monitor pane
    
    
    """
    
    def object():
        """
        object(self) -> str
        
        Return the object that the event applies to. Return None if the
        event is not associated with an object.
        
        
        """
        pass
        
    
    def stop():
        """
        stop(self)
        
        Stop the event timer and return a 2-tuple, (<time>, <memory>),
        containing the event's elapsed time and memory growth.
        
        The elapsed time is the number of milliseconds that the event was
        timing for. The memory growth is the increase in memory usage by
        Houdini (in bytes) from when the event started and when it stopped.
        
        If the event was not recording memory, then the returned memory
        value is 0.0. Likewise, if the event was not recording time, then
        the returned time value is 0.0.
        
        Raises hou.OperationFailed if the event is already stopped.
        
        
        """
        pass
        
    
    def isTiming():
        """
        isTiming(self) -> bool
        
        This method is deprecated in favor of isRunning.
        
        
        """
        pass
        
    
    def startTime():
        """
        startTime(self) -> float
        
        Return the start time of the event in milliseconds since the epoch
        date.
        
        Raises hou.OperationFailed if the event does not contain any time
        data. This can happen if the event was started when the Performance
        Monitor was not recording any time statistics.
        
        
        """
        pass
        
    
    def id():
        """
        id(self) -> int
        
        Return the event's unique identifier which is used internally by the
        performance monitor.
        
        This method is deprecated.
        
        
        """
        pass
        
    
    def name():
        """
        name(self) -> str
        
        Return the event name.
        
        This method is deprecated.
        
        
        """
        pass
        
    
    def isRunning():
        """
        isRunning(self) -> bool
        
        Return true if the event is running, that is, if the event has been
        started but not stopped.
        
        
        """
        pass
        
    
    def isAutoNestEnabled():
        """
        isAutoNestEnabled(self) -> bool
        
        Return True if the event will automatically 'nest' other events that
        are started and stopped while this event is running. When the event
        is stopped, it will decrement the times and memory of its nested
        events from its total time and memory. That way, the event's total
        time and memory will reflect the work performed in the event itself
        and not in any of its nested events.
        
        
        """
        pass
        

def PerfMonEvent_swigregister():
    """None"""
    pass
    

class PerfMonProfile(object):
    """
    hou.PerfMonProfile
    
    Represents a performance monitor profile.
    
    RELATED
    
    * hou.perfMon
    
    * hou.PerfMonEvent
    
    * hou.PerfMonRecordOptions
    
    * Performance monitor pane
    
    
    """
    
    def isRecordingMemoryStats():
        """None"""
        pass
        
    
    def isRecordingDrawStats():
        """
        isRecordingDrawStats(self) -> bool
        
        Return True if the profile is recording draw events and statistics.
        
        
        """
        pass
        
    
    def isRecordingGPUDrawStats():
        """
        isRecordingGPUDrawStats(self) -> bool
        
        Return True if the profile is recording GPU draw events and
        statistics.
        
        
        """
        pass
        
    
    def isRecordingViewportStats():
        """
        isRecordingViewportStats(self) -> bool
        
        Return True if the profile is recording viewport events and
        statistics.
        
        
        """
        pass
        
    
    def isRecordingErrors():
        """
        isRecordingErrors(self) -> bool
        
        Return True if the profile is recording errors.
        
        
        """
        pass
        
    
    def stop():
        """
        stop(self)
        
        Stop the profile from recording and generate statistics for the
        events that it has already recorded.
        
        Raises hou.OperatioNFailed if the profile is not active.
        
        
        """
        pass
        
    
    def isRecordingSolveStats():
        """
        isRecordingSolveStats(self) -> bool
        
        Return True if the profile is recording simulation solver events and
        statistics.
        
        
        """
        pass
        
    
    def pause():
        """
        pause(self)
        
        Pause the profile from recording events and statistics.
        
        Raises hou.OperationFailed if the profile is stopped or already
        paused.
        
        
        """
        pass
        
    
    def cancel():
        """
        cancel(self)
        
        Stop the profile from recording timed events and remove it from the
        performance monitor.
        
        Raises hou.OperationFailed if the profile is not active, that is,
        the profile is neither recording nor paused.
        
        
        """
        pass
        
    
    def isRecordingCookStats():
        """
        isRecordingCookStats(self) -> bool
        
        Return True if the profile is recording cook events and statistics.
        
        
        """
        pass
        
    
    def id():
        """
        id(self) -> int
        
        Return the profile's unique identifier which is used internally by
        the performance monitor.
        
        
        """
        pass
        
    
    def isRecordingScriptStats():
        """
        isRecordingScriptStats(self) -> bool
        
        Return True if the profile is recording script events and
        statistics.
        
        
        """
        pass
        
    
    def stats(self):
        """
        stats(self)
        
        Return the profile statistics in JSON format.
        
        Raises hou.OperationFailed if the profile is still active and has
        not generated any statistics.
        
        """
        pass
        
    
    def title():
        """
        title(self) -> str
        
        Return the profile title.
        
        
        """
        pass
        
    
    def resume():
        """
        resume(self)
        
        Unpause the profile so that it can record events and statistics.
        
        Raises hou.OperationFailed if the profile is stopped or is already
        recording (i.e. not paused).
        
        
        """
        pass
        
    
    def exportAsCSV(file_path):
        """
        exportAsCSV(self, file_path)
        
        Export the profile statistics to disk using a comma-separated (CSV)
        format. The exported .csv file can be loaded into a spreadsheet
        application such as Microsoft Excel and used to generate graphs.
        
        Raises hou.OperationFailed if the profile is still active or if the
        .csv file could not be written to disk (i.e. permission problems).
        
        
        """
        pass
        
    
    def isRecordingRenderStats():
        """
        isRecordingRenderStats(self) -> bool
        
        Return True if the profile is recording statistics related to
        rendering.
        
        
        """
        pass
        
    
    def isRecordingThreadStats():
        """
        isRecordingThreadStats(self) -> bool
        
        Return True if the profile is recording thread statistics.
        
        
        """
        pass
        
    
    def isActive():
        """
        isActive(self) -> bool
        
        Return True if the profile is either recording events or is paused.
        
        
        """
        pass
        
    
    def isPaused():
        """
        isPaused(self) -> bool
        
        Return True if the profile is paused from recording.
        
        
        """
        pass
        
    
    def isRecordingFrameStats():
        """
        isRecordingFrameStats(self) -> bool
        
        Return True if the profile is recording frame events and statistics.
        
        
        """
        pass
        
    
    def save(file_path):
        """
        save(self, file_path)
        
        Save the profile to disk.
        
        Raises hou.OperationFailed if the profile is still active or if the
        file could not be written to disk (i.e. permission problems).
        
        
        """
        pass
        
    
    def _stats():
        """None"""
        pass
        

def PerfMonProfile_swigregister():
    """None"""
    pass
    

class PerfMonRecordOptions(object):
    """
    hou.PerfMonRecordOptions
    
    Represents the set of options used by the Performance Monitor and
    specifies the type of statistics to be recorded in a profile.
    
    RELATED
    
    * hou.perfMon
    
    * hou.PerfMonProfile
    
    * Performance monitor pane
    
    
    """
    
    def recordThreadStats():
        """
        recordThreadStats(self) -> bool
        
        Return True if thread statistics should be recorded.
        
        
        """
        pass
        
    
    def setRecordCookStats(record):
        """
        setRecordCookStats(self, record)
        
        Turn the recording of cook statistics on or off.
        
        
        """
        pass
        
    
    def setRecordViewportStats(record):
        """
        setRecordViewportStats(self, record)
        
        Turn the recording of viewport statistics on or off.
        
        
        """
        pass
        
    
    def recordRenderStats():
        """
        recordRenderStats(self) -> bool
        
        Return True if Mantra render statistics should be recorded.
        
        
        """
        pass
        
    
    def recordFrameStats():
        """
        recordFrameStats(self) -> bool
        
        Return True if frame statistics should be recorded.
        
        
        """
        pass
        
    
    def recordScriptStats():
        """
        recordScriptStats(self) -> bool
        
        Return True if hscript and Python script statistics should be
        recorded.
        
        
        """
        pass
        
    
    def setRecordDrawStats(record):
        """
        setRecordDrawStats(self, record)
        
        Turn the recording of node draw statistics on or off.
        
        
        """
        pass
        
    
    def setRecordSolveStats(record):
        """
        setRecordSolveStats(self, record)
        
        Turn the recording of DOP solver statistics on or off.
        
        
        """
        pass
        
    
    def setRecordMemoryStats(record):
        """
        setRecordMemoryStats(self, record)
        
        Turn the recording of memory statistics on or off.
        
        
        """
        pass
        
    
    def setRecordErrors(record):
        """
        setRecordErrors(self, record)
        
        Turn the recording of warnings and errors on or off.
        
        
        """
        pass
        
    
    def setRecordGPUDrawStats(record):
        """
        setRecordGPUDrawStats(self, record)
        
        Turn the recording of node GPU draw statistics on or off.
        
        
        """
        pass
        
    
    def setRecordThreadStats(record):
        """
        setRecordThreadStats(self, record)
        
        Turn the recording of thread statistics on or off.
        
        
        """
        pass
        
    
    def recordDrawStats():
        """
        recordDrawStats(self) -> bool
        
        Return True if node draw statistics should be recorded.
        
        
        """
        pass
        
    
    def setRecordScriptStats(record):
        """
        setRecordScriptStats(self, record)
        
        Turn the recording of hscript and Python statistics on or off.
        
        
        """
        pass
        
    
    def setRecordRenderStats(record):
        """
        setRecordRenderStats(self, record)
        
        Turn the recording of Mantra render statistics on or off.
        
        
        """
        pass
        
    
    def recordViewportStats():
        """
        recordViewportStats(self) -> bool
        
        Return True if viewport statistics should be recorded.
        
        
        """
        pass
        
    
    def setRecordFrameStats(record):
        """
        setRecordFrameStats(self, record)
        
        Turn the recording of frame statistics on or off.
        
        
        """
        pass
        
    
    def recordErrors():
        """
        recordErrors(self) -> bool
        
        Return True if warnings and errors should be recorded.
        
        
        """
        pass
        
    
    def recordSolveStats():
        """
        recordSolveStats(self) -> bool
        
        Return True if DOP solver statistics should be recorded.
        
        
        """
        pass
        
    
    def recordMemoryStats():
        """
        recordMemoryStats(self) -> bool
        
        Return True if memory statistics should be recorded.
        
        
        """
        pass
        
    
    def recordCookStats():
        """
        recordCookStats(self) -> bool
        
        Return True if cook statistics should be recorded.
        
        
        """
        pass
        
    
    def recordGPUDrawStats():
        """
        recordGPUDrawStats(self) -> bool
        
        Return True if node GPU draw statistics should be recorded.
        
        
        """
        pass
        

def PerfMonRecordOptions_swigregister():
    """None"""
    pass
    

class PerformanceMonitor(PaneTab):
    """
    hou.PerformanceMonitor
    
    Represents a Performance Monitor panetab.
    
    REPLACES
    
    * performance
    
    
    """
    
    def isRecording():
        """
        isRecording(self) -> bool
        
        Return whether the performance monitor is recording.
        
        
        """
        pass
        
    
    def stopRecording():
        """
        stopRecording(self)
        
        Stop recording in the performance monitor.
        
        Raises hou.OperationFailed if the performance monitor is already
        stopped.
        
        
        """
        pass
        
    
    def sampleObjectGPUDrawStats(on):
        """
        sampleObjectGPUDrawStats(self, on)
        
        Turn sampling of object GPU drawing statistics on or off.
        
        
        """
        pass
        
    
    def isSamplingViewportStats():
        """
        isSamplingViewportStats(self) -> bool
        
        Return whether the sampling of viewport statistics is turned on.
        
        
        """
        pass
        
    
    def objectView():
        """
        objectView(self) -> hou.perfMonObjectView enum value
        
        Return the structure type that is used to view objects in the
        statistics viewer.
        
        
        """
        pass
        
    
    def isSamplingCookStats():
        """
        isSamplingCookStats(self) -> bool
        
        Return whether the sampling of cook statistics is turned on.
        
        
        """
        pass
        
    
    def enableLiveUpdates(on):
        """
        enableLiveUpdates(self, on)
        
        Enable or disable live updates for recordings. If live updates is
        enabled, then statistics are displayed in the statistics viewer and
        are periodically updated while the performance monitor is recording.
        
        
        """
        pass
        
    
    def sampleCookStats(on):
        """
        sampleCookStats(self, on)
        
        Turn sampling of cook statistics on or off.
        
        
        """
        pass
        
    
    def sampleScriptStats(on):
        """
        sampleScriptStats(self, on)
        
        Turn sampling of script statistics on or off.
        
        
        """
        pass
        
    
    def sampleErrors(on):
        """
        sampleErrors(self, on)
        
        Turn sampling of warnings and errors on or off.
        
        
        """
        pass
        
    
    def sampleMemoryStats():
        """None"""
        pass
        
    
    def isSamplingThreadStats():
        """
        isSamplingThreadStats(self) -> bool
        
        Return whether the sampling of thread statistics is turned on.
        
        
        """
        pass
        
    
    def isSamplingFrameStats():
        """
        isSamplingFrameStats(self) -> bool
        
        Return whether the sampling of frame statistics is turned on.
        
        
        """
        pass
        
    
    def isSamplingErrors():
        """
        isSamplingErrors(self) -> bool
        
        Return whether the sampling of warnings and errors is turned on.
        
        
        """
        pass
        
    
    def setObjectView(view):
        """
        setObjectView(self, view)
        
        Set the structure type to use when viewing objects in the statistics
        viewer.
        
        
        """
        pass
        
    
    def sampleThreadStats(on):
        """
        sampleThreadStats(self, on)
        
        Turn sampling of thread statistics on or off. Note that turning on
        thread sampling can add overhead to the processing times (i.e. cook
        times, solve times, etc.) in the scene.
        
        
        """
        pass
        
    
    def isSamplingObjectGPUDrawStats():
        """
        isSamplingObjectGPUDrawStats(self) -> bool
        
        Return whether the sampling of object GPU drawing statistics is
        turned on.
        
        
        """
        pass
        
    
    def sampleViewportStats(on):
        """
        sampleViewportStats(self, on)
        
        Turn sampling of object-drawing statistics on or off.
        
        
        """
        pass
        
    
    def sampleFrameStats(on):
        """
        sampleFrameStats(self, on)
        
        Turn sampling of frame statistics on or off.
        
        
        """
        pass
        
    
    def sampleSolveStats(on):
        """
        sampleSolveStats(self, on)
        
        Turn sampling of DOP solve statistics on or off.
        
        
        """
        pass
        
    
    def startRecording():
        """
        startRecording(self)
        
        Start recording in the performance monitor.
        
        Raises hou.OperationFailed if the performance monitor is already
        recording.
        
        
        """
        pass
        
    
    def timeFormat():
        """
        timeFormat(self) -> hou.perfMonTimeFormat enum value
        
        Return the format that is used to view times in the statistics
        viewer.
        
        
        """
        pass
        
    
    def isSamplingMemoryStats():
        """None"""
        pass
        
    
    def isSamplingScriptStats():
        """
        isSamplingScriptStats(self) -> bool
        
        Return whether the sampling of script statistics is turned on.
        
        
        """
        pass
        
    
    def isLiveUpdatesEnabled():
        """
        isLiveUpdatesEnabled(self) -> bool
        
        Return whether live updates is enabled.
        
        
        """
        pass
        
    
    def isSamplingObjectDrawStats():
        """
        isSamplingObjectDrawStats(self) -> bool
        
        Return whether the sampling of object drawing statistics is turned
        on.
        
        
        """
        pass
        
    
    def isSamplingSolveStats():
        """
        isSamplingSolveStats(self) -> bool
        
        Return whether the sampling of DOP solve statistics is turned on.
        
        
        """
        pass
        
    
    def sampleObjectDrawStats(on):
        """
        sampleObjectDrawStats(self, on)
        
        Turn sampling of object drawing statistics on or off.
        
        
        """
        pass
        
    
    def setTimeFormat(format):
        """
        setTimeFormat(self, format)
        
        Set the format to use when viewing times in the statistics viewer.
        
        
        """
        pass
        

def PerformanceMonitor_swigregister():
    """None"""
    pass
    

class PermissionError(Error):
    """
    hou.PermissionError
    
    """
    
    def description():
        """
        description(self) -> str
        
        Return a description of the class of exception. The description is
        not related to the exception instance.
        
        
        """
        pass
        
    
    def exceptionTypeName():
        """
        exceptionTypeName(self) -> str
        
        Return the name of the exception type. Instances of different
        subclasses of hou.Error will return different names. Instances of
        the base class will return "Error".
        
        You can also use str(e.__class__) to get the name of the subclass.
        
        
        """
        pass
        
    
    def instanceMessage():
        """
        instanceMessage(self) -> str
        
        Return a message specific to the exception instance.
        
        
        """
        pass
        

def PermissionError_swigregister():
    """None"""
    pass
    

class Point(object):
    """
    hou.Point
    
    Represents a point on a geometry primitive, such as a polygon or NURBS
    surface.
    
    Each Point object resides inside a Geometry object and stores a 3D
    position. Points may be shared between primitives (such as polygons),
    and the set of points and primitives describes a 3D shape.
    
    Each point can store arbitrary values in named attributes.
    
    
    """
    
    def weight():
        """
        weight(self) -> float
        
        Return the weight of this point. Point weights are displayed in
        Houdini's geometry spreadsheet as the fourth component of the
        position. Point weights are used by NURBS.
        
        Usually, the weight is 1.0.
        
        This method is a shortcut for accessing the Pw attribute of the
        point.
        
        > point.weight()
        > # is equivalent to
        > point.attribValue("Pw")
        
        You can build a hou.Vector4 containing both the position and weight:
        
        > hou.Vector4(tuple(point.position()) + (point.weight(),))
        
        See also hou.Point.position.
        
        
        """
        pass
        
    
    def stringListAttribValue(name_or_attrib):
        """
        stringListAttribValue(self, name_or_attrib) -> tuple of str
        
        Return the point attribute value for a particular string attribute.
        The attribute may be specified by name or by hou.Attrib object. The
        return value is a tuple of strings.
        
        It is valid to call this method when the attribute's size is 1. In
        this case, a tuple with one element is returned. See
        hou.Point.floatAttribValue for more information.
        
        
        """
        pass
        
    
    def number():
        """
        number(self) -> int
        
        Returns the point number of this point. Points are numbered
        sequentially across the entire Geometry starting from 0, and the
        points returned by hou.Geometry.points are in point number order.
        
        
        """
        pass
        
    
    def intAttribValue(name_or_attrib):
        """
        intAttribValue(self, name_or_attrib) -> int
        
        Return the point attribute value for a particular integer attribute
        of size 1. The attribute may be specified by name or by hou.Attrib
        object. See hou.Point.floatAttribValue for more information.
        
        
        """
        pass
        
    
    def setAttribValue(name_or_attrib, attrib_value):
        """
        setAttribValue(self, name_or_attrib, attrib_value)
        
        Store an attribute value in this point. The attribute may be
        specified by name or by hou.Attrib object, and must be an existing
        point attribute in the geometry. You would typically call this
        method from the code of a Python-defined SOP.
        
        Raises hou.OperationFailed if no attribute exists with this name or
        if the attribute's data type does not match the value passed in. If
        the attribute's size is more than 1, the attribute value must be a
        sequence of integers/floats, and the size of the sequence must match
        the attribute's size.
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable.
        
        See hou.Geometry.addAttrib for an example.
        
        See also:
        
        * hou.Prim.setAttribValue
        
        * hou.Vertex.setAttribValue
        
        * hou.Geometry.setGlobalAttribValue
        
        
        """
        pass
        
    
    def stringAttribValue(name_or_attrib):
        """
        stringAttribValue(self, name_or_attrib) -> str
        
        Return the point attribute value for a particular string attribute.
        The attribute may be specified by name or by hou.Attrib object. See
        hou.Point.floatAttribValue for more information.
        
        
        """
        pass
        
    
    def setPosition(position):
        """
        setPosition(self, position)
        
        Changes the point's location. You would typically call this method
        from the code of a Python-defined SOP.
        
        position is any sequence of floats, such has a hou.Vector3 or a
        tuple or list of floats, of length 3 or 4. The fourth coordinate
        corresponds to the weight, and is usually 1. The weight is typically
        used by NURBS curves and sequences. If the sequence is of size 3,
        the weight will be unchanged.
        
        This method is a shortcut for calling hou.Point.setAttribValue on
        the P attribute.
        
        > point.setPosition((x, y, z))
        > # is the same as
        > point.setAttribValue("P", (x, y, z))
        
        Raises hou.GeometryPermissionError if the geometry is not
        modifiable. Raises hou.InvalidSize if the length of position is not
        3 or 4.
        
        
        """
        pass
        
    
    def floatListAttribValue(name_or_attrib):
        """
        floatListAttribValue(self, name_or_attrib) -> tuple of float
        
        Return the point attribute value for a particular floating point
        attribute. The attribute may be specified by name or by hou.Attrib
        object. The return value is a tuple of floats.
        
        It is valid to call this method when the attribute's size is 1. In
        this case, a tuple with one element is returned.
        
        See also hou.Point.attribValue.
        
        
        """
        pass
        
    
    def intListAttribValue(name_or_attrib):
        """
        intListAttribValue(self, name_or_attrib) -> tuple of int
        
        Return the point attribute value for a particular integer attribute.
        The attribute may be specified by name or by hou.Attrib object. The
        return value is a tuple of ints. See hou.Point.floatListAttribValue
        for more information.
        
        
        """
        pass
        
    
    def setWeight(weight):
        """
        setWeight(self, weight)
        
        Change the point's weight. You would typically call this method from
        the code of a Python-defined SOP.
        
        This method is a shortcut for calling hou.Point.setAttribValue on
        the Pw attribute.
        
        See hou.Point.weight for more information about a point's weight.
        See also hou.Point.setPosition.
        
        
        """
        pass
        
    
    def vertices():
        """
        vertices(self) -> tuple of hou.Vertex
        
        Returns a tuple of the vertices that reference this point.
        
        This requires a search through a primitive's vertices, so the cost
        grows with the total number of vertices across this point's
        primitives.
        
        
        """
        pass
        
    
    def floatAttribValue(name_or_attrib):
        """
        floatAttribValue(self, name_or_attrib) -> float
        
        Return the point attribute value for a particular floating point
        attribute. The attribute may be specified by name or by hou.Attrib
        object.
        
        Raises hou.OperationFailed if no attribute exists with this name or
        the attribute is not float of size 1.
        
        In most cases, you'll just use hou.Point.attribValue to access
        attribute values. Houdini uses this method internally to implement
        attribValue.
        
        
        """
        pass
        
    
    def geometry():
        """
        geometry(self) -> hou.Geometry
        
        Returns the hou.Geometry object containing this point.
        
        
        """
        pass
        
    
    def attribValue(name_or_attrib):
        """
        attribValue(self, name_or_attrib) -> int, float, str, or tuple
        
        Return value stored in this point for a particular attribute. The
        attribute may be specified by name or by hou.Attrib object.
        
        Looking up an attribute value using a hou.Attrib object is slightly
        faster than looking it up by name. When looking up attribute values
        inside a loop, look up the hou.Attrib object outside the loop, and
        pass it into this method.
        
        Note that the point position attribute is named P and is 4 floats in
        size. This attribute always exists.
        
        When looking up the attribute values of all points, it is faster to
        call hou.Geometry.pointFloatAttribValues or
        hou.Geometry.pointFloatAttribValuesAsString than to call this method
        for each point in the geometry.
        
        Raises hou.OperationFailed if no attribute exists with this name.
        
        > # Create an object containing two SOPs: a box SOP wired into a color SOP.
        > geo_node = hou.node("/obj").createNode("geo")
        > box = geo_node.createNode("box")
        > color = geo_node.createNode("color")
        > color.setFirstInput(box)
        >
        > # Grab the color SOP's geometry, get its first point, and print out the
        > # value of the Cd attribute.
        > geo = color.geometry()
        > point = geo.iterPoints()[0]
        > print point.attribValue("Cd")
        >
        > # Look up the Cd attribute and illustrate how to access the attribute
        > # value using the attribute object.
        > cd_attribute = geo.findPointAttrib("Cd")
        > print point.attribValue(cd_attribute)
        
        """
        pass
        
    
    def attribType():
        """
        attribType(self) -> hou.attribType enum value
        
        Always returns hou.attribType.Point.
        
        This is only useful if you want to write generic code that works
        whether the input objects are hou.Prim, hou.Point, or hou.Vertex.
        They all have an attribType() method that returns the right
        attribType value for the given object.
        
        
        """
        pass
        
    
    def prims():
        """
        prims(self) -> tuple of hou.Prim
        
        Returns a tuple of the primitives that reference this point.
        
        
        """
        pass
        
    
    def position():
        """
        position(self) -> hou.Vector3
        
        Return the position of this point as a hou.Vector3 containing the
        (X, Y, Z) values.
        
        You can transform the Vector3 using a hou.Matrix4:
        
        > xform = hou.node("/obj/geo1").worldTransform()  # Matrix4
        > new_pos = point.position() * xform
        
        This method is a shortcut for accessing the P attribute of the
        point. However, it is not equivalent, because point.attribValue("P")
        returns a 3-tuple of floats, not a Vector3 object:
        
        > point.position()
        > # is equivalent to
        > hou.Vector3(point.attribValue("P"))
        
        """
        pass
        

class PointGroup(object):
    """
    hou.PointGroup
    
    A named group of points inside a Geometry object.
    
    Point groups reside inside the geometry, and each point group has a
    unique name.
    
    Groups are either ordered or unordered. When asking for the contents of
    an ordered group, the results will be returned in the order they were
    added to to the group. For an unordered group, the results will be
    returned in an arbitrary order (though it is normally arranged by
    increasing point number). When creating a group using the group SOP, use
    the <Create Ordered> checkbox to create an ordered group. When creating
    one from Python, Use the is_ordered parameter of
    hou.Geometry.createPointGroup to control whether a group is ordered.
    
    See hou.Point for more information about points. See also hou.PrimGroup.
    
    REPLACES
    
    * haspoint()
    
    * pointlist()
    
    
    """
    
    def optionType(name):
        """
        optionType(self, name) -> hou.fieldType enum value
        
        Return a hou.fieldType enumerated value that describes the type of
        data stored in an option. Returns hou.fieldType.NoSuchField if no
        field exists with that name.
        
        
        """
        pass
        
    
    def option():
        """None"""
        pass
        
    
    def removeOption(name):
        """
        removeOption(self, name)
        
        Remove an entry in the dictionary of options. See
        hou.PointGroup.options for more information.
        
        Raises hou.OperationFailed if there is no entry in the dictionary
        with this name.
        
        
        """
        pass
        
    
    def isOrdered():
        """None"""
        pass
        
    
    def clear():
        """
        clear(self)
        
        Remove all points from this group. You would typically call this
        method from the code of a Python-defined SOP.
        
        The points remain in the geometry; only the group is affected.
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable.
        
        
        """
        pass
        
    
    def name():
        """
        name(self)
        
        Return the name of the group. Each point group has a unique name.
        
        
        """
        pass
        
    
    def geometry():
        """
        geometry(self) -> hou.Geometry
        
        Return the geometry object containing this group.
        
        
        """
        pass
        
    
    def setOption(name, value, type_hint, =, hou.fieldType::NoSuchField):
        """
        setOption(self, name, value, type_hint = hou.fieldType::NoSuchField)
        
        Set an entry in the dictionary of options. See
        hou.PointGroup.options for more information.
        
        
        name
        The name of the option to set.
        
        value
        An integer, float, string, hou.Vector2, hou.Vector3,
        hou.Vector4, hou.Quaternion, hou.Matrix3, hou.matrix4, or
        sequence of numbers.
        
        type_hint
        Used to determine the exact hou.fieldType desired when the
        specified value type is not enough to unambiguously determine
        it.
        
        
        """
        pass
        
    
    def contains(point):
        """
        contains(self, point) -> bool
        
        Return whether or not a point is in this group.
        
        Raises hou.OperationFailed if the point belongs to a different
        geometry object than this group.
        
        
        """
        pass
        
    
    def remove(point_or_list_or_point_group):
        """
        remove(self, point_or_list_or_point_group)
        
        If given a hou.Point or a list of hou.Point's, remove the point from
        the group. If given a hou.PointGroup, remove all points in the other
        group from this group (the other group is unaffected). You would
        typically call this method from the code of a Python-defined SOP.
        
        It is not an error to try to remove a point from the group that
        wasn't already in the group.
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable.
        
        Raises hou.OperationFailed if the point belongs to a different
        geometry object than this group.
        
        
        """
        pass
        
    
    def options(name):
        """
        option(self, name) -> bool, int, float, str, hou.Vector2, , hou.Vector4,
        hou.Quaternion, hou.Matrix3, hou.Matrix4, tuple of int, or tuple of
        float
        
        Return the value of an individual option, on None if no such option
        exists.
        
        See also hou.PointGroup.options, hou.PointGroup.setOption and
        hou.PointGroup.removeOption.
        
        
        """
        pass
        
    
    def add(point_or_list_or_point_group):
        """
        add(self, point_or_list_or_point_group)
        
        If given a hou.Point or a list of hou.Point's, add the point(s) to
        the group. If given a hou.PointGroup, merge the contents of the
        other point group with this group (the other group is unaffected).
        You would typically call this method from the code of a Python-
        defined SOP.
        
        It is ok to add points to the group that were already in the group.
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable.
        
        Raises hou.OperationFailed if the point or point group belong to a
        different geometry object than this group.
        
        
        """
        pass
        
    
    def points():
        """
        points(self) -> tuple of hou.Point
        
        Return the contents of this group.
        
        
        """
        pass
        
    
    def destroy():
        """
        destroy(self)
        
        Remove this group from the geometry. You would typically call this
        method from the code of a Python-defined SOP.
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable.
        
        
        """
        pass
        

def PointGroup_swigregister():
    """None"""
    pass
    

def Point_swigregister():
    """None"""
    pass
    

class Polygon(Face):
    """
    hou.Polygon
    
    A Polygon is a kind of Face whose vertices are connected via straight
    lines.
    
    Currently, hou.Face, and its base class hou.Prim contain all the
    necessary methods for polygon inspection and manipulation.
    
    
    """

def Polygon_swigregister():
    """None"""
    pass
    

class PopNetNode(Node):
    """
    hou.PopNetNode
    
    """
    
    def renderNode():
        """
        renderNode(self) -> Node
        
        
        """
        pass
        
    
    def displayNode():
        """
        displayNode(self) -> Node
        
        
        """
        pass
        

def PopNetNode_swigregister():
    """None"""
    pass
    

class PopNode(Node):
    """
    hou.PopNode
    
    Represents a particle node.
    
    REPLACES
    
    * opget
    
    * opset
    
    * opflag()
    
    * popevent()
    
    * popeventtime()
    
    * poppoint()
    
    * poppointid()
    
    * poppointnum()
    
    
    """
    
    def curPoint():
        """
        curPoint(self) -> hou.Point
        
        Returns the current point, equivalent to the $PT local variable.
        This function only works on a node that has a $PT local variable,
        and only when the node is being cooked.
        
        
        """
        pass
        
    
    def isBypassed():
        """
        isBypassed(self) -> bool
        
        Returns whether this node's bypass flag is on.
        
        
        """
        pass
        
    
    def setRenderFlag(on):
        """
        setRenderFlag(self, on)
        
        Turns this node's render flag on or off.
        
        
        """
        pass
        
    
    def setDisplayFlag(on):
        """
        setDisplayFlag(self, on)
        
        Turn this node's display flag on or off.
        
        
        """
        pass
        
    
    def isRenderFlagSet():
        """
        isRenderFlagSet(self) -> bool
        
        Returns whether this node's render flag is on.
        
        
        """
        pass
        
    
    def isDisplayFlagSet():
        """
        isDisplayFlagSet(self) -> bool
        
        Returns whether this node's display flag is on.
        
        
        """
        pass
        
    
    def renderNode():
        """
        renderNode(self) -> Node
        
        
        """
        pass
        
    
    def setTemplateFlag(on):
        """
        setTemplateFlag(self, on)
        
        Sets this node's template flag on or off.
        
        
        """
        pass
        
    
    def bypass(on):
        """
        bypass(self, on)
        
        Turns this node's bypass flag on or off, making this node have no
        effect.
        
        
        """
        pass
        
    
    def isTemplateFlagSet():
        """
        isTemplateFlagSet(self) -> bool
        
        Returns whether the template flag on this node is on.
        
        
        """
        pass
        
    
    def displayNode():
        """
        displayNode(self) -> Node
        
        
        """
        pass
        

def PopNode_swigregister():
    """None"""
    pass
    

class Prim(object):
    """
    hou.Prim
    
    Each Prim resides inside a Geometry object and stores some sort of 3D
    geometric primitive, like a polygon, a NURBS curve, or a volume. Each
    primitive usually contains a set of Vertex objects, each of which
    references a Point object.
    
    This class has a number of subclasses for the different primitive types,
    such as hou.Polygon and hou.Volume.
    
    
    """
    
    def stringAttribValue(name_or_attrib):
        """
        stringAttribValue(self, name_or_attrib) -> str
        
        Return the primitive attribute value for a particular string
        attribute. The attribute may be specified by name or by hou.Attrib
        object. See hou.Prim.floatAttribValue for more information.
        
        
        """
        pass
        
    
    def number():
        """
        number(self) -> int
        
        Return the number of this primitive. Primitives are numbered
        sequentially starting from 0, and the primitives returned by
        hou.Geometry.prims are in order by their number.
        
        
        """
        pass
        
    
    def numEdges():
        """None"""
        pass
        
    
    def setIntrinsicValue(intrinsic_name, value):
        """
        setIntrinsicValue(self, intrinsic_name, value)
        
        Some "intrinsic" values can be modified. For example, you change the
        internal size and rotation (transform) of a sphere primitive by
        passing a 9 float tuple representing the transform to
        hou.Prim.setIntrinsicValue. Raises hou.OperationFailed if the
        intrinsic is not writeable or does not accept the passed value, or
        if the given intrinsic name does not exist.
        
        
        """
        pass
        
    
    def intAttribValue(name_or_attrib):
        """
        intAttribValue(self, name_or_attrib) -> int
        
        Return the primitive attribute value for a particular integer
        attribute of size 1. The attribute may be specified by name or by
        hou.Attrib object. See hou.Point.floatAttribValue for more
        information.
        
        
        """
        pass
        
    
    def intrinsicValue(intrinsic_name):
        """
        intrinsicValue(self, intrinsic_name) -> int, float, str, or tuple
        
        Gets the value of an "intrinsic", often computed, value of the
        primitive, such as bounds, measuredarea, vertexcount, and so on.
        
        Most intrinsic values are computed, such as measuredarea, however a
        few are writeable with hou.Prim.setIntrinsicValue. For example,
        sphere primitives have a transform matrix as part of their
        definition.
        
        You can also view these values in the user interface using the
        geometry spreadsheet.
        
        Raises hou.OperationFailed if the given intrinsic name does not
        exist. You can get a list of the available intrinsic value names
        with hou.Prim.intrinsicNames. Different primitive types will have
        different intrinsic values available.
        
        
        """
        pass
        
    
    def stringListAttribValue(name_or_attrib):
        """
        stringListAttribValue(self, name_or_attrib) -> tuple of str
        
        Return the primitive attribute value for a particular string
        attribute. The attribute may be specified by name or by hou.Attrib
        object. The return value is a tuple of strings.
        
        It is valid to call this method when the attribute's size is 1. In
        this case, a tuple with one element is returned.
        
        See also hou.Prim.attribValue.
        
        
        """
        pass
        
    
    def numVertices():
        """
        numVertices(self) -> int
        
        A shortcut for len(self.vertices()). You probably don't need to call
        this method.
        
        
        """
        pass
        
    
    def intrinsicSize(intrinsic_name):
        """
        intrinsicSize(self, intrinsic_name) -> int
        
        Returns the intrinsic value's tuple size.
        
        
        """
        pass
        
    
    def intListAttribValue(name_or_attrib):
        """
        intListAttribValue(self, name_or_attrib) -> tuple of int
        
        Return the primitive attribute value for a particular integer
        attribute. The attribute may be specified by name or by hou.Attrib
        object. The return value is a tuple of ints. See
        hou.Prim.floatListAttribValue for more information.
        
        
        """
        pass
        
    
    def nearestToPosition(pos3):
        """
        nearestToPosition(self, pos3)
        
        Given a sequence of three floats containing a position, find the
        location on this primitive that is closest to that position. Returns
        a tuple containing the u value on this primitive, the v value on
        this primitive, and the distance to this primitive.
        
        
        """
        pass
        
    
    def attribValue(name_or_attrib):
        """
        attribValue(self, name_or_attrib) -> int, float, str or tuple
        
        Return the value stored in this primitive for a particular
        attribute. The attribute may be specified by name or by hou.Attrib
        object.
        
        Looking an attribute value using a hou.Attrib object is slightly
        faster than looking it up by name. When looking up attribute values
        inside a loop, look up the hou.Attrib object outside the loop, and
        pass it into this method.
        
        When looking up the attribute values of all primitives, it is faster
        to call hou.Geometry.primFloatAttribValues or
        hou.Geometry.primFloatAttribValuesAsString than to call this method
        for each primitive in the geometry.
        
        Raises hou.OperationFailed if no attribute exists with this name.
        
        
        """
        pass
        
    
    def intrinsicValueDict(self):
        """
        intrinsicValueDict(self) -> dict of str to value
        
        Returns a dictionary mapping intrinsic names to their values.
        
        """
        pass
        
    
    def type():
        """
        type(self) -> hou.primType enum value
        
        Return a hou.primType value containing the type of this primitive
        (e.g. polygon, NURBS curve, metaball, etc).
        
        
        """
        pass
        
    
    def intrinsicNames():
        """
        intrinsicNames(self) -> tuple of str
        
        Returns a tuple of strings representing the intrinsic values
        available for this primitive. Different primitive types will have
        different intrinsic values available. You can then get or set the
        value using hou.Prim.intrinsicValue and/or
        hou.Prim.setIntrinsicValue.
        
        
        """
        pass
        
    
    def attribValueAtInterior(attrib_or_name, u, v, w=0.0):
        """
        attribValueAtInterior(self, attrib_or_name, u, v, w=0.0) -> int, float,
        str or tuple
        
        Return an attribute value at the normalized u, v, w parametric
        position in the interior of the primitive.
        
        Raises hou.OperationFailed if the attribute is not a point or vertex
        attribute. If you want a primitive attribute value, it doesn't vary
        across the surface, so use hou.Prim.attribValue.
        
        Use hou.Face.attribValueAt for querying attributes along the
        perimeter.
        
        
        """
        pass
        
    
    def setAttribValue(name_or_attrib, attrib_value):
        """
        setAttribValue(self, name_or_attrib, attrib_value)
        
        Store an attribute value in this primitive. The attribute may be
        specified by name or by hou.Attrib object, and must be an existing
        primitive attribute in the geometry. You would typically call this
        method from the code of a Python-defined SOP.
        
        Raises hou.OperationFailed if no attribute exists with this name or
        if the attribute's data type does not match the value passed in. If
        the attribute's size is more than 1, the attribute value must be a
        sequence of integers/floats, and the size of the sequence must match
        the attribute's size.
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable.
        
        > # Create a float primitive attribute of size 3 named "Cd", and assign
        > # each primitive a unique color.  This code will work from inside a Python
        > # SOP, but not from the Python shell.
        > geo = hou.pwd().geometry()
        > color_attrib = geo.addAttrib(hou.attribType.Prim, "Cd", (1.0, 1.0, 1.0))
        > num_prims = len(geo.prims())
        > color = hou.Color()
        > for prim in geo.prims():
        >     fraction = float(prim.number()) / num_prims
        >     # Give each primitive a different hue, but full saturation and value.
        >     # Store the RGB value in the attribute.
        >     color.setHSV((fraction * 255, 1, 1))
        >     prim.setAttribValue(color_attrib, color.rgb())
        
        """
        pass
        
    
    def edges():
        """None"""
        pass
        
    
    def groups():
        """
        groups(self) -> tuple of hou.PrimGroup
        
        Return a tuple of the primitive groups that contain this primitive.
        
        
        """
        pass
        
    
    def boundingBox():
        """
        boundingBox(self) -> hou.BoundingBox
        
        Return an axis-aligned 3D bounding box that is sized and positioned
        to be large enough to hold this primitive.
        
        
        """
        pass
        
    
    def floatListAttribValue(name_or_attrib):
        """
        floatListAttribValue(self, name_or_attrib) -> tuple of float
        
        Return the primitive attribute value for a particular floating point
        attribute. The attribute may be specified by name or by hou.Attrib
        object. The return value is a tuple of floats.
        
        It is valid to call this method when the attribute's size is 1. In
        this case, a tuple with one element is returned.
        
        See also hou.Prim.attribValue.
        
        
        """
        pass
        
    
    def attribType():
        """
        attribType(self) -> hou.attribType enum value
        
        Return the enumerated value hou.attribType.Prim. Points, primitives,
        vertices, and geometry support the same set of methods for querying
        their attributes, and this method is one of them.
        
        See also:
        
        * hou.Point.attribType
        
        * hou.Vertex.attribType
        
        * hou.Geometry.attribType
        
        * hou.attribType
        
        
        """
        pass
        
    
    def positionAtInterior(u, v, w=0.0):
        """
        positionAtInterior(self, u, v, w=0.0) -> hou.Vector3
        
        Given normalized (i.e. from 0 to 1) u, v, w values, return the
        interior position of the primitive at that parametric location.
        
        Use hou.Face.positionAt for querying positions along the perimeter.
        
        
        """
        pass
        
    
    def geometry():
        """
        geometry(self) -> hou.Geometry
        
        Return the hou.Geometry object containing this primitive.
        
        
        """
        pass
        
    
    def vertices():
        """
        vertices(self) -> generator of hou.Vertex
        
        Return a sequence of the vertices contained in this primitive.
        
        If the primitive is a face (e.g. a polygon or NURBS curve), the
        result corresponds to the order of the vertices in that face. If it
        is a surface (e.g. a NURBS mesh), however, the primitive has a 2D
        array of vertices, and this method returns all vertices in the 2D
        array, ordered by the rows.
        
        See hou.Surface.vertex for more information about the relationship
        between the 2D vertex array and the sequential vertex index, and for
        more ways to access the vertices in a surface.
        
        
        """
        pass
        
    
    def intrinsicReadOnly(intrinsic_name):
        """
        intrinsicReadOnly(self, intrinsic_name) -> bool
        
        Returns whether the intrinsic is read-only or can be modified with
        hou.Prim.setIntrinsicValue.
        
        
        """
        pass
        
    
    def points(self):
        """
        points(self) -> list of hou.Point
        
        Shortcut for getting all the points of a primitive without iterating
        through each vertex.
        
        """
        pass
        
    
    def floatAttribValue(attrib):
        """
        floatAttribValue(self, attrib) -> float
        
        Return the primitive attribute value for a particular floating point
        attribute. The attribute may be specified by name or by hou.Attrib
        object.
        
        Raises hou.OperationFailed if no attribute exists with this name or
        the attribute is not float of size 1.
        
        In most cases, you'll just use hou.Prim.attribValue to access
        attribute values. Houdini uses this method internally to implement
        attribValue.
        
        
        """
        pass
        

class PrimGroup(object):
    """
    hou.PrimGroup
    
    A named group of primitives inside a Geometry object.
    
    Primitive groups reside inside the geometry, and each primitive group
    has a unique name.
    
    Groups are either ordered or unordered. When asking for the contents of
    an ordered group, the results will be returned in the order they were
    added to to the group. For an unordered group, the results will be
    returned in an arbitrary order (though it is normally arranged by
    increasing primitive number). When creating a group using the group SOP,
    use the <Create Ordered> checkbox to create an ordered group. When
    creating one from Python, Use the is_ordered parameter of
    hou.Geometry.createPrimGroup to control whether a group is ordered.
    
    See hou.Prim for more information about primitives. See also
    hou.PrimGroup.
    
    REPLACES
    
    * hasprim()
    
    * primlist()
    
    
    """
    
    def optionType(name):
        """
        optionType(self, name) -> hou.fieldType enum value
        
        Return a hou.fieldType enumerated value that describes the type of
        data stored in an option. Returns hou.fieldType.NoSuchField if no
        field exists with that name.
        
        
        """
        pass
        
    
    def option():
        """None"""
        pass
        
    
    def removeOption(name):
        """
        removeOption(self, name)
        
        Remove an entry in the dictionary of options. See
        hou.PrimGroup.options for more information.
        
        Raises hou.OperationFailed if there is no entry in the dictionary
        with this name.
        
        
        """
        pass
        
    
    def isOrdered():
        """None"""
        pass
        
    
    def clear():
        """
        clear(self)
        
        Remove all primitives from this group. You would typically call this
        method from the code of a Python-defined SOP.
        
        The primitives remain in the geometry; only the group is affected.
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable.
        
        
        """
        pass
        
    
    def name():
        """
        name(self)
        
        Return the name of the group. Each primitive group has a unique
        name.
        
        
        """
        pass
        
    
    def geometry():
        """
        geometry(self) -> hou.Geometry
        
        Return the geometry object containing this group.
        
        
        """
        pass
        
    
    def setOption(name, value, type_hint, =, hou.fieldType::NoSuchField):
        """
        setOption(self, name, value, type_hint = hou.fieldType::NoSuchField)
        
        Set an entry in the dictionary of options. See hou.PrimGroup.options
        for more information.
        
        
        name
        The name of the option to set.
        
        value
        An integer, float, string, hou.Vector2, hou.Vector3,
        hou.Vector4, hou.Quaternion, hou.Matrix3, hou.Matrix4, or
        sequence of numbers.
        
        type_hint
        Used to determine the exact hou.fieldType desired when the
        specified value type is not enough to unambiguously determine
        it.
        
        
        """
        pass
        
    
    def contains(prim):
        """
        contains(self, prim) -> bool
        
        Return whether or not a primitive is in this group.
        
        Raises hou.OperationFailed if the primitive belongs to a different
        geometry object than this group.
        
        
        """
        pass
        
    
    def remove(prim_or_list_or_prim_group):
        """
        remove(self, prim_or_list_or_prim_group)
        
        If given a hou.Prim or a list of hou.Prim's, remove the primitive(s)
        from the group. If given a hou.PrimGroup, remove all primitives in
        the other group from this group (the other group is unaffected). You
        would typically call this method from the code of a Python-defined
        SOP.
        
        It is not an error to try to remove a primitive from the group that
        wasn't already in the group.
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable.
        
        Raises hou.OperationFailed if the primitive belongs to a different
        geometry object than this group.
        
        
        """
        pass
        
    
    def options(name):
        """
        option(self, name) -> bool, int, float, str, hou.Vector2, hou.Vector3,
        hou.Vector4, hou.Quaternion, hou.Matrix3, hou.Matrix4, tuple of int, or
        tuple of float
        
        Return the value of an individual option, on None if no such option
        exists.
        
        See also hou.PrimGroup.options, hou.PrimGroup.setOption and
        hou.PrimGroup.removeOption.
        
        
        """
        pass
        
    
    def add(prim_or_list_or_prim_group):
        """
        add(self, prim_or_list_or_prim_group)
        
        If given a hou.Prim or a list of hou.Prim's, add the primitive(s) to
        the group. If given a hou.PrimGroup, merge the contents of the other
        primitive group with this group (the other group is unaffected). You
        would typically call this method from the code of a Python-defined
        SOP.
        
        It is okay to add primitives to the group that were already in the
        group.
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable.
        
        Raises hou.OperationFailed if the primitive or primitive group
        belong to a different geometry object than this group.
        
        
        """
        pass
        
    
    def prims():
        """
        prims(self) -> tuple of hou.Prim
        
        Return the contents of this group.
        
        
        """
        pass
        
    
    def destroy():
        """
        destroy(self)
        
        Remove this group from the geometry. You would typically call this
        method from the code of a Python-defined SOP.
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable.
        
        
        """
        pass
        

def PrimGroup_swigregister():
    """None"""
    pass
    

def Prim_swigregister():
    """None"""
    pass
    

class PySwigIterator(object):
    """None"""
    
    def advance():
        """None"""
        pass
        
    
    def decr():
        """None"""
        pass
        
    
    def copy():
        """None"""
        pass
        
    
    def previous():
        """None"""
        pass
        
    
    def distance():
        """None"""
        pass
        
    
    def incr():
        """None"""
        pass
        
    
    def equal():
        """None"""
        pass
        
    
    def value():
        """None"""
        pass
        
    
    def next():
        """None"""
        pass
        

def PySwigIterator_swigregister():
    """None"""
    pass
    

class PythonPanel(PathBasedPaneTab):
    """
    hou.PythonPanel
    
    Class representing a pane tab that can display an embedded PySide or
    PyQt interface.
    
    See also hou.pypanel and hou.PythonPanelInterface.
    
    
    NOTE
    PySide and PyQt interfaces can only be created from the main Houdini
    application thread. You cannot call any method in this class from a
    separate thread (i.e. do not call from a Python Shell).
    
    
    """
    
    def isToolbarShown():
        """
        isToolbarShown(self) -> bool
        
        Return True if the toolbar is shown and False otherwise.
        
        
        """
        pass
        
    
    def setActiveInterface(interface):
        """
        setActiveInterface(self, interface)
        
        Show the specified interface in the Python Panel. interface is a
        hou.PythonPanelInterface object.
        
        Raises hou.OperationFailed if interface is not an installed Python
        Panel interface.
        
        
        """
        pass
        
    
    def setLabel():
        """None"""
        pass
        
    
    def isToolbarExpanded():
        """
        isToolbarExpanded(self) -> bool
        
        Return True if the toolbar is expanded and False otherwise.
        
        
        """
        pass
        
    
    def activeInterfaceRootWidget():
        """
        activeInterfaceRootWidget(self) -> Qt.QtWidgets.QWidget subclass
        
        Returns a reference to the user-defined root widget created by the
        active interface in the Python Panel. Returns None if there is no
        active interface or widget.
        
        
        """
        pass
        
    
    def activeInterface():
        """
        activeInterface(self) -> hou.PythonPanelInterface
        
        Returns the interface currently assigned to the Python Panel, or
        None if no interface has been assigned.
        
        
        """
        pass
        
    
    def showToolbar(show):
        """
        showToolbar(self, show)
        
        Show or hide the toolbar. show must be either True or False.
        
        
        """
        pass
        
    
    def expandToolbar():
        """None"""
        pass
        

class PythonPanelInterface(object):
    """
    hou.PythonPanelInterface
    
    Represents the definition of a Python panel interface.
    
    RELATED
    
    * hou.pypanel
    
    * hou.PythonPanel
    
    
    """
    
    def help():
        """None"""
        pass
        
    
    def setName(selfname):
        """
        setName(self,name)
        
        Sets the name for this interface.
        
        
        """
        pass
        
    
    def filePath():
        """
        filePath(self) -> str
        
        Returns the file path for this interface.
        
        
        """
        pass
        
    
    def setScript(selfscript):
        """
        setScript(self,script)
        
        Sets the script for this interface.
        
        
        """
        pass
        
    
    def setLabel(selflabel):
        """
        setLabel(self,label)
        
        Sets the label for this interface.
        
        
        """
        pass
        
    
    def setHelpURL():
        """None"""
        pass
        
    
    def id():
        """
        id(self) -> int
        
        Returns the id for this interface.
        
        
        """
        pass
        
    
    def icon():
        """
        icon(self) -> str
        
        Returns the icon for this interface.
        
        
        """
        pass
        
    
    def setFilePath(selfscript):
        """
        setFilePath(self,script)
        
        Sets the file path for this interface.
        
        
        """
        pass
        
    
    def name():
        """
        name(self) -> str
        
        Returns the name for this interface.
        
        
        """
        pass
        
    
    def setHelp():
        """None"""
        pass
        
    
    def script():
        """
        script(self) -> str
        
        Returns the script for this interface.
        
        
        """
        pass
        
    
    def label():
        """
        label(self) -> str
        
        Returns the label for this interface.
        
        
        """
        pass
        
    
    def helpURL():
        """None"""
        pass
        
    
    def setIcon(selficon):
        """
        setIcon(self,icon)
        
        Sets the icon for this interface.
        
        
        """
        pass
        

def PythonPanelInterface_swigregister():
    """None"""
    pass
    

def PythonPanel_swigregister():
    """None"""
    pass
    

class Quadric(Prim):
    """
    hou.Quadric
    
    A Quadric is a kind of geometry primitive (Prim object) that represents
    a 3-dimensional surface defined by a quadratic polynomial equation (e.g.
    a sphere or tube).
    
    
    """
    
    def getTransform():
        """None"""
        pass
        
    
    def vertex(index):
        """
        vertex(self, index) -> hou.Vertex
        
        A shortcut for self.vertices()[index]. You probably don't need to
        call this method.
        
        This method supports negative indices to index from the end, just
        like self.vertices()[index] would. Also, like Python's indexing
        operator, it will raise IndexError when the index is out of range.
        
        
        """
        pass
        
    
    def transform():
        """
        transform(self) -> hou.Matrix3
        
        Return the 3x3 matrix associated with this quadric. This matrix
        determines what type of quadric it is.
        
        See Wikipedia's Quadric page for more information.
        
        
        """
        pass
        

def Quadric_swigregister():
    """None"""
    pass
    

class Quaternion(object):
    """
    hou.Quaternion
    
    A representation of a 3D rotation (or orientation). You can smoothly
    interpolate between two rotation values by interpolating between two
    quaternions.
    
    Quaternions provide an easy way to nicely interpolate between two
    rotation values, and avoid the gimbal lock and direction changes caused
    by interpolating Euler angles. They can easily be converted to and from
    rotation matrices, Euler angles, and angle-axis rotations.
    
    A quaternion is represented by a vector of 4 floats (x, y, z, and w).
    Any rotation in three dimensions is a rotation by some angle about some
    axis, and you can think of the (x, y, z) portion of the quaternion as
    storing the axis and the w portion as storing a (representation of) the
    angle.
    
    See Wikipedia's Quaternion page and its Quaternions and space rotation
    page for more information.
    
    
    """
    
    def almostEqual():
        """None"""
        pass
        
    
    def setToRotationMatrix(matrix3_or_matrix4):
        """
        setToRotationMatrix(self, matrix3_or_matrix4)
        
        Set this quaternion to contain the rotation component of the
        transformation in a hou.Matrix3 or hou.Matrix4.
        
        See also hou.Quaternion.extractRotationMatrix3.
        
        
        """
        pass
        
    
    def extractRotationMatrix3():
        """
        extractRotationMatrix3(self) -> hou.Matrix3
        
        Return a 3x3 rotation matrix corresponding to the rotation in the
        quaternion.
        
        To create a hou.Matrix4 instead of a hou.Matrix3, you can easily
        create a Matrix4 from the Matrix3:
        
        > hou.Matrix4(quaternion.extractRotationMatrix3())
        
        If the quaternion is the zero quaternion, this method does not raise
        an exception. Instead, it returns the identity matrix.
        
        See also hou.Quaternion.setToRotationMatrix.
        
        
        """
        pass
        
    
    def setTo(tuple):
        """
        setTo(self, tuple)
        
        Set the quaternion's 4 float values (x, y, z, and w). tuple must be
        a sequence of 4 floats.
        
        This method will modify an existing quaternion object. Use
        hou.Quaternion.__init__ to construct a new quaternion from these
        four values.
        
        See also hou.Quaternion.__setitem__.
        
        
        """
        pass
        
    
    def conjugate():
        """
        conjugate(self) -> hou.Quaternion
        
        Return a quaternion containing the opposite rotation of that stored
        in this quaternion. Intuitively, for unit length quaternions, the
        quaternion returned contains a rotation by the same angle about an
        axis pointing in the opposite direction.
        
        
        """
        pass
        
    
    def slerp(other, fraction):
        """
        slerp(self, other, fraction) -> hou.Quaternion
        
        Perform spherical linear interpolation between this quaternion and
        another, returning a new quaternion. fraction is a float from 0.0 to
        1.0, where 0.0 gives this quaternion and 1.0 gives the other
        quaternion. This method is very useful to smoothly interpolate
        between two different rotations.
        
        See Wikipedia's Slerp page for more information.
        
        The following example will nicely interpolate between two sets of
        Euler rotations.
        
        > def interpolateEulerRotations(rotation1, rotation2, fraction, rotate_order="xyz"):
        >     quaternion1 = hou.Quaternion()
        >     quaternion1.setToEulerRotates(rotation1, rotate_order)
        >     quaternion2 = hou.Quaternion()
        >     quaternion2.setToEulerRotates(rotation2, rotate_order)
        >
        >     return quaternion1.slerp(quaternion2, fraction).extractEulerRotates(rotate_order)
        
        """
        pass
        
    
    def inverse():
        """
        inverse(self) -> hou.Quaternion
        
        Return a quaternion containing the multiplicative inverse of this
        quaternion. For unit quaternions, the inverse is the same as the
        conjugate.
        
        See also hou.Quaternion.conjugate.
        
        
        """
        pass
        
    
    def setToVectors(a, b):
        """
        setToVectors(self, a, b)
        
        Sets this quaternion to the quaternion which rotates the hou.Vector3
        a onto the vector b.
        
        
        """
        pass
        
    
    def _asVoidPointer():
        """None"""
        pass
        
    
    def setToEulerRotates(angles_in_deg, rotate_order="xyz"):
        """
        setToEulerRotates(self, angles_in_deg, rotate_order="xyz")
        
        Set this quaternion to contain the rotation specified by Euler
        rotations about the x, y, and z coordinate axes.
        
        This method can also be implemented as follows:
        
        > def setToEulerRotates(self, angles_in_deg, rotate_order="xyz"):
        >     self.setToRotationMatrix(
        >         hou.hmath.buildRotate(angles_in_deg, rotate_order))
        
        See also hou.Quaternion.extractEulerRotates and
        hou.hmath.buildRotate.
        
        
        """
        pass
        
    
    def isAlmostEqual(quaternion, tolerance=0.00001):
        """
        isAlmostEqual(self, quaternion, tolerance=0.00001) -> bool
        
        Returns whether this quaternion is equal to another, within a
        numerical tolerance.
        
        
        """
        pass
        
    
    def normalized():
        """
        normalized(self) -> hou.Quaternion
        
        Return a normalized version of this quaternion (i.e. a version of
        this quaternion whose length is one). Quaternions that represent
        rotations are always normalized.
        
        Normalizing a quaternion whose length is zero or near zero will
        return a new quaternion with the same values.
        
        This method can be implemented as follows (for non-zero length
        quaternions):
        
        > def normalized(self):
        >     return self * (1.0 / self.length())
        
        """
        pass
        
    
    def extractAngleAxis():
        """
        extractAngleAxis(self) -> (float, hou.Vector3)
        
        Return an axis and a rotation about that axis corresponding to the
        rotation in the quaternion. The return value is a 2-tuple containing
        a float and a hou.Vector3. The returned axis vector is normalized.
        
        If this quaternion is the zero quaternion, the angle returned is
        zero and the vector is the zero vector. Otherwise, if it is not
        normalized, the return values will correspond to the rotation
        represented by the normalized quaternion.
        
        See also hou.Quaternion.setToAngleAxis.
        
        
        """
        pass
        
    
    def rotate(vec):
        """
        rotate(self, vec) -> hou.Vector3
        
        Rotates the given hou.Vector3 by this quaternion and returns the
        result.
        
        
        """
        pass
        
    
    def length():
        """
        length(self) -> float
        
        Return the length of the quaternion. When quaternions represent
        rotations, their length is one.
        
        A quaternion's length is compute the same as a Vector4's:
        hou.Vector4(self).length()
        
        
        """
        pass
        
    
    def setToAngleAxis(angle_in_deg, axis):
        """
        setToAngleAxis(self, angle_in_deg, axis)
        
        Set this quaternion to contain the rotation about an axis by the
        given angle. angle_in_deg is in degrees and axis is a sequence of 3
        floats.
        
        This method can also be implemented as follows:
        
        > def setToAngleAxis(self, angle_in_deg, axis):
        >     self.setToRotationMatrix(
        >         hou.hmath.buildRotateAboutAxis(axis, angle_in_deg))
        
        See also hou.Quaternion.extractAngleAxis.
        
        
        """
        pass
        
    
    def dot(other):
        """
        dot(self, other) -> float
        
        Return the dot product of this quaternion with another one.
        
        
        """
        pass
        
    
    def extractEulerRotates(rotate_order="xyz"):
        """
        extractEulerRotates(self, rotate_order="xyz") -> hou.Vector3
        
        Return the Euler rotations (the x, y, and z rotation values, in
        degrees, about the coordinate axes) corresponding to the rotation in
        the quaternion.
        
        This method can also be implemented as follows:
        
        > def extractEulerRotates(self, rotate_order="xyz"):
        >     return hou.Matrix4(self.extractRotationMatrix3()).explode(rotate_order=rotate_order)["rotate"]
        
        See also hou.Quaternion.setToEulerRotates.
        
        
        """
        pass
        

def Quaternion_swigregister():
    """None"""
    pass
    

class RadialItem(object):
    """
    hou.RadialItem
    
    RELATED
    
    * hou.ui.RadialScriptItem
    
    * hou.ui.RadialSubmenu
    
    
    """
    
    def destroy():
        """
        destroy(self)
        
        Deletes this radial menu item.
        
        
        """
        pass
        
    
    def type():
        """
        type(self) -> hou.radialItemType
        
        Return this radial menu item's type.
        
        
        """
        pass
        

def RadialItem_swigregister():
    """None"""
    pass
    

class RadialMenu(RadialSubmenu):
    """
    hou.RadialMenu
    * Use hou.ui.radialMenus or hou.ui.radialMenu to get a reference to an
    existing menu.
    
    * Use hou.ui.createRadialMenu to create a new menu.
    
    RELATED
    
    * hou.ui.radialMenu
    
    * hou.ui.radialMenus
    
    * hou.ui.createRadialMenu
    
    * hou.RadialItem
    
    
    """
    
    def sourceFile():
        """
        sourceFile(self) -> str
        
        Return the name of the file from which this radial menu was loaded
        or saved.
        
        
        """
        pass
        
    
    def setCategories(categories):
        """
        setCategories(self, categories)
        
        Sets this radial menu's categories (specified as a comma separated
        list).
        
        
        """
        pass
        
    
    def save(filename):
        """
        save(self, filename)
        
        Saves this radial menu to the specified file.
        
        
        """
        pass
        
    
    def categories():
        """
        categories(self) -> str
        
        Return a comma separated list of this radial menu's categories.
        
        
        """
        pass
        
    
    def name():
        """
        name(self) -> str
        
        Return this radial menu's name.
        
        
        """
        pass
        

def RadialMenu_swigregister():
    """None"""
    pass
    

class RadialScriptItem(RadialItem):
    """
    hou.RadialScriptItem
    
    """
    
    def script():
        """
        script(self) -> str
        
        Return Python code that will be run when the radial menu item is
        activated.
        
        
        """
        pass
        
    
    def setScript():
        """
        setScript(self)
        
        Sets the Python code that will be run when the radial menu item is
        activated.
        
        
        """
        pass
        
    
    def setLabel():
        """
        setLabel(self)
        
        Sets this radial menu item's label.
        
        
        """
        pass
        
    
    def label():
        """
        label(self) -> str
        
        Return this radial menu item's label.
        
        
        """
        pass
        
    
    def setCheck():
        """
        setCheck(self)
        
        Sets the Python expression used to determine the radial menu item's
        checked state.
        
        
        """
        pass
        
    
    def setIcon():
        """
        setIcon(self)
        
        Sets this radial menu item's icon.
        
        
        """
        pass
        
    
    def check():
        """
        check(self) -> str
        
        Return a Python expression used to determine the radial menu item's
        checked state.
        
        
        """
        pass
        
    
    def icon():
        """
        icon(self) -> str
        
        Return this radial menu item's icon.
        
        
        """
        pass
        

def RadialScriptItem_swigregister():
    """None"""
    pass
    

class RadialSubmenu(RadialItem):
    """
    hou.RadialSubmenu
    
    """
    
    def createScriptItem([Hom:hou.radialItemLocation], label=None, icon=None, check=None, script=None):
        """
        createScriptItem(self, [Hom:hou.radialItemLocation], label=None,
        icon=None, check=None, script=None) -> hou.RadialScriptItem
        
        Creates a script item at the specified location (replacing any
        existing radial menu item) and initializing the script item's label,
        icon, expression specifying the checked state, and script executed
        when the item is activated. The new script item is returned.
        
        
        """
        pass
        
    
    def items():
        """
        items(self) -> dict of hou.radialItemLocation to hou.RadialItem
        
        Return a dict mapping radial item locations to radial menu items.
        
        
        """
        pass
        
    
    def setLabel():
        """
        setLabel(self)
        
        Sets this submenu's label.
        
        
        """
        pass
        
    
    def createSubmenu([Hom:hou.radialItemLocation], label=None):
        """
        createSubmenu(self, [Hom:hou.radialItemLocation], label=None) ->
        hou.RadialSubmenu
        
        Creates a submenu at the specified location (replacing any existing
        radial menu item) and initializing the submenu's label. The new
        submenu is returned.
        
        
        """
        pass
        
    
    def label():
        """
        label(self) -> str
        
        Return this submenu's label.
        
        
        """
        pass
        
    
    def item([Hom:hou.radialItemLocation]):
        """
        item(self, [Hom:hou.radialItemLocation]) -> hou.RadialItem
        
        Return the radial menu item at the specified location. Return None
        if no radial menu item exists at the specified location.
        
        
        """
        pass
        

def RadialSubmenu_swigregister():
    """None"""
    pass
    

class Ramp(object):
    """
    hou.Ramp
    
    A Ramp represents a function that yields either floating point values or
    colors. You can evaluate this function between 0.0 and 1.0, and the
    function's shape is determined by a sequence of values at key positions
    between 0.0 and 1.0.
    
    If you evaluate a ramp parameter on a node, Houdini will return a Ramp
    object.
    
    You can check the curve "basis" of a ramp you get from a parameter by
    calling the hou.Ramp.basis method,which returns a hou.rampBasis value.
    
    In the Hermite basis, the curve passes through the _odd_ control points,
    and the _even_ control points control the tangent at the previous point.
    See the Wikipedia article on Hermite spline curves for more information.
    
    To get a smooth curve, you should evenly space the control points.
    
    RELATED
    
    * spline()
    
    
    """
    
    def basis():
        """
        basis(self) -> tuple of hou.rampBasis enum values
        
        Return a tuple of hou.rampBasis enumeration values that determine
        how Houdini interpolates between the keys in the ramp. See
        hou.Ramp.__init__ for more information.
        
        
        """
        pass
        
    
    def keys():
        """
        keys(self) -> tuple of float
        
        Return a tuple of floats between 0.0 and 1.0 containing the ramp key
        positions. See hou.Ramp.__init__ for more information.
        
        
        """
        pass
        
    
    def _asVoidPointer():
        """None"""
        pass
        
    
    def isColor():
        """
        isColor(self) -> bool
        
        Return True if this is a color ramp, and False if it is a single
        float ramp.
        
        
        """
        pass
        
    
    def values():
        """
        values(self) -> tuple of float or tuple of tuple of float
        
        Return a tuple of floats (for a float ramp) or a tuple of tuples of
        3 floats (for a color ramp) corresponding to the values in the ramp
        stored at each key. See hou.Ramp.__init__ for more information.
        
        
        """
        pass
        
    
    def setColorType(hou.colorType):
        """
        setColorType(self, hou.colorType)
        
        If this is a color ramp, set the color space that is used during
        interpolation. The default is hou.colorType.RGB.
        
        To obtain a more perceptually uniform interpolation, use
        hou.colorType.LAB. To obtain a ramp that matches the rainbow, use
        hou.colorType.HSV.
        
        Raises hou.OperationFailed if this ramp is not a color ramp.
        
        
        """
        pass
        
    
    def lookup(interpolant):
        """
        lookup(self, interpolant) -> float or tuple
        
        Return the value of the ramp at a specified position from 0.0 to
        1.0, inclusive.
        
        Returns a float (for floating-point value ramps) or a tuple of 3
        floats (for color ramps).
        
        
        """
        pass
        
    
    def colorType():
        """
        colorType(self) -> colorType
        
        If this is a color ramp, return the color space that is used during
        interpolation. The default is hou.colorType.RGB.
        
        Raises hou.OperationFailed if this ramp is not a color ramp.
        
        
        """
        pass
        

class RampParmTemplate(ParmTemplate):
    """
    hou.RampParmTemplate
    
    Parameter template for a ramp parameter.
    
    
    """
    
    def setDefaultExpression(tuple_of_default_expressions):
        """
        setDefaultExpression(self, tuple_of_default_expressions)
        
        Set the default expression, which when evaluated, returns the number
        of ramp keys to be used in new ramp parameter instances.
        
        If default_expression is the empty string, then the default
        expression is unset.
        
        
        """
        pass
        
    
    def parmType():
        """None"""
        pass
        
    
    def setDefaultValue(tuple_of_default_values):
        """
        setDefaultValue(self, tuple_of_default_values)
        
        Set the default number of ramp keys to be used in new ramp parameter
        instances.
        
        
        """
        pass
        
    
    def setDefaultExpressionLanguage(tuple_of_default_expression_languages):
        """
        setDefaultExpressionLanguage(self,
        tuple_of_default_expression_languages)
        
        Set the default expression language.
        
        See the defaultExpressionLanguage method for more information.
        
        
        """
        pass
        
    
    def setShowsControls(on):
        """
        setShowsControls(self, on)
        
        Set whether new instances of this ramp parameter have the controls
        expanded by default.
        
        
        """
        pass
        
    
    def setDefaultBasis(ramp_basis):
        """
        setDefaultBasis(self, ramp_basis)
        
        Set the basis function used to control how values are interpolated
        between ramp keys. ramp_basis is a hou.rampBasis enum value.
        
        
        """
        pass
        
    
    def colorType():
        """
        colorType(self) -> hou.colorType enum value
        
        The color space in which to interpolate color ramp keys.
        
        See hou.colorType for more information on color spaces.
        
        
        """
        pass
        
    
    def setParmType(ramp_parm_type):
        """
        setParmType(self, ramp_parm_type)
        
        Set the type of this ramp to a hou.rampParmType enum value.
        
        
        """
        pass
        
    
    def defaultExpression():
        """
        defaultExpression(self) -> string
        
        Return the expression, which when evaluated, returns the number of
        ramp keys to be used in new ramp parameter instances.
        
        The default expression takes precedence over the default value. If
        the default expression is not set (i.e. an empty string), then the
        default value is used instead.
        
        Note that the default expression language is needed to interpret the
        meaning of the default expression.
        
        
        """
        pass
        
    
    def defaultValue():
        """
        defaultValue(self) -> int
        
        Return this is the default number of ramp keys in new ramp parameter
        instances.
        
        
        """
        pass
        
    
    def showsControls():
        """
        showsControls(self) -> bool
        
        Return whether new instances of this ramp parameter have the
        controls expanded by default. The user may later expand or collapse
        the ramp controls on the parameter.
        
        
        """
        pass
        
    
    def defaultExpressionLanguage():
        """
        defaultExpressionLanguage(self) -> tuple of hou.scriptLanguage
        
        Return the default expression language.
        
        The default expression language only applies if the default
        expression is set. If the default expression is not set, then the
        expression language is set to hou.scriptLanguage.Hscript.
        
        
        """
        pass
        
    
    def setColorType(color_type):
        """
        setColorType(self, color_type)
        
        Set the color space in which to interpolate color ramp keys to a
        hou.colorType enum value.
        
        
        """
        pass
        
    
    def defaultBasis():
        """
        defaultBasis(self) -> hou.rampBasis enum value
        
        The basis function used to control how values are interpolated
        between ramp keys.
        
        See hou.rampBasis for more information.
        
        
        """
        pass
        

def RampParmTemplate_swigregister():
    """None"""
    pass
    

def Ramp_swigregister():
    """None"""
    pass
    

class RedrawBlock(object):
    """
    hou.RedrawBlock
    
    Use this class to collect multiple redraws for any Python code block and
    only redraw once.
    
    
    """

def RedrawBlock_swigregister():
    """None"""
    pass
    

class ReferencePlane(object):
    """
    hou.ReferencePlane
    
    The reference grid (a.k.a. reference plane) in the scene viewer pane
    tab.
    
    
    """
    
    def setTransform(matrix):
        """
        setTransform(self, matrix)
        
        Set the transformation matrix for this plane to a hou.Matrix4.
        
        This matrix is used to translate and rotate the plane. See the
        transform method for more information.
        
        Note that scale information inside the transformation matrix is
        ignored.
        
        The following function will change the position of the origin of the
        plane:
        
        > def set_origin(reference_plane, new_origin):
        >     translation = hou.hmath.buildTranslate(hou.Vector3(new_origin) - origin(reference_plane))
        >     reference_plane.setTransform(reference_plane.transform() * translation)
        >
        > def origin(reference_plane):
        >     return hou.Vector3(0, 0, 0) * reference_plane.transform()
        
        The following function will change the normal of the plane:
        
        > def set_normal(reference_plane, normal_vector):
        >     existing_rotation = hou.Matrix4(reference_plane.transform().extractRotationMatrix3())
        >     rotation = existing_rotation * normal(reference_plane).matrixToRotateTo(normal_vector)
        >     translation = hou.hmath.buildTranslate(origin(reference_plane))
        >     reference_plane.setTransform(rotation * translation)
        >
        > def normal(reference_plane):
        >     return hou.Vector3(0, 0, 1) * reference_plane.transform().inverted().transposed()
        >
        > def origin(reference_plane):
        >     return hou.Vector3(0, 0, 0) * reference_plane.transform()
        
        """
        pass
        
    
    def numberOfCellsPerRulerLine():
        """
        numberOfCellsPerRulerLine(self) -> tuple of int
        
        Return the number of cells in the x and y directions between ruler
        lines. Ruler lines are darker than the normal lines drawn between
        grid cells.
        
        
        """
        pass
        
    
    def setCellSize(size):
        """
        setCellSize(self, size)
        
        Change the x and y sizes (width and height) of each cell in the grid
        of cells. size is a sequence of two floats.
        
        Changing the size of each cell will change the total size of the
        grid.
        
        
        """
        pass
        
    
    def sceneViewer():
        """
        sceneViewer(self) -> hou.SceneViewer
        
        Return the scene viewer containing this plane.
        
        
        """
        pass
        
    
    def setNumberOfCellsPerRulerLine():
        """None"""
        pass
        
    
    def transform():
        """
        transform(self) -> hou.Matrix4
        
        Return the transformation matrix for this plane.
        
        When the transformation matrix is the identity matrix, the plane's
        bottom-left corner is at the origin and it sits in the XY plane. In
        this orientation, increasing the number of cells in x or the size of
        a cell in x grows the plane outward from the origin along the
        x-axis. Similarly, increasing the number of cells or size of a cell
        in y grows the plane along the y-axis.
        
        Note that the transformation matrix does not contain any scale
        information. The reference plane extends to infinity.
        
        The following function will return the normal of the plane:
        
        > def normal(reference_plane):
        >     return hou.Vector3(0, 0, 1) * reference_plane.transform().inverted().transposed()
        
        """
        pass
        
    
    def setIsVisible(on):
        """
        setIsVisible(self, on)
        
        Make this grid visible or invisible in the viewer.
        
        
        """
        pass
        
    
    def isVisible():
        """
        isVisible(self) -> bool
        
        Return whether the grid is visible in the viewer.
        
        
        """
        pass
        
    
    def cellSize():
        """
        cellSize(self) -> tuple of float
        
        Return the x and y sizes (width and height) of one cell in the grid
        of cells. The return value is a tuple of two floats.
        
        
        """
        pass
        

def ReferencePlane_swigregister():
    """None"""
    pass
    

class RopNode(Node):
    """
    hou.RopNode
    
    Represents a render output node.
    
    REPLACES
    
    * opset
    
    * render
    
    * opflag()
    
    * opget
    
    
    """
    
    def render(frame_range=():
        """
        render(self, frame_range=(), res=(), output_file=None,
        output_format=None, to_flipbook=False, quality=2, ignore_inputs=False,
        method=RopByRop, ignore_bypass_flags=False, ignore_lock_flags=False,
        verbose=False, output_progress=False)
        
        Renders this node and optionally any of its inputs. Inputs are
        recursively processed (unless ignore_inputs is True), so that all
        descendents are rendered in the proper order before this node is
        rendered.
        
        
        frame_range
        Sequence of 2 or 3 values, overrides the frame range and frame
        increment to render. The first two values specify the start and
        end frames, and the third value (if given) specifies the frame
        increment. If no frame increment is given and the ROP node
        doesn't specify a frame increment, then a value of 1 will be
        used. If no frame range is given, and the ROP node doesn't
        specify a frame range, then the current frame will be rendered.
        
        res
        Sequence of two scaling factors that will be used to scale the
        resolution of the image, along the x- and y-axes. The scaling
        factors will be applied to the node and all dependencies that
        are also rendered.
        
        output_file
        Overrides the location to which the image is written.
        
        output_format
        Overrides the format of the image.
        
        to_flipbook
        If True, renders this node to a flipbook.
        
        quality
        Overrides the render quality.
        
        ignore_inputs
        If True, renders only this node (does not render any of its
        dependencies).
        
        method
        Either hou.renderMethod.RopByRop or
        hou.renderMethod.FrameByFrame. The default is ROP by ROP: each
        ROP will render its entire sequence before proceeding to the
        next ROP. If you specify FrameByFrame, all ROPs will render the
        first frame, then the second, etc.
        
        This parameter is only relevant when rendering ROPs in a
        dependency network.
        
        ignore_bypass_flags
        If True, renders this node even if its bypass flag is on.
        
        ignore_lock_flags
        If True, ignores any lock flags on this node and its
        dependencies.
        
        verbose
        If True, then the method will print messages during the render.
        For example, a message is printed when each frame starts
        rendering.
        
        output_progress
        If True, then the method will print Alfred-style progress
        messages. This argument does not apply if the verbose argument
        is set to False.
        
        
        """
        pass
        
    
    def setLocked(on):
        """
        setLocked(self, on)
        
        Sets this node's lock flag on or off. The lock flag caches the
        node's data and the data from its inputs and prevents them from
        being recalculated during cooking.
        
        
        """
        pass
        
    
    def isLocked():
        """
        isLocked(self) -> bool
        
        Returns whether this node's lock flag is on.
        
        
        """
        pass
        
    
    def bypass(on):
        """
        bypass(self, on)
        
        Turns the node's bypass flag on or off, making this node have no
        effect.
        
        
        """
        pass
        
    
    def isBypassed():
        """
        isBypassed(self) -> bool
        
        Returns whether this node's bypass flag is on.
        
        
        """
        pass
        
    
    def inputDependencies():
        """
        inputDependencies(self) -> (tuple of hou.RopNode, tuple of tuples of
        float)
        
        Returns the input dependencies of the ROP node, consisting of ROPs,
        and the frames that need to be be rendered prior to rendering the
        ROP.
        
        This method returns a tuple of two elements:
        
        * The first element is a sequence of the hou.RopNode objects
        representing the input dependencies.
        
        * The second element is a sequence, where each element corresponds to
        the RopNode object at the same position in the first sequence, and
        is a sequence of floats representing the frames that must be
        rendered for the corresponding RopNode.
        
        
        """
        pass
        

def RopNode_swigregister():
    """None"""
    pass
    

class SceneGraphTree(PathBasedPaneTab):
    """None"""

def SceneGraphTree_swigregister():
    """None"""
    pass
    

class SceneViewer(PathBasedPaneTab):
    """
    hou.SceneViewer
    
    REPLACES
    
    * vieweroption
    
    * viewlayout
    
    * viewls
    
    * viewsnapshot
    
    * viewsnapshotoption
    
    
    """
    
    def setSnapToTemplates(on):
        """
        setSnapToTemplates(self, on)
        
        
        """
        pass
        
    
    def setPickingContainedGeometry(on):
        """
        setPickingContainedGeometry(self, on)
        
        Turns on or off the option to select only fully contained components
        when performing area-based selections such as box or brush picking.
        
        
        """
        pass
        
    
    def setOrientOnSnap(on):
        """
        setOrientOnSnap(self, on)
        
        
        """
        pass
        
    
    def setDefaultPickModifier(modifier):
        """
        setDefaultPickModifier(self, modifier)
        
        Sets the default pick modifier to which Houdini will revert after a
        select state terminates.
        
        
        """
        pass
        
    
    def selectGeometry(prompt='Select, geometry', sel_index=0, allow_drag=False, quick_select=False, use_existing_selection=True, initial_selection, =, None, initial_selection_type, =, None, ordered=False, geometry_types=():
        """
        selectGeometry(self, prompt='Select geometry', sel_index=0,
        allow_drag=False, quick_select=False, use_existing_selection=True,
        initial_selection = None, initial_selection_type = None, ordered=False,
        geometry_types=(), primitive_types=(), allow_obj_sel=True, icon=None,
        label=None, prior_selection_paths=[], prior_selection_ids=[],
        prior_selections=[], allow_other_sops=True, consume_selections=True) ->
        GeometrySelection
        
        
        """
        pass
        
    
    def pickStyle():
        """
        pickStyle(self)
        
        Returns the style of area picking currently being used by this
        viewer. This option corresponds to the picking style specified in
        the select tool's context menu.
        
        
        """
        pass
        
    
    def setPickingVisibleGeometry(on):
        """
        setPickingVisibleGeometry(self, on)
        
        Turns on or off the option to select only visible components when
        performing area-based selections such as box or brush picking.
        
        
        """
        pass
        
    
    def groupListMask():
        """
        groupListMask(self)
        
        Returns true if the group list gadget has been turned on for this
        viewer.
        
        
        """
        pass
        
    
    def setGroupListColoringGeometry(on):
        """
        setGroupListColoringGeometry(self, on)
        
        Turns on or off the group list gadget to coloring of geometry in the
        viewer based on group membership or attribute value.
        
        
        """
        pass
        
    
    def snappingPriorities():
        """
        snappingPriorities(self): -> tuple of hou.snappingPriority values
        
        Returns a tuple of hou.snappingPriority values for the current
        snapping mode. The values are sorted in order of priority
        (descending) as set in the Snap options window. Returns an empty
        tuple if the mode has no priorities.
        
        
        """
        pass
        
    
    def setSnapToOtherObjects(on):
        """
        setSnapToOtherObjects(self, on)
        
        
        """
        pass
        
    
    def enterCurrentNodeState(wait_for_exit=False):
        """
        enterCurrentNodeState(self, wait_for_exit=False)
        
        Enters the viewer into the node-specific tool state of the last
        selected node. If wait_for_exit is True, then the function will not
        return until the viewer exits the tool.
        
        
        """
        pass
        
    
    def setGroupListVisible(on):
        """
        setGroupListVisible(self, on)
        
        Turns on or off the group list gadget for this viewer.
        
        
        """
        pass
        
    
    def curViewport():
        """
        curViewport(self) -> hou.GeometryViewport
        
        Returns this viewer's current viewport. The current viewport is the
        one containing the mouse cursor. If the cursor is not in a viewport,
        then the selected, or active, viewport is returned.
        
        
        """
        pass
        
    
    def isWholeGeometryPicking():
        """
        isWholeGeometryPicking(self)
        
        Returns true if selections made in this viewer will automatically
        expand to include the whole geometry. This option corresponds to the
        matching check box in the component selection button's context menu.
        
        
        """
        pass
        
    
    def setGroupListCondensingPathHierarchies(on):
        """
        setGroupListCondensingPathHierarchies(self, on)
        
        Turns on or off the condensing of the hierarchy in the group list.
        This applies to components grouped by string attributes representing
        a path. Turning this option on can fit more information into the
        list, but can make it harder to distinguish levels in the hierarchy.
        
        
        """
        pass
        
    
    def selectSceneGraph(prompt, preselection, prim_mask, quick_select, use_existing_selection, confirm_existing, allow_multisel, allow_drag, path_prefix_mask, prim_kind):
        """
        selectSceneGraph(self, prompt, preselection, prim_mask, quick_select,
        use_existing_selection, confirm_existing, allow_multisel, allow_drag,
        path_prefix_mask, prim_kind) -> tuple of string
        
        
        """
        pass
        
    
    def setCurrentSceneGraphSelection(selection):
        """
        setCurrentSceneGraphSelection(selection)
        
        
        """
        pass
        
    
    def groupListSize():
        """
        groupListSize(self)
        
        Returns the width and height in inches of the group list gadget.
        
        
        """
        pass
        
    
    def endStateUndo():
        """
        endStateUndo(self)
        
        Closes an undo block previously opened with
        hou.SceneViewer.beginStateUndo.
        
        endStateUndo will raise an exception if called before
        beginStateUndo.
        
        
        """
        pass
        
    
    def isWorldSpaceLocal():
        """
        isWorldSpaceLocal(self) -> bool
        
        Returns true if values that would normally be in world space are
        actually in the local space of the current object. This includes
        things like the return values of selectPositions(),
        hou.GeometryViewport::mapToScreen(),
        hou.GeometryViewport::mapToWorld(),
        hou.GeometryViewport().viewPivot(), etc.
        
        
        """
        pass
        
    
    def selectDynamics(prompt='Select, dynamics, objects', sel_index=0, allow_objects=True, allow_modifiers=False, quick_select=False, use_existing_selection=True, allow_multisel=True, icon=None, label=None, prior_selection_paths=[], prior_selection_ids=[], prior_selections=[]):
        """
        selectDynamics(self, prompt='Select dynamics objects', sel_index=0,
        allow_objects=True, allow_modifiers=False, quick_select=False,
        use_existing_selection=True, allow_multisel=True, icon=None, label=None,
        prior_selection_paths=[], prior_selection_ids=[], prior_selections=[])
        -> tuple of hou.DopData
        
        
        """
        pass
        
    
    def isSnappingToTemplates():
        """
        isSnappingToTemplates(self)
        
        
        """
        pass
        
    
    def enterTranslateToolState(wait_for_exit=False):
        """
        enterTranslateToolState(self, wait_for_exit=False)
        
        Enters the viewer into translate tool state. This is available only
        for the node contexts that support the move tools. If wait_for_exit
        is True, then the function will not return until the viewer exits
        the tool.
        
        
        """
        pass
        
    
    def showHandle(name, value):
        """
        showHandle(self, name, value)
        
        Shows or hides a display handle linked to the current tool state.
        This API is typically used with Python states and can be called from
        any python state callbacks -- with one small caveat. Avoid calling
        showHandle from the python state constructor, doing so will lead to
        a runtime error.
        
        See also hou.Handle.show.
        
        
        name
        The name of the handle as specified with
        hou.ViewerStateTemplate.bindHandle
        
        value
        Bool value, True to show the handle, False to hide it.
        
        
        """
        pass
        
    
    def isGroupListShowingEmptyGroups():
        """
        isGroupListShowingEmptyGroups(self)
        
        Returns true if the group list gadget is including empty groups in
        its list.
        
        
        """
        pass
        
    
    def snappingMode():
        """
        snappingMode(self)
        
        
        """
        pass
        
    
    def denoise():
        """
        denoise(self) -> bool
        
        Denoising setting for non-GL renders (on/off).
        
        
        """
        pass
        
    
    def currentGeometrySelection():
        """
        currentGeometrySelection(self) -> hou.GeometrySelection
        
        Returns the current geometry selection if the viewer is in a
        geometry select mode and otherwise returns None.
        
        
        """
        pass
        
    
    def setPickingCurrentNode(on):
        """
        setPickingCurrentNode(self, on)
        
        Tells this viewer whether picks should be made on the Current SOP or
        on the Display SOP.
        
        
        """
        pass
        
    
    def setCurrentGeometrySelection(geometry_type, nodes, selections):
        """
        setCurrentGeometrySelection(self, geometry_type, nodes, selections)
        
        Replaces a current geometry selection if the viewer is in a geometry
        select mode and otherwise raises hou.NotAvailable. Any of the
        specified selections not matching geometry_type will be
        automatically converted to that type where possible.
        
        
        """
        pass
        
    
    def setGroupListMask(mask):
        """
        setGroupListMask(self, mask)
        
        Sets the mask value in the group list gadget for this viewer. This
        can be a filter applied to the component groups, or an attribute
        name (starting with an @ character), or a connectivity type.
        
        
        """
        pass
        
    
    def selectOrientedPositions(prompt='Click, to, specify, a, position', number_of_positions=1, connect_positions=True, show_coordinates=True, bbox=BoundingBox():
        """
        selectOrientedPositions(self, prompt='Click to specify a position',
        number_of_positions=1, connect_positions=True, show_coordinates=True,
        bbox=BoundingBox(),icon=None, label=None) -> tuple of (Vector3, Matrix3)
        tuples
        
        This method is very similar to hou.SceneViewer.selectPositions,
        except the position type is always world space, and instead of a
        tuple of positions this returns a tuple of (position, orientation)
        pairs, with the position a hou.Vector3 and the orientation a
        hou.Matrix3. This allows you to prompt the user for oriented
        position, respecting possible orientation aids such as the
        construction plane and alignment.
        
        
        """
        pass
        
    
    def stage():
        """
        stage(self)
        
        
        """
        pass
        
    
    def beginStateUndo(label):
        """
        beginStateUndo(self, label)
        
        Opens an undo block to perform undoable operations with the current
        viewer state. All operations performed after the opening will appear
        as one single operation on the undo stack. Use
        hou.SceneViewer.endStateUndo to close an open block.
        
        beginStateUndo and endStateUndo can be used for managing an undo
        block that begins in one function but ends in another one. Only one
        undo block is supported for a sequence of undoable operations.
        Exceptions will be raised if a call to a second beginStateUndo is
        detected before the undo block is closed by endStateUndo.
        
        Python state example of a valid undo block:
        
        > def onMouseEvent(self, kwargs):
        >     ui_event = kwargs["ui_event"]
        >     node = kwargs["node"]
        >     if ui_event.reason() == hou.uiEventReason.Start:
        >         # left mouse button pressed
        >         self.scale = node.parent().parm("scale").evalAsFloat()
        >         self.scene_viewer.beginStateUndo('scale')
        >
        >     if ui_event.reason() == hou.uiEventReason.Active:
        >         # left mouse button down while the mouse is moving
        >         self.scale *= 1.01
        >         node.parent().parm("scale").set(self.scale)
        >
        >     if ui_event.reason() == hou.uiEventReason.Changed:
        >         # left mouse button released
        >         self.scene_viewer.endStateUndo()
        
        Example of a non-valid undo block that raises an exception:
        
        > def onMouseEvent(self, kwargs):
        >     ui_event = kwargs["ui_event"]
        >     node = kwargs["node"]
        >     if ui_event.reason() == hou.uiEventReason.Start:
        >         # left mouse button pressed
        >         self.tx = node.parent().parm("tx").evalAsFloat()
        >         self.scale = node.parent().parm("scale").evalAsFloat()
        >         self.scene_viewer.beginStateUndo('scale')
        >
        >     if ui_event.reason() == hou.uiEventReason.Active:
        >         # left mouse button down while the mouse is moving
        >         self.scale *= 1.01
        >         node.parent().parm("scale").set(self.scale)
        >
        >         self.scene_viewer.beginStateUndo('move x')
        >         self.tx += 0.2
        >         node.parent().parm("tx").set(self.tx)
        >         self.scene_viewer.endStateUndo()
        >
        >     if ui_event.reason() == hou.uiEventReason.Changed:
        >         # left mouse button released
        >         self.scene_viewer.endStateUndo()
        
        label
        The label of the undo block used for displaying the undo
        operation in the Edit menu. An exception is raised if the label
        is empty.
        
        
        """
        pass
        
    
    def setGroupListShowingEmptyGroups(on):
        """
        setGroupListShowingEmptyGroups(self, on)
        
        Turns on or off the display of empty groups in the group list
        gadget.
        
        
        """
        pass
        
    
    def setGroupListShowingOnlyPreSelectedGroups(on):
        """
        setGroupListShowingOnlyPreSelectedGroups(self, on)
        
        Turns on or off the trimming of the group list to show only groups
        that contain one or more selected or pre-selected components.
        
        
        """
        pass
        
    
    def _evalCurrentStateParm():
        """None"""
        pass
        
    
    def setHydraRenderer(ren_name):
        """
        setHydraRenderer(self, ren_name)
        
        
        """
        pass
        
    
    def setSnappingMode(snapping_mode):
        """
        setSnappingMode(self, snapping_mode)
        
        
        """
        pass
        
    
    def enterRotateToolState(wait_for_exit=False):
        """
        enterRotateToolState(self, wait_for_exit=False)
        
        Enters the viewer into rotate tool state. This is available only for
        the node contexts that support the move tools. If wait_for_exit is
        True, then the function will not return until the viewer exits the
        tool.
        
        
        """
        pass
        
    
    def setGroupListSize(width, height):
        """
        setGroupListSize(self, width, height)
        
        Sets the size in inches of the group list gadget.
        
        
        """
        pass
        
    
    def pickFacing():
        """
        pickFacing(self)
        
        Returns a value indicating whether the user is able to pick front
        facing components, back facing components, or both. This option
        corresponds to the frant and back facing options in the component
        selection button's context menu.
        
        
        """
        pass
        
    
    def triggerStateSelector(action, name=None):
        """
        triggerStateSelector(self, action, name=None)
        
        Triggers an action on a selector of the current state. The state
        must be a Python state type or an exception is thrown.
        
        
        action
        The type of action to trigger as specified with
        hou.triggerSelectorAction.
        
        name
        The name of a selector to trigger, should match the name used
        for registering the selector, see
        hou.ViewerStateTemplate.bindGeometrySelector or
        hou.ViewerStateTemplate.bindObjectSelector for details.
        
        The value can be empty (default) in which case the state first
        registered selector is triggered. An exception is thrown if name
        is not a known selector.
        
        
        """
        pass
        
    
    def showSelection():
        """
        showSelection(self) -> bool
        
        
        """
        pass
        
    
    def hydraRenderers():
        """
        hydraRenderers(self) -> tuple of str
        
        
        """
        pass
        
    
    def selectionMode():
        """
        selectionMode(self)
        
        Returns the selection mode of the viewer of type hou.selectionMode.
        
        
        """
        pass
        
    
    def displayRadialMenu():
        """None"""
        pass
        
    
    def flipbookSettings():
        """
        flipbookSettings(self) -> hou.FlipbookSettings
        
        Access to the flipbook dialog settings, which can be queried, set,
        or copied.
        
        
        """
        pass
        
    
    def selectDynamicsPoints(prompt='Select, dynamics, points', sel_index=0, quick_select=False, use_existing_selection=True, allow_multisel=True, only_select_points=True, object_based_point_selection=False, use_last_selected_object=False, icon=None, label=None, prior_selection_paths=[], prior_selection_ids=[], prior_selections=[]):
        """
        selectDynamicsPoints(self, prompt='Select dynamics points', sel_index=0,
        quick_select=False, use_existing_selection=True, allow_multisel=True,
        only_select_points=True, object_based_point_selection=False,
        use_last_selected_object=False, icon=None, label=None,
        prior_selection_paths=[], prior_selection_ids=[], prior_selections=[])
        -> tuple of (hou.DopData, hou.GeometrySelection)
        
        
        """
        pass
        
    
    def setSecureSelection(on):
        """
        setSecureSelection(self, on)
        
        Turns on or off the secure selection option in this viewer.
        
        
        """
        pass
        
    
    def flipbook(viewport=None, settings=None, open_dialog=False):
        """
        flipbook(self, viewport=None, settings=None, open_dialog=False)
        
        Capture a flipbook. A flipbook creates a quick preview animation by
        taking consecutive screenshots of a viewport at each frame.
        
        
        viewport
        A
        
        Launch a flipbook for viewport if specified or the current viewport
        if viewport is not. Optionally a hou.FlipbookSettings object can be
        passed to settings which will override the current settings. This
        override will only affect the current flipbook and not change the
        dialog settings. If open_dialog is True, the flipbook dialog is
        presented to the user, otherwise a flipbook is launched immediately.
        
        
        """
        pass
        
    
    def setShowSelection(show):
        """
        setShowSelection(self, show)
        
        
        """
        pass
        
    
    def setPickGeometryType(geometry_type):
        """
        setPickGeometryType(self, geometry_type)
        
        Sets the type of geometry that will be picked in this viewer. This
        value can be changed at any time by the user, or when a selector is
        invoked.
        
        
        """
        pass
        
    
    def enterScaleToolState(wait_for_exit=False):
        """
        enterScaleToolState(self, wait_for_exit=False)
        
        Enters the viewer into scale tool state. This is available only for
        the node contexts that support the move tools. If wait_for_exit is
        True, then the function will not return until the viewer exits the
        tool.
        
        
        """
        pass
        
    
    def isPickingCurrentNode():
        """
        isPickingCurrentNode(self)
        
        Returns true if selections made in this viewer will pick from the
        Current SOP. If not, the pick occurs on the Display SOP. This option
        corresponds to the current/display option in the component selection
        button's context menu.
        
        
        """
        pass
        
    
    def selectObjects(prompt='Select, objects', sel_index=0, allow_drag=False, quick_select=False, use_existing_selection=True, allow_multisel=True, allowed_types=('*'):
        """
        selectObjects(self, prompt='Select objects', sel_index=0,
        allow_drag=False, quick_select=False, use_existing_selection=True,
        allow_multisel=True, allowed_types=('*',), icon=None, label=None,
        prior_selection_paths=[], prior_selection_ids=[], prior_selections=[])
        -> tuple of Nodes
        
        
        """
        pass
        
    
    def pickGeometryType():
        """
        pickGeometryType(self)
        
        Returns the type of geometry that will be picked in this viewer.
        This option corresponds to the component types selectable in the
        component selection button's context menu.
        
        
        """
        pass
        
    
    def setPickFacing(facing):
        """
        setPickFacing(self, facing)
        
        Sets the option of whether to restrict selection to front facing,
        back facing, or either type of components.
        
        
        """
        pass
        
    
    def selectDynamicsPolygons(prompt='Select, dynamics, polygons', sel_index=0, quick_select=False, use_existing_selection=True, object_based_point_selection=False, use_last_selected_object=False, icon=None, label=None, prior_selection_paths=[], prior_selection_ids=[], prior_selections=[]):
        """
        selectDynamicsPolygons(self, prompt='Select dynamics polygons',
        sel_index=0, quick_select=False, use_existing_selection=True,
        object_based_point_selection=False, use_last_selected_object=False,
        icon=None, label=None, prior_selection_paths=[], prior_selection_ids=[],
        prior_selections=[]) -> tuple of (hou.DopData, hou.GeometrySelection)
        
        
        """
        pass
        
    
    def enterViewState(wait_for_exit=False):
        """
        enterViewState(self, wait_for_exit=False)
        
        Enters the viewer into view tool state. If wait_for_exit is True,
        then the function will not return until the viewer exits the tool.
        
        
        """
        pass
        
    
    def setShowGeometry(show):
        """
        setShowGeometry(self, show)
        
        
        """
        pass
        
    
    def currentSceneGraphSelection():
        """
        currentSceneGraphSelection() -> tuple of string
        
        
        """
        pass
        
    
    def isGroupListCondensingPathHierarchies():
        """
        isGroupListCondensingPathHierarchies(self)
        
        Returns true if the group list will condense the hierarchy of groups
        defined by a string attribute representing a path.
        
        
        """
        pass
        
    
    def currentState():
        """
        currentState(self) -> string
        
        Returns the name of the viewer's current tool state.
        
        
        """
        pass
        
    
    def viewerType():
        """
        viewerType(self) -> hou.stateViewerType enum value
        
        Returns the type of the viewer, either Scene for a viewer looking at
        Objects, SOPs, or DOPs; or SceneGraph for a viewer looking at LOPs.
        
        
        """
        pass
        
    
    def _getCurrentStateParmNames():
        """None"""
        pass
        
    
    def setDenoise(enable):
        """
        setDenoise(self, enable)
        
        Enables denoising for non-GL renders.
        
        
        """
        pass
        
    
    def groupListType():
        """
        groupListType(self)
        
        Returns the type of component listed in the group list gadget.
        
        
        """
        pass
        
    
    def setSelectionMode(selection_mode):
        """
        setSelectionMode(self, selection_mode)
        
        Sets the selection mode of this view. The value for 'selection_mode'
        must be from hou.selectionMode.
        
        
        """
        pass
        
    
    def setShowLights(show):
        """
        setShowLights(self, show)
        
        
        """
        pass
        
    
    def setShowCameras(show):
        """
        setShowCameras(self, show)
        
        
        """
        pass
        
    
    def runShelfTool(tool_name):
        """
        runShelfTool(self, tool_name)
        
        Run the named shelf tool in the current viewport.
        
        
        """
        pass
        
    
    def setWholeGeometryPicking(on):
        """
        setWholeGeometryPicking(self, on)
        
        Turns on or off the option to expand selections made in this viewer
        to include the entire geometry.
        
        
        """
        pass
        
    
    def setDepthSnapping(on):
        """
        setDepthSnapping(self, on)
        
        
        """
        pass
        
    
    def clearPromptMessage():
        """
        clearPromptMessage(self)
        
        Clear the prompt message previously set with
        hou.SceneViewer.setPromptMessage.
        
        
        """
        pass
        
    
    def setCurrentState(state, wait_for_exit=False, generate=hou.stateGenerateMode.Insert, request_new_on_generate=True):
        """
        setCurrentState(self, state, wait_for_exit=False,
        generate=hou.stateGenerateMode.Insert, request_new_on_generate=True)
        
        Sets the current tool state of the viewer. If wait_for_exit is True,
        then the function will not return until the viewer exits the tool.
        
        
        generate
        A hou.stateGenerateMode enumeration value to specify how a new
        node should be generated, inserted inline or into a new branch.
        
        request_new_on_generate
        Some states reuse the current node whenever possible. Setting
        this argument to True requests that such states generate a new
        node.
        
        
        """
        pass
        
    
    def defaultPickModifier():
        """
        defaultPickModifier(self)
        
        Returns the default pick modifier to which Houdini will revert after
        a select state terminates.
        
        
        """
        pass
        
    
    def setPickStyle(style):
        """
        setPickStyle(self, style)
        
        Sets the style of area picking to be used by this viewer.
        
        
        """
        pass
        
    
    def showCameras():
        """
        showCameras(self) -> bool
        
        
        """
        pass
        
    
    def setGroupPicking(on):
        """
        setGroupPicking(self, on)
        
        Turns on or off the group, attribute, or connectivity based picking.
        When turned on, the group list gadget is automatically made visible.
        
        
        """
        pass
        
    
    def stageSerial():
        """
        stageSerial() -> int
        
        Integer that is increased every time the Scene Graph View data is
        modified. Only count on this number to be bigger when changes occur,
        and not necessarily incremented by 1.
        
        
        """
        pass
        
    
    def isGroupListColoringGeometry():
        """
        isGroupListColoringGeometry(self)
        
        Returns true if the group list gadget is configured to color
        geometry in the viewer based on group membership or attribute value.
        
        
        """
        pass
        
    
    def snappingGravity():
        """
        snappingGravity(self): -> float
        
        Returns the gravity value for the current snapping mode.
        
        
        """
        pass
        
    
    def isOrientingOnSnap():
        """
        isOrientingOnSnap(self)
        
        
        """
        pass
        
    
    def isGroupPicking():
        """
        isGroupPicking(self)
        
        Returns true if group, attribute, or connectivity information will
        be used to automatically expand selections made in this viewer. This
        option corresponds to the matching check box in the component
        selection button's context menu.
        
        
        """
        pass
        
    
    def viewportLayout():
        """
        viewportLayout(self) -> hou.geometryViewportLayout
        
        Returns the current viewport layout as a hou.geometryViewportLayout
        value.
        
        
        """
        pass
        
    
    def _setCurrentStateParm():
        """None"""
        pass
        
    
    def constructionPlane():
        """
        constructionPlane(self) -> hou.ConstructionPlane
        
        Return the construction plane (or grid) in the perspective viewport
        of this viewer.
        
        See hou.ConstructionPlane for more information.
        
        
        """
        pass
        
    
    def isPickingVisibleGeometry():
        """
        isPickingVisibleGeometry(self)
        
        Returns true if the viewer is configured to only pick visible
        components when performing an area-based selection. This option
        corresponds to the matching check box in the component selection
        button's context menu.
        
        
        """
        pass
        
    
    def isSecureSelection():
        """
        isSecureSelection(self)
        
        Returns true if secure selection is turned on in this viewer. This
        option corresponds to the secure selection option in the select
        tool's context menu.
        
        
        """
        pass
        
    
    def setViewportLayout(layout, single=-1):
        """
        setViewportLayout(self, layout, single=-1)
        
        Sets the viewer's viewport layout.
        
        
        layout
        A hou.geometryViewportLayout value. For example, to set the
        viewer to show four viewports at the corners:
        
        > viewer_pane.setViewportLayout(hou.geometryViewportLayout.Quad)
        
        single
        If you specify the layout, this argument lets you specify which
        of the four viewports from the quad view to show as the single
        
        -1
        
        Use the current viewport (the viewport the mouse is/was over).
        
        0
        
        Use the top-left viewport from the quad layout (usually the Top
        view).
        
        1
        
        Use the top-right viewport from the quad layout (usually the
        Perspective view).
        
        2
        
        Use the bottom-left viewport from the quad layout (usually the
        Front view).
        
        3
        
        Use the bottom-right viewport from the quad layout (usually the
        Right view).
        
        
        """
        pass
        
    
    def setPromptMessage(message, message_type=promptMessageType.Prompt):
        """
        setPromptMessage(self, message, message_type=promptMessageType.Prompt)
        
        Sets the viewport to display a message at the bottom of the screen.
        
        
        message
        Text message to display.
        
        message_type
        A hou.promptMessageType value representing the type of message
        to display. Defaults to hou.promptMessageType.Prompt.
        
        
        """
        pass
        
    
    def pickModifier():
        """
        pickModifier(self)
        
        Returns the manner in which additional selection are combined with
        the existing selection. This option corresponds to the picking
        modifier in the select tool context menu.
        
        
        """
        pass
        
    
    def isDepthSnapping():
        """
        isDepthSnapping(self)
        
        
        """
        pass
        
    
    def findViewport(name):
        """
        findViewport(self, name) -> hou.GeometryViewport
        
        
        """
        pass
        
    
    def setGroupListType(group_list_type):
        """
        setGroupListType(self, group_list_type)
        
        Sets the type of component listed in the group list gadget. This can
        be set to a specific component type or to follow the current
        component selection type.
        
        
        """
        pass
        
    
    def isPickingContainedGeometry():
        """
        isPickingContainedGeometry(self)
        
        Returns true if the viewer is configured to only pick fully
        contained components when performing an area-based selection. This
        option corresponds to the matching check box in the component
        selection button's context menu.
        
        
        """
        pass
        
    
    def selectPositions(prompt='Click, to, specify, a, position', number_of_positions=1, connect_positions=True, show_coordinates=True, bbox=BoundingBox():
        """
        selectPositions(self, prompt='Click to specify a position',
        number_of_positions=1, connect_positions=True, show_coordinates=True,
        bbox=BoundingBox(), position_type=positionType.WorldSpace, icon=None,
        label=None) -> tuple of Vector3s
        
        
        """
        pass
        
    
    def currentHydraRenderer():
        """
        currentHydraRenderer(self) -> str
        
        
        """
        pass
        
    
    def showGeometry():
        """
        showGeometry(self) -> bool
        
        
        """
        pass
        
    
    def currentStateSelector():
        """
        currentStateSelector(self) -> string
        
        Returns the name of the current state selector. If no selector is
        active, an empty string is returned. The state must be a Python
        state type or an exception is thrown.
        
        
        """
        pass
        
    
    def referencePlane():
        """
        referencePlane(self) -> hou.ReferencePlane
        
        Return the reference plane (or grid) in the perspective viewport of
        this viewer.
        
        See hou.ReferencePlane for more information.
        
        
        """
        pass
        
    
    def showLights():
        """
        showLights(self) -> bool
        
        
        """
        pass
        
    
    def setPickModifier(modifier):
        """
        setPickModifier(self, modifier)
        
        Sets the method used to modify the existing selection when a new
        selection is made. Modifier keys can still be used to alter this
        behavior. Only the default operation (with no modifier keys) is
        affected by this setting. Note that the select state will revert to
        the default pick modifier upon termination, so to make your change
        persist beyond this you will also need to change this default using
        setDefaultPickModifier().
        
        
        """
        pass
        
    
    def _pressCurrentStateButton():
        """None"""
        pass
        
    
    def isGroupListShowingOnlyPreSelectedGroups():
        """
        isGroupListShowingOnlyPreSelectedGroups(self)
        
        Returns true if the group list is showing only groups that contain
        one or more selected or pre-selected components.
        
        
        """
        pass
        
    
    def viewports():
        """
        viewports(self) -> tuple of hou.GeometryViewports
        
        
        """
        pass
        
    
    def isSnappingToOtherObjects():
        """
        isSnappingToOtherObjects(self)
        
        
        """
        pass
        
    
    def isCreateInContext():
        """
        isCreateInContext(self) -> bool
        
        
        """
        pass
        
    
    def isGroupListVisible():
        """
        isGroupListVisible(self)
        
        Returns true if the group list gadget has been turned on for this
        viewer. This function only refers to the option to show the group
        list when not selecting groups in the viewer. In that case the group
        list will be visible, but this function may still return False.
        
        
        """
        pass
        

def SceneViewer_swigregister():
    """None"""
    pass
    

class ScriptEvalContext(object):
    """
    hou.ScriptEvalContext
    
    Use this to temporarily change the scripting evaluation context within a
    Python code block.
    
    
    """
    
    def node():
        """
        node(self)
        
        Return the hou.Node for this context.
        
        
        """
        pass
        
    
    def parm():
        """
        parm(self)
        
        Return the hou.Parm for this context. Returns None if this context
        was created from a hou.Node.
        
        @related
        
        * hou.evaluatingParm
        
        
        """
        pass
        

def ScriptEvalContext_swigregister():
    """None"""
    pass
    

class Selection(object):
    """
    hou.Selection
    
    A class that represents a geometry component selection.
    
    Component selections are not tied to any specific hou.Geometry.
    Therefore most method on this class must be passed a Geometry object to
    look up information about individual components. This explicit
    separation allows the selection class to be used as a utility class for
    processing geometry topology (growing the set of components, shrinking
    it, finding the boundary, etc.). This separation also avoids any
    expectations that changing the contents of a selection object might be
    expected to update the selection visible on some geometry in the
    viewport. Setting the visible viewport selection must always be an
    explicit operation on a hou.SopNode in order for Houdini to be able to
    track changes properly.
    
    If a selection object is returned from a call to hou.Geometry.selection,
    hou.GeometrySelection.selections, or a hou.SopNode.selection, the
    selection cannot be modified. A copy of the selection must be made first
    with the freeze() method. This new selection can be modified, and passed
    back into a hou.SopNode.setSelection if desired. Because each SOP has a
    selection for each component type, when you set a new selection it will
    replace the existing selection of that component type. Note that this
    may not result in the visible selection in the viewport changing if the
    viewport is not currently configured to select that component type. The
    viewport selection type can be controlled with the hou.SceneViewer
    class. A selection created by calling any of the hou.Selection()
    initializer methods are created in a modifiable state, so a call to
    freeze() is not required.
    
    A selection returned from a hou.Geometry or a hou.SopNode is a reference
    to the source selection, and so will change if the selection on the
    source geometry is changed. This seems like a departure from the
    separation of selection objects from any particular geometry, however it
    matches the behavior of the hou.Geometry class returned from a SOP node.
    This is because the underlying selection data is shared with the SOP
    rather than copied. The freeze() method can be used to force a copy of
    the selection data that is disconnected from any particular SOP (as well
    as allowing the selection contents to be modified).
    
    
    """
    
    def selectionString(geo, force_numeric, =, False, collapse_where_possible, =, True, asterisk_to_select_all, =, False):
        """
        selectionString(self, geo, force_numeric = False,
        collapse_where_possible = True, asterisk_to_select_all = False) -> str
        
        Returns a string that specifies the selected components. The format
        of this string is appropriate for use in SOP Group parameter fields.
        
        
        geo
        A hou.Geometry object that is used when generating the selection
        string (such as determining if all components are selected).
        
        force_numeric
        Set this to True to force the generated string to contain only
        numeric ranges, even if the selection was constructed with group
        or attribute based selection.
        
        collapse_where_possible
        Set this to True to cause numeric ranges to be collapsed as much
        as possible, regardless of the selection order. So for example
        if the user selected primitive 3, then 2, then 1, the generated
        selection string would either be '3 2 1' or '1-3' depending on
        this parameter.
        
        asterisk_to_select_all
        When this parameter is set to False, if a selection contains all
        components in the supplied geometry, the resulting value is an
        empty string. This is appropriate when using the resulting
        string in a SOP node Group parameter. If this parameter is set
        to True, a full selection will return a value of '*' instead.
        
        
        """
        pass
        
    
    def freeze():
        """
        freeze(self) -> hou.Selection
        
        Returns a copy of the Selection object. This copy can be modified
        with any of the functions that alter the selection.
        
        
        """
        pass
        
    
    def clear():
        """
        clear(self)
        
        Removes all components from the current selection.
        
        
        """
        pass
        
    
    def edges(geo):
        """
        edges(self, geo) -> tuple of hou.Edge
        
        Returns a tuple of all edges in the selection. If the selection does
        not contain edges, an implicit conversion to edges is performed to
        generate the return value.
        
        
        """
        pass
        
    
    def numSelected():
        """
        numSelected(self)
        
        Returns the number of components in the selection.
        
        
        """
        pass
        
    
    def grow(geo, uv_connectivity, =, False):
        """
        grow(self, geo, uv_connectivity = False)
        
        Using the supplied hou.Geometry object for reference, adds to the
        selection any components connected to the current selection. The
        uv_connectivity parameter controls whether to use topology or uv
        attribute values to determine whether components are connected.
        
        
        """
        pass
        
    
    def convert(geo, selection_type):
        """
        convert(self, geo, selection_type)
        
        Using the supplied hou.Geometry object for reference, converts the
        current selection to the new hou.geometryType.
        
        
        """
        pass
        
    
    def selectionType():
        """
        selectionType(self)
        
        Returns a hou.geometryType value indicating the type of component
        referenced by this selection.
        
        
        """
        pass
        
    
    def invert(geo):
        """
        invert(self, geo)
        
        Using the supplied hou.Geometry object for reference, inverts the
        current selection. The selection will contain only those components
        that were not in the selection before this method call.
        
        
        """
        pass
        
    
    def vertices(geo):
        """
        vertices(self, geo) -> tuple of hou.Vertex
        
        Returns a tuple of all vertices in the selection. If the selection
        does not contain vertices, an implicit conversion to vertices is
        performed to generate the return value.
        
        
        """
        pass
        
    
    def points(geo):
        """
        points(self, geo) -> tuple of hou.Point
        
        Returns a tuple of all points in the selection. If the selection
        does not contain points, an implicit conversion to points is
        performed to generate the return value.
        
        
        """
        pass
        
    
    def combine(geo, selection, modifier):
        """
        combine(self, geo, selection, modifier)
        
        Using the supplied hou.Geometry object for reference, combines this
        selection with another.
        
        
        geo
        A hou.Geometry object that is used when doing any selection
        conversions.
        
        selection
        A hou.Selection object that will be combined with the current
        selection. If this selection does not have the same component
        type as the current selection, an implicit conversion to the
        current component type is performed before combining the
        selections.
        
        modifier
        A hou.pickModifier value that controls how the selections will
        be combined. This lets you perform a union, intersection, or
        other operation on a pairs of selections.
        
        
        """
        pass
        
    
    def prims(goe):
        """
        prims(self, goe) -> tuple of hou.Prim
        
        Returns a tuple of all primitives in the selection. If the selection
        does not contain primitives, an implicit conversion to primitives is
        performed to generate the return value.
        
        
        """
        pass
        
    
    def boundary(geo, uv_connectivity, =, False):
        """
        boundary(self, geo, uv_connectivity = False)
        
        Using the supplied hou.Geometry object for reference, changes the
        selection to contain those components on the boundary of the current
        selection. The uv_connectivity parameter controls whether to use
        topology or uv attribute values to determine whether components are
        connected.
        
        
        """
        pass
        
    
    def shrink(geo, uv_connectivity, =, False):
        """
        shrink(self, geo, uv_connectivity = False)
        
        Using the supplied hou.Geometry object for reference, removes from
        the selection any components on the boundary of the current
        selection. The uv_connectivity parameter controls whether to use
        topology or uv attribute values to determine whether components are
        connected.
        
        
        """
        pass
        

def Selection_swigregister():
    """None"""
    pass
    

class Selector(object):
    """
    hou.Selector
    
    Describes how Houdini should prompt the user to choose geometry in the
    viewport when creating a new SOP node instance.
    
    Use hou.SopNodeType.addSelector to create a selector and add it to a SOP
    node type. When the user creates a new instance of a node type in the
    viewer, Houdini will invoke all of its selectors sequentially. Each
    selector prompts the user to select geometry. When all selectors have
    been invoked, Houdini creates the new node and each selector connects
    its input nodes and fills in any group parameters on the node to match
    what was selected.
    
    
    """
    
    def prompt():
        """
        prompt(self) -> str
        
        A string to display at the bottom of the viewer to instruct the user
        what to select.
        
        
        """
        pass
        
    
    def inputIndex():
        """
        inputIndex(self) -> int
        
        Return the index of the input connector on the SOP node where the
        selector should wire input SOPs. A cookie SOP, for example, has two
        input connectors and one selector for each input connector.
        
        
        """
        pass
        
    
    def inputRequired():
        """
        inputRequired(self) -> bool
        
        Return whether or not this input is required or optional. If the
        user does not select any geometry and the input is not required, the
        selector will not connect anything to its input connector.
        
        
        """
        pass
        
    
    def primitiveTypes():
        """
        primitiveTypes(self) -> tuple of hou.primType enum values
        
        Return a sequence of hou.primType enumeration values to specify what
        primitive types are allowed.
        
        Note that if you pass an empty sequence for the primitive_types
        parameter in hou.SopNodeType.addSelector and then call this method
        on the newly-created selector, this method will return a tuple of
        all primitive types.
        
        
        """
        pass
        
    
    def allowDragging():
        """
        allowDragging(self) -> bool
        
        Return whether the user is allowed to select the geometry and begin
        manipulating the handles with a single mouse click. A transform SOP,
        for example, lets you select the geometry and drag it right away.
        Dragging the geometry forces the selector to finish immediately, the
        selector connects the input and sets the group parameter, and
        subsequent mouse movements are passed to the handle which translates
        the geometry by changing parameter values.
        
        
        """
        pass
        
    
    def geometryTypes():
        """
        geometryTypes(self) -> tuple of hou.geometryType enum values
        
        Return a tuple of hou.geometryType enumeration values. This tuple
        describes which geometry entities (e.g. points, primitives, edges,
        etc.) the selector allows. Note that this list is a property of the
        selector type and you cannot specify it when creating a new
        selector. Instead, you must choose a selector type with the desired
        geometry types.
        
        See hou.SopNodeType.selectors for a function that returns a list of
        all the selector types. The following function will return the
        geometry types for a particular selector type.
        
        > def geometryTypesForSelectorType(selector_type):
        >     '''Given a selector type name, return the tuple of geometry types it
        >        will select.'''
        >     # First find a node type that uses this selector.
        >     for node_type in hou.sopNodeTypeCategory().nodeTypes().values():
        >         # Skip manager nodes, like shopnets, ropnets, etc.
        >         if not isinstance(node_type, hou.SopNodeType):
        >             continue
        >
        >         for selector in node_type.selectors():
        >             if selector_type == selector.selectorType():
        >                 return selector.geometryTypes()
        >
        >     # The selector type name is invalid.
        >     raise hou.OperationFailed("Invalid selector type")
        
        """
        pass
        
    
    def ordered():
        """
        ordered(self) -> bool
        
        Return whether or not this selector preserves the order in which the
        user selected the geometry.
        
        For example, the selector is for points and the user clicks on
        points 1, 0, and 2, in that order, an ordered selector will set the
        SOP's group parameter to "1 0 2", while an unordered selector will
        set it to "0-2". For SOPs where the order of the group selector
        matters, use ordered selectors.
        
        Whether or not a selector is ordered is a property of the selector
        type, and you cannot specify it when creating a new selector.
        Instead, you must choose the appropriate selector type. For example,
        "prims" is an unordered selector type, but "ordered_prims" is
        ordered. See hou.Selector.geometryTypes for a function that can be
        adapted to determine if a selector is ordered, and see
        hou.SopNodeType.selectors for a function to list all the selector
        types.
        
        
        """
        pass
        
    
    def groupParmName():
        """
        groupParmName(self) -> str
        
        Return the name of the SOP node parameter containing the group
        field. The selector will set this parameter to the string
        representing the points, primitives, edges, etc. chosen by the user
        in the viewer. It is typically named "group".
        
        
        """
        pass
        
    
    def groupTypeParmValues():
        """
        groupTypeParmValues(self) -> tuple of int
        
        Return a tuple of indices mapping geometry types to indices on the
        geometry type parameter menu.
        
        Whether or not a selector is ordered is a property of the selector
        type, and you cannot specify it when creating a new selector.
        Instead, you must choose the appropriate selector type. For example,
        the "everything" selector can select primitives, primitive groups,
        points, point groups, edges, and breakpoints. It sets a group type
        menu parameter to match the type of selection, and this menu must
        have the entries "Guess from Group", "Breakpoints", "Edges",
        "Points", and "Primitives". For an "everything" selector, this
        method returns (4, 4, 3, 3, 2, 1), mapping the geometry element
        types to 0-based entries in the menu. For example, if the user
        selects edges, the selector will look up the fifth element (2) and
        set the menu parameter to the item at index 2 ("Edges").
        
        The length of the tuple of ints is the same as
        len(self.geometryTypes). If this selector is not intended to work
        with a menu parameter, each value in the tuple will be -1.
        
        See also hou.Selector.geometryTypes.
        
        
        """
        pass
        
    
    def groupTypeParmName():
        """
        groupTypeParmName(self) -> str
        
        Return the name of the SOP node parameter containing the menu of
        geometry types. If the selector can select multiple geometry types
        (e.g. points or primitives), it will set this parameter to match the
        type of geometry the user chose. The transform SOP, for example, has
        a Group Type parameter that tells it how to interpret the string in
        the Group parameter. For such selectors, the parameter is typically
        named "grouptype". For selectors that do not allow multiple geometry
        types, this parameter is usually "".
        
        
        """
        pass
        
    
    def nodeType():
        """
        nodeType(self) -> hou.NodeType
        
        Return the node type that this selector is attached to.
        
        
        """
        pass
        
    
    def name():
        """
        name(self) -> str
        
        Return the name of this selector. The name is unique within the node
        type it is attached to.
        
        
        """
        pass
        
    
    def emptyStringSelectsAll():
        """
        emptyStringSelectsAll(self) -> bool
        
        Return whether or not use an empty string in the group parameter if
        the user selects all the geometry. If False, Houdini will place an
        asterisk (*) in the group parameter when the user selects all the
        geometry. Most SOPs use an empty string.
        
        
        """
        pass
        
    
    def extraInfo():
        """
        extraInfo(self) -> str
        
        Returns an optional extra info string that contains additional
        settings.
        
        
        """
        pass
        
    
    def selectorType():
        """
        selectorType(self) -> str
        
        Return the name of the type of selector to use. Different selectors
        have different behaviors. For example "prims" will select only
        primitives and is used, for example, by the cookie SOP. "points"
        will select only points, and is used by SOPs like the point SOP.
        "everything" will select any geometry, and is used for SOPs like
        "xform" and "blast".
        
        See hou.SopNodeType.selectors for example code that returns all the
        available selector types.
        
        
        """
        pass
        
    
    def destroy():
        """
        destroy(self)
        
        Remove this selector from its node type.
        
        See also hou.SopNodeType.addSelector.
        
        
        """
        pass
        

def Selector_swigregister():
    """None"""
    pass
    

class SeparatorParmTemplate(ParmTemplate):
    """
    hou.SeparatorParmTemplate
    
    Template for a separator parameter. Separators are just lines between
    parameters and do not store any parameter values.
    
    
    """

def SeparatorParmTemplate_swigregister():
    """None"""
    pass
    

class Shelf(ShelfElement):
    """
    hou.Shelf
    
    Represents a tab of shelf tools.
    
    You can't instantiate this object directly, call hou.shelves.newShelf
    instead.
    
    
    """
    
    def setTools(tools):
        """
        setTools(self, tools)
        
        Replaces the current contents of the shelf with the given list of
        hou.Tool objects.
        
        
        """
        pass
        
    
    def destroy():
        """
        destroy(self)
        
        Removes this shelf tab from Houdini and deletes it from the shelf
        defintion file.
        
        
        """
        pass
        
    
    def tools():
        """
        tools(self) -> tuple of hou.Tool
        
        Returns the tools on this shelf tab.
        
        
        """
        pass
        

class ShelfDock(object):
    """
    hou.ShelfDock
    
    Represents the shelf area at the top of the screen, within which shelf
    sets and shelf tabs exist.
    
    The shelf docking area on any given desktop has space for any number of
    shelf sets, each of which may contain shelf tabs.
    
    RELATED
    
    * hou.Desktop
    
    
    """
    
    def shelfSets():
        """
        shelfSets(self) -> tuple of hou.ShelfSet
        
        Returns a list of the shelf sets in the current shelf dock.
        
        
        """
        pass
        
    
    def show(on):
        """
        show(self, on)
        
        Show or hide the shelf dock by uncollapsing or collapsing its stow
        bar.
        
        
        """
        pass
        
    
    def iconsize():
        """
        iconsize(self) -> (int, int)
        
        Returns the height and width, in pixels, of the icons in the shelf
        at the current "Display Tools As" setting.
        
        
        """
        pass
        

def ShelfDock_swigregister():
    """None"""
    pass
    

class ShelfElement(object):
    """
    hou.ShelfElement
    
    Superclass of shelf tools, shelf tabs, and shelf sets.
    
    
    """
    
    def setName(name):
        """
        setName(self, name)
        
        Sets this object's internal name. This is how you refer to the
        object in scripts.
        
        The name has similar rules to naming Houdini nodes: it must not
        start with a number, and can only contain letters, numbers, an
        underscores.
        
        For example, if a Tool objects name is foo, you can get a reference
        to it using:
        
        > footool = shelves.tool("foo")
        
        """
        pass
        
    
    def filePath():
        """
        filePath(self) -> str
        
        Returns the file that contains the definition of this object.
        
        
        """
        pass
        
    
    def setLabel(label):
        """
        setLabel(self, label)
        
        Sets the object's human-readable label. This is what's displayed in
        the UI.
        
        
        """
        pass
        
    
    def name():
        """
        name(self) -> str
        
        Returns the internal name of this object.
        
        Multiple objects may have the same name (for example, two different
        assets might both provide a hammer tool), but only one will be
        active at a time in a Houdini session.
        
        
        """
        pass
        
    
    def setFilePath(file_path):
        """
        setFilePath(self, file_path)
        
        Sets the path string for where this object's definition is stored.
        
        
        """
        pass
        
    
    def isReadOnly():
        """
        isReadOnly(self) -> bool
        
        Returns True if the element is read-only (can't be edited).
        
        
        """
        pass
        
    
    def label():
        """
        label(self) -> str
        
        Returns the object's human-readable label.
        
        
        """
        pass
        
    
    def setReadOnly(on):
        """
        setReadOnly(self, on)
        
        > # Get a reference to a tool
        > t = hou.shelves.tool("geometry_sphere")
        > # Prevent the tool from being modified
        > t.setReadOnly(True)
        > # Allow the tool to be modified
        > t.setReadOnly(False)
        
        """
        pass
        

def ShelfElement_swigregister():
    """None"""
    pass
    

class ShelfSet(ShelfElement):
    """
    hou.ShelfSet
    
    Represents a collection of shelf tabs.
    
    You can't instantiate this object directly, call hou.shelves.newShelfSet
    instead.
    
    
    """
    
    def shelves():
        """
        shelves(self) -> tuple of hou.Shelf
        
        Returns the shelf tabs in this shelf set.
        
        
        """
        pass
        
    
    def setShelves(shelves):
        """
        setShelves(self, shelves)
        
        Replaces the current contents of the shelf with the given list of
        hou.Shelf objects.
        
        
        """
        pass
        
    
    def destroy():
        """
        destroy(self)
        
        Removes this shelf set from Houdini and deletes it from the shelf
        definition file.
        
        
        """
        pass
        

def ShelfSet_swigregister():
    """None"""
    pass
    

def Shelf_swigregister():
    """None"""
    pass
    

class ShellIO(object):
    """
    hou.ShellIO
    
    A proxy object that replaces Python's stdin, stdout, and stderr streams
    within Houdini.
    
    This class is mostly an implementation detail of how Houdini replaces
    Python's standard streams with versions that allow Python input and
    output in Houdini windows and pane tabs.
    
    The methods that might be useful outside of internal SideFX scripts are
    addCloseCallback(), removeCloseCallback(), and callbacks(). These let
    you register functions that Houdini calls when the Python shell window
    or pane tab is closed (the equivalent of atexit() scripts in regular
    Python).
    
    The other methods should be considered internal implementation details,
    and you should not use them.
    
    
    """
    
    def isatty():
        """
        isatty(self) -> bool
        
        Implemented as part of the "file-like object" interface.
        
        
        """
        pass
        
    
    def getAndClearWrittenData():
        """
        getAndClearWrittenData(self) -> string
        
        
        """
        pass
        
    
    def isWaitingForCommand():
        """
        isWaitingForCommand(self) -> bool
        
        
        """
        pass
        
    
    def removeExitCallback():
        """None"""
        pass
        
    
    def flush():
        """None"""
        pass
        
    
    def readline(size=-1):
        """
        readline(self, size=-1) -> string
        
        Implemented as part of the "file-like object" interface.
        
        
        """
        pass
        
    
    def addCloseCallback(callback):
        """
        addCloseCallback(callback)
        
        Register a Python callback to be called whenever the last Houdini
        Python Shell is closed.
        
        The argument is a callable object that expects no parameters.
        
        > def cleanup():
        >     # Here is where you would run your cleanup code when
        >     # the Python shell has closed.
        >     pass
        >
        > hou.ui.shellIO().addCloseCallback(cleanup)
        
        You might use this function to cleanly terminate any mechanisms that
        are dependent on the Python shell. For example, you can register a
        callback which disables an object from logging output messages to
        the shell.
        
        
        """
        pass
        
    
    def exitCallbacks():
        """None"""
        pass
        
    
    def addExitCallback():
        """None"""
        pass
        
    
    def addDataForReading(data):
        """
        addDataForReading(self, data)
        
        
        """
        pass
        
    
    def write(data):
        """
        write(self, data)
        
        Implemented as part of the "file-like object" interface.
        
        
        """
        pass
        
    
    def CloseCallbacks():
        """None"""
        pass
        
    
    def addEOFForReading():
        """
        addEOFForReading(self)
        
        
        """
        pass
        
    
    def setIsWaitingForCommand(on):
        """
        setIsWaitingForCommand(self, on)
        
        
        """
        pass
        
    
    def interruptShellThread():
        """
        interruptShellThread(self)
        
        
        """
        pass
        
    
    def removeCloseCallback(callback):
        """
        removeCloseCallback(callback)
        
        Remove a Python callback that was previously registered with
        hou.ShellIO.addCloseCallback. See hou.ShellIO.addCloseCallback for
        more information.
        
        Raises hou.OperationFailed if the callback was not previously
        registered.
        
        
        """
        pass
        

def ShellIO_swigregister():
    """None"""
    pass
    

class ShopNode(Node):
    """
    hou.ShopNode
    
    The base class for all SHOP nodes in Houdini. An instance of this class
    corresponds to exactly one instance of a node in Houdini.
    
    See hou.Node for more information.
    
    
    """
    
    def shaderType():
        """
        shaderType(self) -> hou.shaderType enum value
        
        Returns a hou.shaderType indicating the type of this shader.
        
        Note that this method is a shortcut for self.type().shaderType(),
        which calls hou.ShopNodeType.shaderType.
        
        
        """
        pass
        
    
    def definingVopNetNode():
        """
        definingVopNetNode(self) -> hou.VopNetNode or None
        
        If this SHOP is defined by a VOP network, return the hou.VopNetNode
        that defines it. Otherwise, return None.
        
        
        """
        pass
        
    
    def supportedRenderers():
        """
        supportedRenderers(self) -> tuple of str
        
        Returns a list of strings describing the renderers this shader
        supports.
        
        
        """
        pass
        
    
    def shaderCode():
        """None"""
        pass
        
    
    def shaderName(as_otl_path=True, shader_type_name=None):
        """
        shaderName(self, as_otl_path=True, shader_type_name=None) -> str
        
        Return the name of the shader inside this SHOP. If as_otl_path is
        True, returns an opdef: path to the SHOP type. The shader_type_name
        is a string indicating the shader context type to use; some nodes
        may provide several shader types, and each may have a different
        name. This is applicable only to multi-context shader nodes, such as
        a vopnet material shop.
        
        
        """
        pass
        
    
    def shaderString(render_type=None):
        """
        shaderString(self, render_type=None) -> str
        
        Return the shader string generated by this shader for the given
        render type. This string is written to the file that is read in by
        the renderer.
        
        
        render_type
        A string representing the renderer. If this string is empty or
        is "*", Houdini uses the default render type for this shader.
        Possible render types include "VMantra" (Mantra), "RIB"
        (RenderMan), "OGL" (OpenGL), "OGL2" (OpenGL 2), and "I3D" (Image
        3D).
        
        You can use hou.ShopNodeType.renderMask to determine the render
        types supported by this SHOP's type. You can also use
        hou.ShopNodeTypeCategory.renderers to get all the possible
        render types. Note that some SHOP types, like the properties
        SHOP or the switch SHOP, have a render mask of "*" to indicate
        that they will work with any shader type.
        
        If you pass in an unknown or unsupported render type, this method
        returns an empty string.
        
        > >>> for node_type_name in ("v_plastic", "ri_matte"):
        > ...     hou.node("/shop").createNode(node_type_name)
        >
        > <hou.ShopNode of type v_plastic at /shop/v_plastic1>
        > <hou.ShopNode of type ri_matte at /shop/ri_matte1>
        >
        > >>> for shop in hou.node("/shop").children():
        > ...     for render_type in shop.type().renderMask().split():
        > ...         print shop.name(), "supports", render_type
        > ...         print "    shader_string:", shop.shaderString(render_type)
        > ...         print
        > v_plastic1 supports VMantra
        >     shader_string: opdef:/Shop/v_plastic
        >
        > v_plastic1 supports OGL
        >     shader_string: /shop/v_plastic1
        >
        > ri_matte1 supports RIB
        >     shader_string: "matte"
        >
        > ri_matte1 supports OGL
        >     shader_string: /shop/ri_matte1
        
        """
        pass
        
    
    def coshaderNodes(parm_name):
        """
        coshaderNodes(self, parm_name) -> tuple of hou.ShopNode
        
        If this SHOP has a co-shader parameter given by parm_name it may
        also have an input corresponding to that parameter. This function
        will return the tuple of hou.ShopNode assigned as co-shaders to this
        SHOP node either via connected input or the operator node path
        specified in that parameter.
        
        If the parameter represents a single co-shader, the array will
        contain at most one element, however if the parameter refers to a
        co-shader array then the tuple may contain more than one element.
        
        
        parm_name
        Co-shader parameter name specifying the co-shader shop to
        return.
        
        
        """
        pass
        

class ShopNodeType(NodeType):
    """
    hou.ShopNodeType
    
    This kind of NodeType contains extra attributes specific to SHOP nodes.
    
    
    """
    
    def shaderType():
        """
        shaderType(self) -> [Hom:hou.shaderType] enum value
        
        Return the type of shader for this SHOP type. For example, this shop
        type might be a surface shader or a displacement shader. See
        hou.shaderType for the possible shader types.
        
        See also hou.ShopNode.shaderType.
        
        
        """
        pass
        
    
    def renderMask():
        """
        renderMask(self) -> string
        
        Return a string with space-separated names of the renderers that
        this SHOP type supports. Note that some SHOP types, like the switch
        SHOP, return "*" to indicate that they support all renderers.
        
        See hou.ShopNode.shaderString for an example.
        
        
        """
        pass
        

def ShopNodeType_swigregister():
    """None"""
    pass
    

def ShopNode_swigregister():
    """None"""
    pass
    

class SopNode(Node):
    """
    hou.SopNode
    
    Represents a surface node.
    
    
    """
    
    def selection(selection_type):
        """
        selection(self, selection_type) -> hou.Selection
        
        Return the current component selection of the specified component
        type.
        
        This method is deprecated now that component selections are once
        again managed at the viewer level. See
        hou.SceneViewer.currentGeometrySelection.
        
        
        """
        pass
        
    
    def copyNodeSelectionToUserSelection():
        """None"""
        pass
        
    
    def curPoint():
        """
        curPoint(self) -> Point
        
        Return this node's current point. You would typically call this
        method from an expression on a node that iterates over a set of
        points and re-evaluates the parameter for each point.
        
        This method lets you implement the Python equivalent of Hscript's
        local variables. Many of Houdini's SOPs iterate over a set of
        points, and for each point they store the current point and then
        evaluate a parameter. If the parameter contains a local variable,
        Houdini looks up the SOP's current point when evaluating that
        variable. For example, the point SOP evaluates the t parameter for
        each point, and sets that point's position according to the value of
        the parameter. If that parameter contains, say, the local variable
        $TX, it will evaluate to the x position of the current point.
        
        This method gives you access to the hou.Point representation of
        Houdini's current point. Using this point you could evaluate the
        position, an attribute value, or do more complex operations like
        compute the distance from the point to the origin.
        
        Raises hou.OperationFailed if you call this method from outside a
        SOP parameter expression, or if the SOP does not support local
        variables.
        
        The following lists Python equivalents for some point-related
        Hscript expression local variables. Note that you can also access
        local variables from Python using hou.lvar.
        
        > # $PT (Hscript expression) or lvar('PT') (Python):
        > pwd().curPoint().number()
        >
        > # $NPT (Hscript expression) or lvar('NPT') (Python):
        > len(pwd().geometry().iterPoints())
        >
        > # $TX (Hscript expression) or lvar('TX') (Python):
        > pwd().curPoint().position()[0]
        >
        > # $WEIGHT (Hscript expression) or lvar('WEIGHT`) (Python):
        > pwd().curPoint().position()[3]
        >
        > # $CR (Hscript expression) or lvar('CR') (Python):
        > pwd().curPoint().attribValue("Cd")[0]
        >
        > # $ID (Hscript expression) or lvar('ID') (Python):
        > pwd().curPoint().attribValue("id")
        >
        > # $LIFE (Hscript expression) or lvar('LIFE') (Python):
        > pwd().curPoint().attribValue("life")
        >
        > # $VX (Hscript expression) or lvar('VX') (Python):
        > pwd().curPoint().attribValue("v")[0]
        
        """
        pass
        
    
    def setHighlightFlag(on):
        """
        setHighlightFlag(self, on)
        
        Turn this node's highlight flag on or off.
        
        
        """
        pass
        
    
    def isRenderFlagSet():
        """
        isRenderFlagSet(self) -> bool
        
        Return whether this node's render flag is on.
        
        
        """
        pass
        
    
    def isSelectableTemplateFlagSet():
        """
        isSelectableTemplateFlagSet(self) -> bool
        
        Return whether this node's selectable template flag is on. A
        selectable template displays like the display SOP in the viewport,
        and you can select it when choosing points, primitives, etc. Note
        that only the display SOP will be included in the containing
        geometry object or SOP subnet, however, so selectable templates are
        only visible while working inside their SOP network.
        
        
        """
        pass
        
    
    def isDisplayFlagSet():
        """
        isDisplayFlagSet(self) -> bool
        
        Return whether this node's display flag is on.
        
        
        """
        pass
        
    
    def curVertex():
        """
        curVertex(self) -> Vertex
        
        Return this node's current vertex. You would typically call this
        method from an expression on a node that iterates over a set of
        primitive vertices and re-evaluates the parameter for each vertex.
        
        See hou.SopNode.curPoint for more information.
        
        Note that hou.SopNode.curPrim returns the primitive containing this
        vertex returned by this method.
        
        The following lists Python equivalents for some vertex-related
        Hscript expression local variables. Note that you can also access
        local variables from Python using hou.lvar.
        
        > # $VTX (Hscript expression) or lvar('VTX') (Python):
        > pwd().curVertex().number()
        >
        > # $NVTX (Hscript expression) or lvar('NVTX') (Python):
        > pwd().curPrim().numVertices()
        
        """
        pass
        
    
    def isHighlightFlagSet():
        """
        isHighlightFlagSet(self) -> bool
        
        Return whether this node's highlight flag is on. When this flag is
        turned on, Houdini displays portions of the geometry in yellow in
        the viewport, to indicate the operations performed by this SOP.
        
        
        """
        pass
        
    
    def renderNode():
        """
        renderNode(self) -> hou.Node
        
        If this is a subnet SOP, return the SOP inside the subnet with its
        render flag on. Otherwise, return None.
        
        
        """
        pass
        
    
    def isSoftLocked():
        """
        isSoftLocked(self) -> bool
        
        Return whether this node is soft-locked. A soft-locked node stores
        position delta information , preventing all but a small set of
        manual modeling changes from being made.
        
        
        """
        pass
        
    
    def bypass(on):
        """
        bypass(self, on)
        
        Turn this node's bypass flag on or off, making this node have no
        effect.
        
        
        """
        pass
        
    
    def setCurPoint(point_or_none):
        """
        setCurPoint(self, point_or_none)
        
        Set this node's current point. You can only call this method from a
        Python-defined SOP.
        
        See hou.SopNode.curPoint for an explanation of a SOP's current
        point. You would use this method to set the current point from
        inside a SOP written in Python, before you evaluate a parameter
        containing a local variable referring to the current point. See
        hou.Geometry.globPoints for an example.
        
        Note that you can set the current point to None. In this case,
        subsequent calls to hou.SopNode.curPoint will raise
        hou.OperationFailed. After a Python SOP is done cooking, Houdini
        will automatically set the current point back to None.
        
        Raises hou.OperationFailed if called from outside a Python-defined
        SOP.
        
        
        """
        pass
        
    
    def isUnloadFlagSet():
        """
        isUnloadFlagSet(self) -> bool
        
        Returns whether this node's unload flag is on.
        
        
        """
        pass
        
    
    def displayNode():
        """
        displayNode(self) -> Node
        
        If this is a subnet SOP, return the SOP inside the subnet with its
        display flag on. Otherwise, return None.
        
        
        """
        pass
        
    
    def inputGeometry(index):
        """
        inputGeometry(self, index) -> hou.Geometry
        
        Return the geometry that is connected to the node input specified by
        index.
        
        The returned Geometry object is not frozen. See hou.Geometry.freeze
        for more information on frozen Geometry objects.
        
        
        """
        pass
        
    
    def setSoftLocked(on):
        """
        setSoftLocked(self, on)
        
        Turns this node's soft-lock flag on or off, allowing a subset of
        manual modeling changes to be made to the locked node.
        
        
        """
        pass
        
    
    def setCurVertex(vertex_or_none):
        """
        setCurVertex(self, vertex_or_none)
        
        Set this node's current primitive. You can only call this method
        from a Python-defined SOP. See hou.SopNode.setCurPoint for more
        information.
        
        Note that setting the current vertex will also set the current
        primitive to the primitive containing the vertex.
        
        
        """
        pass
        
    
    def inputGeometryAtFrame(frame, index):
        """
        inputGeometryAtFrame(self, frame, index) -> hou.Geometry
        
        Return the geometry that is connected to the node input specified by
        index and at the specified frame.
        
        The returned Geometry object is not frozen. See hou.Geometry.freeze
        for more information on frozen Geometry objects.
        
        
        """
        pass
        
    
    def verb():
        """
        verb(self) -> hou.SopVerb
        
        Returns the verb associated with a specific node. This allows you to
        run the nodes operation on geometry independently of the node
        itself.
        
        
        """
        pass
        
    
    def setHardLocked(on):
        """
        setHardLocked(self, on)
        
        Turn this node's hard-lock flag on or off. Locking a node saves its
        current cooked geometry into the node. If you unlock a hard-locked
        node, it will discard its locked geometry data and recook, computing
        its geometry from its inputs and parameters.
        
        
        """
        pass
        
    
    def curPrim():
        """
        curPrim(self) -> Prim
        
        Return this node's current primitive. You would typically call this
        method from an expression on a node that iterates over a set of
        primitives and re-evaluates the parameter for each primitive.
        
        See hou.SopNode.curPoint for more information.
        
        The following lists Python equivalents for some primitive-related
        Hscript expression local variables. Note that you can also access
        local variables from Python using hou.lvar.
        
        > # $PR (Hscript expression) or lvar('PR') (Python):
        > pwd().curPrim().number()
        >
        > # $NPR (Hscript expression) or lvar('NPR') (Python):
        > len(pwd().geometry().iterPrims())
        >
        > # $NX (Hscript expression) or lvar('NX') (Python):
        > pwd().curPrim().attribValue("N")[0]
        > pwd().curPrim().normal()[0]
        >
        > # $CR (Hscript expression) or lvar('CR') (Python):
        > pwd().curPrim().attribValue("Cd")[0]
        
        """
        pass
        
    
    def isBypassed():
        """
        isBypassed(self) -> bool
        
        Return whether this node's bypass flag is on.
        
        
        """
        pass
        
    
    def setRenderFlag(on):
        """
        setRenderFlag(self, on)
        
        Turns this node's render flag on or off.
        
        
        """
        pass
        
    
    def setDisplayFlag(on):
        """
        setDisplayFlag(self, on)
        
        Turn this node's display flag on or off.
        
        
        """
        pass
        
    
    def geometryDelta():
        """
        geometryDelta(self) -> hou.GeometryDelta
        
        Return the geometry delta stored in this SOP node. If the SOP has no
        deltas then None is returned.
        
        If the SOP recooks, the geometry delta objects will update to the
        SOP's new geometry delta object. If the SOP is deleted, accessing
        the geometry delta object will raise a hou.ObjectWasDeleted
        exception.
        
        
        """
        pass
        
    
    def setSelection(selection):
        """
        setSelection(self, selection)
        
        Sets the current component selection to the supplied value. A
        separate selection object is stored for each component type, so
        changing the selection this way may not update the viewport if it is
        not currently set to show this type of selection.
        
        This method is deprecated now that component selections are once
        again managed at the viewer level. See
        hou.SceneViewer.setCurrentGeometrySelection.
        
        
        """
        pass
        
    
    def geometry(output_index=0):
        """
        geometry(self, output_index=0) -> hou.Geometry
        
        Return the geometry computed by this SOP node. If the SOP has not
        already cooked, this method will cook the SOP.
        
        The returned Geometry object is not frozen. See hou.Geometry.freeze
        for more information on frozen Geometry objects.
        
        You can optionally specify the output_index argument to request the
        geometry attached to another output on the node. This only applies
        to SOP nodes with multiple outputs. If there is no geometry for the
        specified output index then None is returned.
        
        
        """
        pass
        
    
    def isHardLocked():
        """
        isHardLocked(self) -> bool
        
        Return whether this node is hard-locked. A hard-locked node stores
        its data inside the node, and no longer responds to parameter or
        input node changes.
        
        
        """
        pass
        
    
    def isTemplateFlagSet():
        """
        isTemplateFlagSet(self) -> bool
        
        Returns whether this node's template flag is on. Templated SOPs are
        display as wireframe in the viewport, and you cannot select geometry
        from them.
        
        
        """
        pass
        
    
    def hasVerb():
        """
        hasVerb(self) -> Boolean
        
        Returns if the node has a verb representation.
        
        
        """
        pass
        
    
    def setUnloadFlag(on):
        """
        setUnloadFlag(self, on)
        
        Turns this node's unload flag on or off.
        
        
        """
        pass
        
    
    def setTemplateFlag(on):
        """
        setTemplateFlag(self, on)
        
        Turns this node's template flag on or off.
        
        
        """
        pass
        
    
    def setCurPrim(prim_or_none):
        """
        setCurPrim(self, prim_or_none)
        
        Set this node's current primitive. You can only call this method
        from a Python-defined SOP. See hou.SopNode.setCurPoint for more
        information.
        
        
        """
        pass
        
    
    def geometryAtFrame(frame, output_index=0):
        """
        geometryAtFrame(self, frame, output_index=0) -> hou.Geometry
        
        Return the geometry computed by this SOP node cooked at the
        specified frame. If the SOP has not already cooked, this method will
        cook the SOP.
        
        The returned Geometry object is frozen. See hou.Geometry.freeze for
        more information on frozen Geometry objects.
        
        You can optionally specify the output_index argument to request the
        geometry attached to another output on the node. This only applies
        to SOP nodes with multiple outputs. If there is no geometry for the
        specified output index then None is returned.
        
        
        """
        pass
        
    
    def setSelectableTemplateFlag(on):
        """
        setSelectableTemplateFlag(self, on)
        
        Turn this node's selectable template flag on or off.
        
        
        """
        pass
        

class SopNodeType(NodeType):
    """
    hou.SopNodeType
    
    This kind of NodeType contains extra attributes specific to SOP nodes.
    
    
    """
    
    def selectors(selector_indices=():
        """
        selectors(self, selector_indices=()) -> tuple of hou.Selector
        
        Return all the selectors for this node type. See
        hou.SopNodeType.addSelector and hou.Selector for more information.
        
        > def sopSelectorTypes():
        >     '''Return a list of all the SOP selector type names.'''
        >     selector_types = []
        >     for node_type in hou.sopNodeTypeCategory().nodeTypes().values():
        >         # Skip manager nodes, like shopnets, ropnets, etc.
        >         if not isinstance(node_type, hou.SopNodeType):
        >             continue
        >
        >         for selector in node_type.selectors():
        >             selector_type = selector.selectorType()
        >             if selector_type not in selector_types:
        >                 selector_types.append(selector_type)
        >     selector_types.sort()
        >     return selector_types
        > def sopTypeNamesUsingSelector(selector_type):
        >     '''Given the name of a selector type, return a list of all the SOP
        >        node types using that selector.'''
        >     node_types = []
        >     for node_type in hou.sopNodeTypeCategory().nodeTypes().values():
        >         # Skip manager nodes, like shopnets, ropnets, etc.
        >         if not isinstance(node_type, hou.SopNodeType):
        >             continue
        >
        >         for selector in node_type.selectors():
        >             if selector.selectorType() == selector_type:
        >                 node_types.append(node_type)
        >
        >     result = [node_type.name() for node_type in node_types]
        >     result.sort()
        >     return result
        
        """
        pass
        
    
    def addSelector(name, selector_type, prompt='Select, components', primitive_types=():
        """
        addSelector(self, name, selector_type, prompt='Select components',
        primitive_types=(), group_parm_name=None, group_type_parm_name=None,
        input_index=0, input_required=True, allow_dragging=False,
        empty_string_selects_all=True) -> hou.Selector
        
        Add a selector to this SOP node type. When the user creates a new
        instance of this SOP in the viewer, Houdini will invoke all the
        selectors, wait for the user to select geometry, and then connect
        input SOPs and fill in group parameters to match what was selected.
        
        
        name
        A name to give this selector. The name must be unique within
        this node type.
        
        selector_type
        The name of the type of selector to use. Different selectors
        have different behaviors. For example "prims" will select only
        primitives and is used, for example, by the cookie SOP. "points"
        will select only points, and is used by SOPs like the point SOP.
        "everything" will select any geometry, and is used for SOPs like
        "xform" and "blast".
        
        prompt
        A string to display at the bottom of the viewer to instruct the
        user what to select.
        
        primitive_types
        A sequence of hou.primType enumeration values to specify what
        primitive types are allowed. This parameter has no effect if the
        selector does not select primitives. If this sequence is empty,
        all primitive types will be allowed.
        
        group_parm_name
        The name of the SOP node parameter containing the group field.
        The selector will set this parameter to the string representing
        the points, primitives, edges, etc. chosen by the user in the
        viewer. If None, the selector will look for a parameter named
        "group".
        
        group_type_parm_name
        The name of the SOP node parameter containing the menu of
        geometry types. If the selector can select multiple geometry
        types (e.g. points or primitives), it will set this parameter to
        match the type of geometry the user chose. The transform SOP,
        for example, has a Group Type parameter that tells it how to
        interpret the string in the Group parameter. If None, the
        selector will look for a parameter named "grouptype".
        
        input_index
        The index of the input connector on the SOP node where the
        selector should wire input SOPs. A cookie SOP, for example, has
        two input connectors. It has two selectors, one for each input
        connector.
        
        input_required
        Whether or not this input is required or optional. If the user
        does not select any geometry and the input is not required, the
        selector will not wire anything to its input connector.
        
        allow_dragging
        Whether the user is allowed to select the geometry and begin
        manipulating the handles with a single mouse drag. A transform
        SOP, for example, lets you select the geometry and drag it right
        away to transform it. Dragging the geometry forces the selector
        to finish immediately, the selector connects the input and sets
        the group parameter, and subsequent mouse movements are passed
        to the handle which translates the geometry by changing
        parameter values.
        
        empty_string_selects_all
        Whether or not to use an empty string in the group parameter if
        the user selects all the geometry. If False, Houdini will place
        an asterisk (*) in the group parameter when the user selects all
        the geometry. Most SOPs use an empty string.
        
        You would typically call this method from the shelf tool script of a
        digital asset. For example, you might put the following in the Tools
        script section of a Python sop that transforms points (having a
        parameter named group):
        
        > hou.sopNodeTypeCategory().nodeTypes()['$HDA_NAME'].addSelector(
        >     "Points to Transform",
        >     "points",
        >     prompt="Select the points to transform and press Enter to complete",
        >     group_parm_name="group")
        
        See also hou.Geometry.globPoints and hou.Geometry.globPrims for
        information on how to parse the strings the selector puts in the
        group field.
        
        See also hou.Selector.
        
        
        """
        pass
        

def SopNodeType_swigregister():
    """None"""
    pass
    

def SopNode_swigregister():
    """None"""
    pass
    

class SopVerb(object):
    """
    hou.SopVerb
    
    Represents the code of a surface node.
    
    
    """
    
    def execute(destgeo, inputgeolist):
        """
        execute(self, destgeo, inputgeolist)
        
        Applies the verb to the giving destination hou.Geometry. The input
        list is a list of hou.Geometry corresponding to the source node's
        inputs. The parameters used in execution are whatever was set with
        the setParms or loadParmsFromNode functions. The parameters are
        initialized with the node defaults.
        
        NOTE: Node defaults may change between versions.
        
        
        """
        pass
        
    
    def setParms(parmdictionary):
        """
        setParms(self, parmdictionary)
        
        Updates a subset of parmeters on this verb with those specified in
        the dictionary. Exceptions are raised if attempts are made to set
        non-existent parameters or with incorrect types.
        
        This uses ParmTuple names, not channel names. So for a transform you
        would use xform.setParms({'t':(2,0,0)}) rather than tx.
        
        
        """
        pass
        
    
    def loadParmsFromNode(sopnode):
        """
        loadParmsFromNode(self, sopnode)
        
        Initializes all the parameters of this verb from the parameters of a
        specific hou.SopNode. Useful for cloning an existing node instance's
        behavior.
        
        
        """
        pass
        
    
    def parms():
        """
        parms(self) -> dictionary
        
        Returns a dictionary of parameter name / value pairs currently set
        on this verb. This will be the complete list understood, including
        defaults. Multiparms are represented as a sub list of dictionaries.
        
        This uses ParmTuple names, not channel names.
        
        
        """
        pass
        
    
    def minNumInputs():
        """
        minNumInputs(self) -> integer
        
        Returns the minimum number of geometry inputs required for this verb
        to compute successfully.
        
        
        """
        pass
        

def SopVerb_swigregister():
    """None"""
    pass
    

class StickyNote(NetworkMovableItem):
    """
    hou.StickyNote
    
    Represents a sticky note.
    
    To create a sticky note, use the hou.Node.createStickyNote method on the
    node inside which you want to create the note. To get an existing sticky
    note, use the hou.Node.findStickyNote method on the node containing the
    sticky note. To get a list of all notes in a network, use the
    hou.Node.stickyNotes method on the containing node.
    
    
    """
    
    def text():
        """
        text(self) -> str
        
        Return the text displayed in the sticky note.
        
        
        """
        pass
        
    
    def textSize():
        """
        textSize(self) -> float
        
        Return the size of the text displayed in the sticky note, expressed
        as the height of the font in network units.
        
        
        """
        pass
        
    
    def resize(vector2):
        """
        resize(self, vector2)
        
        Resizes a sticky note by the increments in the given hou.Vector2.
        Use setSize() to set the note's absolute size.
        
        
        """
        pass
        
    
    def restoredSize():
        """
        restoredSize(self) -> hou.Vector2
        
        Return the size of this item's tile in the network editor graph if
        it is not minimized. Returned as a Vector2.
        
        
        """
        pass
        
    
    def setDrawBackground(on):
        """
        setDrawBackground(self, on)
        
        Turns on or off the drawing of the colored background for the text
        and the title bar in the network editor. Turning this on makes the
        sticky note easier to see. Turning it off allows the text to be less
        obtrusive.
        
        
        """
        pass
        
    
    def minimizedSize():
        """
        minimizedSize(self) -> hou.Vector2
        
        Return the size of this item's tile in the network editor graph if
        it is minimized. Returned as a Vector2.
        
        
        """
        pass
        
    
    def setTextSize(size):
        """
        setTextSize(self, size)
        
        Sets the size of the text of the sticky note. The size value
        specifies the height (in network units) of the font.
        
        
        """
        pass
        
    
    def isMinimized():
        """
        isMinimized(self) -> bool
        
        Returns whether the sticky note is minimized.
        
        
        """
        pass
        
    
    def drawBackground():
        """
        drawBackground(self) -> bool
        
        Returns whether the sticky note will draw a colored background and
        title bar.
        
        
        """
        pass
        
    
    def setText(str):
        """
        setText(self, str)
        
        Sets the text of the sticky note.
        
        
        """
        pass
        
    
    def setBounds():
        """None"""
        pass
        
    
    def asCode(brief=False, recurse=False, save_box_contents=False, save_channels_only=False, save_creation_commands=False, save_keys_in_frames=False, save_parm_values_only=False, save_spare_parms=False, function_name=None):
        """
        asCode(self, brief=False, recurse=False, save_box_contents=False,
        save_channels_only=False, save_creation_commands=False,
        save_keys_in_frames=False, save_parm_values_only=False,
        save_spare_parms=False, function_name=None) -> str
        
        Prints the Python code necessary to recreate a sticky note.
        
        See hou.Node.asCode for information on the keyword arguments.
        
        
        """
        pass
        
    
    def setTextColor(color):
        """
        setTextColor(self, color)
        
        Sets the color of the text of the sticky note. The color parameter
        should be a hou.Color object.
        
        
        """
        pass
        
    
    def destroy():
        """
        destroy(self)
        
        Remove and delete the sticky note.
        
        
        """
        pass
        
    
    def setMinimized(on):
        """
        setMinimized(self, on)
        
        Minimizes or restores the sticky note.
        
        
        """
        pass
        
    
    def textColor():
        """
        textColor(self) -> hou.Color
        
        Return the color of the text displayed in the sticky note.
        
        
        """
        pass
        
    
    def setSize(size):
        """
        setSize(self, size)
        
        Sets the size of this sticky note to the given hou.Vector2 size
        parameter. Use resize() to set the note's size relative to its
        current size.
        
        
        """
        pass
        

def StickyNote_swigregister():
    """None"""
    pass
    

class StringKeyframe(BaseKeyframe):
    """
    hou.StringKeyframe
    
    """
    
    def asJSON(self, brief=False, save_keys_in_frames=False):
        """
        asJSON(self, brief=False, save_keys_in_frames=False) -> dict
        
        Returns a JSON dictionary that describes the keyframe. The
        dictionary includes the keyframe time and the expression if it has
        been set. If the save_keys_in_frames parameter is set to True, a
        frame number is used instead of a time.
        
        See also the fromJSON method.
        
        """
        pass
        
    
    def fromJSON(self, keyframe_dict):
        """
        fromJSON(self, keyframe_dict)
        
        Sets the keyframe time and expression using the key/value pairs from
        a JSON dictionary.
        
        See also the asJSON method.
        
        """
        pass
        
    
    def evaluatedType():
        """
        evaluatedType(self) -> hou.parmData enum value
        
        Return the data type of the keyframe's evaluated value. For string
        keyframes this method returns hou.parmData.String.
        
        
        """
        pass
        

def StringKeyframe_swigregister():
    """None"""
    pass
    

class StringParmTemplate(ParmTemplate):
    """
    hou.StringParmTemplate
    
    Describes a parameter tuple containing string values. These values can
    be arbitrary strings or references to files or nodes
    
    Note that string parameters may also be menu parameters. String
    parameters with menus are different from hou.MenuParmTemplate objects
    because menu parm templates evaluate to integers.
    
    
    """
    
    def stringType():
        """
        stringType(self) -> hou.stringParmType enum value
        
        Return the type of this string parameter. This type determines
        whether the parameter has special selection controls to choose a
        file path or the paths to one or more nodes.
        
        See hou.stringParmType for more information.
        
        
        """
        pass
        
    
    def setDefaultExpression(tuple_of_default_expressions):
        """
        setDefaultExpression(self, tuple_of_default_expressions)
        
        Set the default expression for new parameter instances to a sequence
        of strings.
        
        See the hou.StringParmTemplate.defaultExpression method for more
        information. Note that if the number of strings in the sequence is
        different from the number of components in the parm template, any
        extra values will be discarded and any missing expressions will
        become the empty string.
        
        
        """
        pass
        
    
    def setDefaultValue(tuple_of_default_values):
        """
        setDefaultValue(self, tuple_of_default_values)
        
        Set the default value for new parameter instances to a sequence of
        strings.
        
        See the defaultValue method for more information. Note that if the
        number of strings in the sequence is different from the number of
        components in the parm template, any extra values will be discarded
        and any missing values will become the last value in the sequence or
        an empty string if the sequence is empty.
        
        
        """
        pass
        
    
    def menuItems():
        """
        menuItems(self) -> tuple of str
        
        Return the tuple of internal menu names. If this string does not use
        a menu, returns an empty tuple.
        
        These internal menu names are not displayed in the UI, but they can
        be passed to hou.Parm.set and will be returned by
        hou.Parm.evalAsString for menu parameters.
        
        
        """
        pass
        
    
    def setDefaultExpressionLanguage(tuple_of_default_expression_languages):
        """
        setDefaultExpressionLanguage(self,
        tuple_of_default_expression_languages)
        
        Set the default expression language for new parameter instances to a
        sequence of hou.scriptLanguage values.
        
        See the defaultExpressionLanguage method for more information. Note
        that if the number of hou.scriptLanguage values in the sequence is
        different from the number of components in the parm template, any
        extra values will be discarded and any missing expression languages
        will become hou.scriptLanguage.Hscript.
        
        
        """
        pass
        
    
    def setItemGeneratorScriptLanguage(language):
        """
        setItemGeneratorScriptLanguage(self, language)
        
        Set the script language used to generate menu items to a
        hou.scriptLanguage enum value.
        
        See the itemGeneratorScriptLanguage method for more information.
        
        
        """
        pass
        
    
    def itemGeneratorScript():
        """
        itemGeneratorScriptLanguage(self) -> hou.scriptLanguage enum value
        
        Return the script used to generate menu items, or an empty string if
        there is no such script.
        
        
        """
        pass
        
    
    def setIconNames(icon_names):
        """
        setIconNames(self, icon_names)
        
        Set the icon names to the given sequence of strings.
        
        
        """
        pass
        
    
    def menuLabels():
        """
        menuLabels(self) -> tuple of str
        
        Return the tuple of menu labels displayed in the UI.
        
        
        """
        pass
        
    
    def menuType():
        """
        menuType(self) -> hou.menuType enum value
        
        Return the type of menu. See hou.menuType for more information.
        
        
        """
        pass
        
    
    def defaultExpression():
        """
        defaultExpression(self) -> tuple of strings
        
        Return the default expression for new parameter instances.
        
        The default expression takes precedence over the default value. If a
        component has no default expression (i.e. an empty string), then the
        default value is used for new parameter instances.
        
        Note that the default expression language is needed to interpret the
        meaning of the default expression.
        
        
        """
        pass
        
    
    def fileType():
        """
        fileType(self) -> hou.fileType enum value
        
        Return the file type of this string parameter. The file type applies
        only when stringType() == hou.stringParmType.FileReference. Only
        hou.fileType.Any, hou.fileType.Image, and hou.fileType.Geometry are
        supported by dialog scripts.
        
        See hou.fileType for more information.
        
        
        """
        pass
        
    
    def setStringType(string_type):
        """
        setStringType(self, string_type)
        
        Set the type of this string parameter to a hou.stringParmType enum
        value.
        
        See the stringType method for more information.
        
        
        """
        pass
        
    
    def itemGeneratorScriptLanguage():
        """None"""
        pass
        
    
    def defaultValue():
        """
        defaultValue(self) -> tuple of str
        
        Return the default value for new parameter instances.
        
        The number of strings in the return value is the same as the number
        of components in the parm template.
        
        
        """
        pass
        
    
    def setItemGeneratorScript(item_generator_script):
        """
        setItemGeneratorScript(self, item_generator_script)
        
        Set the script used to generate menu items.
        
        See the itemGeneratorScript method for more information.
        
        
        """
        pass
        
    
    def defaultExpressionLanguage():
        """
        defaultExpressionLanguage(self) -> tuple of hou.scriptLanguage
        
        Return the default expression language for new parameter instances.
        
        The default expression language only applies if the default
        expression is set. If the default expression of a component is not
        set, then the expression language is set to
        hou.scriptLanguage.Hscript.
        
        
        """
        pass
        
    
    def setMenuItems(menu_items):
        """
        setMenuItems(self, menu_items)
        
        Set the internal menu names to the given sequence of strings.
        
        See the menuItems method for more information.
        
        If the new number of menu items is less than the old number, the
        menu labels will be shortened and the default value will be modified
        if it is out of range.
        
        
        """
        pass
        
    
    def iconNames():
        """
        iconNames(self) -> tuple of str
        
        Return the tuple of icons corresponding to the menu items. If there
        are no icons, returns a tuple of empty strings.
        
        These icons are used when this parm template uses a menu.
        
        
        """
        pass
        
    
    def setMenuLabels():
        """None"""
        pass
        
    
    def setMenuType(menu_type):
        """
        setMenuType(self, menu_type)
        
        Set the type of menu to a hou.menuType enum value.
        
        See the menuType method for more information.
        
        
        """
        pass
        
    
    def setFileType(file_type):
        """
        setFileType(self, file_type)
        
        Set the type of this string parameter to a hou.fileType enum value.
        
        See the fileType method for more information.
        
        
        """
        pass
        

def StringParmTemplate_swigregister():
    """None"""
    pass
    

class StyleSheet(object):
    """
    hou.StyleSheet
    
    A class that represents a Houdini style sheet. It can be used to
    evaluate, test, and debug style sheet output.
    
    Unlike the hou.styles module, the style sheets represented by this class
    are not saved anywhere. They are parsed style sheets that can be
    evaluated for particular objects and geometry. This allows you to debug
    the operation of your style sheets outside of mantra. It also allows
    building SOPs which evaluate style information to apply it to a more
    specific target.
    
    
    """
    
    def cloneWithShape(shape_name, prim):
        """
        cloneWithShape(self, shape_name, prim) -> hou.StyleSheet
        
        Makes a copy of an existing style sheet object which contains only
        the styling information that applies to the named shape in the
        provided crowd agent hou.PackedPrim.
        
        
        """
        pass
        
    
    def clone():
        """
        clone(self) -> hou.StyleSheet
        
        Makes an identical copy of an existing style sheet object.
        
        
        """
        pass
        
    
    def cloneWithAddedStyleSheet(stylesheet, target):
        """
        cloneWithAddedStyleSheet(self, stylesheet, target) -> hou.StyleSheet
        
        Makes a copy of an existing style sheet object combined with another
        style sheet object. The added styles are given a lower priority than
        the styles already in the style sheet. In addition, a target
        argument can be provided which is a JSON formatted string describing
        a target condition which must be satisfied in order for the added
        styles to be applied. This function can therefore be used to build
        an object level style sheet by combining per-primitive style sheets
        from the object's geometry.
        
        
        """
        pass
        
    
    def asJSON():
        """
        asJSON(self) -> str
        
        Returns a string containing the JSON that represents the style
        sheet. If the style sheet was constructed from a string argument,
        the original string will be returned even if there were parsing
        errors. If this style sheet was cloned with a specific target, the
        JSON string is generated from the style information that applies to
        that target.
        
        
        """
        pass
        
    
    def errors():
        """
        errors(self) -> str
        
        Returns any errors generated while parsing the style sheet. If there
        are no errors, an empty string is returned. For style sheet objects
        returned from any of the cloneWith methods, the returned string will
        always be empty.
        
        
        """
        pass
        
    
    def cloneWithPrim(prim):
        """
        cloneWithPrim(self, prim) -> hou.StyleSheet
        
        Makes a copy of an existing style sheet object which contains only
        the styling information that applies to the provided hou.Prim.
        
        
        """
        pass
        
    
    def cloneWithObject(object):
        """
        cloneWithObject(self, object) -> hou.StyleSheet
        
        Makes a copy of an existing style sheet object which contains only
        the styling information that applies to the provided hou.ObjNode.
        
        
        """
        pass
        

def StyleSheet_swigregister():
    """None"""
    pass
    

class SubnetIndirectInput(IndirectInput):
    """
    hou.SubnetIndirectInput
    
    A node-like item that appears inside subnets and corresponds to the node
    wired into the subnet.
    
    For example, suppose you have a font SOP, polyextrude SOP, and facet SOP
    connected together in a chain. If you collapse the polyextrude and facet
    SOPs into a subnet, you're left with a font SOP connected to a subnet
    SOP. Inside the subnet SOP is subnet indirect input #1 connected to a
    polyextrude SOP, which is connected to the facet SOP.
    
    Each subnet indirect input is numbered starting from 1 and corresponds
    to an input connector on the subnet. (See hou.NodeConnection for more
    information on input connectors.)
    
    The names of the subnet indirect inputs in the network pane correspond
    to the contents of the Input #n Label parameters on the subnet node,
    where n is the number.
    
    
    """
    
    def number():
        """
        number(self) -> int
        
        Return the number of the corresponding input connector on the
        subnet. Note that the first input corresponds to the number 1, not
        0.
        
        
        """
        pass
        
    
    def inputConnections():
        """
        inputConnections(self) -> tuple of hou.NodeConnection
        
        Returns an empty tuple. This method exists to mirror similar methods
        on hou.Node and hou.NetworkDot. This allows these network items to
        be treated in a more uniform way in Python code.
        
        
        """
        pass
        

def SubnetIndirectInput_swigregister():
    """None"""
    pass
    

class Surface(Prim):
    """
    hou.Surface
    
    A Surface is a kind of geometry primitive (Prim object) that contains a
    two dimensional grid of vertices (Vertex objects). How these vertices
    are used depends on the type of surface: meshes, for example, use the
    vertices to define a quadrilateral mesh, while NURBS surfaces use them
    as control points.
    
    A hou.Face, on the other hand, stores a sequence of vertices, and might
    be a polygon or NURBS curve.
    
    
    """
    
    def positionAt(u, v):
        """
        positionAt(self, u, v) -> hou.Vector3
        
        Given normalized (i.e. from 0 to 1) u and v values, returns the
        position of the surface at that parametric location.
        
        See the surface_wires cookbook example for an example.
        
        
        """
        pass
        
    
    def vertex(u_index, v_index):
        """
        vertex(self, u_index, v_index)
        
        Return an element in the 2D array of vertices, given the u (column)
        and v (row) indices into the array.
        
        Negative indices are allowed, in which case Houdini will index
        starting from the last vertex.
        
        For non-negative indices, this method is roughly equivalent to
        writing surf.vertices()[v_index * surf.numCols() + u_index].
        
        Raises hou.OperationFailed if the u or v indices are invalid.
        
        > # Use a grid SOP to create a NURBS grid with 3 rows and 2 columns.
        > geo = hou.node("/obj").createNode("geo").createNode("grid").geometry()
        > grid_node = geo.sopNode()
        > grid_node.setDisplayFlag(True)
        > for name, value in ("type", "nurbs"), ("rows", 5), ("cols", 4):
        >     grid_node.parm(name).set(value)
        >
        > # Print out the x positions of all the vertices in the surface.
        > surf = geo.iterPrims()[0]
        > for v_index in surf.numRows():
        >     for u_index in surf.numCols():
        >         print surf.vertex(u_index, v_index).point().position()[0],
        >     print
        
        See also:
        
        * hou.Prim.vertices
        
        * hou.Surface.verticesInCol
        
        * hou.Surface.verticesInRow
        
        * hou.Geometry.iterPrims
        
        
        """
        pass
        
    
    def verticesInRow(v_index):
        """
        verticesInRow(self, v_index)
        
        Given a v (i.e. row) index, return a tuple containing all the
        vertices in that row.
        
        See also hou.Prim.vertices.
        
        
        """
        pass
        
    
    def attribValueAt(attrib_or_name, u, v, du=0, dv=0):
        """
        attribValueAt(self, attrib_or_name, u, v, du=0, dv=0) -> int, float, str
        or tuple
        
        Return an attribute value at a normalized (u, v) parametric position
        on the surface. If du and dv are both 0, returns the interpolated
        attribute value; otherwise, returns the (partial) derivative of the
        attribute value.
        
        Raises hou.OperationFailed if the attribute is not a point or vertex
        attribute. If you want a primitive attribute value, it doesn't vary
        across the surface, so use hou.Prim.attribValue.
        
        
        """
        pass
        
    
    def isClosedInU():
        """
        isClosedInU(self)
        
        Return whether the first and last columns of vertices are connected.
        
        A grid, for example, is open in both U and V. A tube is open in one
        of U or V and closed in the other. A torus is closed in both U and
        V.
        
        
        """
        pass
        
    
    def isClosedInV():
        """
        isClosedInV(self)
        
        Return whether the first and last rows of vertices are connected.
        
        See hou.Surface.isClosedInU for more information.
        
        
        """
        pass
        
    
    def numCols():
        """
        numCols(self)
        
        Return the number of columns in the 2D array of vertices.
        
        
        """
        pass
        
    
    def verticesInCol():
        """None"""
        pass
        
    
    def numRows():
        """
        numRows(self)
        
        Return the number of rows in the 2D array of vertices.
        
        
        """
        pass
        
    
    def addCol(after=-1):
        """
        addCol(self, after=-1)
        
        Add a column of vertices after the given u (i.e. column) index. You
        would typically call this method from the code of a Python-defined
        SOP.
        
        This method also adds one point per vertex added. The new points are
        located at the origin until you move them.
        
        The u (i.e. column) index after may be negative, in which case the
        indexing starts from the end. By default, after is -1, meaning that
        the new column will go after the last column. Raises
        hou.OperationFailed if the after index is invalid.
        
        >
        > # This code will work from inside a Python SOP, but not from the Python
        > # shell.
        > def vertexPos(vertex):
        >     return hou.Vector3(vertex.point().position())
        >
        > # Build a NURBS surface.
        > geo = hou.pwd().geometry()
        > surf = geo.createNURBSSurface(10, 10)
        >
        > # Add a new column, and set the new point positions to the average of
        > # the adjacent point positions.
        > surf.addCol(after=7)
        > for v_index in range(surf.numRows()):
        >     vertex_before = surf.vertex(7, v_index)
        >     vertex_after = surf.vertex(9, v_index)
        >     surf.vertex(8, v_index).point().setPosition(
        >         (vertexPos(vertex_before) + vertexPos(vertex_after)) * 0.5)
        
        """
        pass
        
    
    def normalAt(u, v):
        """
        normalAt(self, u, v) -> Vector3
        
        Given normalized (i.e. from 0 to 1) u and v values, returns the
        normal of the surface at that parametric location. The normal is a
        vector that is perpendicular to the surface at that location.
        
        The normal vector is normalized (i.e. it is a unit vector, so its
        length is 1).
        
        See the surface_wires cookbook example for an example.
        
        
        """
        pass
        
    
    def addRow(after=-1):
        """
        addRow(self, after=-1)
        
        Add a row of vertices after the given v (i.e. row) index. The new
        vertices are located at the origin until you move them. You would
        typically call this method from the code of a Python-defined SOP.
        
        See hou.Surface.addCol for more information.
        
        
        """
        pass
        

def Surface_swigregister():
    """None"""
    pass
    

class SystemExit(SystemExit):
    """
    hou.SystemExit
    
    """
    
    def code():
        """
        code(self) -> int
        
        
        """
        pass
        

def SystemExit_swigregister():
    """None"""
    pass
    

class Take(object):
    """
    hou.Take
    
    RELATED
    
    * hou.takes
    
    
    """
    
    def removeParmTuple(parm_tuple):
        """
        removeParmTuple(self, parm_tuple)
        
        Exclude the given parameter from this take making it uneditable in
        this take.
        
        This method does nothing if the parameter is not included in this
        take.
        
        Raise hou.OperationFailed if the parm_tuple argument is None. Raise
        hou.OperationFailed if this take is not the current take.
        
        
        """
        pass
        
    
    def addNodeBypassFlag(node):
        """
        removeNodeBypassFlag(self, node)
        
        Exclude the given node's bypass flag from this take making it
        uneditable in this take.
        
        This method does nothing if the node's bypass flag is not included
        in the take.
        
        Raise hou.OperationFailed if the node argument is None. Raise
        hou.OperationFailed if this take is not the current take.
        
        
        """
        pass
        
    
    def addParmTuple(parm_tuple):
        """
        addParmTuple(self, parm_tuple)
        
        Include the given parameter in this take making it editable in this
        take.
        
        This method does nothing if the parameter is already included in
        this take.
        
        Raise hou.OperationFailed if the parm_tuple argument is None. Raise
        hou.OperationFailed if this take is not the current take.
        
        
        """
        pass
        
    
    def removeNodeDisplayFlag():
        """None"""
        pass
        
    
    def addChildTake(name):
        """
        addChildTake(self, name) -> hou.Take
        
        Create a new take with the given name and add it as a child to this
        take.
        
        If no name is specified then the take will have a generated name
        based on the default take name.
        
        
        """
        pass
        
    
    def children():
        """
        children(self) -> tuple of hou.Take
        
        Return a tuple of the child takes.
        
        
        """
        pass
        
    
    def addNodeRenderFlag(node):
        """
        removeNodeRenderFlag(self, node)
        
        Exclude the given node's render flag from this take making it
        uneditable in this take.
        
        This method does nothing if the node's render flag is not included
        in the take.
        
        Raise hou.OperationFailed if the node argument is None. Raise
        hou.OperationFailed if this take is not the current take.
        
        
        """
        pass
        
    
    def parent():
        """
        parent(self) -> hou.Take
        
        Return the parent take or None if this take is the main (master)
        take.
        
        
        """
        pass
        
    
    def moveUnderTake(take):
        """
        moveUnderTake(self, take)
        
        Reparent this take to the specified take.
        
        Raise hou.OperationFailed if the take argument is None. Raise
        hou.OperationFailed if this take is the main (master) take.
        
        
        """
        pass
        
    
    def removeNodeRenderFlag():
        """None"""
        pass
        
    
    def removeParmTuplesFromNode(node):
        """
        removeParmTuplesFromNode(self, node)
        
        Exclude all the given node's parameters from this take making them
        uneditable in this take.
        
        Raise hou.OperationFailed if the node argument is None. Raise
        hou.OperationFailed if this take is not the current take.
        
        
        """
        pass
        
    
    def destroy(recurse=False):
        """
        destroy(self, recurse=False)
        
        Deletes the take.
        
        If recurse is True then all child and descendent takes will be
        deleted as well.
        
        
        """
        pass
        
    
    def saveToFile(filename, recurse=False):
        """
        saveToFile(self, filename, recurse=False)
        
        Save this take to a file on disk.
        
        If recurse is True then any child and descendent takes will also be
        saved to the file.
        
        Note that the saved file can only be loaded within the same .hip
        file session. If Houdini is restarted or if the .hip file is closed
        and re-opened then the saved file will fail to load.
        
        Raise hou.OperationFailed if the filename argument does not point to
        a valid location on disk.
        
        
        """
        pass
        
    
    def parmTuples():
        """
        parmTuples(self) -> tuple of hou.ParmTuple
        
        Return a tuple of node parameters that are included and editable in
        this take.
        
        
        """
        pass
        
    
    def setName(name):
        """
        setName(self, name)
        
        Rename the take.
        
        
        """
        pass
        
    
    def hasParmTuple(parm_tuple):
        """
        hasParmTuple(self, parm_tuple) -> bool
        
        Return True if the given parameter is included in this take and
        False otherwise.
        
        Raise hou.OperationFailed if the parm_tuple argument is None.
        
        
        """
        pass
        
    
    def addParmTuplesFromTake(take, overwrite_existing=True):
        """
        addParmTuplesFromTake(self, take, overwrite_existing=True)
        
        Include all the given take's parameters in this take making the
        parameters editable in this take.
        
        If overwrite_existing is True then parameters that are already
        included in this take will have their values overwritten by the same
        parameters found in the other take. Otherwise, parameters already
        included in this take will not be affected by the same parameters
        found in the other take.
        
        Raise hou.OperationFailed if the take argument is None. Raise
        hou.OperationFailed if this take is not the current take.
        
        
        """
        pass
        
    
    def isCurrent():
        """
        isCurrent(self) -> bool
        
        Return True if the take is the current take and False otherwise.
        
        
        """
        pass
        
    
    def path():
        """
        path(self) -> str
        
        Return the path of the take. The take path consists of the name of
        this take as well as the names of its ancestor takes.
        
        
        """
        pass
        
    
    def loadChildTakeFromFile(filename):
        """
        loadChildTakeFromFile(self, filename) -> tuple of hou.Take
        
        Load a take from a file that is saved to disk and make it a child of
        this take. This will also load any child and descendent takes that
        are saved in the file.
        
        Return a tuple of takes that have been loaded from the file. The
        first take in the tuple is the direct child take of this take. All
        takes that follow are the children and descendents of the first
        take.
        
        Loaded takes will be renamed if there already exists takes with the
        same names.
        
        Note that you can only load files that have been saved from the same
        .hip file session. If Houdini is restarted or if the .hip file is
        closed and re-opened after the save then the file will fail to load.
        
        Raise hou.OperationFailed if the filename argument does not point to
        a valid file on disk.
        
        
        """
        pass
        
    
    def name():
        """
        name(self)
        
        Return the name of the take.
        
        
        """
        pass
        
    
    def addNodeDisplayFlag(node):
        """
        removeNodeDisplayFlag(self, node)
        
        Exclude the given node's display flag from this take making it
        uneditable in this take.
        
        This method does nothing if the node's display flag is not included
        in the take.
        
        Raise hou.OperationFailed if the node argument is None. Raise
        hou.OperationFailed if this take is not the current take.
        
        
        """
        pass
        
    
    def insertTakeAbove(name):
        """
        insertTakeAbove(self, name) -> hou.Take
        
        Create a new take with the given name and add it as a child of this
        take's parent. This take is reparented with the newly created take
        as the parent.
        
        Raise hou.OperationFailed if this take is the main (master) take.
        
        
        """
        pass
        
    
    def addParmTuplesFromNode():
        """None"""
        pass
        
    
    def removeNodeBypassFlag():
        """None"""
        pass
        

def Take_swigregister():
    """None"""
    pass
    

class ToggleParmTemplate(ParmTemplate):
    """
    hou.ToggleParmTemplate
    
    Describes a parameter tuple containing a checkbox.
    
    
    """
    
    def defaultExpression():
        """
        defaultExpression(self) -> string
        
        Return the expression, which when evaluated, returns the initial
        value of the toggle.
        
        The default expression takes precedence over the default value. If
        the default expression is not set (i.e. an empty string), then the
        default value is used instead.
        
        Note that the default expression language is needed to interpret the
        meaning of the default expression.
        
        
        """
        pass
        
    
    def setDefaultValue(tuple_of_default_values):
        """
        setDefaultValue(self, tuple_of_default_values)
        
        Set the default value for new parameter instances.
        
        
        """
        pass
        
    
    def defaultValue():
        """
        defaultValue(self) -> bool
        
        Returns the default value for new parameter instances.
        
        Note that ToggleParmTemplates have only one component. Unlike float,
        integer, and string parm templates, the default value is a single
        bool and not a tuple.
        
        
        """
        pass
        
    
    def setDefaultExpressionLanguage(tuple_of_default_expression_languages):
        """
        setDefaultExpressionLanguage(self,
        tuple_of_default_expression_languages)
        
        Set the default expression language.
        
        See the defaultExpressionLanguage method for more information.
        
        
        """
        pass
        
    
    def defaultExpressionLanguage():
        """
        defaultExpressionLanguage(self) -> tuple of hou.scriptLanguage
        
        Return the default expression language.
        
        The default expression language only applies if the default
        expression is set. If the default expression is not set, then the
        expression language is set to hou.scriptLanguage.Hscript.
        
        
        """
        pass
        
    
    def setDefaultExpression(tuple_of_default_expressions):
        """
        setDefaultExpression(self, tuple_of_default_expressions)
        
        Set the default expression, which when evaluated, returns the
        initial value of the toggle.
        
        If default_expression is the empty string, then the default
        expression is unset.
        
        
        """
        pass
        

def ToggleParmTemplate_swigregister():
    """None"""
    pass
    

class Tool(ShelfElement):
    """
    hou.Tool
    
    Represents a tool on the shelf, encapsulating a script as well as a
    label, help, and other information.
    
    You can't instantiate this object directly, call hou.shelves.newTool
    instead.
    
    
    """
    
    def help():
        """
        help(self) -> str
        
        Returns the tool's help text.
        
        
        """
        pass
        
    
    def setScript(script):
        """
        setScript(self, script)
        
        Sets the text of the script to run when the user clicks the tool in
        the shelf. See how to write a tool script for information on the
        global variables available to the script and tips for common tasks.
        
        
        """
        pass
        
    
    def setToolLocations(locations):
        """
        setToolLocations(self, locations)
        
        Sets the description of the places that the tool should show up in
        the UI. Eg, a tool could be configured to be included in the network
        pane's TAB menu but not in the viewport pane's TAB menu.
        
        
        """
        pass
        
    
    def setToolMenuCategories(pane_type, categories):
        """
        setToolMenuCategories(self, pane_type, categories)
        
        Set the tool categories. The categories are used to further control
        the visibility of the tool. For example, some tools specify "Mantra"
        or "RenderMan" as keywords, and they show up in the TAB menu only if
        the specified renderer is configured as active in the preferences
        pane.
        
        
        """
        pass
        
    
    def setHelpURL(help_url):
        """
        setHelpURL(self, help_url)
        
        Sets a URL the help viewer should go to when the user requests help
        for this tool. If this is not empty, Hoduini will open this URL in
        the help viewer instead of parsing and displaying the contents of
        Tool.help().
        
        
        """
        pass
        
    
    def keywords():
        """None"""
        pass
        
    
    def icon():
        """
        icon(self) -> str
        
        Returns the tool's icon string.
        
        
        """
        pass
        
    
    def setHelp(help):
        """
        setHelp(self, help)
        
        Sets the tool's help text. Houdini will parse this as wiki text and
        display it in the help viewer when the user requests help for this
        tool. To have the help viewer go to a URL instead, use setHelpURL.
        
        
        """
        pass
        
    
    def helpURL():
        """
        helpURL(self) -> str
        
        Returns the URL pointing to this tool's help.
        
        
        """
        pass
        
    
    def toolMenuCategories(pane_type):
        """
        toolMenuCategories(self, pane_type) -> tuple of hou.NodeTypeCategory
        
        Returns the categories specified for the tool.
        
        
        """
        pass
        
    
    def language():
        """
        language(self) -> hou.scriptLanguage enum value
        
        Returns a value representing the language in which the tool script
        is written.
        
        > >>> t = shelves.tool("geometry_sphere")
        > >>> t.language() == hou.scriptLanguage.Python
        > True
        
        """
        pass
        
    
    def script():
        """
        script(self) -> str
        
        Returns the text of the script that runs when the user clicks the
        tool.
        
        
        """
        pass
        
    
    def setLanguage(language):
        """
        setLanguage(self, language)
        
        Sets a new language for the script, where <language> is a value from
        the hou.scriptLanguage module (usually hou.scriptLanguage.Python).
        
        > t = shelves.tool("tool_1")
        > t.setLanguage(hou.scriptLanguage.Hscript)
        > t.setScript("message hello")
        
        NOTE
        We *highly* recommend writing scripts in Python rather than
        Hscript.
        
        
        """
        pass
        
    
    def toolMenuLocations():
        """
        toolMenuLocations(self) -> tuple of str
        
        Returns the submenus of the TAB menu in which the tool is included.
        
        
        """
        pass
        
    
    def toolMenuOpType(pane_type):
        """
        toolMenuOpType(self, pane_type) -> str
        
        Returns the operator type associated with this tool.
        
        
        """
        pass
        
    
    def setToolMenuOpType(pane_type, op_type):
        """
        setToolMenuOpType(self, pane_type, op_type)
        
        Sets the operator type to be associated with the tool. The tool will
        show up in the TAB menu only if the operator can be created. For
        example, some operator types are scoped only to a particular parent,
        thus the tool that creates nodes of this type makes sense only
        inside that parent.
        
        
        """
        pass
        
    
    def destroy():
        """
        destroy(self)
        
        Deletes the tool from Houdini session and removes its definition
        from the file it's stored in.
        
        
        """
        pass
        
    
    def setKeywords():
        """None"""
        pass
        
    
    def setIcon(icon):
        """
        setIcon(self, icon)
        
        Sets a new icon string for the tool. The string can contain a file
        path or URL pointing to an SVG file or an image file Houdini knows
        how to load. You can use an opdef: path to refer to an icon file
        inside an asset.
        
        
        """
        pass
        
    
    def setData(script='', language=hou.scriptLanguage.Python, icon='', help='', help_url='', network_categories=():
        """
        setData(self, script='', language=hou.scriptLanguage.Python, icon='',
        help='', help_url='', network_categories=(), viewer_categories=(),
        cop_viewer_categories=(), network_op_type='', viewer_op_type='',
        locations=())
        
        Convenience method for setting multiple options at once, rather than
        calling multiple set methods. Sets various options on the tool based
        on optional keyword arguments you pass.
        
        > # Get a tool
        > t = shelves.tool("geometry_sphere")
        > # Set the tool's icon and help URL
        > t.setData(icon="SOP_sphere", help_url="tool:sphere")
        
        """
        pass
        

def Tool_swigregister():
    """None"""
    pass
    

class TopNode(Node):
    """
    hou.TopNode
    
    Represents a task node.
    
    
    """
    
    def graphCommands():
        """
        graphCommands(self) -> str
        
        Returns a string containing python commands require to construct the
        PDG graph owned by the parent network of this node.
        
        
        """
        pass
        
    
    def outputDataTypes():
        """
        outputDataTypes(self) -> tuple of str
        
        Returns a tuple of the data types for the output ports of this node.
        
        
        """
        pass
        
    
    def dirtyAllTasks(remove_outputs):
        """
        dirtyAllTasks(self, remove_outputs)
        
        Dirties all the tasks in a PDG graph so that when the graph cooks
        again, it will cause a complete recook.
        
        
        remove_outputs
        If True, then it will also delete all generated file results
        from disk.
        
        
        """
        pass
        
    
    def isPDGFilter():
        """None"""
        pass
        
    
    def isMapper():
        """
        isMapper(self) - > bool
        
        Returns true if the TOP node is a mapper.
        
        
        """
        pass
        
    
    def dirtyTasks():
        """None"""
        pass
        
    
    def isRenderFlagSet():
        """
        isRenderFlagSet(self) -> bool
        
        Returns whether this node's render flag is on.
        
        
        """
        pass
        
    
    def setRenderFlag(on):
        """
        setRenderFlag(self, on)
        
        Turns this node's render flag on or off.
        
        
        """
        pass
        
    
    def isDisplayFlagSet():
        """
        isDisplayFlagSet(self) -> bool
        
        Returns whether this node's display flag is on.
        
        
        """
        pass
        
    
    def isScheduler():
        """
        isScheduler(self) - > bool
        
        Returns true if the TOP node is a scheduler.
        
        
        """
        pass
        
    
    def getCookState():
        """None"""
        pass
        
    
    def renderNode():
        """
        renderNode(self) -> Node
        
        If this is a subnet TOP, return the TOP node inside the subnet with
        its render flag on. Otherwise, return None.
        
        
        """
        pass
        
    
    def displayNode():
        """
        displayNode(self) -> Node
        
        If this is a subnet TOP, return the TOP node inside the subnet with
        its display flag on. Otherwise, return None.
        
        
        """
        pass
        
    
    def bypass(on):
        """
        bypass(self, on)
        
        Turns this node's bypass flag on or off, making this node have no
        effect.
        
        
        """
        pass
        
    
    def getPDGGraphContextName():
        """
        getPDGGraphContextName(self) -> str
        
        Returns a string containing the name of the graph context owned by
        the parent network of this node.
        
        
        """
        pass
        
    
    def addPDGFilter(idx):
        """
        isPDGFilter(self, idx) -> bool
        
        Returns true if the static work item with the given index part if
        the filter.
        
        
        """
        pass
        
    
    def isPartitioner():
        """
        isPartitioner(self) -> bool
        
        Returns true if the TOP node is a partitioner.
        
        
        """
        pass
        
    
    def executeGraph(filter_static, block, generate_only, tops_only):
        """
        executeGraph(self, filter_static, block, generate_only, tops_only)
        
        Generates and then cooks the PDG graph owned by the parent network
        of this node.
        
        
        filter_static
        If True, then the graph will be executed with respect to the
        static work items stored by the TOP Network filter.
        
        block
        If True, the call will not return until the cook is complete.
        
        generate_only
        If True, only the generation phase of the cook will be done.
        
        tops_only
        If True, TOP nodes will be cooked and schedulers will be
        initialized. No PDG cooking will occur, and no work items will
        be generated.
        
        
        """
        pass
        
    
    def generateStaticItems(block):
        """
        generateStaticItems(self, block)
        
        Generates static work items on the PDG graph owned by the parent
        network of this node.
        
        
        block
        If True, the call will not return until work item generation is
        complete.
        
        
        """
        pass
        
    
    def getSelectedWorkItem():
        """
        getSelectedWorkItem(self) -> int
        
        Returns the index of the current selected work item in this TOP
        Network.
        
        
        """
        pass
        
    
    def isProcessor():
        """
        isProcessor(self) -> bool
        
        Returns true if the TOP node is a processor.
        
        
        """
        pass
        
    
    def inputDataTypes():
        """
        inputDataTypes(self) -> tuple of str
        
        Returns a tuple of the data types for the input ports of this node.
        
        
        """
        pass
        
    
    def getWorkItemName(idx):
        """
        getWorkItemName(self, idx) -> str
        
        Returns the name of the work item with the given index.
        
        
        """
        pass
        
    
    def getPDGNodeName():
        """
        getPDGNodeName(self) -> str
        
        Returns the name of the PDG node owned by this node.
        
        
        """
        pass
        
    
    def getFilterNodes():
        """
        getFilterNodes(self) -> tuple of hou.Node
        
        Returns a tuple of all nodes whose filters affect the node.
        
        
        """
        pass
        
    
    def isBypassed():
        """
        isBypassed(self) -> bool
        
        Returns whether this node's bypass flag is on.
        
        
        """
        pass
        
    
    def isFilterOn():
        """
        isFilterOn(self) -> bool
        
        Returns true is this node is currently affected by a work item
        filter set on another node in the network.
        
        
        """
        pass
        
    
    def setDisplayFlag(on):
        """
        setDisplayFlag(self, on)
        
        Turn this node's display flag on or off.
        
        
        """
        pass
        
    
    def getPDGNode(self):
        """None"""
        pass
        
    
    def removePDGFilter():
        """None"""
        pass
        
    
    def setSelectedWorkItem(idx):
        """
        setSelectedWorkItem(self, idx)
        
        Sets the selected work item in this TOP Network to be the work item
        with the given index.
        
        
        """
        pass
        
    
    def getPDGGraphContext(self):
        """None"""
        pass
        
    
    def taskGraphCommands():
        """
        taskGraphCommands(self) -> str
        
        Returns a string containing python commands require to construct the
        PDG task graph owned by the parent network of this node.
        
        
        """
        pass
        
    
    def enablePDGFilter(filter_on):
        """
        enablePDGFilter(self, filter_on)
        
        Sets the node's TOP network to use the current static task filter.
        
        
        """
        pass
        

def TopNode_swigregister():
    """None"""
    pass
    

class Track(object):
    """
    hou.Track
    
    Each hou.ChopNode contains its data in one or more tracks. A track
    contains a sequence of floating point samples over time. Each track has
    a unique name in its containing CHOP.
    
    REPLACES
    
    * chop()
    
    * chopcf()
    
    * chopci()
    
    * chopct()
    
    * chopf()
    
    * chopi()
    
    * chopl()
    
    * chopstr()
    
    * chopt()
    
    
    """
    
    def allSamples():
        """
        allSamples(self) -> tuple of double
        
        Returns all the sample values in this track.
        
        
        """
        pass
        
    
    def evalAtSampleRange(start, end):
        """
        evalAtSampleRange(self, start, end) -> tuple of double
        
        Returns the sample values of this track between a given start and
        end sample index.
        
        
        """
        pass
        
    
    def evalAtTime(time):
        """
        evalAtTime(self, time) -> double
        
        Returns the value of this track at a given time.
        
        
        """
        pass
        
    
    def evalAtTimeRange(start, end):
        """
        evalAtTimeRange(self, start, end) -> tuple of double
        
        Returns the sample values of this track between a given start and
        end time.
        
        
        """
        pass
        
    
    def eval():
        """
        eval(self) -> double
        
        Returns the value of this track at the current time.
        
        
        """
        pass
        
    
    def evalAtSampleIndex(index):
        """
        evalAtSampleIndex(self, index) -> double
        
        This method is deprecated in favor of evalAtSample.
        
        
        """
        pass
        
    
    def name():
        """
        name(self) -> str
        
        Returns the name of this track (each track in a CHOP has a unique
        name).
        
        
        """
        pass
        
    
    def chopNode():
        """
        chopNode(self) -> hou.ChopNode
        
        Returns the hou.ChopNode owner of this track.
        
        
        """
        pass
        
    
    def _asVoidPointer():
        """None"""
        pass
        
    
    def numSamples():
        """
        numSamples(self) -> int
        
        Return the number of samples in this track.
        
        
        """
        pass
        
    
    def evalAtSample(sample):
        """
        evalAtSample(self, sample) -> double
        
        Returns the value of the track at a given sample value.
        
        
        """
        pass
        
    
    def evalAtFrame(frame):
        """
        evalAtFrame(self, frame) -> double
        
        Returns the value of this track at a given frame.
        
        
        """
        pass
        
    
    def evalAtFrameRange(start, end):
        """
        evalAtFrameRange(self, start, end) -> tuple of double
        
        Returns the sample values of this track between a given start and
        end frame.
        
        
        """
        pass
        

def Track_swigregister():
    """None"""
    pass
    

class TypeError(Error):
    """
    hou.TypeError
    
    """
    
    def description():
        """
        description(self) -> str
        
        Return a description of the class of exception. The description is
        not related to the exception instance.
        
        
        """
        pass
        
    
    def exceptionTypeName():
        """
        exceptionTypeName(self) -> str
        
        Return the name of the exception type. Instances of different
        subclasses of hou.Error will return different names. Instances of
        the base class will return "Error".
        
        You can also use str(e.__class__) to get the name of the subclass.
        
        
        """
        pass
        

def TypeError_swigregister():
    """None"""
    pass
    

class UIEvent(object):
    """
    hou.UIEvent
    
    Represents a user interface event, such as a mouse press. You can access
    this object in an event handler to respond to user input.
    
    hou.UIEvent provides information to interact with user input and is used
    with Python states. You do not instantiate this type of object yourself.
    
    RELATED
    
    hou.ViewerEvent
    
    
    """
    
    def queuedEvents():
        """
        queuedEvents(self) -> list of hou.UIEventDevice
        
        If hou.UIEvent.hasQueuedEvents returns True, this method returns the
        list of queued input device events.
        
        
        """
        pass
        
    
    def valueType():
        """None"""
        pass
        
    
    def value():
        """
        value(self) -> obj
        
        Returns the value payload of this event. You can tell the type of
        this value by calling hou.UIEvent.valueType.
        
        
        """
        pass
        
    
    def reason():
        """
        reason(self) -> hou.uiEventReason
        
        For events related to state changes, returns an enum value
        representing the type of state change that triggered the event.
        
        
        """
        pass
        
    
    def device():
        """
        device(self) -> hou.UIEventDevice
        
        Returns an object containing input-device-specific event data. For
        example, if this is a mouse click event, you can use
        event.device().mouseX() to get the X coordinate in screen space, and
        event.device().isLeftButton() to check whether the left mouse button
        was pressed.
        
        > if ui_event.device().isLeftButton():
        >     ...
        
        """
        pass
        
    
    def hasQueuedEvents():
        """
        hasQueuedEvents(self) -> bool
        
        Returns true if this event contains queued device events.
        
        
        """
        pass
        

class UIEventDevice(object):
    """
    hou.UIEventDevice
    
    Object containing methods for testing input-device-specific information
    on a UI event, such as which mouse button was pressed.
    
    Do not instantiate this object yourself. You can get a UIEventDevice
    object from a hou.UIEvent using hou.UIEvent.device. For more information
    see Python states.
    
    
    """
    
    def isKeyPad():
        """
        isKeyPad(self) -> bool
        
        Returns True if the pressed key was on the number pad.
        
        
        """
        pass
        
    
    def isAltKey():
        """
        isAltKey(self) -> bool
        
        Returns True if an Alt/Option key was pressed.
        
        
        """
        pass
        
    
    def isRightButton():
        """
        isRightButton(self) -> bool
        
        Returns True if the [RMB] right mouse button was pressed.
        
        
        """
        pass
        
    
    def isArrowRight():
        """
        isArrowRight(self) -> bool
        
        Returns True if the Right arrow key was pressed.
        
        
        """
        pass
        
    
    def isTablet():
        """
        isTablet(self) -> bool
        
        Returns True if the event was generated by a tablet stylus.
        
        
        """
        pass
        
    
    def keyValue():
        """
        keyValue(self) -> int
        
        Returns the ascii code for the key being pressed. If modifiers, such
        as shift and ctrl, are pressed with a key, keyValue returns only the
        ascii code of the key, unlike hou.UIEvent.value which returns the
        encoded value of the keys combination.
        
        
        """
        pass
        
    
    def tabletPressure():
        """
        tabletPressure(self) -> double
        
        Returns the tablet pressure value.
        
        
        """
        pass
        
    
    def mouseWheel():
        """
        mouseWheel(self) -> int
        
        The result is negative if the wheel was rotated up and positive if
        it was rotated down.
        
        Different mice will produce different outputs:
        
        * Mice with "clicky" wheels will generally output a -1 or +1 event for
        each click (at least that is the intention).
        
        * Mice with "free spinning" wheels, or touch sensitive surfaces (such
        as the Apple Magic Mouse), will produce a wider range of values.
        Small/slow scrolling might trigger a mouse wheel event but this
        method returns 0, whereas big/fast scrolling can produce higher
        numbers for each event, up to around 7, with the numbers increasing
        as the user "throws" the wheel and decreasing as it slows.
        
        
        """
        pass
        
    
    def isMiddleButton():
        """
        isMiddleButton(self) -> bool
        
        Returns True if the [MMB] middle mouse button was pressed.
        
        
        """
        pass
        
    
    def isLeftButton():
        """
        isLeftButton(self) -> bool
        
        Returns True if the [LMB] left mouse button was pressed.
        
        
        """
        pass
        
    
    def isCapsLock():
        """
        isCapsLock(self) -> bool
        
        Returns True if the Caps Lock key was pressed.
        
        
        """
        pass
        
    
    def isKeyPressed():
        """
        isKeyPressed(self) -> bool
        
        Returns True if any key is pressed.
        
        
        """
        pass
        
    
    def isShiftKey():
        """
        isShiftKey(self) -> bool
        
        Returns True if the a Shift key was pressed.
        
        
        """
        pass
        
    
    def isCtrlKey():
        """
        isCtrlKey(self) -> bool
        
        Returns True if the Control key was pressed.
        
        
        """
        pass
        
    
    def isAutoRepeat():
        """
        isAutoRepeat(self) -> bool
        
        Returns True if the held key was auto-repeating.
        
        
        """
        pass
        
    
    def mouseX():
        """
        mouseX(self) -> int
        
        Returns the horizontal mouse position in screen coordinates,
        counting from the left edge of the view.
        
        
        """
        pass
        
    
    def keyString():
        """
        keyString(self) -> string
        
        Returns the string representation of the key being pressed. The
        return value can also contain space separated modifier symbols.
        
        Few examples:
        
        a
        
        a
        
        <cariage return>
        
        CR
        
        <tab space>
        
        TAB
        
        <back space>
        
        BS
        
        <esc>
        
        ESC
        
        <ctrl-space>
        
        ctrl SP
        
        <shft-a>
        
        shift a
        
        <ctrl-shift-a>
        
        ctrl shift a
        
        <alt-ctrl-a>
        
        alt ctrl a
        
        
        """
        pass
        
    
    def tabletAngle():
        """
        tabletAngle(self) -> double
        
        Returns tablet stylus angle value.
        
        
        """
        pass
        
    
    def tabletTilt():
        """
        tabletTilt(self) -> double
        
        Returns the tablet stylus tilt value.
        
        
        """
        pass
        
    
    def isArrowLeft():
        """
        isArrowLeft(self) -> bool
        
        Returns True if the Left arrow key was pressed.
        
        
        """
        pass
        
    
    def isArrowDown():
        """
        isArrowDown(self) -> bool
        
        Returns True if the Down arrow key was pressed.
        
        
        """
        pass
        
    
    def modifierString():
        """
        modifierString(self) -> string
        
        Returns the string representation of the modifier keys being
        pressed.
        
        The return value contain only modifier symbols, the key pressed is
        ignored.
        
        Few examples:
        
        <shift>
        
        shift
        
        <ctrl shift>
        
        ctrl shift
        
        <alt shift>
        
        alt shift
        
        
        """
        pass
        
    
    def tabletRoll():
        """
        tabletRoll(self) -> double
        
        Returns the tablet stylus roll value.
        
        
        """
        pass
        
    
    def isArrowUp():
        """
        isArrowUp(self) -> bool
        
        Returns True if the Up arrow key was pressed.
        
        
        """
        pass
        
    
    def time():
        """
        time(self): -> double
        
        Returns the time in seconds relative to the event.
        
        
        """
        pass
        
    
    def mouseY():
        """
        mouseY(self) -> int
        
        Returns the vertical mouse position in screen coordinates, counting
        from the bottom edge of the view.
        
        
        """
        pass
        

def UIEventDevice_swigregister():
    """None"""
    pass
    

def UIEvent_swigregister():
    """None"""
    pass
    

class UndosDisabler(object):
    """
    hou.UndosDisabler
    
    Use this class to disable undos within a Python code block.
    
    This object cannot be instantiated directly. See hou.undos.disabler.
    
    This object is a context manager. You can create one using
    hou.undos.disabler. Changes inside the with block will not add actions
    to the undo stack.
    
    
    """

def UndosDisabler_swigregister():
    """None"""
    pass
    

class UndosGroup(object):
    """
    hou.UndosGroup
    
    Used to group all undos within a Python code block into a single action.
    
    This object is a context manager. You can create one using
    hou.undos.group. Changes inside the with block appear as a single action
    in the undo stack.
    
    
    """
    
    def label():
        """
        label(self)
        
        Returns the group label.
        
        
        """
        pass
        

def UndosGroup_swigregister():
    """None"""
    pass
    

class VDB(Prim):
    """
    hou.VDB
    
    A VDB is a kind geometry primitive (Prim object) that stores data in a
    three dimensional grid of voxels.
    
    
    """
    
    def voxel(index):
        """
        voxel(self, index) -> float
        
        Given a sequence of three integers containing a voxel index, return
        the value of the corresponding voxel.
        
        
        """
        pass
        
    
    def voxelRange(range):
        """
        voxelRangeAsVector3(self, range) -> tuple of hou.Vector3
        
        Return a tuple containing the values of all voxels withing a
        bounding box range. It is faster to call this method to retrieve all
        the voxels than it is to loop through the voxel array in Python.
        
        See help for hou.VDB.voxelRange for implementation details.
        
        
        """
        pass
        
    
    def dataType():
        """
        dataType(self) -> hou.vdbData
        
        Returns the voxel data type within the VDB volume.
        
        
        """
        pass
        
    
    def vertex(index):
        """
        vertex(self, index) -> hou.Vertex
        
        A shortcut for self.vertices()[index]. You probably don't need to
        call this method.
        
        This method supports negative indices to index from the end, just
        like self.vertices()[index] would. Also, like Python's indexing
        operator, it will raise IndexError when the index is out of range.
        
        
        """
        pass
        
    
    def sample(position):
        """
        sample(self, position) -> float
        
        Given a sequence of three floats containing a 3D position, return
        the value of the volume at that position. If the position is not in
        the middle of a voxel, Houdini will interpolate using values from
        surrounding voxels.
        
        See also hou.VDB.voxel and hou.VDB.posToIndex.
        
        
        """
        pass
        
    
    def activeVoxelCount():
        """
        activeVoxelCount(self) -> int
        
        Returns the number of active voxels in the volume.
        
        
        """
        pass
        
    
    def voxelRangeAsFloat():
        """None"""
        pass
        
    
    def indexToPos(index):
        """
        indexToPos(self, index) -> hou.Vector3
        
        Given a sequence of three ints containing an index into the voxel
        array, return the corresponding 3D position of the middle of that
        voxel.
        
        
        """
        pass
        
    
    def posToIndex(position):
        """
        posToIndex(self, position) -> tuple of int
        
        Given a sequence of three floats containing a 3D position, return a
        tuple of three ints containing the corresponding index into the
        voxel array.
        
        
        """
        pass
        
    
    def voxelRangeAsBool():
        """None"""
        pass
        
    
    def taper():
        """
        taper(self) -> int
        
        Returns the taper value of the volume's transform. For untapered
        transforms, this value will be 1.
        
        
        """
        pass
        
    
    def gradient(position):
        """
        gradient(self, position) -> hou.Vector3
        
        Given a sequence of three floats containing a 3D position, return a
        vector which points in the direction of the greatest rate of
        increase of the volume's value.
        
        See Wikipedia's gradient page for more information.
        
        
        """
        pass
        
    
    def isSDF():
        """
        isSDF(self) -> bool
        
        Return whether or not the volume should be semantically treated as a
        signed distance field. If true, the volume can be thought of as
        representing a closed surface, where the negative voxel values are
        inside, the positive voxel values are outside, and voxels on the
        surface are zero.
        
        For VDB volumes, there is typically only a 3 voxel radius around the
        surface where there exists data.
        
        
        """
        pass
        
    
    def transform():
        """
        transform(self) -> hou.Matrix3
        
        Return a 3x3 matrix containing the scale and rotation
        transformations for this volume.
        
        Note that the position information for the volume can be obtained by
        calling volume.vertex(0).point().position().
        
        The following function returns a 4x4 transformation matrix for the
        volume that includes the translation:
        
        > def fullTransform(volume):
        >     return (hou.Matrix4(volume.transform()) *
        >         hou.hmath.buildTranslate(volume.vertex(0).point().position()))
        
        NOTE
        You need to get the object node's transform to get to
        worldspace.
        
        
        """
        pass
        
    
    def activeVoxelBoundingBox():
        """
        activeVoxelBoundingBox(self) -> hou.BoundingBox
        
        Returns the smallest exclusive bounding box within the VDB volume
        that has active voxels.
        
        
        """
        pass
        
    
    def isEmpty():
        """
        isEmpty(self) -> bool
        
        Returns whether the VDB volume has no data.
        
        
        """
        pass
        
    
    def voxelSize():
        """
        voxelSize(self) -> hou.Vector3
        
        Returns the size of voxels within the VDB volume. All voxels will be
        of this size for untapered volumes. For tapered volumes, this size
        represents the size of voxel at the origin of the frustum.
        
        
        """
        pass
        
    
    def voxelRangeAsVector3():
        """None"""
        pass
        
    
    def voxelRangeAsInt():
        """None"""
        pass
        
    
    def resolution():
        """
        resolution(self) -> hou.Vector3
        
        Return the x, y, and z dimensions of hou.VDB.activeVoxelBoundingBox.
        Since VDB volumes are sparse, this represents the virtual resolution
        of all the voxels which have data (or are "active").
        
        
        """
        pass
        

def VDB_swigregister():
    """None"""
    pass
    

class ValueError(Error):
    """
    hou.ValueError
    
    """
    
    def description():
        """
        description(self) -> str
        
        Return a description of the class of exception. The description is
        not related to the exception instance.
        
        
        """
        pass
        
    
    def exceptionTypeName():
        """
        exceptionTypeName(self) -> str
        
        Return the name of the exception type. Instances of different
        subclasses of hou.Error will return different names. Instances of
        the base class will return "Error".
        
        You can also use str(e.__class__) to get the name of the subclass.
        
        
        """
        pass
        

def ValueError_swigregister():
    """None"""
    pass
    

class Vector2(object):
    """
    hou.Vector2
    
    A sequence of 2 floating point values, with associated mathematical
    operations.
    
    A Vector2 might be used to represent a position in 2D space, a 2D
    direction and length, or the size of a rectangle. For example,
    hou.Node.position returns a position and hou.Node.size returns the size
    of a rectangle.
    
    See also hou.Vector3 and hou.Vector4.
    
    
    """
    
    def almostEqual():
        """None"""
        pass
        
    
    def lengthSquared():
        """
        lengthSquared(self) -> float
        
        Interpret this vector as a direction vector and return the square of
        its length. The result is the same as self[0]**2 + self[1]**2.
        
        
        """
        pass
        
    
    def isAlmostEqual(vector2, tolerance=0.00001):
        """
        isAlmostEqual(self, vector2, tolerance=0.00001) -> bool
        
        Return whether this vector is equal to another, within a tolerance.
        Verifies that the difference between each component of this vector
        and the corresponding component of the other vector is within the
        tolerance.
        
        
        """
        pass
        
    
    def normalized():
        """
        normalized(self) -> hou.Vector2
        
        Interpreting this vector as a direction, return a vector with the
        same direction but with a length of 1.
        
        If the vector's length is 0 (or close to it), the result is the
        original vector.
        
        For vector's with non-zero lengths, this method is equivalent to
        self * (1.0/self.length()).
        
        
        """
        pass
        
    
    def setTo(sequence):
        """
        setTo(self, sequence)
        
        Set the contents of this vector to a sequence of floats.
        
        Raises InvalidSize if values is not 2 elements long, or TypeError if
        values is not a sequence of floats or ints.
        
        
        """
        pass
        
    
    def distanceTo(vector2):
        """
        distanceTo(self, vector2) -> float
        
        Interpret this vector and the argument as 2D positions, and return
        the distance between them. The return value is equivalent to (self -
        vector2).length().
        
        
        """
        pass
        
    
    def dot(vector2):
        """
        dot(self, vector2) -> float
        
        Return the dot product between this vector and the one in the
        parameter.
        
        See Wikipedia's dot product page.
        
        
        """
        pass
        
    
    def _asVoidPointer():
        """None"""
        pass
        
    
    def length():
        """
        length(self) -> float
        
        Interpret this vector as a direction vector and return its length.
        The result is the same as math.sqrt(self[0]**2 + self[1]**2).
        
        
        """
        pass
        
    
    def y():
        """
        y(self) -> float
        
        Return the second component of the vector. Equivalent to v.
        
        
        """
        pass
        
    
    def x():
        """
        x(self) -> float
        
        Return the first component of the vector. Equivalent to v.
        
        
        """
        pass
        

def Vector2_swigregister():
    """None"""
    pass
    

class Vector3(object):
    """
    hou.Vector3
    
    A sequence of 3 floating point values, with associated mathematical
    operations.
    
    A Vector3 might be used to represent a position in 3D space, or a 3D
    direction with a length.
    
    See also hou.Vector2 and hou.Vector4.
    
    
    """
    
    def almostEqual():
        """None"""
        pass
        
    
    def smoothRotation(reference, rotate_order="xyz"):
        """
        smoothRotation(self, reference, rotate_order="xyz") -> hou.Vector3
        
        Returns the Euler rotations (in degrees) that have the closest
        values to reference while still describing the same orientation as
        this vector.
        
        
        reference
        A hou.Vector3 of Euler angles, in degrees. Typically, this will
        be the rotations from the previous sample or frame.
        
        rotate_order
        A string containing a permutation of the letters x, y, and z
        that determines the order in which rotations are performed about
        the coordinate axes.
        
        
        """
        pass
        
    
    def distanceToSegment(point1, point2):
        """
        pointOnSegment(self, point1, point2) -> hou.Vector3
        
        Project the underlying vector onto the line segment defined by
        point1 to point2. The returned point will lie on the line segment.
        
        
        `point1'
        The first hou.Vector3 of the line segment.
        
        `point2'
        The second hou.Vector3 of the line segment.
        
        
        """
        pass
        
    
    def setTo(sequence):
        """
        setTo(self, sequence)
        
        Set the contents of this vector to a sequence of floats.
        
        Raises InvalidSize if values is not 3 elements long, or TypeError if
        values is not a sequence of floats or ints.
        
        
        """
        pass
        
    
    def distanceTo(vector3):
        """
        distanceTo(self, vector3) -> float
        
        Interpret this vector and the argument as 3D positions, and return
        the distance between them. The return value is equivalent to (self -
        vector3).length().
        
        
        """
        pass
        
    
    def _asVoidPointer():
        """None"""
        pass
        
    
    def cross(vector3):
        """
        cross(self, vector3) -> hou.Vector3
        
        Return the cross product of this vector with another vector. The
        return value is a vector that is perpendicular to both vectors,
        pointing in the direction defined by the right-hand rule, with
        length self.length() * vector3.length() *
        math.sin(hou.hmath.degToRad(self.angleTo(vector3))).
        
        See Wikipedia's cross product page.
        
        
        """
        pass
        
    
    def pointOnSegment():
        """None"""
        pass
        
    
    def multiplyAsDir(matrix4):
        """
        multiplyAsDir(self, matrix4) -> hou.Vector3
        
        Interpret this vector as a direction and returns a transformed
        direction that has been rotated and scaled (not translated) by the
        matrix4
        
        
        """
        pass
        
    
    def lengthSquared():
        """
        lengthSquared(self) -> float
        
        Interpret this vector as a direction vector and return the square of
        its length. The result is the same as self[0]**2 + self[1]**2 +
        self[2]**2.
        
        
        """
        pass
        
    
    def matrixToRotateTo(vector3):
        """
        matrixToRotateTo(self, vector3) -> hou.Matrix4
        
        Return a matrix that rotates this vector onto vector3, rotating
        about the axis perpendicular to the two vectors. If the two vectors
        have the same direction, return the identity matrix.
        
        
        """
        pass
        
    
    def angleTo(vector3):
        """
        angleTo(self, vector3) -> float
        
        Interprets this Vector3 and the parameter as directions and returns
        the angle (in degrees) formed between the two vectors when you place
        the origins at the same location.
        
        
        """
        pass
        
    
    def isAlmostEqual(vector3, tolerance=0.00001):
        """
        isAlmostEqual(self, vector3, tolerance=0.00001) -> bool
        
        Return whether this vector is equal to another, within a tolerance.
        Verifies that the difference between each component of this vector
        and the corresponding component of the other vector is within the
        tolerance.
        
        
        """
        pass
        
    
    def normalized():
        """
        normalized(self) -> hou.Vector3
        
        Interpret this vector as a direction and return a vector with the
        same direction but with a length of 1.
        
        If the vector's length is 0 (or close to it), the result is the
        original vector.
        
        For vectors with non-zero lengths, this method is equivalent to self
        * (1.0/self.length()).
        
        
        """
        pass
        
    
    def ocio_transform(src_space, dest_space):
        """
        ocio_transform(self, src_space, dest_space) -> hou.Vector3
        
        Use Open Color IO to transform the color from the source space to
        the destination space.
        
        
        """
        pass
        
    
    def length():
        """
        length(self) -> float
        
        Interpret this vector as a direction vector and return its length.
        The result is the same as math.sqrt(self[0]**2 + self[1]**2 +
        self[2]**2).
        
        
        """
        pass
        
    
    def distance2ToSegment():
        """None"""
        pass
        
    
    def y():
        """
        y(self) -> float
        
        Return the second component of the vector. Equivalent to v.
        
        
        """
        pass
        
    
    def x():
        """
        x(self) -> float
        
        Return the first component of the vector. Equivalent to v.
        
        
        """
        pass
        
    
    def z():
        """
        z(self) -> float
        
        Return the third component of the vector. Equivalent to v.
        
        
        """
        pass
        
    
    def dot(vector3):
        """
        dot(self, vector3) -> float
        
        Return the dot product between this vector and the one in the
        parameter. This value is equal to self[0]*vector3[0] +
        self[1]*vector3[1] + self[2]*vector3[2], which is also equal to
        self.length() * vector3.length() *
        math.cos(hou.hmath.degToRad(self.angleTo(vector3)))
        
        See Wikipedia's dot product page.
        
        
        """
        pass
        

def Vector3_swigregister():
    """None"""
    pass
    

class Vector4(object):
    """
    hou.Vector4
    
    A sequence of 4 floating point values, with associated mathematical
    operations.
    
    A Vector4 could be used to represent a position or direction in 4D
    space. In 3D math, however, it is more commonly used to represent either
    a position or a vector, depending on the value of the fourth component.
    Positions have a fourth component of 1.0, and vectors have a fourth
    component of 0.0. Subtracting a position from another yields a vector,
    adding two vectors together yields a vector, and adding a point and a
    vector yields a point. Operations that yield a fourth component value
    other than 0 or 1, like adding two points together, are not valid.
    Similarly, is makes sense to speak about a vector's length but not a
    position's length. The fourth component also affects how the
    position/vector is transformed; see hou.Vector3.__mul__ for more
    information.
    
    See also hou.Vector2 and hou.Vector3.
    
    
    """
    
    def almostEqual():
        """None"""
        pass
        
    
    def lengthSquared():
        """
        lengthSquared(self) -> float
        
        Return the result of self.length()**2. The result is the same as
        self[0]**2 + self[1]**2 + self[2]**2 + self[3]**2.
        
        
        """
        pass
        
    
    def isAlmostEqual(vector4, tolerance=0.00001):
        """
        isAlmostEqual(self, vector4, tolerance=0.00001) -> bool
        
        Return whether this vector is equal to another, within a tolerance.
        Verifies that the difference between each component of this vector
        and the corresponding component of the other vector is within the
        tolerance.
        
        
        """
        pass
        
    
    def normalized():
        """
        normalized(self) -> Vector4
        
        Interpret this vector as a 4D direction and return a vector with the
        same direction but with a length of 1. If this vector being used to
        represent a 3D direction (so the fourth component is 0), the result
        is still meaningful, and represents the corresponding 3D direction.
        
        If the vector's length is 0 (or close to it), the result is the
        original vector.
        
        For vectors with non-zero lengths, this method is equivalent to self
        * (1.0/self.length()).
        
        
        """
        pass
        
    
    def setTo(sequence):
        """
        setTo(self, sequence)
        
        Set the contents of this vector to a sequence of floats.
        
        Raises InvalidSize if values is not 4 elements long, or TypeError if
        values is not a sequence of floats or ints.
        
        
        """
        pass
        
    
    def ocio_transform(src_space, dest_space):
        """
        ocio_transform(self, src_space, dest_space) -> hou.Vector4
        
        Use Open Color IO to transform the color from the source space to
        the destination space.
        
        
        """
        pass
        
    
    def dot(vector4):
        """
        dot(self, vector4) -> float
        
        Return the dot product between this 4D vector and the one in the
        parameter. This value is equal to self[0]*vector4[0] +
        self[1]*vector4[1] + self[2]*vector4[2] + self[3]*vector4[3].
        
        
        """
        pass
        
    
    def _asVoidPointer():
        """None"""
        pass
        
    
    def length():
        """
        length(self) -> float
        
        Interpret this vector as a 4D direction vector and return its
        length. If this vector is representing a 3D direction (so the fourth
        component is 0), the result is the 3D length.
        
        The result is the same as math.sqrt(self[0]**2 + self[1]**2 +
        self[2]**2 + self[3]**2).
        
        
        """
        pass
        
    
    def w():
        """
        w(self) -> float
        
        Return the fourth component of the vector. Equivalent to v.
        
        
        """
        pass
        
    
    def y():
        """
        y(self) -> float
        
        Return the second component of the vector. Equivalent to v.
        
        
        """
        pass
        
    
    def x():
        """
        x(self) -> float
        
        Return the first component of the vector. Equivalent to v.
        
        
        """
        pass
        
    
    def z():
        """
        z(self) -> float
        
        Return the third component of the vector. Equivalent to v.
        
        
        """
        pass
        

def Vector4_swigregister():
    """None"""
    pass
    

class Vertex(object):
    """
    hou.Vertex
    
    Existing inside a Geometry object, a Vertex object is contained in
    exactly one Prim, and references exactly one Point.
    
    This setup allows points to be shared between primitives. For example, a
    polygon contains its own list of vertices that are not shared with other
    primitives, but vertices in different polygons may refer to the same
    point. When that point moves, the corresponding vertices on all adjacent
    polygons will also move, preventing polygon edges from separating.
    
    Note that you can use hou.Vertex.point to retrieve a point from a
    vertex, but there is no method to retrieve all the vertices referring to
    a point. Houdini does not store this information internally, but you can
    derive it. The best way to quickly retrieve this information is to build
    a dictionary mapping all points to sets of vertices, and then reuse this
    dictionary in your algorithm.
    
    
    """
    
    def linearNumber():
        """
        linearNumber(self) -> int
        
        Return the number of this vertex within its whole detail. Vertices
        in the detail are sometimes in the same order as they occur in
        primitives, but this is often *not* true. Linear vertex numbers in a
        detail are sequential, starting from 0, and ending with one less
        than the total number of vertices in the detail. This can be useful
        so that a function that can be applied to point, vertex, primitive,
        or detail attributes doesn't have to take two numbers just to handle
        the vertex case.
        
        
        """
        pass
        
    
    def prim():
        """
        prim(self) -> hou.Prim
        
        Return the hou.Prim object containing this vertex.
        
        If the primitive is a face, use hou.Prim.vertices to access the
        other vertices in the primitive. If it is a surface, use
        hou.Surface.vertex, hou.Surface.numRows, and hou.Surface.numCols.
        
        
        """
        pass
        
    
    def point():
        """
        point(self) -> hou.Point
        
        Return the hou.Point object that this vertex refers to. Each vertex
        refers to exactly one point.
        
        
        """
        pass
        
    
    def stringListAttribValue(name_or_attrib):
        """
        stringListAttribValue(self, name_or_attrib) -> tuple of str
        
        Return the vertex attribute value for a particular string attribute.
        The attribute may be specified by name or by hou.Attrib object. The
        return value is a tuple of strings.
        
        It is valid to call this method when the attribute's size is 1. In
        this case, a tuple with one element is returned.
        
        See also hou.Vertex.attribValue.
        
        
        """
        pass
        
    
    def number():
        """
        number(self) -> int
        
        Return the number of this vertex within its primitive. Vertices in
        the same primitive are numbered sequentially starting from 0, and
        the vertices returned by hou.Prim.vertices are in order by their
        number.
        
        
        """
        pass
        
    
    def intAttribValue(name_or_attrib):
        """
        intAttribValue(self, name_or_attrib) -> int
        
        Return the vertex attribute value for a particular integer attribute
        of size 1. The attribute may be specified by name or by hou.Attrib
        object. See hou.Vertex.floatAttribValue for more information.
        
        
        """
        pass
        
    
    def setAttribValue(name_or_attrib, attrib_value):
        """
        setAttribValue(self, name_or_attrib, attrib_value)
        
        Store an attribute value in this vertex. The attribute may be
        specified by name or by hou.Attrib object, and must be an existing
        vertex attribute in the geometry. You would typically call this
        method from the code of a Python-defined SOP.
        
        Raises hou.OperationFailed if no attribute exists with this name or
        if the attribute's data type does not match the value passed in. If
        the attribute's size is more than 1, the attribute value must be a
        sequence of integers/floats, and the size of the sequence must match
        the attribute's size.
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable.
        
        
        """
        pass
        
    
    def stringAttribValue(name_or_attrib):
        """
        stringAttribValue(self, name_or_attrib) -> str
        
        Return the vertex attribute value for a particular string attribute.
        The attribute may be specified by name or by hou.Attrib object. See
        hou.Vertex.floatAttribValue for more information.
        
        
        """
        pass
        
    
    def floatListAttribValue(name_or_attrib):
        """
        floatListAttribValue(self, name_or_attrib) -> tuple of float
        
        Return the vertex attribute value for a particular floating point
        attribute. The attribute may be specified by name or by hou.Attrib
        object. The return value is a tuple of floats.
        
        It is valid to call this method when the attribute's size is 1. In
        this case, a tuple with one element is returned.
        
        See also hou.Vertex.attribValue.
        
        
        """
        pass
        
    
    def intListAttribValue(name_or_attrib):
        """
        intListAttribValue(self, name_or_attrib) -> tuple of int
        
        Return the vertex attribute value for a particular integer
        attribute. The attribute may be specified by name or by hou.Attrib
        object. The return value is a tuple of ints. See
        hou.Vertex.floatListAttribValue for more information.
        
        
        """
        pass
        
    
    def floatAttribValue(name_or_attrib):
        """
        floatAttribValue(self, name_or_attrib) -> float
        
        Return the vertex attribute value for a particular floating point
        attribute. The attribute may be specified by name or by hou.Attrib
        object.
        
        Raises hou.OperationFailed if no attribute exists with this name or
        the attribute is not float of size 1.
        
        In most cases, you'll just use hou.Vertex.attribValue to access
        attribute values. Houdini uses this method internally to implement
        attribValue.
        
        
        """
        pass
        
    
    def geometry():
        """
        geometry(self) -> Geometry
        
        Return the hou.Geometry object containing this vertex.
        
        
        """
        pass
        
    
    def attribValue(name_or_attrib):
        """
        attribValue(self, name_or_attrib) -> int, float, str or tuple
        
        Return the value store in this vertex for a particular attribute.
        The attribute may be specified by name or by hou.Attrib object.
        
        Looking an attribute value using a hou.Attrib object is slightly
        faster than looking it up by name. When looking up attribute values
        inside a loop, look up the hou.Attrib object outside the loop, and
        pass it into this method.
        
        Raises hou.OperationFailed if no attribute exists with this name.
        
        
        """
        pass
        
    
    def attribType():
        """
        attribType(self) -> hou.attribType enum value
        
        Return the enumerated value hou.attribType.Vertex. Points,
        primitives, vertices, and geometry support the same set of methods
        for querying their attributes, and this method is one of them.
        
        See also:
        
        * hou.Point.attribType
        
        * hou.Prim.attribType
        
        * hou.Geometry.attribType
        
        * hou.attribType
        
        
        """
        pass
        

def Vertex_swigregister():
    """None"""
    pass
    

class VexContext(object):
    """
    hou.VexContext
    
    Represents a VEX/VOP context. Different contexts allow the use of
    different functions/VOPs.
    
    
    NOTE
    This class is for internal use by Houdini and isn't usually
    necessary for scripting Houdini or creating tools.
    
    This object is returned by hou.vexContextForNodeTypeCategory and
    hou.vexContextForShaderType. You can get a list of all VEX context
    objects using hou.vexContexts.
    
    REPLACES
    
    * vexinfo
    
    
    """
    
    def nodeTypeCategory():
        """
        nodeTypeCategory(self) -> hou.NodeTypeCategory
        
        Returns the hou.NodeTypeCategory object associated with this VEX
        context.
        
        > >>> # Get a reference to a SOP node
        > >>> n = hou.node("/obj/geo1/pointvop1")
        > >>> # Get its type category (SOPs)
        > >>> sops = n.type().category()
        > >>> # Get the context associated with the SOPs category
        > >>> ctx = hou.vexContextForNodeTypeCategory(sops)
        > >>> # Get the node type category associated with the Sop context
        > >>> ctx.nodeTypeCategory()
        > <hou.NodeTypeCategory for Sop>
        
        """
        pass
        
    
    def shaderType():
        """
        shaderType(self) -> hou.shaderType enum value or None
        
        Returns a hou.shaderType value representing the shader type
        associated with this VEX context.
        
        
        """
        pass
        
    
    def pathsToLoadedVexFunctions():
        """
        pathsToLoadedVexFunctions(self) -> dict mapping names to paths
        
        
        """
        pass
        
    
    def name():
        """
        name(self) -> str
        
        Returns the name of this context as a string. For example, 'Sop' or
        'surface'.
        
        
        """
        pass
        

def VexContext_swigregister():
    """None"""
    pass
    

class ViewerEvent(UIEvent):
    """
    hou.ViewerEvent
    
    Represents a user interface event specific to viewers.
    
    hou.ViewerEvent objects are used with Python states. Houdini will call
    event handlers with a dictionary containing various useful data,
    including a ui_event key containing a ViewerEvent object. You do not
    instantiate this type of object yourself. See Python states for more
    information.
    
    hou.ViewerEvent is a specialized hou.UIEvent class that you can used for
    accessing ray coordinates in a viewer.
    
    
    """
    
    def snappingRay():
        """
        snappingRay(self) -> (origin_point, direction, snapped)
        
        Same as hou.ViewerEvent.ray, but the returned original point may be
        snapped with respect to the snapping controls in Houdini. The tuple
        returns the hou.Vector3 objects representing the origin point and a
        direction vector along with a bool value (snapped) representing the
        snap result.
        
        If snapped is True, the origin point corresponds to a snapped
        coordinate in 3D world space. If False, the origin point is a
        regular "pointing ray".
        
        
        Note
        snapped may be False if snap is not enabled or the origin point
        doesn't correspond to a snapped point.
        
        
        """
        pass
        
    
    def ray():
        """
        ray(self) -> (origin_point, direction)
        
        Returns a tuple of two hou.Vector3 objects representing the origin
        point and a direction vector of a "pointing ray" in 3D world space
        corresponding to the underlying hou.UIEventDevice's mouse
        coordinates in screen space.
        
        The resulting ray can be used to shoot into the scene that passes
        through whatever is under the mouse. The method puts the ray origin
        at the mouse screen coordinates on the near plane and then maps the
        camera space position to world space. For a perspective projection,
        the near plane part of the frustum is usually small in world space,
        so the origin point will be pretty close to the camera position.
        
        
        """
        pass
        

def ViewerEvent_swigregister():
    """None"""
    pass
    

class ViewerState(object):
    """
    hou.ViewerState
    
    Describes an interactive state for a viewer pane.
    
    Viewer panes such as a Scene Viewer or Compositor Viewer can enter
    specific "states". A state controls the available handles, mouse
    interactions, and in some cases node creation or deletion based on user
    interaction with the viewer pane. This class does not represent a
    running state in a viewer, but instead describes a state that can be
    entered with methods such as hou.SceneViewer.setCurrentState or
    hou.CompositorViewer.setCurrentState.
    
    Each node type that can be displayed in a viewer pane will have an
    associated viewer state (though not all viewer states need to be
    associated with a node type). This node type specific viewer state is
    used to create new instances or edit existing instances of the node type
    in a viewer pane.
    
    The list of viewer states associated with a given node type category is
    returned from the hou.NodeTypeCategory.viewerStates method.
    
    
    """
    
    def nodeType():
        """
        nodeType(self) -> hou.NodeType or None
        
        Return the node type associated with this state. May return None if
        this state is not associated with a particular node type, such as
        the SOP or Object View states which are used for panning and
        tumbling in a scene viewer pane.
        
        
        """
        pass
        
    
    def parmTemplates():
        """
        parmTemplates(self) -> hou.ParmTemplateGroup
        
        Return the parameter templates associated with this state.
        
        
        """
        pass
        
    
    def name():
        """
        name(self) -> string
        
        Return the internal name of this state, which is the string that
        must be passed to the setCurrentState() method of the viewer pane to
        enter this state.
        
        
        """
        pass
        
    
    def hotkey():
        """
        hotkey(self) -> string
        
        Return the hotkey associated with this state.
        
        
        """
        pass
        
    
    def icon():
        """
        icon(self) -> string
        
        Return the icon for the state that appears in the upper left corner
        of the viewer pane when this state is active.
        
        
        """
        pass
        
    
    def isHidden():
        """None"""
        pass
        
    
    def categories():
        """
        categories(self) -> tuple of hou.NodeTypeCategory
        
        Return the node type category for the nodes that are associated with
        this state.
        
        
        """
        pass
        
    
    def description():
        """
        description(self) -> string
        
        Return the brief name of the state that appears in the upper left
        corner of the viewer pane when this state is active.
        
        
        """
        pass
        

class ViewerStateMenu(object):
    """
    hou.ViewerStateMenu
    
    Builds a context menu for a viewer state.
    
    OVERVIEW
    
    The ViewerStateMenu class lets you build a context menu for a viewer
    state. This class is also represents sub-menus of the top-level
    context menu.
    
    Currently you can add the following items to the menu
    
    * Toggle (checkbox) item: represents a setting you can turn on or off
    
    * Radio strip: represents a choice of several mutually exclusive
    items.
    
    * Action item: represents an action to preform. You implement the
    action in the state's onMenuAction method.
    
    * Separator item: creates a visual separation between groups of items
    in the menu.
    
    Hotkeys created with hou.hotkeys.addCommand can be added to toggle,
    action and radio strip menu items.
    
    See setting up viewer state context menus for more information.
    
    The following example shows how to implement and bind a menu to a
    sop viewer state.
    
    > from __future__ import print_function
    > import hou
    >
    >
    > class ExampleState(object):
    >     def __init__(self, state_name, scene_viewer):
    >         self.state_name = state_name
    >         self.scene_viewer = scene_viewer
    >
    >     # the menu callback
    >     def onMenuAction(self, kwargs):
    >         action = kwargs["menu_item"]
    >         if action == 'toggle1':
    >             print("Set toggle 1 to", kwargs["toggle1"])
    >
    >         elif action == 'toggle2':
    >             print("Set toggle 2 to", kwargs["toggle2"])
    >
    >         elif action == 'action':
    >             print("Chose action 1")
    >
    >         elif action == 'radio_strip':
    >             print("Set the radio strip to", kwargs["radio_strip"])
    >
    >         elif action == 'submenu_toggle1':
    >             print("Set the submenu toggle to", kwargs["submenu_toggle1"])
    >
    >
    > def createViewerStateTemplate(state_type, state_label):
    >     template = hou.ViewerStateTemplate(
    >         state_type, state_label, hou.sopNodeTypeCategory()
    >     )
    >     template.bindFactory(ExampleState)
    >
    >     # create some hotkeys
    >     example_context = "h.pane.gview.state.sop.example"
    >     hou.hotkeys.addContext(example_context, "Example Operation", "These keys apply to the Example operations")
    >
    >     h1 = example_context + 'h1'
    >     hou.hotkeys.addCommand(h1, 'example 1', 'example 1')
    >     hou.hotkeys.addAssignment(h1, '1')
    >
    >     h2 = example_context + 'h2'
    >     hou.hotkeys.addCommand(h2, 'example 2', 'example 2')
    >     hou.hotkeys.addAssignment(h2, '2')
    >
    >     h3 = example_context + 'h3'
    >     hou.hotkeys.addCommand(h3, 'example 3', 'example 3')
    >     hou.hotkeys.addAssignment(h3, '3')
    >
    >     h4 = example_context + 'h3'
    >     hou.hotkeys.addCommand(h4, 'example 4', 'example 4')
    >     hou.hotkeys.addAssignment(h4, '4')
    >
    >     # define the state popupmenu
    >     m = hou.ViewerStateMenu('menu', 'Example')
    >
    >     m.addSeparator()
    >     m.addToggleItem( 'toggle1', 'Toggle1', True, hotkey=h1 )
    >     m.addToggleItem( 'toggle2', 'Toggle2', False )
    >     m.addSeparator()
    >     m.addActionItem( 'action', 'Action1', hotkey=h2 )
    >     m.addSeparator()
    >     m.addRadioStrip( 'radio_strip', 'Radio', "radio_item1" )
    >     m.addRadioStripItem( 'radio_strip', 'radio_item1', 'Radio1', hotkey=h3 )
    >     m.addRadioStripItem( 'radio_strip', 'radio_item2', 'Radio2', hotkey=h4 )
    >     m.addSeparator()
    >     subm = hou.ViewerStateMenu('submenu', 'More Example...')
    >     subm.addToggleItem( 'submenu_toggle1', 'Sub toggle1', True )
    >     m.addMenu( subm )
    >     m.addSeparator()
    >
    >     # attach popupmenu to state
    >     template.bindMenu(m)
    >
    >     return t
    
    
    """
    
    def addActionItem():
        """None"""
        pass
        
    
    def addRadioStripItem(strip_id, id, label, hotkey=''):
        """
        addRadioStripItem(self, strip_id, id, label, hotkey='')
        
        Adds an menu item to a radio strip menu.
        
        
        strip_id
        The string ID of the radio strip (created with addRadioStrip()).
        All items that share the same strip_id are mutually exclusive.
        
        id
        A unique string ID for this item.
        
        label
        The menu item text as it will appear in the menu.
        
        hotkey
        An optional hotkey ID string to associate with this menu item.
        You can use hou.hotkeys.addCommand to create a custom hotkey.
        
        > menu = hou.ViewerStateMenu("menu", "State Menu")
        > menu.addRadioStrip("deform_type", "Deformation", "bend")
        > menu.addRadioStripItem("deform_type", "bend", "Bend")
        > menu.addRadioStripItem("deform_type", "squash", "Squash")
        
        """
        pass
        
    
    def addSeparator():
        """
        addSeparator(self)
        
        Adds a separator menu item.
        
        > menu = hou.ViewerStateMenu("menu", "State Menu")
        > menu.addActionItem("delete", "Delete")
        > menu.addSeparator()
        > menu.addToggleItem("show_points", "Show Points", True)
        > menu.addToggleItem("show_point_nums", "Show Point Numbers", False)
        
        """
        pass
        
    
    def addRadioStrip(id, label, default):
        """
        addRadioStrip(self, id, label, default)
        
        Prepares the menu to accept a group of mutually exclusive "radio
        button" items.
        
        
        id
        A unique string ID for the strip. All menu items added to the
        group with addRadioStripItem() will have this string as their
        first argument.
        
        label
        A title displayed above the group in the menu.
        
        default
        A radio item id as specified with
        hou.ViewerStateMenu.addRadioStripItem representing the default
        choice when the menu is created.
        
        > menu = hou.ViewerStateMenu("menu", "State Menu")
        > menu.addRadioStrip("deform_type", "Deformation", "bend")
        > menu.addRadioStripItem("deform_type", "bend", "Bend")
        > menu.addRadioStripItem("deform_type", "squash", "Squash")
        
        """
        pass
        
    
    def addMenu(submenu):
        """
        addMenu(self, submenu)
        
        Adds a ViewerStateMenu object as a submenu.
        
        > menu = hou.ViewerStateMenu("menu", "State Menu")
        > menu.addActionItem("delete", "Delete")
        > menu.addSeparator()
        > submenu = hou.ViwerStateMenu("options", "Options")
        > submenu.addToggleItem("show_points", "Show Points", True)
        > submenu.addToggleItem("show_point_nums", "Show Point Numbers", False)
        > menu.addMenu(submenu)
        
        """
        pass
        
    
    def addToggleItem(id, label, default, hotkey=''):
        """
        addToggleItem(self, id, label, default, hotkey='' )
        
        Adds a toggle menu item to this menu.
        
        
        id
        A unique string ID for this item.
        
        label
        The menu item text as it will appear in the menu.
        
        default
        Whether the item is on or off by default when the menu is
        created.
        
        hotkey
        An optional hotkey ID string to associate with this menu item.
        You can use hou.hotkeys.addCommand to create a custom hotkey.
        
        > menu = hou.ViewerStateMenu("menu", "State Menu")
        > menu.addToggleItem("show_points", "Show Points", True)
        > menu.addToggleItem("show_point_nums", "Show Point Numbers", False
        
        """
        pass
        

def ViewerStateMenu_swigregister():
    """None"""
    pass
    

class ViewerStateTemplate(object):
    """
    hou.ViewerStateTemplate
    
    Contains attributes describing a custom viewer state (tool).
    
    Viewer states control interaction in the viewport. For example, the
    Rotate tool is a view state. The Handles tool allows access to the state
    associated with the current node. Houdini lets you create and register
    your own custom view states in Python.
    
    This object describes a custom state, including its implementation class
    and any bindings (menus, handles, hotkeys, selectors). You supply an
    instance of this object when registering a custom state, and Houdini
    uses it to create concrete instances of the state from the template.
    
    > import hou
    >
    > # Create a class implementing the state callbacks
    > class MyState(object):
    >     def __init__(self, state_name, scene_viewer):
    >         self.state_name = state_name
    >         self.scene_viewer = scene_viewer
    >
    >
    > # Create a template to describe the state and its bindings
    > template = hou.ViewerStateTemplate(
    >     "mystate", "My Custom State",
    >     hou.sopNodeTypeCategory()
    > )
    > template.bindFactory(MyState)
    > template.bindHandleStatic(
    >     "rotate", "rot",
    >     [("rx", "x"), ("ry", "y"), ("rz", "z")]
    > )
    >
    > # Register the template with Houdini
    > hou.ui.registerViewerState(my_template)
    
    For information on how to create your own custom view states, see Python
    states.
    
    
    """
    
    def categoryName():
        """
        categoryName(self) -> str
        
        Returns the name of the node type category of the state which you
        can use for creating the proper category object.
        
        
        """
        pass
        
    
    def bindFactory(callable):
        """
        bindFactory(self, callable)
        
        Takes a callable object (such as a class or function) that returns
        an implementation of the state interface. Usually this will be a
        class (a Python class is a callable object which returns an instance
        of the class). The callable should accept two arguments: a string
        containing the name of the state, and a hou.SceneViewer object
        representing the current viewer.
        
        > class MyState(object):
        >     def __init__(self, state_name, scene_viewer):
        >         self.state_name = state_name
        >         self.scene_viewer = scene_viewer
        >
        >     def onMouseEvent(sefl, kwargs):
        >         ui_event = kwargs["ui_event"]
        >
        >
        > def createViewerTemplate(*args):
        >     template = hou.ViewerStateTemplate("mystate", "My State", hou.sopNodeTypeCategory())
        >     template.bindFactory(MyState)
        >     return template
        
        """
        pass
        
    
    def typeName():
        """
        typeName(self) -> str
        
        Returns a unique string used to identify the viewer state.
        
        
        """
        pass
        
    
    def bindDynamicsSelector(prompt, allow_objects=True, allow_modifiers=False, quick_select=True, auto_start=True, use_existing_selection=True, allow_multisel=True, hotkey=None, name=None):
        """
        bindDynamicsSelector(self, prompt, allow_objects=True,
        allow_modifiers=False, quick_select=True, auto_start=True,
        use_existing_selection=True, allow_multisel=True, hotkey=None,
        name=None)
        
        Binds a dynamics selector to a DOP viewer state. This selector is
        used for selecting dynamics objects and modifiers when the
        underlying viewer state is active. This selector can only be used in
        a scene viewer, exception is thrown otherwise at registration
        (hou.ui.registerViewerStateTemplate).
        
        Multiple dynamics, point and polygon selectors can be bound to a
        viewer state. However, other selector types cannot be mixed with DOP
        selectors, exception is thrown otherwise.
        
        The viewer state plug-in can implement the onSelection method to
        receive new selections. onSelection gets the new selection as a list
        of hou.DopData objects stored in the selection entry of the input
        kwargs dictionary. The return value can be True to stop the
        selection tool or False to keep it running. Pressing [Enter] also
        terminates the selector.
        
        
        allow_modifiers
        Allows the tool to select simulation modifiers. Exception is
        thrown if allow_modifiers and allow_objects are both set to
        False. Default to False.
        
        allow_multisel
        Allows the tool to select multiple elements. Defaults to True.
        
        allow_objects
        Allows object selection. Exception is thrown if allow_modifiers
        and allow_objects are both set to False. Defaults to True.
        
        auto_start
        If True (the default), start the selector when the viewer state
        is activated. If False, you must specify a hotkey argument that
        activates the selector.
        
        hotkey
        An optional hotkey which acts as a switch for starting or
        stopping the selector. The default is None.
        
        name
        Optional name identifier (None by default) for the selector,
        must be unique within the viewer state. The name is used for
        triggering selector operations.
        
        prompt
        Prompt displayed in the viewport when the selector is active.
        The prompt is mandatory.
        
        quick_select
        If this is True, the state's selection event is called whenever
        the selection changes. If this is False, Houdini waits for the
        user to finish selection by pressing [Enter] before it notifies
        the state about the new selection.
        
        use_existing_selection
        If this is True, and a component selection exists when the user
        activates the state, Houdini will call onSelection with that
        selection. If this is False, Houdini will clear any existing
        selection and ask for a new selection.
        
        
        """
        pass
        
    
    def bindDynamicsPolygonSelector(prompt, quick_select=True, auto_start=True, use_existing_selection=True, object_based_point_selection=False, use_last_selected_object=False, hotkey=None, name=None):
        """
        bindDynamicsPolygonSelector(self, prompt, quick_select=True,
        auto_start=True, use_existing_selection=True,
        object_based_point_selection=False, use_last_selected_object=False,
        hotkey=None, name=None)
        
        Binds a dynamics polygon selector to a DOP viewer state. This
        selector is used for selecting polygon elements when the underlying
        viewer state is active. This selector can only be used in a scene
        viewer, exception is thrown otherwise at registration
        (hou.ui.registerViewerStateTemplate).
        
        Multiple dynamics, point and polygon selectors can be bound to a
        viewer state. However, other selector types cannot be mixed with DOP
        selectors, exception is thrown otherwise.
        
        The viewer state plug-in can implement the onSelection method to
        receive new selections. onSelection gets the new selection as a list
        of (hou.DopData,hou.GeometrySelection) tuples stored in the
        selection entry of the input kwargs dictionary. The return value can
        be True to stop the selection tool or False to keep it running.
        Pressing [Enter] also terminates the selector.
        
        
        auto_start
        If True (the default), start the selector when the viewer state
        is activated. If False, you must specify a hotkey argument that
        activates the selector.
        
        hotkey
        An optional hotkey which acts as a switch for starting or
        stopping the selector. The default is None.
        
        name
        Optional name identifier (None by default) for the selector,
        must be unique within the viewer state. The name is used for
        triggering selector operations.
        
        object_based_point_selection
        Force selection of points on the currently selected object
        instead of the default selection of points on the closest
        object. Default to False.
        
        prompt
        Prompt displayed in the viewport when the selector is active.
        The prompt is mandatory.
        
        quick_select
        If this is True, the state's selection event is called whenever
        the selection changes. If this is False, Houdini waits for the
        user to finish selection by pressing [Enter] before it notifies
        the state about the new selection.
        
        use_existing_selection
        If this is True, and a component selection exists when the user
        activates the state, Houdini will call onSelection with that
        selection. If this is False, Houdini will clear any existing
        selection and ask for a new selection.
        
        use_last_selected_object
        Force polygon selection to only be possible on the specified
        object and do not allow selection of a different object. Default
        to False.
        
        
        """
        pass
        
    
    def bindSelector(name, selector_type, prompt, primitive_types=None, group_parm_name=None, input_index=0, input_required=True, allow_dragging=True):
        """
        bindSelector(self, name, selector_type, prompt, primitive_types=None,
        group_parm_name=None, input_index=0, input_required=True,
        allow_dragging=True)
        
        Binds a selector to the digital asset tied to this viewer state. You
        can bind multiple selectors to the same viewer state.
        
        These selectors are typically used by the shelf tool of the digital
        asset to create new instances of the SOP nodes. Houdini will invoke
        all bounded selectors, wait for the user to select geometries, and
        then connect the input SOPs and fill in group parameters to match
        what was selected.
        
        This kind of selector is different from the ones created with
        hou.ViewerStateTemplate.bindGeometrySelector or
        hou.ViewerStateTemplate.bindObjectSelector. They are stricly used by
        Houdini and cannot be triggered with
        hou.SceneViewer.triggerStateSelector.
        
        
        name
        A unique selector name identifier.
        
        selector_type
        The type of the selector to bind. The following types are
        supported:
        
        prims
        
        Select only primitives.
        
        points
        
        Select only points.
        
        edges
        
        Select only edges.
        
        everything
        
        Select any geometries.
        
        prompt
        Prompt displayed in the viewport to instruct the user what to
        select. The prompt is mandatory.
        
        primitive_types
        Specify the type of selectable primitives (hou.primType).
        Defaults to all types.
        
        group_parm_name
        The name of the SOP node parameter containing the group field.
        The selector will set this parameter to the string representing
        the points, primitives, edges, etc. chosen by the user in the
        viewer. If None, the selector will look for a parameter named
        "group".
        
        input_index
        The index of the input connector on the SOP node where the
        selector should wire input SOPs. A cookie SOP, for example, has
        two input connectors. It has two selectors, one for each input
        connector. Defaults to 0.
        
        input_required
        Specify if an input is required or not. If the user does not
        select any geometry and the input is not required, the selector
        will not wire anything to its input connector. Defaults to True.
        
        allow_dragging
        Determines if click-and-drag operations are allowed. Click-and-
        drag operations select the geometry and begin manipulating the
        handles with a single mouse drag. Dragging the geometry forces
        the selector to finish immediately, the selector connects the
        input and sets the group parameter, and subsequent mouse
        movements are passed to the handle which translates the geometry
        by changing parameter values. Defaults to True.
        
        
        """
        pass
        
    
    def bindMenu():
        """None"""
        pass
        
    
    def bindDynamicsPointSelector(prompt, allow_objects=True, allow_modifiers=False, quick_select=True, auto_start=True, use_existing_selection=True, allow_multisel=True, only_select_points=True, object_based_point_selection=False, use_last_selected_object=False, hotkey=None, name=None):
        """
        bindDynamicsPointSelector(self, prompt, allow_objects=True,
        allow_modifiers=False, quick_select=True, auto_start=True,
        use_existing_selection=True, allow_multisel=True,
        only_select_points=True, object_based_point_selection=False,
        use_last_selected_object=False, hotkey=None, name=None)
        
        Binds a dynamics point selector to a DOP viewer state. This selector
        is used for selecting point elements when the underlying viewer
        state is active. This selector can only be used in a scene viewer,
        exception is thrown otherwise at registration
        (hou.ui.registerViewerStateTemplate).
        
        Multiple dynamics, polygon and point selectors can be bound to a
        viewer state. However, other selector types cannot be mixed with DOP
        selectors, exception is thrown otherwise.
        
        The viewer state plug-in can implement the onSelection method to
        receive new selections. onSelection gets the new selection as a list
        of (hou.DopData,hou.GeometrySelection) tuples stored in the
        selection entry of the input kwargs dictionary. The return value can
        be True to stop the selection tool or False to keep it running.
        Pressing [Enter] also terminates the selector.
        
        
        allow_modifiers
        Allows the tool to select simulation modifiers. Default to
        False.
        
        allow_multisel
        Allows the tool to select multiple elements. Defaults to True.
        
        allow_objects
        Allows object selection. Defaults to True.
        
        auto_start
        If True (the default), start the selector when the viewer state
        is activated. If False, you must specify a hotkey argument that
        activates the selector.
        
        hotkey
        An optional hotkey which acts as a switch for starting or
        stopping the selector. The default is None.
        
        name
        Optional name identifier (None by default) for the selector,
        must be unique within the viewer state. The name is used for
        triggering selector operations.
        
        object_based_point_selection
        Force selection of points on the currently selected object
        instead of the default selection of points on the closest
        object. Default to False.
        
        only_select_points
        Default to True.
        
        prompt
        Prompt displayed in the viewport when the selector is active.
        The prompt is mandatory.
        
        quick_select
        If this is True, the state's selection event is called whenever
        the selection changes. If this is False, Houdini waits for the
        user to finish selection by pressing [Enter] before it notifies
        the state about the new selection.
        
        use_existing_selection
        If this is True, and a component selection exists when the user
        activates the state, Houdini will call onSelection with that
        selection. If this is False, Houdini will clear any existing
        selection and ask for a new selection.
        
        use_last_selected_object
        Force point selection to only be possible on the specified
        object and do not allow selection of a different object. Default
        to False.
        
        
        """
        pass
        
    
    def bindGeometrySelector(prompt, allow_drag=False, quick_select=True, auto_start=True, use_existing_selection=True, consume_selection=True, initial_selection="", initial_selection_type=hou.geometryType.Primitives, ordered=False, geometry_types=hou.geometryType.Primitives, primitive_types=None, allow_other_sops=False, hotkey=None, name=None):
        """
        bindGeometrySelector(self, prompt, allow_drag=False, quick_select=True,
        auto_start=True, use_existing_selection=True, consume_selection=True,
        initial_selection="",
        initial_selection_type=hou.geometryType.Primitives, ordered=False,
        geometry_types=hou.geometryType.Primitives, primitive_types=None,
        allow_other_sops=False, hotkey=None, name=None)
        
        Binds a geometry selector to a SOP viewer state. This selector is
        used for selecting geometry elements when the underlying viewer
        state is active. This selector can only be used in a scene viewer,
        exception is thrown otherwise at registration
        (hou.ui.registerViewerStateTemplate).
        
        Multiple geometry selectors can be bound to a viewer state. However,
        other selector types cannot be mixed, exception is thrown otherwise.
        
        The viewer state plug-in can implement the onSelection method to
        receive new selections. onSelection gets the new selection as a
        hou.GeometrySelection stored in the selection entry of the input
        kwargs dictionary. The return value can be True to stop the
        selection tool or False to keep it running. Pressing [Enter] also
        terminates the selector.
        
        
        allow_drag
        Determines whether selecting a component with a single mouse
        click completes the selection. This is typically used to prevent
        a multiple component selection. Defaults to False.
        
        allow_other_sops
        Allow selecting components on geometry from other geometry nodes
        visible in the viewport. Defaults to False.
        
        auto_start
        If True (the default), starts the selector when the viewer state
        is activated. If False, you must specify a hotkey argument that
        activates the selector.
        
        consume_selection
        If True (default), clears the current selection when the
        selector is deactivated.
        
        geometry_types
        A hou.geometryType value representing the component type the
        user can select. The default is hou.geometryType.Primitives.
        
        hotkey
        An optional hotkey which acts as a switch for starting or
        stopping the selector. The default is None.
        
        initial_selection
        When use_existing_selection is False, this is a string of
        component group syntax representing what to set the selection to
        when the state is activated. The default is no selection.
        
        initial_selection_type
        A hou.geometryType value, representing the type of components
        specified by the initial_selection argument. The default is
        hou.geometryType.Primitives.
        
        name
        Optional name identifier (None by default) for the selector,
        must be unique within the viewer state. The name is used for
        triggering selector operations.
        
        ordered
        If this is True, Houdini returns the components in the selection
        in the order the user selected them. The default is False,
        meaning the order of the components you get is unrelated to the
        order they were selected.
        
        Only set this to True if for some reason you need to
        distinguish, for example, the first primitive the user clicked,
        or the last, or that kind of thing.
        
        prompt
        Prompt displayed in the viewport when the selector is active.
        The prompt is mandatory.
        
        primitive_types
        If this is not None, it should be a hou.primType value
        representing a type of primitive the user can select. The
        default of None allows selecting all types.
        
        quick_select
        If this is True, the state's selection event is called whenever
        the selection changes. If this is False, Houdini waits for the
        user to finish selection by pressing [Enter] before it notifies
        the state about the new selection.
        
        use_existing_selection
        If this is True, and a component selection exists when the user
        activates the state, Houdini will call onSelection with that
        selection. If this is False, Houdini will clear any existing
        selection and ask for a new selection.
        
        
        """
        pass
        
    
    def contexts():
        """
        contexts(self) -> list of hou.NodeTypeCategory
        
        Returns the list of contexts in which the state can be used.
        
        
        """
        pass
        
    
    def bindHandle(handle_type, name, bindings, settings=None):
        """
        bindHandleStatic(self, handle_type, name, bindings, settings=None)
        
        Binds a handle to a node parameter, so dragging the handle
        automatically updates the bound parameter.
        
        
        handle_type
        A string naming the type of handle.
        
        name
        A unique string to use to identify the handle. Each binding's
        name must be unique _within this state_. Trying to bind the same
        name more than once will raise an exception.
        
        bindings
        A list of ("node_parm_name", "handle_parm_name") tuples. This
        binds the parts of the handle to individual parameters on the
        node. For example:
        
        Holds the binding information for the handle to node parm
        mappings. The bindings are provided as a list of node to handle
        parm name tuples.
        
        settings
        A string containing specific settings of a handle. These
        settings are mostly read-only and cannot be changed at runtime.
        
        > t = hou.ViewerStateTemplate('my_state', 'my_state_label', hou.sopNodeTypeCategory())
        > ...
        > t.bindHandleStatic( 'vector', 'Up Direction',
        >     [
        >                     ('group', 'input'),
        >                     ('originx', 'tx'),
        >                     ('originy', 'ty'),
        >                     ('originz', 'tz'),
        >                     ('upx', 'vx'),
        >                     ('upy', 'vy'),
        >                     ('upz', 'vz')
        >     ]
        > )
        
        """
        pass
        
    
    def bindSceneGraphSelector(prompt, allow_drag=True, quick_select=True, auto_start=True, use_existing_selection=True, consume_selection=False, allow_multisel=True, prior_selection_paths=None, prim_mask=None, path_prefix_mask=None, prim_kind=None, hotkey=None, name=None):
        """
        bindSceneGraphSelector(self, prompt, allow_drag=True, quick_select=True,
        auto_start=True, use_existing_selection=True, consume_selection=False,
        allow_multisel=True, prior_selection_paths=None, prim_mask=None,
        path_prefix_mask=None, prim_kind=None, hotkey=None, name=None)
        
        Binds a scene graph selector to a SOP viewer state. This selector is
        used for selecting scene graph elements when the underlying viewer
        state is active. This selector can only be bound used in a scene
        graph viewer, exception is thrown otherwise at registration
        (hou.ui.registerViewerStateTemplate).
        
        Multiple scene graph selectors can be bound to a viewer state.
        However, other selector types cannot be mixed with scene graph
        selectors, exception is thrown otherwise.
        
        The viewer state plug-in can implement the onSelection method to
        receive new selections. onSelection gets the new selection as a list
        of element paths stored in the selection entry of the input kwargs
        dictionary. The return value can be True to keep running the
        selection tool or False to stop it. Pressing [Enter] also terminates
        the selector.
        
        
        allow_drag
        Allows the selection to be completed with a single mouse click.
        Defaults to True.
        
        allow_multisel
        Allows the tool to select multiple elements. Defaults to True.
        
        auto_start
        Start the selector when the viewer state is activated. True by
        default.
        
        hotkey
        An optional hotkey which acts as a toggle switch for starting or
        stopping the selector. No hotkey by default.
        
        name
        Optional name identifier (None by default) for the selector,
        must be unique within the viewer state. The name is used for
        triggering selector operations.
        
        path_prefix_mask
        Filter out selectable elements by a name prefix. Empty by
        default.
        
        prim_kind
        Primitive kind to highlight. Empty by default.
        
        prim_mask
        Filter mask for the selection (hou.scenePrimMask). Defaults to
        hou.scenePrimMask.ViewerSetting
        
        prior_selection_paths
        Array of element paths to pre-select.
        
        prompt
        Prompt displayed in the viewport when the selector is active.
        The prompt is mandatory.
        
        quick_select
        Configure the selector to use quick selections. When True the
        selection callback is called automatically for each selection,
        if False the user must hit 'enter' to complete the selection.
        Defaults to True.
        
        use_existing_selection
        If True, the selector uses the existing selection. Defaults to
        True.
        
        consume_selection
        If True, clears the current selection when the selector is
        deactivated. Defaults to False.
        
        
        """
        pass
        
    
    def bindObjectSelector(prompt, quick_select=True, auto_start=True, use_existing_selection=True, allow_multisel=True, allowed_types=('*'):
        """
        bindObjectSelector(self, prompt, quick_select=True, auto_start=True,
        use_existing_selection=True, allow_multisel=True, allowed_types=('*',),
        hotkey=None, name=None)
        
        Binds an object selector to a OBJ viewer state. This selector is
        used for selecting objects when the underlying viewer state is
        active. This selector can only be used in a scene viewer, exception
        is thrown otherwise at registration
        (hou.ui.registerViewerStateTemplate).
        
        Multiple object selectors can be bound to a viewer state. However,
        other selector types cannot be mixed with OBJ selectors, exception
        is thrown otherwise.
        
        The viewer state plug-in can implement the onSelection method to
        receive new selections. onSelection gets the new selection as a list
        of hou.Node objects stored in the selection entry of the input
        kwargs dictionary. The return value can be True to stop the
        selection tool or False to keep it running. Pressing [Enter] also
        terminates the selector.
        
        
        allowed_types
        A list of strings to specify one or multiple object types the
        user can select. For instance, add geo to allowed_types to
        select geometry objects only. Patterns such as * can be used to
        select any objects or more restritive patterns such as *cam* for
        selecting any camera objects. All available object types can be
        obtained with hou.objNodeTypeCategory.nodeTypes. Defaults to *.
        
        auto_start
        If True (the default), start the selector when the viewer state
        is activated. If False, you must specify a hotkey argument that
        activates the selector.
        
        hotkey
        An optional hotkey which acts as a switch for starting or
        stopping the selector. The default is None.
        
        name
        Optional name identifier (None by default) for the selector,
        must be unique within the viewer state. The name is used for
        triggering selector operations.
        
        prompt
        Prompt displayed in the viewport when the selector is active.
        The prompt is mandatory.
        
        quick_select
        If this is True, the state's selection event is called whenever
        the selection changes. If this is False, Houdini waits for the
        user to finish selection by pressing [Enter] before it notifies
        the state about the new selection. Defaults to True.
        
        use_existing_selection
        If this is True, and a component selection exists when the user
        activates the state, Houdini will call onSelection with that
        selection. If this is False, Houdini will clear any existing
        selection and ask for a new selection. Defaults to True.
        
        
        """
        pass
        
    
    def bindHandleStatic():
        """None"""
        pass
        

def ViewerStateTemplate_swigregister():
    """None"""
    pass
    

def ViewerState_swigregister():
    """None"""
    pass
    

class ViewportVisualizer(object):
    """
    hou.ViewportVisualizer
    
    Represents a viewport visualizer.
    
    You can create a new visualizer by calling
    hou.viewportVisualizers.createVisualizer. You can get a list of
    registered visualizers by calling hou.viewportVisualizers.visualizers.
    
    
    """
    
    def evalParm(parm_name):
        """
        evalParm(self, parm_name) -> int, float, or str
        
        Evaluate the specified parameter and return the result.
        
        
        """
        pass
        
    
    def isActiveWhenCurrent():
        """
        isActiveWhenCurrent(self) -> bool
        
        Return True if the visualizer is applied when the geometry is the
        current geometry. Return False otherwise.
        
        
        """
        pass
        
    
    def isShownInToolbar():
        """
        isShownInToolbar(self) -> bool
        
        Return True if the visualizer appears in the viewer pane's toolbar.
        Return False otherwise.
        
        
        """
        pass
        
    
    def setLabel(label):
        """
        setLabel(self, label)
        
        Set the visualizer's user-friendly label.
        
        
        """
        pass
        
    
    def isActiveWhenDisplayed():
        """
        isActiveWhenDisplayed(self) -> bool
        
        Return True if the visualizer is applied when the geometry is
        displayed. Return False otherwise.
        
        
        """
        pass
        
    
    def setScope(scope):
        """
        setScope(self, scope)
        
        Set the scope of geometries that the visualizer affects.
        
        This method does nothing if the visualizer belongs to the Common or
        Scene because the scope is always global.
        
        
        """
        pass
        
    
    def setIsActiveWhenSelected(on):
        """
        setIsActiveWhenSelected(self, on)
        
        Set whether the visualizer is applied when the geometry is selected.
        
        
        """
        pass
        
    
    def label():
        """
        label(self) -> string
        
        Return the visualizer's user-friendly label.
        
        
        """
        pass
        
    
    def setType(type):
        """
        setType(self, type)
        
        Sets the visualizer's type. This essentially recreates the
        visualizer and rebuilds its customizable parameters. Call
        hou.ViewportVisualizer.parmNames to get a list of the parameters.
        
        
        """
        pass
        
    
    def category():
        """
        category(self) -> hou.viewportVisualizerCategory
        
        Return the category that the visualizer belongs to.
        
        
        """
        pass
        
    
    def evalParmAsRamp():
        """
        evalParmAsRamp(self) -> hou.Ramp
        
        Evalute the specified parameter and return the result as a ramp.
        
        Raises hou.TypeError if the parameter is not a ramp.
        
        
        """
        pass
        
    
    def setIsActiveWhenDisplayed(on):
        """
        setIsActiveWhenDisplayed(self, on)
        
        Set whether the visualizer is applied when the geometry is
        displayed.
        
        
        """
        pass
        
    
    def categoryNode():
        """
        categoryNode(self) -> hou.Node
        
        Return the node that the visualizer is installed on. This only
        applies if the visualizer belongs to the Node category.
        
        Return None if the visualizer belongs to either the Common or Scene
        category.
        
        
        """
        pass
        
    
    def setIsActiveWhenCurrent(on):
        """
        setIsActiveWhenCurrent(self, on)
        
        Set whether the visualizer is applied when the geometry is the
        current geometry.
        
        
        """
        pass
        
    
    def setIsActiveWhenUnselected(on):
        """
        setIsActiveWhenUnselected(self, on)
        
        Set whether the visualizer is applied when the geometry is
        unselected.
        
        
        """
        pass
        
    
    def isActiveWhenUnselected():
        """
        isActiveWhenUnselected(self) -> bool
        
        Return True if the visualizer is applied when the geometry is
        unselected. Return False otherwise.
        
        
        """
        pass
        
    
    def destroy():
        """
        destroy(self)
        
        Delete this viewport visualizer.
        
        If you call methods on a visualizer instance after it has been
        destroyed, Houdini will raise hou.ObjectWasDeleted.
        
        
        """
        pass
        
    
    def isActiveWhenGhosted():
        """
        isActiveWhenGhosted(self) -> bool
        
        Return True if the visualizer is applied when the geometry is
        ghosted. Return False otherwise.
        
        
        """
        pass
        
    
    def setIcon(icon):
        """
        setIcon(self, icon)
        
        Set the visualizer's icon. icon must be the icon name.
        
        
        """
        pass
        
    
    def setName(name):
        """
        setName(self, name)
        
        Set the visualizer's unique identifier.
        
        
        """
        pass
        
    
    def setIsActiveWhenTemplated(on):
        """
        setIsActiveWhenTemplated(self, on)
        
        Set whether the visualizer is applied when the geometry is
        templated.
        
        
        """
        pass
        
    
    def parmNames():
        """
        parmNames(self) -> tuple of string
        
        Return a tuple of the visualizer's customizable parameters. Note
        that the parameters can change when either the visualizer's type
        changes or one of the parameters changes (for example changing the
        Color Type parameter on a color visualizer).
        
        
        """
        pass
        
    
    def isActiveWhenTemplated():
        """
        isActiveWhenTemplated(self) -> bool
        
        Return True if the visualizer is applied when the geometry is
        templated.
        
        
        """
        pass
        
    
    def evalParmAsInt(parm_name):
        """
        evalParmAsInt(self, parm_name) -> int
        
        Evaluate the specified parameter and return the result as an
        integer.
        
        Raise hou.TypeError if the value cannot be converted to a integer.
        
        
        """
        pass
        
    
    def showInToolbar(on):
        """
        showInToolbar(self, on)
        
        Set whether the visualizer appears in the viewer pane's toolbar.
        
        
        """
        pass
        
    
    def evalParmAsString(parm_name):
        """
        evalParmAsString(self, parm_name) -> int
        
        Evaluate the specified parameter and return the result as a string.
        
        Raise hou.TypeError if the value cannot be converted to a string.
        
        
        """
        pass
        
    
    def setIsActiveWhenGhosted(on):
        """
        setIsActiveWhenGhosted(self, on)
        
        Set whether the visualizer is applied when the geometry is ghosted.
        
        
        """
        pass
        
    
    def icon():
        """
        icon(self) -> string
        
        Return the name of the visualizer's icon.
        
        
        """
        pass
        
    
    def isActive(viewport=None):
        """
        isActive(self, viewport=None) -> bool
        
        If this is a Common or Scene visualizer then return True if it is
        active for the specified viewport or False otherwise. The viewport
        argument must be a hou.GeometryViewport object.
        
        If this is a Node visualizer then return True if it is active for
        all viewports and False otherwise.
        
        Raise hou.TypeError if this is a Node visualizer and the viewport
        argument is not None. Node visualizers are either active in all
        viewports or none of them. They cannot be activated for a specific
        viewport.
        
        Raise hou.TypeError if this is either a Common or Scene visualizer
        and the viewport argument is None.
        
        
        """
        pass
        
    
    def name():
        """
        name(self) -> string
        
        Return the visualizer's unique identifier.
        
        
        """
        pass
        
    
    def type():
        """
        type(self) -> hou.ViewportVisualizerType
        
        Return the visualizer's type.
        
        
        """
        pass
        
    
    def evalParmAsFloat(parm_name):
        """
        evalParmAsFloat(self, parm_name) -> float
        
        Evaluate the specified parameter and return the result as a float.
        
        Raise hou.TypeError if the value cannot be converted to a float.
        
        
        """
        pass
        
    
    def setIsActive(on, viewport=None):
        """
        setIsActive(self, on, viewport=None)
        
        If this is a Common or Scene visualizer then set whether it is
        active or not for a specified viewport. The viewport argument must
        be a hou.GeometryViewport object.
        
        If this is a Node visualizer then set whether it is active or not
        for all viewports.
        
        Raise hou.TypeError if this is a Node visualizer and the viewport
        argument is not None. Node visualizers are either active in all
        viewports or none of them. They cannot be activated for a specific
        viewport.
        
        Raise hou.TypeError if this is either a Common or Scene visualizer
        and the viewport argument is None.
        
        
        """
        pass
        
    
    def isActiveWhenSelected():
        """
        isActiveWhenSelected(self) -> bool
        
        Return True if the visualizer is applied when the geometry is
        selected. Return False otherwise.
        
        
        """
        pass
        
    
    def setParm():
        """None"""
        pass
        
    
    def scope():
        """
        scope(self) -> hou.viewportVisualizerScope
        
        Return the scope of geometries that the visualizer affects.
        
        
        """
        pass
        

class ViewportVisualizerType(object):
    """
    hou.ViewportVisualizerType
    
    Represents a viewport visualizer type.
    
    
    """
    
    def name():
        """
        name(self) -> string
        
        Return the visualizer type's unique identifier.
        
        
        """
        pass
        
    
    def icon():
        """
        icon(self) -> string
        
        Return the name of the type's icon.
        
        
        """
        pass
        
    
    def description():
        """
        description(self) -> string
        
        Return a brief description of the visualizer type.
        
        
        """
        pass
        

def ViewportVisualizerType_swigregister():
    """None"""
    pass
    

def ViewportVisualizer_swigregister():
    """None"""
    pass
    

class Volume(Prim):
    """
    hou.Volume
    
    A Volume is a kind geometry primitive (Prim object) storing a three
    dimensional array of voxels.
    
    
    """
    
    def voxel(index):
        """
        voxel(self, index) -> float
        
        Given a sequence of three integers containing a voxel index, return
        the value of the corresponding voxel.
        
        > >>> volume_sop = hou.node("/obj").createNode("geo").createNode("volume")
        > >>> volume_sop.parm("initialval1").set(0.3)
        > >>> volume = volume_sop.geometry().prims()[0]
        > >>> volume.resolution()
        > (10, 10, 10)
        > >>> volume.voxel((0, 0, 0))
        > 0.3
        
        """
        pass
        
    
    def voxelSliceAsString(plane, index):
        """
        voxelSliceAsString(plane, index) -> str
        
        Return a binary string representation of the floats containing all
        the values of voxels in a particular slice.
        
        See hou.Volume.voxelSlice and hou.Volume.allVoxelsAsString for more
        information.
        
        
        """
        pass
        
    
    def setTransform(matrix4):
        """
        setTransform(self, matrix4)
        
        Given a 4x4 matrix, set the position, rotation, and scale of this
        volume.
        
        Note that if you want to just set the translate portion of a volume
        to a hou.Vector3, you could just call
        volume.vertex(0).point().setPosition(position).
        
        
        """
        pass
        
    
    def setAllVoxels(values):
        """
        setAllVoxels(self, values)
        
        Set the value of all voxels in this volume. You would typically call
        this method from the code of a Python-defined SOP.
        
        Raises hou.OperationFailed if the sequence of values is not exactly
        the same as self.resolution()[0] * self.resolution()[1] *
        self.resolution()[2].
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable.
        
        See also hou.Volume.allVoxels.
        
        
        """
        pass
        
    
    def setAllVoxelsFromString(values):
        """
        setAllVoxelsFromString(self, values)
        
        Set the value of all voxels in this volume from a string
        representation of a sequence of single precision float values. This
        method is faster than hou.Volume.setAllVoxels.
        
        Note that this method can accept more types that just a string: it
        can receive any Python object that supports the buffer interface. In
        particular, arrays from the array and numpy Python modules are
        supported, so there is no need to first construct strings from those
        arrays.
        
        Raises hou.OperationFailed if the length of the string is not
        exactly the same as self.resolution()[0] * self.resolution()[1] *
        self.resolution()[2] * 4.
        
        See hou.Volume.setAllVoxels and hou.Volume.allVoxelsAsString for
        more information.
        
        The following example function accepts an array.array("f") and sets
        the voxels to its contents:
        
        > def setAllVoxelsFromArray(volume, arr):
        >     assert(arr.typecode == "f")
        >     volume.setAllVoxelsFromString(arr)
        
        """
        pass
        
    
    def sample(position):
        """
        sample(self, position) -> float
        
        Given a sequence of three floats containing a 3D position, return
        the value of the volume at that position. If the position is not in
        the middle of a voxel, Houdini will interpolate using values from
        surrounding voxels.
        
        See also hou.Volume.voxel and hou.Volume.posToIndex.
        
        
        """
        pass
        
    
    def volumeMax():
        """
        volumeMax(self) -> float
        
        Return the maximum value of all voxels.
        
        
        """
        pass
        
    
    def isValidIndex(index):
        """
        isValidIndex(self, index) -> bool
        
        Return whether or not a sequence of three ints containing an index
        into the voxel array is valid, ie, within the bounds of the array.
        
        This method can approximately be implemented as follows:
        
        > def isValidIndex(self, index):
        >     for i, maximum in zip(index, self.resolution()):
        >         if i < 0 or i >= maximum:
        >             return False
        >     return True
        
        """
        pass
        
    
    def posToIndex(position):
        """
        posToIndex(self, position) -> tuple of int
        
        Given a sequence of three floats containing a 3D position, return a
        tuple of three ints containing the corresponding index into the
        voxel array.
        
        Note that the returned index will be invalid if the position is
        outside the volume. Use hou.Volume.isValidIndex to determine if the
        index is valid.
        
        
        """
        pass
        
    
    def gradient(position):
        """
        gradient(self, position) -> hou.Vector3
        
        Given a sequence of three floats containing a 3D position, return a
        vector which points in the direction of the greatest rate of
        increase of the volume's value.
        
        See Wikipedia's gradient page for more information.
        
        
        """
        pass
        
    
    def volumeMin():
        """
        volumeMin(self) -> float
        
        Return the minimum value of all voxels.
        
        
        """
        pass
        
    
    def isSDF():
        """
        isSDF(self) -> bool
        
        Return whether or not the volume is flagged as a signed distance
        field. Such volumes have a special border condition where out of
        bound reads will add the distance to the bounding box to the
        streaked boundary condition. They are also best to be semantically
        treated as signed distance fields.
        
        
        """
        pass
        
    
    def transform():
        """
        transform(self) -> hou.Matrix3
        
        Return a 3x3 matrix containing the scale and rotation
        transformations for this volume.
        
        Note that the position information for the volume can be obtained by
        calling volume.vertex(0).point().position().
        
        The following function returns a 4x4 transformation matrix for the
        volume that includes the translation:
        
        > def fullTransform(volume):
        >     return (hou.Matrix4(volume.transform()) *
        >         hou.hmath.buildTranslate(volume.vertex(0).point().position()))
        
        NOTE
        You need to get the node transform to get to worldspace.
        
        
        """
        pass
        
    
    def voxelSlice(plane, index):
        """
        voxelSlice(plane, index) -> tuple of float
        
        Return a tuple of floats containing the values of all voxels in a
        particular slice. It is faster to call this method to retrieve a
        slice than it is to loop through the voxel array in Python.
        
        
        plane
        The plane corresponding to this slice. This value must be either
        "xy", "xz", or "yz".
        
        index
        The index of this slice in the array. For example, if the plane
        is "xy", this index is the z value and the result will contain
        all values in the voxel with this particular z value.
        
        This method can be approximately implemented as follows (though this
        Python implementation is much slower):
        
        > def voxelSlice(self, plane, index):
        >     result = []
        >
        >     start = [0] * 3
        >     stop = list(self.resolution())
        >
        >     slice_axis = {"xy": 2, "xz": 1, "yz": 0}[plane]
        >     start[slice_axis] = index
        >     stop[slice_axis] = index + 1
        >
        >     for z in range(start[2], stop[2]):
        >         for y in range(start[1], stop[1]):
        >             for x in range(start[0], stop[0]):
        >                 result.append(self.voxel((x, y, z)))
        >     return tuple(result)
        
        See also hou.Volume.voxelSliceAsString and hou.Volume.allVoxels.
        
        
        """
        pass
        
    
    def isHeightField():
        """
        isHeightField(self) -> bool
        
        Return whether or not the volume is flagged as a heightfield. Such
        volumes are two dimensional and have the heightfield visualization
        set.
        
        
        """
        pass
        
    
    def allVoxelsAsString():
        """
        allVoxelsAsString(self) -> str
        
        Return a binary string representation of the floats containing all
        the values of all voxels. This method is faster than
        hou.Volume.allVoxels, and you can use the array module to convert
        the string into a Python sequence.
        
        This method provides a faster implementation of the following:
        
        > import array
        > def allVoxelsAsString(self):
        >     return array.array("f", self.allVoxels()).tostring()
        
        You can convert the return value from this method to an array using
        the following method:
        
        > import array
        > def allVoxelsAsArray(volume):
        >     a = array.array("f")
        >     a.fromstring(volume.allVoxelsAsString())
        >     return a
        
        See hou.Volume.allVoxels for more information.
        
        
        """
        pass
        
    
    def vertex(index):
        """
        vertex(self, index) -> hou.Vertex
        
        A shortcut for self.vertices()[index]. You probably don't need to
        call this method.
        
        This method supports negative indices to index from the end, just
        like self.vertices()[index] would. Also, like Python's indexing
        operator, it will raise IndexError when the index is out of range.
        
        
        """
        pass
        
    
    def indexToPos(index):
        """
        indexToPos(self, index) -> hou.Vector3
        
        Given a sequence of three ints containing an index into the voxel
        array, return the corresponding 3D position of the middle of that
        voxel.
        
        
        """
        pass
        
    
    def allVoxels():
        """
        allVoxels(self) -> tuple of float
        
        Return a tuple of floats containing the values of all voxels. It is
        faster to call this method to retrieve all the voxels than it is to
        loop through the voxel array in Python.
        
        You can, for example, use Python's Numpy library to perform
        operations on the voxel data and then store the result back into the
        volume from a Python SOP using hou.Volume.setAllVoxels. Note that
        Numpy allows you to reshape the flat tuple of floats to behave like
        a 3D matrix of floats.
        
        This method can be approximately implemented as follows (though this
        Python implementation is much slower):
        
        > def allVoxels(self):
        >     result = []
        >     xres, yres, zres = self.resolution()
        >     for z in range(zres):
        >         for y in range(yres):
        >             for x in range(xres):
        >                 result.append(self.voxel((x, y, z)))
        >     return tuple(result)
        
        See also hou.Volume.allVoxelsAsString,
        hou.Geometry.pointFloatAttribValues, and
        hou.Geometry.primFloatAttribValues.
        
        
        """
        pass
        
    
    def setVoxel(index, value):
        """
        setVoxel(self, index, value)
        
        Set the value of a voxel. You would typically call this method from
        the code of a Python-defined SOP.
        
        
        index
        A sequence of three integers containing a voxel index. Raises
        hou.OperationFailed if any of the values in index are out of
        range.
        
        value
        A float containing the voxel's new value.
        
        Raises hou.GeometryPermissionError if this geometry is not
        modifiable.
        
        
        """
        pass
        
    
    def setVoxelSliceFromString():
        """None"""
        pass
        
    
    def setVoxelSlice(values, plane, index):
        """
        setVoxelSliceFromString(self, values, plane, index)
        
        Set the value of the voxels in a particular slice of this volume.
        You would typically call this method from the code of a Python-
        defined SOP.
        
        
        values
        A binary string representing of a sequence of floats containing
        the new values for the slice.
        
        Note that this method can accept more types that just a string:
        it can receive any Python object that supports the buffer
        interface. In particular, arrays from the array and numpy Python
        modules are supported, so there is no need to first construct
        strings from those arrays.
        
        plane
        The plane corresponding to this slice. This value must be either
        "xy", "xz", or "yz".
        
        index
        The index of this slice in the array.
        
        See hou.Volume.setVoxelSlice for more information.
        
        The following example builds a volume from an compositing network
        sequence:
        
        > def buildVolumeFromCopSequence(
        >         cop_node, geo, voxel_depth, plane="C", component="r"):
        >     zres = int(cop_node.sequenceFrameLength())
        >     volume_bbox = hou.BoundingBox(*(
        >         0, 0, 0,
        >         cop_node.xRes(), cop_node.yRes(), zres) * voxel_depth)
        >     volume = geo.createVolume(
        >         cop_node.xRes(), cop_node.yRes(), zres, volume_bbox)
        >
        >     for z in range(zres):
        >         pixels = cop_node.allPixelsAsString(
        >             plane, component,
        >             time=hou.frameToTime(z + cop_node.sequenceStartFrame()))
        >         volume.setVoxelSliceFromString(pixels, "xy", z)
        
        """
        pass
        
    
    def volumeAverage():
        """
        volumeAverage(self) -> float
        
        Return the average value of all voxels.
        
        
        """
        pass
        
    
    def taperX():
        """None"""
        pass
        
    
    def taperY():
        """None"""
        pass
        
    
    def resolution():
        """
        resolution(self) -> hou.Vector3
        
        Return the x, y, and z dimensions of the volume. For example, a
        resolution of (10, 20, 30) means the volume is 10 voxels in x by 20
        voxels in y by 30 voxels in z.
        
        
        """
        pass
        

def Volume_swigregister():
    """None"""
    pass
    

class VopNetNode(Node):
    """
    hou.VopNetNode
    
    """
    
    def vexContext():
        """
        vexContext(self) -> VexContext
        
        
        """
        pass
        
    
    def shaderType():
        """
        shaderType(self) -> hou.shaderType enum value or None
        
        
        """
        pass
        
    
    def definedType():
        """
        definedType(self) -> NodeType
        
        
        """
        pass
        

def VopNetNode_swigregister():
    """None"""
    pass
    

class VopNode(Node):
    """
    hou.VopNode
    
    Represents a VOP (VEX Operator) node.
    
    
    """
    
    def code():
        """
        code(self) -> str
        
        Returns the VEX or RSL code that defines this node.
        
        
        """
        pass
        
    
    def setDetailLowFlag(on):
        """
        setDetailLowFlag(self, on)
        
        Turns on or off the low detail flag for this node's inputs and
        outputs. With this flag turned on, all inputs and outputs to this
        node will appear in the network view as connecting to a single
        location on the node. This flag does not affect the operation of
        this node, only its appearance in the network view. The value of the
        on argument must be True or False.
        
        Raises hou.PermissionError if the node is unwritable.
        
        
        """
        pass
        
    
    def isDetailHighFlagSet():
        """
        isDetailHighFlagSet(self) -> bool
        
        Returns True if the node's high detail flag is turned on. Returns
        False otherwise.
        
        
        """
        pass
        
    
    def outputDataTypes():
        """
        outputDataTypes(self) -> tuple of str
        
        Returns a tuple of all output data types for this node. Data types
        for output connectors that are hidden are also included.
        
        The strings returned by this method can be used to set the Type
        parameter on a Parameter or Constant VOP.
        
        
        """
        pass
        
    
    def shaderLanguageName():
        """
        shaderLanguageName(self) -> str
        
        Returns the name of the language the shader is written in.
        
        
        """
        pass
        
    
    def isMaterialFlagSet():
        """
        isMaterialFlagSet(self) -> bool
        
        Returns True if the node's material flag is turned on. Returns False
        otherwise. The material flag indicates whether this node is intended
        for use as a material to be assigned to objects or geometry.
        
        
        """
        pass
        
    
    def setMaterialFlag(on):
        """
        setMaterialFlag(self, on)
        
        Turns the node's material flag on or off. If the material flag is
        True, it indicates that this node is meant to be used as a material
        to be assigned to objects or geometry. It will appear in material
        node choosers and be saved to IFDs generated with the option to save
        all materials turned on.
        
        Raises hou.PermissionError if the node is unwritable.
        
        
        """
        pass
        
    
    def isBypassed():
        """
        isBypassed(self) -> bool
        
        Returns True if the node's bypass flag is turned on. Returns False
        otherwise.
        
        
        """
        pass
        
    
    def setDebugFlag(on):
        """
        setDebugFlag(self, on)
        
        Turns the node's debug flag on or off. The value of the on argument
        must be True or False.
        
        Raises hou.PermissionError if the node is unwritable.
        
        
        """
        pass
        
    
    def inputParmTypes():
        """None"""
        pass
        
    
    def setCompressFlag(on):
        """
        setCompressFlag(self, on)
        
        Turns the node's compress flag on or off. If the compress flag is
        True, this node will not show a preview image in the Network View.
        If the compress flag is False, a preview image will be shown in the
        Network View. The value of the on argument must be True or False.
        
        Raises hou.PermissionError if the node is unwritable.
        
        
        """
        pass
        
    
    def isDetailLowFlagSet():
        """
        isDetailLowFlagSet(self) -> bool
        
        Returns True if the node's low detail flag is turned on. Returns
        False otherwise.
        
        
        """
        pass
        
    
    def parmDefinerNode():
        """
        parmDefinerNode(self) -> hou.VopNode
        
        Return the Parameter VOP node that defines the parameter that this
        node is bound to. This method only applies to Parameter VOP nodes.
        
        Return None if this node is not a Parameter VOP or if this node is
        the definer node.
        
        
        """
        pass
        
    
    def shaderCode(shader_type=hou.shaderType.Surface):
        """
        shaderCode(self, shader_type=hou.shaderType.Surface) -> str
        
        Returns the generated VEX or RSL code for this VOP, using the given
        shader type to control output context. If the VOP is a subnet that
        can be packaged up as an encapsulated shader, then the specific code
        to define an encapsulated shader is output. Otherwise, the code
        generated for the entire VOP network is output.
        
        
        """
        pass
        
    
    def isCompressFlagSet():
        """
        isCompressFlagSet(self) -> bool
        
        Returns True if the node's compress flag is turned on. Returns False
        otherwise. The compress flag controls whether or not a preview image
        is shown for this node in the Network View.
        
        
        """
        pass
        
    
    def shaderName(as_otl_path=True, shader_type_name=None):
        """
        shaderName(self, as_otl_path=True, shader_type_name=None) -> str
        
        Return the name of the shader defined by this VOP (if it is an
        embedded shader) or the shader name defined by the shop in which
        this VOP resides. If as_otl_path is True, returns an opdef: path to
        the SHOP type. The shader_type_name is a string indicating the
        shader context type to use; some nodes may provide several shader
        types, and each may have a different name. This is applicable only
        to multi-context shader nodes, such as a vopnet material shop.
        
        
        """
        pass
        
    
    def isInputGroupExpanded(group):
        """
        isInputGroupExpanded(self, group) -> bool
        
        Returns True if the group with the name specified by group is
        expanded in the Network View. The group parameter should be a value
        returned by the hou.VopNode.inputGroupName method. Returns the
        current expanded state of the group even if the group is not
        currently visible due to the setting of the input/output detail
        flags. Returns True if the group name is not valid.
        
        
        """
        pass
        
    
    def bypass(on):
        """
        bypass(self, on)
        
        Turns the node's bypass flag on or off. When the bypass flag is on,
        the node will have no effect on the scene. The value of the on
        argument must be True or False.
        
        Raises hou.PermissionError if the node is unwritable.
        
        
        """
        pass
        
    
    def inputDataTypes():
        """
        inputDataTypes(self) -> tuple of str
        
        Returns a tuple of all input data types for this node. Data types
        for input connectors that are hidden are also included.
        
        The strings returned by this method can be used to set the Type
        parameter on a Parameter or Constant VOP.
        
        
        """
        pass
        
    
    def shaderString(render_type=None, shader_type=hou.shaderType.Surface, as_encapsulated=False):
        """
        shaderString(self, render_type=None, shader_type=hou.shaderType.Surface,
        as_encapsulated=False) -> str
        
        Returns the string that encodes the shader name and parameter values
        suitable for specifying as a shader assignment in an input stream
        acceptable by the renderer of a given type. If the VOP is material
        that provides a few shader contexts (eg, surface and displacement),
        it is necessary to provide the shader type explicitly. If
        as_encapsulated is true, the returned shader string will encode the
        shader as embedded in the parent shader with parameters referencing
        the parent, if needed.
        
        
        """
        pass
        
    
    def setDetailMediumFlag(on):
        """
        setDetailMediumFlag(self, on)
        
        Turns on or off the medium detail flag for this node's inputs and
        outputs. With this flag turned on, only connected inputs and outputs
        to this node will be visible in the network view. This flag does not
        affect the operation of this node, only its appearance in the
        network view. The value of the on argument must be True or False.
        
        Raises hou.PermissionError if the node is unwritable.
        
        
        """
        pass
        
    
    def deleteIndependentInputNodes(input_index):
        """
        deleteIndependentInputNodes(self, input_index):, make_parm_node,
        reference_input_defaults) -> bool
        
        Deletes a chain of nodes wired into a particular input if and only
        if they are wired only into the specified input on this node.
        Returns true if nodes were deleted, false otherwise.
        
        
        """
        pass
        
    
    def inputsInGroup(group):
        """
        inputsInGroup(self, group) -> tuple of int
        
        Returns the input index values of all inputs that appear in the
        group with the name specified in group. This parameter should be a
        value returned by the hou.VopNode.inputGroupName method. This method
        returns the same set of inputs whether the group is expanded or
        collapsed. Returns an empty tuple if the group name contains no
        inputs or is not a recognized group name.
        
        
        """
        pass
        
    
    def isInputCompatible(idx, other, other_idx, allow_conversions, =, False):
        """
        isInputCompatible(self, idx, other, other_idx, allow_conversions =
        False) -> bool`
        
        Return True if input idx of this object can be connected to output
        other_idx of node other. Two inputs can be connected if they are of
        the same data type. If the allow_conversions parameter is set to
        True, a more permissive check is done which accepts an input
        connection if the output data type can be automatically converted to
        the input data type without an explicit conversion node (such as a
        float output to a vector input).
        
        
        """
        pass
        
    
    def isDebugFlagSet():
        """
        isDebugFlagSet(self) -> bool
        
        Returns True if the node's debug flag is turned on. Returns False
        otherwise.
        
        
        """
        pass
        
    
    def inputIndexOrder():
        """
        inputIndexOrder(self) -> tuple of int
        
        Return a tuple of integers which represent input index numbers that
        can be passed to hou.Node.setInput and related functions. The order
        of the index numbers represents the order in which those inputs
        appear in the network view tile for this object. This ordering is
        affected by the way inputs are grouped together on the parameter
        pane for this node.
        
        
        """
        pass
        
    
    def inputGroupNames():
        """
        inputGroupNames(self) -> tuple of str
        
        Returns the names of the input groups on this VOP Node. Note that
        not all groups will contain any inputs, and so not all groups will
        be visible in the Network View. Use the hou.VopNode.inputsInGroup
        method to determine which inputs are part of a particular group.
        
        
        """
        pass
        
    
    def dependsOnlyOn():
        """None"""
        pass
        
    
    def setIsInputVisible(input_name, is_visible):
        """
        setIsInputVisible(self, input_name, is_visible)
        
        Shows or hides an input connector of this node. The input is
        specified by input_name. The connector is shown if is_visible is
        True, and hidden otherwise.
        
        
        """
        pass
        
    
    def coshaderNodesOutputNames():
        """None"""
        pass
        
    
    def isInputVisible(input_name):
        """
        isInputVisible(self, input_name) -> bool
        
        Returns True if the input connector specified by input_name on this
        node is visible, False otherwise.
        
        
        """
        pass
        
    
    def extraBindings():
        """
        extraBindings(self) -> tuple of str
        
        Returns the list of extra bindings the VOP node would add to the
        generated code. Implemented specifically for Snippet VOPs, this
        allows one to determine what bindings will be created by any adhoc @
        references.
        
        
        """
        pass
        
    
    def insertParmGenerator(input_name, parm_gen_type, reference_input_defaults):
        """
        insertParmGenerator(self, input_name, parm_gen_type,
        reference_input_defaults) -> hou.VopNode
        
        Creates a parameter or a constant node and wires it into an input
        specified by input_name on this node. parm_gen_type must be a value
        of hou.vopParmGenType. If reference_input_defaults is True, this
        node will reference the defaults of the newly created node.
        
        A resultant parameter or constant node is returned.
        
        
        """
        pass
        
    
    def setInputGroupExpanded(group, expanded):
        """
        setInputGroupExpanded(self, group, expanded)
        
        Sets the expanded state of the input group with the name specified
        by the group parameter. This controls the appearance of this input
        group in the Network View. Pass a group value of None to expand or
        collapse all input groups.
        
        
        """
        pass
        
    
    def currentSignatureName():
        """
        currentSignatureName(self) -> str
        
        Returns the current signature name of this node. The HDA nodes may
        provide several valid signatures, and this function returns the name
        of the currently used signature. A signature is defined by a set of
        input types and each set is assigned a name.
        
        
        """
        pass
        
    
    def isDetailMediumFlagSet():
        """
        isDetailMediumFlagSet(self) -> bool
        
        Returns True if the node's medium detail flag is turned on. Returns
        False otherwise.
        
        
        """
        pass
        
    
    def outerCode():
        """
        outerCode(self) -> str
        
        Returns the outer code associated with this node.
        
        
        """
        pass
        
    
    def setDetailHighFlag(on):
        """
        setDetailHighFlag(self, on)
        
        Turns on or off the high detail flag for this node's inputs and
        outputs. With this flag turned on, all inputs and outputs to this
        node will appear in the network view, whether they are connected to
        another node or not. This flag does not affect the operation of this
        node, only its appearance in the network view. The value of the on
        argument must be True or False.
        
        Raises hou.PermissionError if the node is unwritable.
        
        
        """
        pass
        
    
    def insertParmGeneratorsForAllInputs(parm_gen_type, reference_input_defaults):
        """
        insertParmGeneratorsForAllInputs(self, parm_gen_type,
        reference_input_defaults) -> dict of str to hou.VopNode
        
        Creates parameter or constant nodes and wires them into unconnected
        inputs on this node. parm_gen_type must be a value of
        hou.vopParmGenType. If reference_input_defaults is True, then this
        node will reference the defaults of the newly created nodes.
        
        A dictionary is returned with input names for keys and hou.VopNode
        objects for values.
        
        
        """
        pass
        
    
    def shaderType():
        """None"""
        pass
        
    
    def coshaderNodes():
        """None"""
        pass
        

class VopNodeType(NodeType):
    """
    hou.VopNodeType
    
    This kind of NodeType contains extra attributes specific to VOP nodes.
    
    
    """
    
    def shaderType():
        """
        shaderType(self) -> [Hom:hou.shaderType] enum value
        
        Returns the type of shader for this VOP type. For example, this vop
        type might be a surface shader or a displacement shader. See
        hou.shaderType for the possible shader types.
        
        See also hou.VopNode.shaderType.
        
        
        """
        pass
        
    
    def outputTags(output_name):
        """
        outputTags(self, output_name) -> dict of string to string
        
        Returns a dictionary of key-value pairs associated with the given
        output. This dictionary allows attaching arbitrary data to node
        outputs.
        
        
        """
        pass
        
    
    def renderMask():
        """
        renderMask(self) -> str
        
        Returns a string with space-separated names of the renderers that
        this VOP type supports. Note that some VOP types, like the switch
        VOP, return "*" to indicate that they support all renderers, while
        others return an empty string to indicate they are not real shaders.
        
        See hou.VopNode.shaderString for an example.
        
        
        """
        pass
        
    
    def inputTags(input_name):
        """
        inputTags(self, input_name) -> dict of string to string
        
        Returns a dictionary of key-value pairs associated with the given
        input. This dictionary allows attaching arbitrary data to node
        inputs.
        
        
        """
        pass
        

def VopNodeType_swigregister():
    """None"""
    pass
    

def VopNode_swigregister():
    """None"""
    pass
    

class _AgentClipTuple(object):
    """None"""
    
    def rend():
        """None"""
        pass
        
    
    def back():
        """None"""
        pass
        
    
    def pop():
        """None"""
        pass
        
    
    def rbegin():
        """None"""
        pass
        
    
    def clear():
        """None"""
        pass
        
    
    def erase():
        """None"""
        pass
        
    
    def append():
        """None"""
        pass
        
    
    def size():
        """None"""
        pass
        
    
    def end():
        """None"""
        pass
        
    
    def iterator():
        """None"""
        pass
        
    
    def swap():
        """None"""
        pass
        
    
    def pop_back():
        """None"""
        pass
        
    
    def empty():
        """None"""
        pass
        
    
    def begin():
        """None"""
        pass
        
    
    def front():
        """None"""
        pass
        
    
    def capacity():
        """None"""
        pass
        
    
    def resize():
        """None"""
        pass
        
    
    def insert():
        """None"""
        pass
        
    
    def get_allocator():
        """None"""
        pass
        
    
    def push_back():
        """None"""
        pass
        
    
    def assign():
        """None"""
        pass
        
    
    def reserve():
        """None"""
        pass
        

class _AgentClipTupleGenerator(object):
    """None"""

def _AgentClipTupleGenerator_swigregister():
    """None"""
    pass
    

def _AgentClipTuple_swigregister():
    """None"""
    pass
    

class _AgentDefnMap(object):
    """None"""
    
    def rend():
        """None"""
        pass
        
    
    def iterator():
        """None"""
        pass
        
    
    def rbegin():
        """None"""
        pass
        
    
    def has_key():
        """None"""
        pass
        
    
    def find():
        """None"""
        pass
        
    
    def size():
        """None"""
        pass
        
    
    def end():
        """None"""
        pass
        
    
    def swap():
        """None"""
        pass
        
    
    def itervalues():
        """None"""
        pass
        
    
    def empty():
        """None"""
        pass
        
    
    def begin():
        """None"""
        pass
        
    
    def keys():
        """None"""
        pass
        
    
    def lower_bound():
        """None"""
        pass
        
    
    def iteritems():
        """None"""
        pass
        
    
    def iterkeys():
        """None"""
        pass
        
    
    def count():
        """None"""
        pass
        
    
    def key_iterator():
        """None"""
        pass
        
    
    def upper_bound():
        """None"""
        pass
        
    
    def items():
        """None"""
        pass
        
    
    def clear():
        """None"""
        pass
        
    
    def value_iterator():
        """None"""
        pass
        
    
    def get_allocator():
        """None"""
        pass
        
    
    def erase():
        """None"""
        pass
        
    
    def values():
        """None"""
        pass
        

def _AgentDefnMap_swigregister():
    """None"""
    pass
    

class _AgentGroupTupleGenerator(object):
    """None"""

def _AgentGroupTupleGenerator_swigregister():
    """None"""
    pass
    

class _AgentLayerTupleGenerator(object):
    """None"""

def _AgentLayerTupleGenerator_swigregister():
    """None"""
    pass
    

class _AgentShapeBindingTuple(object):
    """None"""
    
    def rend():
        """None"""
        pass
        
    
    def back():
        """None"""
        pass
        
    
    def pop():
        """None"""
        pass
        
    
    def rbegin():
        """None"""
        pass
        
    
    def clear():
        """None"""
        pass
        
    
    def erase():
        """None"""
        pass
        
    
    def append():
        """None"""
        pass
        
    
    def size():
        """None"""
        pass
        
    
    def end():
        """None"""
        pass
        
    
    def iterator():
        """None"""
        pass
        
    
    def swap():
        """None"""
        pass
        
    
    def pop_back():
        """None"""
        pass
        
    
    def empty():
        """None"""
        pass
        
    
    def begin():
        """None"""
        pass
        
    
    def front():
        """None"""
        pass
        
    
    def capacity():
        """None"""
        pass
        
    
    def resize():
        """None"""
        pass
        
    
    def insert():
        """None"""
        pass
        
    
    def get_allocator():
        """None"""
        pass
        
    
    def push_back():
        """None"""
        pass
        
    
    def assign():
        """None"""
        pass
        
    
    def reserve():
        """None"""
        pass
        

def _AgentShapeBindingTuple_swigregister():
    """None"""
    pass
    

class _AgentTransformGroupTuple(object):
    """None"""
    
    def rend():
        """None"""
        pass
        
    
    def back():
        """None"""
        pass
        
    
    def pop():
        """None"""
        pass
        
    
    def rbegin():
        """None"""
        pass
        
    
    def clear():
        """None"""
        pass
        
    
    def erase():
        """None"""
        pass
        
    
    def append():
        """None"""
        pass
        
    
    def size():
        """None"""
        pass
        
    
    def end():
        """None"""
        pass
        
    
    def iterator():
        """None"""
        pass
        
    
    def swap():
        """None"""
        pass
        
    
    def pop_back():
        """None"""
        pass
        
    
    def empty():
        """None"""
        pass
        
    
    def begin():
        """None"""
        pass
        
    
    def front():
        """None"""
        pass
        
    
    def capacity():
        """None"""
        pass
        
    
    def resize():
        """None"""
        pass
        
    
    def insert():
        """None"""
        pass
        
    
    def get_allocator():
        """None"""
        pass
        
    
    def push_back():
        """None"""
        pass
        
    
    def assign():
        """None"""
        pass
        
    
    def reserve():
        """None"""
        pass
        

def _AgentTransformGroupTuple_swigregister():
    """None"""
    pass
    

class _BoolTuple(object):
    """None"""
    
    def rend():
        """None"""
        pass
        
    
    def back():
        """None"""
        pass
        
    
    def pop():
        """None"""
        pass
        
    
    def rbegin():
        """None"""
        pass
        
    
    def clear():
        """None"""
        pass
        
    
    def erase():
        """None"""
        pass
        
    
    def append():
        """None"""
        pass
        
    
    def size():
        """None"""
        pass
        
    
    def end():
        """None"""
        pass
        
    
    def iterator():
        """None"""
        pass
        
    
    def swap():
        """None"""
        pass
        
    
    def pop_back():
        """None"""
        pass
        
    
    def empty():
        """None"""
        pass
        
    
    def begin():
        """None"""
        pass
        
    
    def front():
        """None"""
        pass
        
    
    def capacity():
        """None"""
        pass
        
    
    def resize():
        """None"""
        pass
        
    
    def insert():
        """None"""
        pass
        
    
    def get_allocator():
        """None"""
        pass
        
    
    def push_back():
        """None"""
        pass
        
    
    def assign():
        """None"""
        pass
        
    
    def reserve():
        """None"""
        pass
        

def _BoolTuple_swigregister():
    """None"""
    pass
    

class _DopDataTupleGenerator(object):
    """None"""

def _DopDataTupleGenerator_swigregister():
    """None"""
    pass
    

class _DopObjectTuple(object):
    """None"""
    
    def rend():
        """None"""
        pass
        
    
    def back():
        """None"""
        pass
        
    
    def pop():
        """None"""
        pass
        
    
    def rbegin():
        """None"""
        pass
        
    
    def clear():
        """None"""
        pass
        
    
    def erase():
        """None"""
        pass
        
    
    def append():
        """None"""
        pass
        
    
    def size():
        """None"""
        pass
        
    
    def end():
        """None"""
        pass
        
    
    def iterator():
        """None"""
        pass
        
    
    def swap():
        """None"""
        pass
        
    
    def pop_back():
        """None"""
        pass
        
    
    def empty():
        """None"""
        pass
        
    
    def begin():
        """None"""
        pass
        
    
    def front():
        """None"""
        pass
        
    
    def capacity():
        """None"""
        pass
        
    
    def resize():
        """None"""
        pass
        
    
    def insert():
        """None"""
        pass
        
    
    def get_allocator():
        """None"""
        pass
        
    
    def push_back():
        """None"""
        pass
        
    
    def assign():
        """None"""
        pass
        
    
    def reserve():
        """None"""
        pass
        

def _DopObjectTuple_swigregister():
    """None"""
    pass
    

class _DopRecordTupleGenerator(object):
    """None"""

def _DopRecordTupleGenerator_swigregister():
    """None"""
    pass
    

class _DoubleTuple(object):
    """None"""
    
    def rend():
        """None"""
        pass
        
    
    def back():
        """None"""
        pass
        
    
    def pop():
        """None"""
        pass
        
    
    def rbegin():
        """None"""
        pass
        
    
    def clear():
        """None"""
        pass
        
    
    def erase():
        """None"""
        pass
        
    
    def append():
        """None"""
        pass
        
    
    def size():
        """None"""
        pass
        
    
    def end():
        """None"""
        pass
        
    
    def iterator():
        """None"""
        pass
        
    
    def swap():
        """None"""
        pass
        
    
    def pop_back():
        """None"""
        pass
        
    
    def empty():
        """None"""
        pass
        
    
    def begin():
        """None"""
        pass
        
    
    def front():
        """None"""
        pass
        
    
    def capacity():
        """None"""
        pass
        
    
    def resize():
        """None"""
        pass
        
    
    def insert():
        """None"""
        pass
        
    
    def get_allocator():
        """None"""
        pass
        
    
    def push_back():
        """None"""
        pass
        
    
    def assign():
        """None"""
        pass
        
    
    def reserve():
        """None"""
        pass
        

class _DoubleTupleTuple(object):
    """None"""
    
    def rend():
        """None"""
        pass
        
    
    def back():
        """None"""
        pass
        
    
    def pop():
        """None"""
        pass
        
    
    def rbegin():
        """None"""
        pass
        
    
    def clear():
        """None"""
        pass
        
    
    def erase():
        """None"""
        pass
        
    
    def append():
        """None"""
        pass
        
    
    def size():
        """None"""
        pass
        
    
    def end():
        """None"""
        pass
        
    
    def iterator():
        """None"""
        pass
        
    
    def swap():
        """None"""
        pass
        
    
    def pop_back():
        """None"""
        pass
        
    
    def empty():
        """None"""
        pass
        
    
    def begin():
        """None"""
        pass
        
    
    def front():
        """None"""
        pass
        
    
    def capacity():
        """None"""
        pass
        
    
    def resize():
        """None"""
        pass
        
    
    def insert():
        """None"""
        pass
        
    
    def get_allocator():
        """None"""
        pass
        
    
    def push_back():
        """None"""
        pass
        
    
    def assign():
        """None"""
        pass
        
    
    def reserve():
        """None"""
        pass
        

def _DoubleTupleTuple_swigregister():
    """None"""
    pass
    

def _DoubleTuple_swigregister():
    """None"""
    pass
    

class _EdgeGroupTuple(object):
    """None"""
    
    def rend():
        """None"""
        pass
        
    
    def back():
        """None"""
        pass
        
    
    def pop():
        """None"""
        pass
        
    
    def rbegin():
        """None"""
        pass
        
    
    def clear():
        """None"""
        pass
        
    
    def erase():
        """None"""
        pass
        
    
    def append():
        """None"""
        pass
        
    
    def size():
        """None"""
        pass
        
    
    def end():
        """None"""
        pass
        
    
    def iterator():
        """None"""
        pass
        
    
    def swap():
        """None"""
        pass
        
    
    def pop_back():
        """None"""
        pass
        
    
    def empty():
        """None"""
        pass
        
    
    def begin():
        """None"""
        pass
        
    
    def front():
        """None"""
        pass
        
    
    def capacity():
        """None"""
        pass
        
    
    def resize():
        """None"""
        pass
        
    
    def insert():
        """None"""
        pass
        
    
    def get_allocator():
        """None"""
        pass
        
    
    def push_back():
        """None"""
        pass
        
    
    def assign():
        """None"""
        pass
        
    
    def reserve():
        """None"""
        pass
        

def _EdgeGroupTuple_swigregister():
    """None"""
    pass
    

class _EdgeTuple(object):
    """None"""
    
    def rend():
        """None"""
        pass
        
    
    def back():
        """None"""
        pass
        
    
    def pop():
        """None"""
        pass
        
    
    def rbegin():
        """None"""
        pass
        
    
    def clear():
        """None"""
        pass
        
    
    def erase():
        """None"""
        pass
        
    
    def append():
        """None"""
        pass
        
    
    def size():
        """None"""
        pass
        
    
    def end():
        """None"""
        pass
        
    
    def iterator():
        """None"""
        pass
        
    
    def swap():
        """None"""
        pass
        
    
    def pop_back():
        """None"""
        pass
        
    
    def empty():
        """None"""
        pass
        
    
    def begin():
        """None"""
        pass
        
    
    def front():
        """None"""
        pass
        
    
    def capacity():
        """None"""
        pass
        
    
    def resize():
        """None"""
        pass
        
    
    def insert():
        """None"""
        pass
        
    
    def get_allocator():
        """None"""
        pass
        
    
    def push_back():
        """None"""
        pass
        
    
    def assign():
        """None"""
        pass
        
    
    def reserve():
        """None"""
        pass
        

class _EdgeTupleGenerator(object):
    """None"""

def _EdgeTupleGenerator_swigregister():
    """None"""
    pass
    

def _EdgeTuple_swigregister():
    """None"""
    pass
    

class _EnumTuple(object):
    """None"""
    
    def rend():
        """None"""
        pass
        
    
    def back():
        """None"""
        pass
        
    
    def pop():
        """None"""
        pass
        
    
    def rbegin():
        """None"""
        pass
        
    
    def clear():
        """None"""
        pass
        
    
    def erase():
        """None"""
        pass
        
    
    def append():
        """None"""
        pass
        
    
    def size():
        """None"""
        pass
        
    
    def end():
        """None"""
        pass
        
    
    def iterator():
        """None"""
        pass
        
    
    def swap():
        """None"""
        pass
        
    
    def pop_back():
        """None"""
        pass
        
    
    def empty():
        """None"""
        pass
        
    
    def begin():
        """None"""
        pass
        
    
    def front():
        """None"""
        pass
        
    
    def capacity():
        """None"""
        pass
        
    
    def resize():
        """None"""
        pass
        
    
    def insert():
        """None"""
        pass
        
    
    def get_allocator():
        """None"""
        pass
        
    
    def push_back():
        """None"""
        pass
        
    
    def assign():
        """None"""
        pass
        
    
    def reserve():
        """None"""
        pass
        

def _EnumTuple_swigregister():
    """None"""
    pass
    

class _FloatTuple(object):
    """None"""
    
    def rend():
        """None"""
        pass
        
    
    def back():
        """None"""
        pass
        
    
    def pop():
        """None"""
        pass
        
    
    def rbegin():
        """None"""
        pass
        
    
    def clear():
        """None"""
        pass
        
    
    def erase():
        """None"""
        pass
        
    
    def append():
        """None"""
        pass
        
    
    def size():
        """None"""
        pass
        
    
    def end():
        """None"""
        pass
        
    
    def iterator():
        """None"""
        pass
        
    
    def swap():
        """None"""
        pass
        
    
    def pop_back():
        """None"""
        pass
        
    
    def empty():
        """None"""
        pass
        
    
    def begin():
        """None"""
        pass
        
    
    def front():
        """None"""
        pass
        
    
    def capacity():
        """None"""
        pass
        
    
    def resize():
        """None"""
        pass
        
    
    def insert():
        """None"""
        pass
        
    
    def get_allocator():
        """None"""
        pass
        
    
    def push_back():
        """None"""
        pass
        
    
    def assign():
        """None"""
        pass
        
    
    def reserve():
        """None"""
        pass
        

class _FloatTupleTuple(object):
    """None"""
    
    def rend():
        """None"""
        pass
        
    
    def back():
        """None"""
        pass
        
    
    def pop():
        """None"""
        pass
        
    
    def rbegin():
        """None"""
        pass
        
    
    def clear():
        """None"""
        pass
        
    
    def erase():
        """None"""
        pass
        
    
    def append():
        """None"""
        pass
        
    
    def size():
        """None"""
        pass
        
    
    def end():
        """None"""
        pass
        
    
    def iterator():
        """None"""
        pass
        
    
    def swap():
        """None"""
        pass
        
    
    def pop_back():
        """None"""
        pass
        
    
    def empty():
        """None"""
        pass
        
    
    def begin():
        """None"""
        pass
        
    
    def front():
        """None"""
        pass
        
    
    def capacity():
        """None"""
        pass
        
    
    def resize():
        """None"""
        pass
        
    
    def insert():
        """None"""
        pass
        
    
    def get_allocator():
        """None"""
        pass
        
    
    def push_back():
        """None"""
        pass
        
    
    def assign():
        """None"""
        pass
        
    
    def reserve():
        """None"""
        pass
        

def _FloatTupleTuple_swigregister():
    """None"""
    pass
    

def _FloatTuple_swigregister():
    """None"""
    pass
    

class _GUDetailHandle(object):
    """None"""
    
    def isReadOnly():
        """None"""
        pass
        
    
    def _asVoidPointer():
        """None"""
        pass
        
    
    def isFrozen():
        """None"""
        pass
        
    
    def destroy():
        """None"""
        pass
        

def _GUDetailHandle_swigregister():
    """None"""
    pass
    

class _GeometryTuple(object):
    """None"""
    
    def rend():
        """None"""
        pass
        
    
    def back():
        """None"""
        pass
        
    
    def pop():
        """None"""
        pass
        
    
    def rbegin():
        """None"""
        pass
        
    
    def clear():
        """None"""
        pass
        
    
    def erase():
        """None"""
        pass
        
    
    def append():
        """None"""
        pass
        
    
    def size():
        """None"""
        pass
        
    
    def end():
        """None"""
        pass
        
    
    def iterator():
        """None"""
        pass
        
    
    def swap():
        """None"""
        pass
        
    
    def pop_back():
        """None"""
        pass
        
    
    def empty():
        """None"""
        pass
        
    
    def begin():
        """None"""
        pass
        
    
    def front():
        """None"""
        pass
        
    
    def capacity():
        """None"""
        pass
        
    
    def resize():
        """None"""
        pass
        
    
    def insert():
        """None"""
        pass
        
    
    def get_allocator():
        """None"""
        pass
        
    
    def push_back():
        """None"""
        pass
        
    
    def assign():
        """None"""
        pass
        
    
    def reserve():
        """None"""
        pass
        

class _GeometryTupleGenerator(object):
    """None"""

def _GeometryTupleGenerator_swigregister():
    """None"""
    pass
    

def _GeometryTuple_swigregister():
    """None"""
    pass
    

class _Int64Tuple(object):
    """None"""
    
    def rend():
        """None"""
        pass
        
    
    def back():
        """None"""
        pass
        
    
    def pop():
        """None"""
        pass
        
    
    def rbegin():
        """None"""
        pass
        
    
    def clear():
        """None"""
        pass
        
    
    def erase():
        """None"""
        pass
        
    
    def append():
        """None"""
        pass
        
    
    def size():
        """None"""
        pass
        
    
    def end():
        """None"""
        pass
        
    
    def iterator():
        """None"""
        pass
        
    
    def swap():
        """None"""
        pass
        
    
    def pop_back():
        """None"""
        pass
        
    
    def empty():
        """None"""
        pass
        
    
    def begin():
        """None"""
        pass
        
    
    def front():
        """None"""
        pass
        
    
    def capacity():
        """None"""
        pass
        
    
    def resize():
        """None"""
        pass
        
    
    def insert():
        """None"""
        pass
        
    
    def get_allocator():
        """None"""
        pass
        
    
    def push_back():
        """None"""
        pass
        
    
    def assign():
        """None"""
        pass
        
    
    def reserve():
        """None"""
        pass
        

def _Int64Tuple_swigregister():
    """None"""
    pass
    

class _IntTuple(object):
    """None"""
    
    def rend():
        """None"""
        pass
        
    
    def back():
        """None"""
        pass
        
    
    def pop():
        """None"""
        pass
        
    
    def rbegin():
        """None"""
        pass
        
    
    def clear():
        """None"""
        pass
        
    
    def erase():
        """None"""
        pass
        
    
    def append():
        """None"""
        pass
        
    
    def size():
        """None"""
        pass
        
    
    def end():
        """None"""
        pass
        
    
    def iterator():
        """None"""
        pass
        
    
    def swap():
        """None"""
        pass
        
    
    def pop_back():
        """None"""
        pass
        
    
    def empty():
        """None"""
        pass
        
    
    def begin():
        """None"""
        pass
        
    
    def front():
        """None"""
        pass
        
    
    def capacity():
        """None"""
        pass
        
    
    def resize():
        """None"""
        pass
        
    
    def insert():
        """None"""
        pass
        
    
    def get_allocator():
        """None"""
        pass
        
    
    def push_back():
        """None"""
        pass
        
    
    def assign():
        """None"""
        pass
        
    
    def reserve():
        """None"""
        pass
        

class _IntTupleTuple(object):
    """None"""
    
    def rend():
        """None"""
        pass
        
    
    def back():
        """None"""
        pass
        
    
    def pop():
        """None"""
        pass
        
    
    def rbegin():
        """None"""
        pass
        
    
    def clear():
        """None"""
        pass
        
    
    def erase():
        """None"""
        pass
        
    
    def append():
        """None"""
        pass
        
    
    def size():
        """None"""
        pass
        
    
    def end():
        """None"""
        pass
        
    
    def iterator():
        """None"""
        pass
        
    
    def swap():
        """None"""
        pass
        
    
    def pop_back():
        """None"""
        pass
        
    
    def empty():
        """None"""
        pass
        
    
    def begin():
        """None"""
        pass
        
    
    def front():
        """None"""
        pass
        
    
    def capacity():
        """None"""
        pass
        
    
    def resize():
        """None"""
        pass
        
    
    def insert():
        """None"""
        pass
        
    
    def get_allocator():
        """None"""
        pass
        
    
    def push_back():
        """None"""
        pass
        
    
    def assign():
        """None"""
        pass
        
    
    def reserve():
        """None"""
        pass
        

def _IntTupleTuple_swigregister():
    """None"""
    pass
    

def _IntTuple_swigregister():
    """None"""
    pass
    

class _InterpreterObjectTuple(object):
    """None"""
    
    def rend():
        """None"""
        pass
        
    
    def back():
        """None"""
        pass
        
    
    def pop():
        """None"""
        pass
        
    
    def rbegin():
        """None"""
        pass
        
    
    def clear():
        """None"""
        pass
        
    
    def erase():
        """None"""
        pass
        
    
    def append():
        """None"""
        pass
        
    
    def size():
        """None"""
        pass
        
    
    def end():
        """None"""
        pass
        
    
    def iterator():
        """None"""
        pass
        
    
    def swap():
        """None"""
        pass
        
    
    def pop_back():
        """None"""
        pass
        
    
    def empty():
        """None"""
        pass
        
    
    def begin():
        """None"""
        pass
        
    
    def front():
        """None"""
        pass
        
    
    def capacity():
        """None"""
        pass
        
    
    def resize():
        """None"""
        pass
        
    
    def insert():
        """None"""
        pass
        
    
    def get_allocator():
        """None"""
        pass
        
    
    def push_back():
        """None"""
        pass
        
    
    def assign():
        """None"""
        pass
        
    
    def reserve():
        """None"""
        pass
        

def _InterpreterObjectTuple_swigregister():
    """None"""
    pass
    

class _NetworkBoxTupleGenerator(object):
    """None"""

def _NetworkBoxTupleGenerator_swigregister():
    """None"""
    pass
    

class _NetworkMovableItemTuple(object):
    """None"""
    
    def rend():
        """None"""
        pass
        
    
    def back():
        """None"""
        pass
        
    
    def pop():
        """None"""
        pass
        
    
    def rbegin():
        """None"""
        pass
        
    
    def clear():
        """None"""
        pass
        
    
    def erase():
        """None"""
        pass
        
    
    def append():
        """None"""
        pass
        
    
    def size():
        """None"""
        pass
        
    
    def end():
        """None"""
        pass
        
    
    def iterator():
        """None"""
        pass
        
    
    def swap():
        """None"""
        pass
        
    
    def pop_back():
        """None"""
        pass
        
    
    def empty():
        """None"""
        pass
        
    
    def begin():
        """None"""
        pass
        
    
    def front():
        """None"""
        pass
        
    
    def capacity():
        """None"""
        pass
        
    
    def resize():
        """None"""
        pass
        
    
    def insert():
        """None"""
        pass
        
    
    def get_allocator():
        """None"""
        pass
        
    
    def push_back():
        """None"""
        pass
        
    
    def assign():
        """None"""
        pass
        
    
    def reserve():
        """None"""
        pass
        

def _NetworkMovableItemTuple_swigregister():
    """None"""
    pass
    

class _NodeConnectionTupleOfTuplesGenerator(object):
    """None"""

def _NodeConnectionTupleOfTuplesGenerator_swigregister():
    """None"""
    pass
    

class _NodeTuple(object):
    """None"""
    
    def rend():
        """None"""
        pass
        
    
    def back():
        """None"""
        pass
        
    
    def pop():
        """None"""
        pass
        
    
    def rbegin():
        """None"""
        pass
        
    
    def clear():
        """None"""
        pass
        
    
    def erase():
        """None"""
        pass
        
    
    def append():
        """None"""
        pass
        
    
    def size():
        """None"""
        pass
        
    
    def end():
        """None"""
        pass
        
    
    def iterator():
        """None"""
        pass
        
    
    def swap():
        """None"""
        pass
        
    
    def pop_back():
        """None"""
        pass
        
    
    def empty():
        """None"""
        pass
        
    
    def begin():
        """None"""
        pass
        
    
    def front():
        """None"""
        pass
        
    
    def capacity():
        """None"""
        pass
        
    
    def resize():
        """None"""
        pass
        
    
    def insert():
        """None"""
        pass
        
    
    def get_allocator():
        """None"""
        pass
        
    
    def push_back():
        """None"""
        pass
        
    
    def assign():
        """None"""
        pass
        
    
    def reserve():
        """None"""
        pass
        

class _NodeTupleGenerator(object):
    """None"""

def _NodeTupleGenerator_swigregister():
    """None"""
    pass
    

def _NodeTuple_swigregister():
    """None"""
    pass
    

class _ParmTemplateTuple(object):
    """None"""
    
    def rend():
        """None"""
        pass
        
    
    def back():
        """None"""
        pass
        
    
    def pop():
        """None"""
        pass
        
    
    def rbegin():
        """None"""
        pass
        
    
    def clear():
        """None"""
        pass
        
    
    def erase():
        """None"""
        pass
        
    
    def append():
        """None"""
        pass
        
    
    def size():
        """None"""
        pass
        
    
    def end():
        """None"""
        pass
        
    
    def iterator():
        """None"""
        pass
        
    
    def swap():
        """None"""
        pass
        
    
    def pop_back():
        """None"""
        pass
        
    
    def empty():
        """None"""
        pass
        
    
    def begin():
        """None"""
        pass
        
    
    def front():
        """None"""
        pass
        
    
    def capacity():
        """None"""
        pass
        
    
    def resize():
        """None"""
        pass
        
    
    def insert():
        """None"""
        pass
        
    
    def get_allocator():
        """None"""
        pass
        
    
    def push_back():
        """None"""
        pass
        
    
    def assign():
        """None"""
        pass
        
    
    def reserve():
        """None"""
        pass
        

def _ParmTemplateTuple_swigregister():
    """None"""
    pass
    

class _PointGroupTuple(object):
    """None"""
    
    def rend():
        """None"""
        pass
        
    
    def back():
        """None"""
        pass
        
    
    def pop():
        """None"""
        pass
        
    
    def rbegin():
        """None"""
        pass
        
    
    def clear():
        """None"""
        pass
        
    
    def erase():
        """None"""
        pass
        
    
    def append():
        """None"""
        pass
        
    
    def size():
        """None"""
        pass
        
    
    def end():
        """None"""
        pass
        
    
    def iterator():
        """None"""
        pass
        
    
    def swap():
        """None"""
        pass
        
    
    def pop_back():
        """None"""
        pass
        
    
    def empty():
        """None"""
        pass
        
    
    def begin():
        """None"""
        pass
        
    
    def front():
        """None"""
        pass
        
    
    def capacity():
        """None"""
        pass
        
    
    def resize():
        """None"""
        pass
        
    
    def insert():
        """None"""
        pass
        
    
    def get_allocator():
        """None"""
        pass
        
    
    def push_back():
        """None"""
        pass
        
    
    def assign():
        """None"""
        pass
        
    
    def reserve():
        """None"""
        pass
        

def _PointGroupTuple_swigregister():
    """None"""
    pass
    

class _PointTuple(object):
    """None"""
    
    def rend():
        """None"""
        pass
        
    
    def back():
        """None"""
        pass
        
    
    def pop():
        """None"""
        pass
        
    
    def rbegin():
        """None"""
        pass
        
    
    def clear():
        """None"""
        pass
        
    
    def erase():
        """None"""
        pass
        
    
    def append():
        """None"""
        pass
        
    
    def size():
        """None"""
        pass
        
    
    def end():
        """None"""
        pass
        
    
    def iterator():
        """None"""
        pass
        
    
    def swap():
        """None"""
        pass
        
    
    def pop_back():
        """None"""
        pass
        
    
    def empty():
        """None"""
        pass
        
    
    def begin():
        """None"""
        pass
        
    
    def front():
        """None"""
        pass
        
    
    def capacity():
        """None"""
        pass
        
    
    def resize():
        """None"""
        pass
        
    
    def insert():
        """None"""
        pass
        
    
    def get_allocator():
        """None"""
        pass
        
    
    def push_back():
        """None"""
        pass
        
    
    def assign():
        """None"""
        pass
        
    
    def reserve():
        """None"""
        pass
        

class _PointTupleGenerator(object):
    """None"""

def _PointTupleGenerator_swigregister():
    """None"""
    pass
    

class _PointTupleTuple(object):
    """None"""
    
    def rend():
        """None"""
        pass
        
    
    def back():
        """None"""
        pass
        
    
    def pop():
        """None"""
        pass
        
    
    def rbegin():
        """None"""
        pass
        
    
    def clear():
        """None"""
        pass
        
    
    def erase():
        """None"""
        pass
        
    
    def append():
        """None"""
        pass
        
    
    def size():
        """None"""
        pass
        
    
    def end():
        """None"""
        pass
        
    
    def iterator():
        """None"""
        pass
        
    
    def swap():
        """None"""
        pass
        
    
    def pop_back():
        """None"""
        pass
        
    
    def empty():
        """None"""
        pass
        
    
    def begin():
        """None"""
        pass
        
    
    def front():
        """None"""
        pass
        
    
    def capacity():
        """None"""
        pass
        
    
    def resize():
        """None"""
        pass
        
    
    def insert():
        """None"""
        pass
        
    
    def get_allocator():
        """None"""
        pass
        
    
    def push_back():
        """None"""
        pass
        
    
    def assign():
        """None"""
        pass
        
    
    def reserve():
        """None"""
        pass
        

def _PointTupleTuple_swigregister():
    """None"""
    pass
    

def _PointTuple_swigregister():
    """None"""
    pass
    

class _PrimGroupTuple(object):
    """None"""
    
    def rend():
        """None"""
        pass
        
    
    def back():
        """None"""
        pass
        
    
    def pop():
        """None"""
        pass
        
    
    def rbegin():
        """None"""
        pass
        
    
    def clear():
        """None"""
        pass
        
    
    def erase():
        """None"""
        pass
        
    
    def append():
        """None"""
        pass
        
    
    def size():
        """None"""
        pass
        
    
    def end():
        """None"""
        pass
        
    
    def iterator():
        """None"""
        pass
        
    
    def swap():
        """None"""
        pass
        
    
    def pop_back():
        """None"""
        pass
        
    
    def empty():
        """None"""
        pass
        
    
    def begin():
        """None"""
        pass
        
    
    def front():
        """None"""
        pass
        
    
    def capacity():
        """None"""
        pass
        
    
    def resize():
        """None"""
        pass
        
    
    def insert():
        """None"""
        pass
        
    
    def get_allocator():
        """None"""
        pass
        
    
    def push_back():
        """None"""
        pass
        
    
    def assign():
        """None"""
        pass
        
    
    def reserve():
        """None"""
        pass
        

def _PrimGroupTuple_swigregister():
    """None"""
    pass
    

class _PrimTuple(object):
    """None"""
    
    def rend():
        """None"""
        pass
        
    
    def back():
        """None"""
        pass
        
    
    def pop():
        """None"""
        pass
        
    
    def rbegin():
        """None"""
        pass
        
    
    def clear():
        """None"""
        pass
        
    
    def erase():
        """None"""
        pass
        
    
    def append():
        """None"""
        pass
        
    
    def size():
        """None"""
        pass
        
    
    def end():
        """None"""
        pass
        
    
    def iterator():
        """None"""
        pass
        
    
    def swap():
        """None"""
        pass
        
    
    def pop_back():
        """None"""
        pass
        
    
    def empty():
        """None"""
        pass
        
    
    def begin():
        """None"""
        pass
        
    
    def front():
        """None"""
        pass
        
    
    def capacity():
        """None"""
        pass
        
    
    def resize():
        """None"""
        pass
        
    
    def insert():
        """None"""
        pass
        
    
    def get_allocator():
        """None"""
        pass
        
    
    def push_back():
        """None"""
        pass
        
    
    def assign():
        """None"""
        pass
        
    
    def reserve():
        """None"""
        pass
        

class _PrimTupleGenerator(object):
    """None"""

def _PrimTupleGenerator_swigregister():
    """None"""
    pass
    

def _PrimTuple_swigregister():
    """None"""
    pass
    

class _RampTuple(object):
    """None"""
    
    def rend():
        """None"""
        pass
        
    
    def back():
        """None"""
        pass
        
    
    def pop():
        """None"""
        pass
        
    
    def rbegin():
        """None"""
        pass
        
    
    def clear():
        """None"""
        pass
        
    
    def erase():
        """None"""
        pass
        
    
    def append():
        """None"""
        pass
        
    
    def size():
        """None"""
        pass
        
    
    def end():
        """None"""
        pass
        
    
    def iterator():
        """None"""
        pass
        
    
    def swap():
        """None"""
        pass
        
    
    def pop_back():
        """None"""
        pass
        
    
    def empty():
        """None"""
        pass
        
    
    def begin():
        """None"""
        pass
        
    
    def front():
        """None"""
        pass
        
    
    def capacity():
        """None"""
        pass
        
    
    def resize():
        """None"""
        pass
        
    
    def insert():
        """None"""
        pass
        
    
    def get_allocator():
        """None"""
        pass
        
    
    def push_back():
        """None"""
        pass
        
    
    def assign():
        """None"""
        pass
        
    
    def reserve():
        """None"""
        pass
        

def _RampTuple_swigregister():
    """None"""
    pass
    

class _StickyNoteTupleGenerator(object):
    """None"""

def _StickyNoteTupleGenerator_swigregister():
    """None"""
    pass
    

class _StringMapDoubleTuple(object):
    """None"""
    
    def rend():
        """None"""
        pass
        
    
    def iterator():
        """None"""
        pass
        
    
    def rbegin():
        """None"""
        pass
        
    
    def has_key():
        """None"""
        pass
        
    
    def find():
        """None"""
        pass
        
    
    def size():
        """None"""
        pass
        
    
    def end():
        """None"""
        pass
        
    
    def swap():
        """None"""
        pass
        
    
    def itervalues():
        """None"""
        pass
        
    
    def empty():
        """None"""
        pass
        
    
    def begin():
        """None"""
        pass
        
    
    def keys():
        """None"""
        pass
        
    
    def lower_bound():
        """None"""
        pass
        
    
    def iteritems():
        """None"""
        pass
        
    
    def iterkeys():
        """None"""
        pass
        
    
    def count():
        """None"""
        pass
        
    
    def key_iterator():
        """None"""
        pass
        
    
    def upper_bound():
        """None"""
        pass
        
    
    def items():
        """None"""
        pass
        
    
    def clear():
        """None"""
        pass
        
    
    def value_iterator():
        """None"""
        pass
        
    
    def get_allocator():
        """None"""
        pass
        
    
    def erase():
        """None"""
        pass
        
    
    def values():
        """None"""
        pass
        

def _StringMapDoubleTuple_swigregister():
    """None"""
    pass
    

class _StringTuple(object):
    """None"""
    
    def rend():
        """None"""
        pass
        
    
    def back():
        """None"""
        pass
        
    
    def pop():
        """None"""
        pass
        
    
    def rbegin():
        """None"""
        pass
        
    
    def clear():
        """None"""
        pass
        
    
    def erase():
        """None"""
        pass
        
    
    def append():
        """None"""
        pass
        
    
    def size():
        """None"""
        pass
        
    
    def end():
        """None"""
        pass
        
    
    def iterator():
        """None"""
        pass
        
    
    def swap():
        """None"""
        pass
        
    
    def pop_back():
        """None"""
        pass
        
    
    def empty():
        """None"""
        pass
        
    
    def begin():
        """None"""
        pass
        
    
    def front():
        """None"""
        pass
        
    
    def capacity():
        """None"""
        pass
        
    
    def resize():
        """None"""
        pass
        
    
    def insert():
        """None"""
        pass
        
    
    def get_allocator():
        """None"""
        pass
        
    
    def push_back():
        """None"""
        pass
        
    
    def assign():
        """None"""
        pass
        
    
    def reserve():
        """None"""
        pass
        

class _StringTupleGenerator(object):
    """None"""

def _StringTupleGenerator_swigregister():
    """None"""
    pass
    

class _StringTupleTuple(object):
    """None"""
    
    def rend():
        """None"""
        pass
        
    
    def back():
        """None"""
        pass
        
    
    def pop():
        """None"""
        pass
        
    
    def rbegin():
        """None"""
        pass
        
    
    def clear():
        """None"""
        pass
        
    
    def erase():
        """None"""
        pass
        
    
    def append():
        """None"""
        pass
        
    
    def size():
        """None"""
        pass
        
    
    def end():
        """None"""
        pass
        
    
    def iterator():
        """None"""
        pass
        
    
    def swap():
        """None"""
        pass
        
    
    def pop_back():
        """None"""
        pass
        
    
    def empty():
        """None"""
        pass
        
    
    def begin():
        """None"""
        pass
        
    
    def front():
        """None"""
        pass
        
    
    def capacity():
        """None"""
        pass
        
    
    def resize():
        """None"""
        pass
        
    
    def insert():
        """None"""
        pass
        
    
    def get_allocator():
        """None"""
        pass
        
    
    def push_back():
        """None"""
        pass
        
    
    def assign():
        """None"""
        pass
        
    
    def reserve():
        """None"""
        pass
        

def _StringTupleTuple_swigregister():
    """None"""
    pass
    

def _StringTuple_swigregister():
    """None"""
    pass
    

class _VertexTuple(object):
    """None"""
    
    def rend():
        """None"""
        pass
        
    
    def back():
        """None"""
        pass
        
    
    def pop():
        """None"""
        pass
        
    
    def rbegin():
        """None"""
        pass
        
    
    def clear():
        """None"""
        pass
        
    
    def erase():
        """None"""
        pass
        
    
    def append():
        """None"""
        pass
        
    
    def size():
        """None"""
        pass
        
    
    def end():
        """None"""
        pass
        
    
    def iterator():
        """None"""
        pass
        
    
    def swap():
        """None"""
        pass
        
    
    def pop_back():
        """None"""
        pass
        
    
    def empty():
        """None"""
        pass
        
    
    def begin():
        """None"""
        pass
        
    
    def front():
        """None"""
        pass
        
    
    def capacity():
        """None"""
        pass
        
    
    def resize():
        """None"""
        pass
        
    
    def insert():
        """None"""
        pass
        
    
    def get_allocator():
        """None"""
        pass
        
    
    def push_back():
        """None"""
        pass
        
    
    def assign():
        """None"""
        pass
        
    
    def reserve():
        """None"""
        pass
        

class _VertexTupleGenerator(object):
    """None"""

def _VertexTupleGenerator_swigregister():
    """None"""
    pass
    

def _VertexTuple_swigregister():
    """None"""
    pass
    

def _addPreloadIcon():
    """None"""
    pass
    

def _clipInfo():
    """None"""
    pass
    

def _currentPythonModuleKey():
    """None"""
    pass
    

def _dopDataList():
    """None"""
    pass
    

def _dopDataPointList():
    """None"""
    pass
    

def _dopDataPolyList():
    """None"""
    pass
    

def _getArgumentAutoComplete():
    """None"""
    pass
    

def _hdaTrustedFunction(f):
    """_hdaTrustedFunction(f)
    
    A decorator for granting functions extra access privileges.
    
    This decorator grants a function defined in an HDA PythonModule
    section access privileges to the internals of that HDA.
    
    This function is only intended for internal Side Effects Software use.
    """
    pass
    

def _isCurrentThreadHoldingHOMLock():
    """None"""
    pass
    

def _isExiting():
    """None"""
    pass
    

def _nodesFromOPNodeList():
    """None"""
    pass
    

class object(object):
    """The most base type"""

def _popAccessPrivilege():
    """None"""
    pass
    

def _pushAccessPrivilege():
    """None"""
    pass
    

def _rasterizePreloadIcons():
    """None"""
    pass
    

def _registerAccessPrivilegeClient():
    """None"""
    pass
    

def _swig_getattr():
    """None"""
    pass
    

class property(object):
    """property(fget=None, fset=None, fdel=None, doc=None) -> property attribute
    
    fget is a function to be used for getting an attribute value, and likewise
    fset is a function for setting, and fdel a function for del'ing, an
    attribute.  Typical use is to define a managed attribute x:
    
    class C(object):
    def getx(self): return self._x
    def setx(self, value): self._x = value
    def delx(self): del self._x
    x = property(getx, setx, delx, "I'm the 'x' property.")
    
    Decorators make defining new properties or modifying existing ones easy:
    
    class C(object):
    @property
    def x(self):
    "I am the 'x' property."
    return self._x
    @x.setter
    def x(self, value):
    self._x = value
    @x.deleter
    def x(self):
    del self._x
    """
    
    def setter():
        """Descriptor to change the setter on a property."""
        pass
        
    
    def getter():
        """Descriptor to change the getter on a property."""
        pass
        
    
    def deleter():
        """Descriptor to change the deleter on a property."""
        pass
        

def _swig_repr():
    """None"""
    pass
    

def _swig_setattr():
    """None"""
    pass
    

def _swig_setattr_nondynamic():
    """None"""
    pass
    

def _swig_setattr_nondynamic_method():
    """None"""
    pass
    

def _syncFromMainContext():
    """None"""
    pass
    

def _syncToMainContext():
    """None"""
    pass
    

def addNodeBundle(name, =, None):
    """
    hou.addNodeBundle
    
    Create a new node bundle with the specified name.
    
    USAGE
    addNodeBundle(name = None) -> hou.NodeBundle
    
    See hou.NodeBundle for more information about node bundles.
    
    If name is None, a unique bundle name is generated automatically.
    
    Raises hou.OperationFailed if the name is not alphanumeric or a bundle
    with that name already exists.
    
    REPLACES
    
    * opbadd
    
    
    """
    pass
    

def allowEnvironmentToOverwriteVariable(or, disallow):
    """
    hou.allowEnvironmentToOverwriteVariable
    
    Allow (or disallow) an environment variable to overwrite the value of a
    global variable saved in a hip file.
    
    USAGE
    allowEnvironmentToOverwriteVariable(name, onoff)
    
    Note that you need to allow the variable to be overwritten from within
    Houdini/hython _before_ loading in the hip file.
    
    For example, suppose you set the JOB environment variable to
    /home/john/dyproject and created a hip file in
    /home/john/myproject/hip/scene.hip. Your hip file could then reference
    files using a $JOB prefix. If you then moved your project to
    /mnt/projects/myproject you cannot simply change the JOB environment
    variable because Houdini saved the old value of $JOB to the hip file.
    This function lets you override the value of $JOB before you load the
    hip file, as follows:
    
    > import os
    > os.environ["JOB"] = "/mnt/projects/myproject"
    > hou.allowEnvironmentToOverwriteVariable("JOB", True)
    > hou.hipFile.load(os.path.expandvars("$JOB/hip/scene.hip"))
    
    """
    pass
    

def almostEqual(x, y):
    """
    hou.almostEqual
    
    Compares two numbers and returns True if they are almost equal in terms
    of how far apart they are when represented as floating point numbers.
    
    USAGE
    almostEqual(x, y) -> bool
    
    
    """
    pass
    

def anonstats_swigregister():
    """None"""
    pass
    

class appearanceChangeType(object):
    """
    hou.appearanceChangeType
    
    Enumeration of types of appearance change events that can happen to
    nodes.
    
    See hou.Node.addEventCallback.
    
    VALUES
    
    
    Any
    ErrorState
    Pick
    Color
    DeleteScript
    CommentLockFlag
    CompressFlag
    OTLMatchState
    ActiveInput
    Connections
    ExpressionLanguage
    NetworkBox
    PostIt
    
    
    """

def appearanceChangeType_swigregister():
    """None"""
    pass
    

def appendSessionModuleSource(source):
    """
    hou.appendSessionModuleSource
    
    Appends the given source code to the hou.session module. The appended
    code is made available immediately. You do not have to re-import
    hou.session.
    
    USAGE
    appendSessionModuleSource(source)
    
    This function throws a hou.OperationFailed exception if it fails to
    update the hou.session module. This can happen if the appended source
    has syntax errors or if it conflicts with the existing contents of the
    module.
    
    RELATED
    
    * hou.session
    
    * hou.sessionModuleSource
    
    * hou.setSessionModuleSource
    
    
    """
    pass
    

def applicationCompilationDate():
    """
    hou.applicationCompilationDate
    
    Returns the application's compilation date.
    
    USAGE
    applicationCompilationDate() -> string
    
    If this method is executed in python, then it returns the date which the
    hou module was compiled on.
    
    REPLACES
    
    * version
    
    RELATED
    
    * hou.applicationName
    
    * hou.applicationVersion
    
    * hou.applicationVersionString
    
    * hou.applicationPlatformInfo
    
    * hou.licenseCategory
    
    * hou.isApprentice
    
    
    """
    pass
    

def applicationName():
    """
    hou.applicationName
    
    Returns the application name.
    
    USAGE
    applicationName() -> string
    
    REPLACES
    
    * version
    
    RELATED
    
    * hou.applicationCompilationDate
    
    * hou.applicationVersion
    
    * hou.applicationVersionString
    
    * hou.applicationPlatformInfo
    
    * hou.licenseCategory
    
    * hou.isApprentice
    
    
    """
    pass
    

def applicationPlatformInfo():
    """
    hou.applicationPlatformInfo
    
    Returns a string containing information about the system that compiled
    this version of Houdini.
    
    USAGE
    applicationPlatformInfo() -> string
    
    Most of the time you can use Python's platform module to get information
    about the current operating system, processor type, etc. However, this
    function can provide information not available through the platform
    module, such as the version of the compiler that compiled Houdini.
    
    > >>> hou.applicationPlatformInfo()
    > linux-x86_64-gcc4.4
    
    RELATED
    
    * hou.applicationCompilationDate
    
    * hou.applicationVersion
    
    * hou.applicationVersionString
    
    * hou.applicationName
    
    * hou.licenseCategory
    
    * hou.isApprentice
    
    
    """
    pass
    

def applicationVersion(major_version, minor_version, build_version):
    """
    hou.applicationVersion
    
    Returns the application's version number as a tuple of integers --
    (major_version, minor_version, build_version).
    
    USAGE
    applicationVersion() -> tuple of 3 ints
    
    If this method is executed in python, then it returns the hou module's
    version number.
    
    REPLACES
    
    * version
    
    RELATED
    
    * hou.applicationCompilationDate
    
    * hou.applicationName
    
    * hou.applicationVersionString
    
    * hou.applicationPlatformInfo
    
    * hou.licenseCategory
    
    * hou.isApprentice
    
    
    """
    pass
    

def applicationVersionString():
    """None"""
    pass
    

class attribData(object):
    """
    hou.attribData
    
    Enumeration of attribute data types.
    
    VALUES
    
    
    Int
    Float
    String
    
    
    """

def attribData_swigregister():
    """None"""
    pass
    

class attribType(object):
    """
    hou.attribType
    
    Enumeration of geometry attribute types.
    
    Note that global attributes are also known as detail attributes.
    
    The type of data (e.g. int, float, string) is called the attribute data
    type, can correspond to hou.attribData.
    
    See hou.Geometry.addAttrib and hou.Attrib for more information.
    
    VALUES
    
    
    Point
    Prim
    Vertex
    Global
    
    
    """

def attribType_swigregister():
    """None"""
    pass
    

def audio_swigregister():
    """None"""
    pass
    

def bezier():
    """
    hou.bezier
    
    Evaluate a Bezier interpolation spline for an animated parameter using
    the left keyframe's outgoing value, tangent, and acceleration and the
    right keyframe's incoming value, tangent, and acceleration.
    
    USAGE
    bezier() -> float
    
    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.
    
    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.
    
    RELATED
    
    * hou.constant
    
    * hou.cubic
    
    * hou.cycle
    
    * hou.cyclet
    
    * hou.ease
    
    * hou.easein
    
    * hou.easeinp
    
    * hou.easeout
    
    * hou.easeoutp
    
    * hou.easep
    
    * hou.linear
    
    * hou.match
    
    * hou.matchin
    
    * hou.matchout
    
    * hou.qlinear
    
    * hou.quintic
    
    * hou.repeat
    
    * hou.repeatt
    
    * hou.spline
    
    * hou.vmatch
    
    * hou.vmatchin
    
    * hou.vmatchout
    
    REPLACES
    
    * bezier()
    
    
    """
    pass
    

class boundaryDisplay(object):
    """
    hou.boundaryDisplay
    
    Enum for viewport boundary overlay.
    
    Boundaries are used to show the edges of polygon mesh islands, for
    either position or UV coordinates.
    
    VALUES
    
    
    hou.boundaryDisplay.Off
    The boundary is disabled.
    
    hou.boundaryDisplay.View3D
    The boundary is shown in 3D viewports only.
    
    hou.boundaryDisplay.ViewUV
    The boundary is shown in UV viewports only.
    
    hou.boundaryDisplay.On
    The boundary is shown in all viewports.
    
    
    """

def boundaryDisplay_swigregister():
    """None"""
    pass
    

def cd():
    """
    hou.cd
    
    Change the current node. Houdini has one current node, analogous to a
    current directory in a file system. If a relative path is given, it is
    relative to the node returned by hou.pwd().
    
    USAGE
    cd(path)
    
    If no node exists at the path, this function raises hou.OperationFailed.
    
    Even though, when called from a parameter's expression, hou.pwd()
    returns the node containing the parameter and not Houdini's current
    node, hou.cd() will always change the current node.
    
    This function will raise hou.NotAvailable if you call it from MPlay.
    
    RELATED
    
    * hou.pwd
    
    * hou.setPwd
    
    REPLACES
    
    * opcf
    
    
    """
    pass
    

def ch():
    """
    hou.ch
    
    The same as evalParm(). Provided for backward compatibility.
    
    USAGE
    ch(path) -> int, float, or string
    
    RELATED
    
    * hou.evalParm
    
    * hou.evalParmTuple
    
    * hou.chsop
    
    * hou.chsoplist
    
    * hou.parm
    
    * hou.parmTuple
    
    REPLACES
    
    * ch()
    
    * chs()
    
    
    """
    pass
    

class channelEditorMode(object):
    """None"""

def channelEditorMode_swigregister():
    """None"""
    pass
    

def chopExportConflictResolutionPattern():
    """
    hou.chopExportConflictResolutionPattern
    
    Returns a CHOP node path pattern to take precedence when exporting to
    the same channel.
    
    USAGE
    chopExportConflictResolutionPattern() -> str
    
    Returns a pattern for matching CHOP node paths that should take
    precedence when there are other CHOPs that override the same channels
    thus leading to conflicts.
    
    
    """
    pass
    

def chopNetNodeTypeCategory(chopnet):
    """
    hou.chopNetNodeTypeCategory
    
    Return the NodeTypeCategory instance for Houdini channel container
    (chopnet) nodes.
    
    USAGE
    chopNetNodeTypeCategory() -> NodeTypeCategory
    
    
    """
    pass
    

def chopNodeTypeCategory(chop):
    """
    hou.chopNodeTypeCategory
    
    Return the NodeTypeCategory instance for Houdini channel (chop) nodes.
    
    USAGE
    chopNodeTypeCategory() -> NodeTypeCategory
    
    
    """
    pass
    

def chsop(path):
    """
    hou.chsop
    
    Evaluate a parameter that references a node, and return the absolute
    path to the node.
    
    USAGE
    chsop(path) -> string
    
    RELATED
    
    * hou.evalParm
    
    * hou.chsoplist
    
    REPLACES
    
    * chsop()
    
    
    """
    pass
    

def chsoplist(path):
    """
    hou.chsoplist
    
    Evaluate a parameter that references a node path list, and return a
    space separated list of absolute node paths.
    
    USAGE
    chsoplist(path) -> string
    
    RELATED
    
    * hou.evalParm
    
    * hou.chsop
    
    REPLACES
    
    * chsoplist()
    
    
    """
    pass
    

def clearAllSelected():
    """
    hou.clearAllSelected
    
    Clears the selected state for all nodes, network boxes, and other
    subclasses of hou.NetworkMovableItem in the Houdini session.
    
    USAGE
    clearAllSelected()
    
    This function is equivalent to traversing the node hierarchy and calling
    setSelected(False) on every hou.NetworkMovableItem in the scene, but
    operates much much faster.
    
    This function will raise hou.NotAvailable if you call it from MPlay.
    
    RELATED
    
    * hou.NetworkBoxItem.isSelected
    
    * hou.NetworkBoxItem.setSelected
    
    
    """
    pass
    

def clipInfo(data, binary=True, blosc_compressed=True):
    """
    hou.clipInfo
    
    USAGE
    clipInfo(data, binary=True, blosc_compressed=True) -> dict
    
    Returns a dictionary with information about the clip specified by
    <data>. The returned dictionary contains the following keys:
    
    * "start" -> the start frame in the clip
    
    * "length" -> the clip length
    
    * "rate" -> the clip's sample rate
    
    * "tracks" -> a list of the track names in the clip
    
    All values in the returned dictionary are strings (or list of strings
    for "tracks").
    
    <binary> and <blosc_compressed> specify the format of the given <data>.
    
    * If <binary> is True, the given data is binary clip data. Otherwise
    it is plain text (ASCII) clip data.
    
    * If <blosc_compressed> is True, the given data is blosc compressed
    binary clip data. This cannot be used with ASCII clip data.
    
    Raises a hou.InvalidInput exception if binary = False and
    blosc_compressed = True.
    
    Raises a hou.OperationFailed exception if the given <data> is invalid.
    
    """
    pass
    

class colorItemType(object):
    """
    hou.colorItemType
    
    <Summary>
    
    <Description>
    
    VALUES
    
    
    NetworkBox
    StickyNote
    StickyNoteText
    
    
    """

def colorItemType_swigregister():
    """None"""
    pass
    

class colorType(object):
    """
    hou.colorType
    
    Enumeration of color spaces.
    
    VALUES
    
    
    RGB
    The red green blue color model.
    
    HSV
    The hue saturation value color model.
    
    HSL
    The hue saturation lightness color model.
    
    LAB
    The CIE L* a* b* color space model.
    
    XYZ
    The CIE XYZ color space model.
    
    
    """

def colorType_swigregister():
    """None"""
    pass
    

def compareHDA():
    """None"""
    pass
    

def compareHDABackup():
    """None"""
    pass
    

def compareHip():
    """None"""
    pass
    

def compareHipBackup():
    """None"""
    pass
    

def compareNode():
    """None"""
    pass
    

def compareNodeBackup():
    """None"""
    pass
    

class componentLoopType(object):
    """
    hou.componentLoopType
    
    Enumeration of component loop types.
    
    VALUES
    
    
    Partial
    A partial loop connects the components provided in a path with
    each input component acting as a way-point on the path. The loop
    will always start with the first provided component and end with
    the last.
    
    Extended
    An extended loop is always created from just two components (or
    possibly one edge component). It finds a path between these two
    components, then extends that path at both ends. It extends each
    direction until it either hits a boundary in the geometry, or
    finds its way back to the existing path. Often the resulting
    path will neither start with the start component or end with the
    end component.
    
    Closed
    A closed loop is always created from just two components (or
    possibly one edge component). It always tries to find a path the
    goes from the starting component, passes through the end
    component, and then continues on looking for a path back to the
    starting component. The paths returned will generally both start
    and end with the starting component.
    
    
    """

def componentLoopType_swigregister():
    """None"""
    pass
    

class compressionType(object):
    """
    hou.compressionType
    
    Enumeration of compression types.
    
    VALUES
    
    
    Gzip
    Compress using Gzip.
    
    Blosc
    Compress using Blosc.
    
    NoCompression
    Do not compress.
    
    
    """

def compressionType_swigregister():
    """None"""
    pass
    

class confirmType(object):
    """
    hou.confirmType
    
    Enumeration of confirmation dialog suppression options.
    
    VALUES
    
    
    OverwriteFile
    UnlockNode
    DeleteSpareParameters
    DeleteWithoutReferences
    NestedChannelGroups
    SiblingChannelGroups
    DeleteShelfElement
    DeleteGalleryEntry
    InactiveSnapMode
    BackgroundSave
    LockMultiNode
    TopCookSave
    TopDeleteResults
    TopDeleteTempDir
    TopHotKeyCancelCook
    
    
    """

def confirmType_swigregister():
    """None"""
    pass
    

class connectivityType(object):
    """
    hou.connectivityType
    
    Enumeration of connectivity types.
    
    VALUES
    
    
    NoConnectivity
    Texture
    Position
    
    
    """

def connectivityType_swigregister():
    """None"""
    pass
    

def constant():
    """
    hou.constant
    
    Evaluate an animation function for an animated parameter. The return
    value is always the left keyframe's outgoing value.
    
    USAGE
    constant() -> float
    
    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.
    
    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.
    
    RELATED
    
    * hou.bezier
    
    * hou.cubic
    
    * hou.cycle
    
    * hou.cyclet
    
    * hou.ease
    
    * hou.easein
    
    * hou.easeinp
    
    * hou.easeout
    
    * hou.easeoutp
    
    * hou.easep
    
    * hou.linear
    
    * hou.match
    
    * hou.matchin
    
    * hou.matchout
    
    * hou.qlinear
    
    * hou.quintic
    
    * hou.repeat
    
    * hou.repeatt
    
    * hou.spline
    
    * hou.vmatch
    
    * hou.vmatchin
    
    * hou.vmatchout
    
    REPLACES
    
    * constant()
    
    
    """
    pass
    

def contextOption(option):
    """
    hou.contextOption
    
    Returns the value of a cook context option.
    
    USAGE
    contextOption(option) -> float or str
    
    The return type will depend on the type of data used to set the option
    value.
    
    Retrieves the current value of a cook context option. This may have been
    set by a node requesting data from another node, or from the global
    default context option values stored in the hip file.
    
    RELATED
    
    * hou.contextOptionNames
    
    * hou.hasContextOption
    
    * hou.setDefaultContextOption
    
    
    """
    pass
    

def contextOptionNames():
    """
    hou.contextOptionNames
    
    Returns the names of all available cook context options.
    
    USAGE
    contextOptionNames() -> tuple of str
    
    Retrieves the names of all options available in the current cook
    context. If this method is invoked outside a cook context, it will
    return the names of all the default cook context options stored in the
    hip file.
    
    RELATED
    
    * hou.contextOption
    
    * hou.hasContextOption
    
    * hou.setDefaultContextOption
    
    
    """
    pass
    

def convertClipData(data, from_binary, from_blosc_compression, to_binary, to_blosc_compression):
    """
    hou.convertClipData
    
    USAGE
    convertClipData(data, from_binary, from_blosc_compression, to_binary,
    to_blosc_compression) -> str
    
    Converts the given clip <data> from the given format into the specified
    format.
    
    <from_binary> and <from_blosc_compression> specify the format of the
    given <data>.
    
    * If <from_binary> is True, the given data is binary clip data.
    Otherwise it is plain text (ASCII) clip data.
    
    * If <from_blosc_compression> is True, the given data is blosc
    compressed binary clip data. This cannot be used with ASCII clip
    data.
    
    <to_binary> and <to_blosc_compression> specify the format the data
    should be converted to.
    
    * If <to_binary> is True, convert to binary clip data. Otherwise
    convert to ASCII clip data.
    
    * If <to_blosc_compression> is True, convert to blosc compressed
    binary clip data. This cannot be used with ASCII clip data.
    
    Raises a hou.InvalidInput exception if from_binary = False and
    from_blosc_compression = True, or if to_binary = False and
    to_blosc_compression = True.
    
    Raises a hou.OperationFailed exception if the given <data> is invalid.
    
    
    """
    pass
    

def convertKeyframesToClipData(keyframe_map, binary=True, use_blosc_compression=True):
    """
    hou.convertKeyframesToClipData
    
    USAGE
    convertKeyframesToClipData(keyframe_map, binary=True,
    use_blosc_compression=True) -> str
    
    Converts the given keyframes into clip data.
    
    
    keyframe_map
    A dictionary mapping parameter names (str) to a list of keyframes
    for the parameter (hou.Keyframe).
    
    <binary> and <use_blosc_compression> specify the format of the returned
    clip data.
    
    * If <binary> is True, the returned data is binary clip data.
    Otherwise it is plain text (ASCII) clip data.
    
    * If <use_blosc_compression> is True, the returned data is blosc
    compressed binary clip data. This cannot be used with ASCII clip
    data.
    
    Raises a hou.InvalidInput exception if binary = False and
    use_blosc_compression = True.
    
    Raises a hou.OperationFailed exception if the given <keyframe_map> is
    empty.
    
    
    """
    pass
    

def cop2NetNodeTypeCategory(copnet):
    """
    hou.cop2NetNodeTypeCategory
    
    Return the NodeTypeCategory instance for Houdini composite container
    (copnet) nodes.
    
    USAGE
    cop2NetNodeTypeCategory() -> NodeTypeCategory
    
    
    """
    pass
    

def cop2NodeTypeCategory(cop):
    """
    hou.cop2NodeTypeCategory
    
    Return the NodeTypeCategory instance for Houdini composite (cop) nodes.
    
    USAGE
    cop2NodeTypeCategory() -> NodeTypeCategory
    
    
    """
    pass
    

def copyNodesTo(nodes, destination_node):
    """
    hou.copyNodesTo
    
    Copy all given nodes to a new place in node hierarchy.
    
    USAGE
    copyNodesTo(nodes, destination_node) -> tuple of Nodes
    
    The nodes to be copied should be a sequence of hou.Node objects. The
    destination node will be the parent of new copied nodes. The type of all
    source nodes should match the destination node child type.
    
    This function returns a tuple of hou.Node objects corresponding to the
    copied nodes.
    
    Nodes will be copied to the destination in batches based on their
    parent. All the nodes in a batch will be copied at the same time. This
    way, any relative channel references between nodes with the same parent
    will be updated to reflect the copied node location. Batches themselves
    will be copied sequentially. Thus, channel references between nodes with
    different parents will not be updated in copies.
    
    For every copied node, if a node with the same name already exists at
    the destination, the copy will be renamed. Any relative channel
    references to the copy will be updated with the new copy name.
    
    This function will raise a hou.OperationFailed exception if any of the
    nodes to be copied are of invalid type, the destination node cannot be
    copied into, or source node type does not match the destination node
    child type.
    
    This function will raise hou.ObjectWasDeleted if any of source nodes or
    the destination node no longer exist in Houdini.
    
    All of the above issues with source and destination nodes will be
    reported before copying starts to avoid partial copy.
    
    After the function finishes execution, all the new nodes created by it
    will be selected.
    
    REPLACES
    
    * opcp
    
    
    """
    pass
    

def copyNodesToClipboard(nodes):
    """
    hou.copyNodesToClipboard
    
    Copy given nodes to clipboard.
    
    USAGE
    copyNodesToClipboard(nodes)
    
    This function copies given nodes to clipboard.
    
    The nodes to be copied should be a sequence of hou.Node objects that
    have the same parent. Copying nodes from different networks at the same
    time is currently not supported.
    
    RELATED
    
    * hou.pasteNodesFromClipboard
    
    REPLACES
    
    * opcopy
    
    
    """
    pass
    

def crowds_swigregister():
    """None"""
    pass
    

def cubic():
    """
    hou.cubic
    
    Smooth curve between the left keyframe's outgoing slope and the right's
    incoming slope.
    
    USAGE
    cubic() -> float
    
    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.
    
    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.
    
    RELATED
    
    * hou.bezier
    
    * hou.constant
    
    * hou.cycle
    
    * hou.cyclet
    
    * hou.ease
    
    * hou.easein
    
    * hou.easeinp
    
    * hou.easeout
    
    * hou.easeoutp
    
    * hou.easep
    
    * hou.linear
    
    * hou.match
    
    * hou.matchin
    
    * hou.matchout
    
    * hou.qlinear
    
    * hou.quintic
    
    * hou.repeat
    
    * hou.repeatt
    
    * hou.spline
    
    * hou.vmatch
    
    * hou.vmatchin
    
    * hou.vmatchout
    
    REPLACES
    
    * cubic()
    
    
    """
    pass
    

def currentDopNet():
    """
    hou.currentDopNet
    
    Returns the DOP Network node set as the "current" simulation in the UI.
    
    USAGE
    currentDopNet() -> hou.Node
    
    The "current" DOP network is the network the shelf tools put new nodes
    into. The user can change this using the simulation menu in the bottom
    right corner of the main window.
    
    If you're building a shelf tool that creates simulation nodes, you
    should use this function to know where to put them.
    
    Call hou.setCurrentDopNet to set the current simulation network
    programmatically.
    
    RELATED
    
    * hou.setCurrentDopNet
    
    
    """
    pass
    

def cycle(start_frame, end_frame):
    """
    hou.cycle
    
    Repeats the motion between two times.
    
    USAGE
    cycle(start_frame, end_frame) -> float
    
    The values within the range are repeated exactly. If you want to line up
    the values with the value of the previous keyframe, use
    hou.cycleoffset() instead.
    
    This function is the same as hou.cyclet() except hou.cyclet() accepts
    times instead of frames.
    
    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.
    
    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.
    
    RELATED
    
    * hou.bezier
    
    * hou.constant
    
    * hou.cubic
    
    * hou.cyclet
    
    * hou.cycleoffset
    
    * hou.cycleoffsett
    
    * hou.ease
    
    * hou.easein
    
    * hou.easeinp
    
    * hou.easeout
    
    * hou.easeoutp
    
    * hou.easep
    
    * hou.linear
    
    * hou.match
    
    * hou.matchin
    
    * hou.matchout
    
    * hou.qlinear
    
    * hou.quintic
    
    * hou.spline
    
    * hou.vmatch
    
    * hou.vmatchin
    
    * hou.vmatchout
    
    REPLACES
    
    * cycle()
    
    
    """
    pass
    

def cycleoffset(start_frame, end_frame):
    """
    hou.cycleoffset
    
    Repeats the motion between two frames, lining up the first repeated
    value with the left keyframe's value.
    
    USAGE
    cycleoffset(start_frame, end_frame) -> float
    
    The repeated values are shifted so that each repeated portion has its
    first value set to the last value of the previous cycle. If the start
    frame is less than the end frame, the animation will cycle forwards.
    Otherwise, it will cycle backwards.
    
    This function is the same as hou.cycleoffsett() except
    hou.cycleoffsett() accepts times instead of frames. If you want to
    repeat motion exactly, use the hou.cycle() function instead.
    
    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.
    
    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.
    
    RELATED
    
    * hou.bezier
    
    * hou.constant
    
    * hou.cubic
    
    * hou.cycle
    
    * hou.cyclet
    
    * hou.cycleoffsett
    
    * hou.ease
    
    * hou.easein
    
    * hou.easeinp
    
    * hou.easeout
    
    * hou.easeoutp
    
    * hou.easep
    
    * hou.linear
    
    * hou.match
    
    * hou.matchin
    
    * hou.matchout
    
    * hou.qlinear
    
    * hou.quintic
    
    * hou.spline
    
    * hou.vmatch
    
    * hou.vmatchin
    
    * hou.vmatchout
    
    REPLACES
    
    * cycleoffset()
    
    
    """
    pass
    

def cycleoffsett(start_time, end_time):
    """
    hou.cycleoffsett
    
    Repeats the motion between two times, lining up the repeated values with
    the left keyframe's value.
    
    USAGE
    cycleoffsett(start_time, end_time) -> float
    
    The repeated values are shifted so that each repeated portion has its
    first value set to the last value of the previous cycle. If the start
    frame is less than the end frame, the animation will cycle forwards.
    Otherwise, it will cycle backwards.
    
    This function is the same as hou.cycleoffset() except hou.cycleoffset()
    accepts frames instead of times. If you want to repeat motion exactly,
    use the hou.cyclet() function instead.
    
    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.
    
    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.
    
    RELATED
    
    * hou.bezier
    
    * hou.constant
    
    * hou.cubic
    
    * hou.cycle
    
    * hou.cyclet
    
    * hou.cycleoffset
    
    * hou.ease
    
    * hou.easein
    
    * hou.easeinp
    
    * hou.easeout
    
    * hou.easeoutp
    
    * hou.easep
    
    * hou.linear
    
    * hou.match
    
    * hou.matchin
    
    * hou.matchout
    
    * hou.qlinear
    
    * hou.quintic
    
    * hou.spline
    
    * hou.vmatch
    
    * hou.vmatchin
    
    * hou.vmatchout
    
    REPLACES
    
    * cycleoffsett()
    
    
    """
    pass
    

def cyclet(start_time, end_time):
    """
    hou.cyclet
    
    Repeats the motion between two times.
    
    USAGE
    cyclet(start_time, end_time) -> float
    
    The values within the range are repeated exactly. If you want to line up
    the values with the value of the previous keyframe, use
    hou.cycleoffsett() instead.
    
    This function is the same as hou.cycle() except hou.cycle() it accepts
    frames instead of times.
    
    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.
    
    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.
    
    RELATED
    
    * hou.bezier
    
    * hou.constant
    
    * hou.cubic
    
    * hou.cycle
    
    * hou.cycleoffset
    
    * hou.cycleoffsett
    
    * hou.ease
    
    * hou.easein
    
    * hou.easeinp
    
    * hou.easeout
    
    * hou.easeoutp
    
    * hou.easep
    
    * hou.linear
    
    * hou.match
    
    * hou.matchin
    
    * hou.matchout
    
    * hou.qlinear
    
    * hou.quintic
    
    * hou.spline
    
    * hou.vmatch
    
    * hou.vmatchin
    
    * hou.vmatchout
    
    REPLACES
    
    * cyclet()
    
    
    """
    pass
    

class dataParmType(object):
    """
    hou.dataParmType
    
    Enumeration of data parameter types.
    
    A hou.DataParmTemplate is set to one of these types to specify whether a
    data parameter will hold geometry data or a key-value dictionary
    structure.
    
    VALUES
    
    
    Geometry
    KeyValueDictionary
    
    
    """

def dataParmType_swigregister():
    """None"""
    pass
    

def decode(str):
    """
    hou.decode
    
    Decodes a variable or geometry attribute name that was previously
    encoded.
    
    USAGE
    decode(str) -> str
    
    Houdini geometry attributes and group names are only allowed to contain
    letters, numbers, and underscores, and must not begin with a number.
    Arbitrary strings can be passed through the encode method to generate a
    string that obeys these restriction. This method takes one of these
    encoded strings, and returns the original string. A string that has not
    been encoded will be returned unmodified.
    
    > >>> hou.decode('xn__foobar_rla')
    > 'foo:bar'
    > >>> hou.decode('safe_name')
    > 'safe_name'
    
    RELATED
    
    hou.encode
    
    
    """
    pass
    

def defaultColor(color_item):
    """
    hou.defaultColor
    
    Return the default color for a particular network element.
    
    USAGE
    defaultColor(color_item) -> hou.Color
    
    Returns the default color that will be used for new network elements
    such as network boxes and sticky notes. Node default colors are
    controlled with methods on the hou.NodeType.
    
    RELATED
    
    * hou.colorItemType
    
    * hou.NodeType.defaultColor
    
    * hou.setDefaultColor
    
    
    """
    pass
    

class displaySetType(object):
    """
    hou.displaySetType
    
    Enum of viewport geometry contexts.
    
    There are several contexts for controlling shading and marker display
    which allow geometries from different operators to be distinguished from
    one another.
    
    VALUES
    
    
    hou.displaySetType.SceneObject
    Objects which are displayed but not selected, when the scene is
    viewing objects.
    
    hou.displaySetType.SelectedObject
    Objects which are displayed and selected, when the scene is
    viewing objects.
    
    hou.displaySetType.GhostObject
    Objects which are not the currently edited object when Ghost
    other Objects display mode is active.
    
    hou.displaySetType.DisplayModel
    The currently displayed surface operater when editing an object.
    
    hou.displaySetType.CurrentModel
    The currently selected surface operater when editing an object.
    
    hou.displaySetType.TemplateModel
    Surface operaters that have their template flag set when editing
    an object.
    
    
    """

def displaySetType_swigregister():
    """None"""
    pass
    

def dopNodeTypeCategory(DOP):
    """
    hou.dopNodeTypeCategory
    
    Return the NodeTypeCategory instance for Houdini dynamic (DOP) nodes.
    
    USAGE
    dopNodeTypeCategory() -> NodeTypeCategory
    
    
    """
    pass
    

def dop_swigregister():
    """None"""
    pass
    

class drawableDisplayMode(object):
    """
    hou.drawableDisplayMode
    
    Enumerator for the drawable display mode.
    
    VALUES
    
    
    hou.drawableDisplayMode.CurrentViewportMode
    Specifies the display mode currently active in the viewport.
    
    hou.drawableDisplayMode.WireframeMode
    Specifies the display mode as wireframe.
    
    
    """

def drawableDisplayMode_swigregister():
    """None"""
    pass
    

class drawablePrimitive(object):
    """
    hou.drawablePrimitive
    
    Enumerator for the drawable primitive types.
    
    VALUES
    
    
    hou.drawablePrimitive.Circle
    hou.drawablePrimitive.Sphere
    hou.drawablePrimitive.Tube
    
    
    """

def drawablePrimitive_swigregister():
    """None"""
    pass
    

def ease():
    """
    hou.ease
    
    Interpolates between the left keyframe's outgoing value and the right
    keyframe's incoming value.
    
    USAGE
    ease() -> float
    
    The tangents will be flat at both ends of the function, so the curve
    will slowly ease from the left value and, near the end of the function,
    slowly reduce the speed until it is at rest at the right value.
    
    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.
    
    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.
    
    RELATED
    
    * hou.bezier
    
    * hou.constant
    
    * hou.cubic
    
    * hou.cycle
    
    * hou.cyclet
    
    * hou.easein
    
    * hou.easeinp
    
    * hou.easeout
    
    * hou.easeoutp
    
    * hou.easep
    
    * hou.linear
    
    * hou.match
    
    * hou.matchin
    
    * hou.matchout
    
    * hou.qlinear
    
    * hou.quintic
    
    * hou.repeat
    
    * hou.repeatt
    
    * hou.spline
    
    * hou.vmatch
    
    * hou.vmatchin
    
    * hou.vmatchout
    
    REPLACES
    
    * ease()
    
    
    """
    pass
    

def easein():
    """
    hou.easein
    
    Interpolates between the left keyframe's outgoing value and the right
    keyframe's incoming value.
    
    USAGE
    easein() -> float
    
    The tangent will be flat at the left end of the function, so it will
    slowly ease from the outgoing value of the left keyframe.
    
    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.
    
    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.
    
    RELATED
    
    * hou.bezier
    
    * hou.constant
    
    * hou.cubic
    
    * hou.cycle
    
    * hou.cyclet
    
    * hou.ease
    
    * hou.easeinp
    
    * hou.easeout
    
    * hou.easeoutp
    
    * hou.easep
    
    * hou.linear
    
    * hou.match
    
    * hou.matchin
    
    * hou.matchout
    
    * hou.qlinear
    
    * hou.quintic
    
    * hou.repeat
    
    * hou.repeatt
    
    * hou.spline
    
    * hou.vmatch
    
    * hou.vmatchin
    
    * hou.vmatchout
    
    REPLACES
    
    * easein()
    
    
    """
    pass
    

def easeinp(ease_speed):
    """
    hou.easeinp
    
    Interpolates between the values of two keyframes.
    
    USAGE
    easeinp(ease_speed) -> float
    
    This function is like hou.easein, except it has an additional parameter
    to say how fast the curve should ease into the motion.
    
    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.
    
    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.
    
    RELATED
    
    * hou.bezier
    
    * hou.constant
    
    * hou.cubic
    
    * hou.cycle
    
    * hou.cyclet
    
    * hou.ease
    
    * hou.easein
    
    * hou.easeout
    
    * hou.easeoutp
    
    * hou.easep
    
    * hou.linear
    
    * hou.match
    
    * hou.matchin
    
    * hou.matchout
    
    * hou.qlinear
    
    * hou.quintic
    
    * hou.repeat
    
    * hou.repeatt
    
    * hou.spline
    
    * hou.vmatch
    
    * hou.vmatchin
    
    * hou.vmatchout
    
    REPLACES
    
    * easeinp()
    
    
    """
    pass
    

def easeout():
    """
    hou.easeout
    
    Interpolates between the left keyframe's outgoing value and the right
    keyframe's incoming value.
    
    USAGE
    easeout() -> float
    
    The tangent will be flat at the right end of the function, so it will
    slowly come to rest at the incoming value of the right keyframe.
    
    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.
    
    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.
    
    RELATED
    
    * hou.bezier
    
    * hou.constant
    
    * hou.cubic
    
    * hou.cycle
    
    * hou.cyclet
    
    * hou.ease
    
    * hou.easein
    
    * hou.easeinp
    
    * hou.easeoutp
    
    * hou.easep
    
    * hou.linear
    
    * hou.match
    
    * hou.matchin
    
    * hou.matchout
    
    * hou.qlinear
    
    * hou.quintic
    
    * hou.repeat
    
    * hou.repeatt
    
    * hou.spline
    
    * hou.vmatch
    
    * hou.vmatchin
    
    * hou.vmatchout
    
    REPLACES
    
    * easeout()
    
    
    """
    pass
    

def easeoutp(ease_speed):
    """
    hou.easeoutp
    
    Interpolates between the values of two keyframes.
    
    USAGE
    easeoutp(ease_speed) -> float
    
    This function is like hou.easeout, except it has an additional parameter
    to say how fast the curve should ease into the motion.
    
    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.
    
    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.
    
    RELATED
    
    * hou.bezier
    
    * hou.constant
    
    * hou.cubic
    
    * hou.cycle
    
    * hou.cyclet
    
    * hou.ease
    
    * hou.easein
    
    * hou.easeinp
    
    * hou.easeout
    
    * hou.easep
    
    * hou.linear
    
    * hou.match
    
    * hou.matchin
    
    * hou.matchout
    
    * hou.qlinear
    
    * hou.quintic
    
    * hou.repeat
    
    * hou.repeatt
    
    * hou.spline
    
    * hou.vmatch
    
    * hou.vmatchin
    
    * hou.vmatchout
    
    REPLACES
    
    * easeoutp()
    
    
    """
    pass
    

def easep(ease_bias):
    """
    hou.easep
    
    Interpolates between the values of two keyframes.
    
    USAGE
    easep(ease_bias) -> float
    
    An ease bias of less than one slow the animation near right keyframe,
    while an ease bias greater than one will slow it near the left keyframe.
    
    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.
    
    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.
    
    RELATED
    
    * hou.bezier
    
    * hou.constant
    
    * hou.cubic
    
    * hou.cycle
    
    * hou.cyclet
    
    * hou.ease
    
    * hou.easein
    
    * hou.easeinp
    
    * hou.easeout
    
    * hou.easeoutp
    
    * hou.linear
    
    * hou.match
    
    * hou.matchin
    
    * hou.matchout
    
    * hou.qlinear
    
    * hou.quintic
    
    * hou.repeat
    
    * hou.repeatt
    
    * hou.spline
    
    * hou.vmatch
    
    * hou.vmatchin
    
    * hou.vmatchout
    
    REPLACES
    
    * easep()
    
    
    """
    pass
    

def encode(str):
    """
    hou.encode
    
    Encodes any string into a valid variable or geometry attribute name.
    
    USAGE
    encode(str) -> str
    
    Houdini geometry attributes and group names are only allowed to contain
    letters, numbers, and underscores, and must not begin with a number.
    This method takes any string, and encodes it into a string that obeys
    these restrictions. The original string can be recovered using the
    decode method. A string that already obeys the rules is returned
    unmodified.
    
    One exception to this rule is that a string starting with xn__ will be
    encoded even if it is already a valid attribute name. This is because
    xn__ is the prefix used to identify an encoded string. In this case, an
    additional xn__ prefix will be added. This means a string can be encoded
    any number of times, then decoded the same number of times to always
    return to the original string, regardless of its contents.
    
    > >>> hou.encode('foo:bar')
    > 'xn__foobar_rla'
    > >>> hou.encode('safe_name')
    > 'safe_name'
    
    RELATED
    
    hou.decode
    
    
    """
    pass
    

def evalParm(path):
    """
    hou.evalParm
    
    Evaluate a parameter, given either an absolute or a relative path to it.
    Relative path searches are done from the node returned by . This
    function is a shortcut for hou.parm(path).eval().
    
    USAGE
    evalParm(path) -> int, float, or string
    
    The return type will depend on the type of the parameter.
    
    When a parameter is evaluating, hou.pwd returns the node containing that
    parameter, so hou.evalParm() can be used inside expressions to perform
    relative parameter references.
    
    This function throws a hou.NotAvailable exception if you call it from
    MPlay.
    
    RELATED
    
    * hou.evalParmTuple
    
    * hou.Parm
    
    * hou.ParmTuple
    
    REPLACES
    
    * ch()
    
    * chs()
    
    
    """
    pass
    

def evalParmTuple(path):
    """
    hou.evalParmTuple
    
    Evaluate a parameter, given either an absolute or a relative path to it.
    Relative path searches are done from the node returned by . This
    function is a shortcut for hou.parmTuple(path).eval().
    
    USAGE
    evalParmTuple(path) -> tuple of int, float, or str, or hou.Ramp
    
    The return type will depend on the type of the parameter.
    
    When a parameter is evaluating, hou.pwd returns the node containing that
    parameter, so hou.evalParmTuple() can be used inside expressions to
    perform relative parameter references.
    
    This function throws a hou.NotAvailable exception if you call it from
    MPlay.
    
    RELATED
    
    * hou.evalParm
    
    * hou.Parm
    
    * hou.ParmTuple
    
    REPLACES
    
    * ch()
    
    * chramp()
    
    * chs()
    
    
    """
    pass
    

def evaluatingParm():
    """
    hou.evaluatingParm
    
    Return the parameter that is currently evaluating.
    
    USAGE
    evaluatingParm() -> hou.Parm
    
    You can call this function from a parameter expression to determine
    which parameter is currently evaluating. This function provides the
    Python equivalent of Hscript's $CH variable.
    
    RELATED
    
    * hou.ScriptEvalContext
    
    
    """
    pass
    

def exit(exit_code=0, suppress_save_prompt=False):
    """
    hou.exit
    
    Exits Houdini, returning the exit code to the operating system. If
    suppress_save_prompt is false, this function asks the user if he/she
    wants to save. If the user presses "Cancel", the exit will be canceled
    and the next statement will execute.
    
    USAGE
    exit(exit_code=0, suppress_save_prompt=False)
    
    The exit confirmation prompt only appears if the session has unsaved
    changes. This function will not return until after the user has made a
    choice from the prompt. If this function is called from outside Houdini
    (e.g. MPlay or a non-graphical Python shell), the dialog is not
    displayed and suppress_save_prompt==True is implied.
    
    Note that if the user chose to exit, this function will raise a Python
    SystemExit exception to ensure the executing Python script terminates.
    This approach ensures that the next Python statement will not be
    executed, since Houdini may add events to its event queue that carry out
    the actual shutdown, or hou.exit() may be called from a different thread
    than the one executing the shutdown.
    
    Note that if you call sys.exit() from within the interactive Houdini
    Python shell, it will call hou.exit() with suppress_save_prompt=True.
    The Houdini Python shell does this by intercepting the SystemExit
    exception raised by sys.exit() and calling hou.exit(). Since both
    sys.exit() and hou.exit() both raise SystemExit exceptions, the shell
    calls hou._isExiting() to differentiate between the two.
    
    Avoid calling sys.exit() from any place other than the interactive
    Houdini Python shell, such as non-graphical Python shells, and instead
    call hou.exit(). Using hou.exit() ensures that Houdini shuts down
    cleanly.
    
    REPLACES
    
    * quit
    
    
    """
    pass
    

def expandString(str):
    """
    hou.expandString
    
    Expands global variables and expressions in a string at the current
    frame.
    
    USAGE
    expandString(str) -> str
    
    Expands global variables in the expression. For example, when Houdini is
    at frame 10:
    
    > >>> hou.expandStringAtFrame('$F')
    > '10'
    
    Also expands HScript expressions in backticks, such as the channel
    reference in this example. This returns the value of the translate X
    parameter for geo1 at the current frame as a string:
    
    > hou.expandStringAtFrame('`ch("/obj/geo1/tx")`')
    
    This function evaluates the string as if it were the contents of a non-
    animated text parameter. To evaluate a straight HScript expression
    (without needing backticks), use hou.hscriptExpression.
    
    Raises hou.OperationFailed exception if the first argument is None.
    
    > >>> hou.expandString("$HIP/file.geo")
    > '/dir/containing/hip/file/file.geo'
    > >>> hou.expandString("file`$F+1`.pic")
    > 'file2.pic'
    
    RELATED
    
    * hou.expandStringAtFrame
    
    * hou.hscriptExpression
    
    
    """
    pass
    

def expandStringAtFrame(str, frame_number):
    """
    hou.expandStringAtFrame
    
    Expands global variables and expressions in a string at a given frame.
    
    USAGE
    expandStringAtFrame(str, frame_number) -> str
    
    Expands global variables in the expression. For example:
    
    > >>> hou.expandStringAtFrame('$F', 10)
    > '10'
    
    Also expands HScript expressions in back-ticks, such as the channel
    reference in this example. This returns the value of the translate X
    parameter for geo1 at the current frame as a string:
    
    > hou.expandStringAtFrame('`ch("/obj/geo1/tx")`', hou.frame())
    
    This function evaluates the string as if it were the contents of a non-
    animated text parameter. To evaluate a straight HScript expression
    (without needing back-ticks), use hou.hscriptExpression.
    
    Raises hou.OperationFailed exception if the first argument is None.
    
    RELATED
    
    * hou.expandString
    
    * hou.hscriptExpression
    
    
    """
    pass
    

class exprLanguage(object):
    """
    hou.exprLanguage
    
    Enumeration of available expression languages.
    
    VALUES
    
    
    Python
    Hscript
    
    
    """

def exprLanguage_swigregister():
    """None"""
    pass
    

def expressionGlobals():
    """
    hou.expressionGlobals
    
    Return the globals dictionary used by the parameter expression
    evaluation namespace.
    
    USAGE
    expressionGlobals() -> dict
    
    When Houdini evaluates a Python expression inside a parameter, it uses a
    separate namespace. This way, Houdini can run from hou import * and from
    hou.session import * in that namespace, allowing you to drop the hou.
    and hou.session. prefixes in your expressions, and the global namespace
    does not get polluted.
    
    In Python, namespaces are stored as dictionaries. This function returns
    the dictionary for the Python parameter expression namespace. It is
    analogous to the builtin globals function, which returns you the
    dictionary for the current namespace.
    
    You might use this function from the pythonrc.py file to set up Python
    functions that can be called from any Python parameter expression. For
    example, if you put your functions in a module called expr, you might
    put the following in pythonrc.py:
    
    > import expr
    > hou.expressionGlobals()['expr'] = expr
    
    Then, from a Python expression, you could write expr.foo(), where foo is
    a function defined in your expr module.
    
    You can also use this dictionary with Python's exec statement. The
    following example also imports the expr module into the both the global
    and expression namespaces:
    
    > code = compile("import expr", "<generated_code>", "exec")
    > exec code
    > exec code in hou.expressionGlobals()
    
    See Python Parameter Expressions for more information on using Python
    expressions in parameters. See startup scripts for more information
    about pythonrc.py.
    
    
    """
    pass
    

class fbxCompatibilityMode(object):
    """None"""

def fbxCompatibilityMode_swigregister():
    """None"""
    pass
    

class fbxMaterialMode(object):
    """None"""

def fbxMaterialMode_swigregister():
    """None"""
    pass
    

class fieldType(object):
    """
    hou.fieldType
    
    Enumeration of field types.
    
    VALUES
    
    
    NoSuchField
    Integer
    Boolean
    Float
    String
    Vector2
    Vector3
    Vector4
    Quaternion
    Matrix3
    Matrix4
    UV
    UVW
    IntArray
    FloatArray
    
    
    """

def fieldType_swigregister():
    """None"""
    pass
    

class fileChooserMode(object):
    """
    hou.fileChooserMode
    
    Enumeration of possible read/write modes for the file chooser.
    
    See hou.ui.selectFile.
    
    VALUES
    
    
    Read
    Write
    ReadAndWrite
    
    
    """

def fileChooserMode_swigregister():
    """None"""
    pass
    

def fileReferences():
    """None"""
    pass
    

class fileType(object):
    """
    hou.fileType
    
    Enumeration of file types.
    
    VALUES
    
    
    Any
    Image
    Geometry
    Ramp
    Capture
    Clip
    Lut
    Cmd
    Midi
    I3d
    Chan
    Sim
    SimData
    Hip
    Otl
    Dae
    Gallery
    Directory
    
    
    """

def fileType_swigregister():
    """None"""
    pass
    

def findDirectories(directory_name):
    """
    hou.findDirectories
    
    Search the Houdini path for the specified directory, returning a tuple
    of all the matches. The directory name specified should be relative to
    the Houdini directory.
    
    USAGE
    findDirectories(directory_name) -> tuple of strings
    
    If the directory cannot be found in the Houdini path, OperationFailed is
    raised.
    
    RELATED
    
    * hou.findDirectory
    
    * hou.findFile
    
    * hou.findFiles
    
    * hou.houdiniPath
    
    
    """
    pass
    

def findDirectory(directory_name):
    """
    hou.findDirectory
    
    Search the Houdini path for a specified directory, returning the first
    match found. The directory name specified should be relative to the
    Houdini directory.
    
    USAGE
    findDirectory(directory_name) -> string
    
    If the directory cannot be found in the Houdini path, OperationFailed is
    raised.
    
    RELATED
    
    * hou.findDirectories
    
    * hou.findFile
    
    * hou.findFiles
    
    * hou.houdiniPath
    
    
    """
    pass
    

def findFile(file_name):
    """
    hou.findFile
    
    Search the Houdini path for a specified file, returning the first match
    found. The filename specified should be relative to the Houdini
    directory.
    
    USAGE
    findFile(file_name) -> string
    
    If the file cannot be found in the Houdini path, OperationFailed is
    raised. Directories are not found, for directories use hou.findDirectory
    instead.
    
    RELATED
    
    * hou.findFiles
    
    * hou.findDirectory
    
    * hou.findDirectories
    
    * hou.houdiniPath
    
    REPLACES
    
    * findfile()
    
    
    """
    pass
    

def findFiles(file_name):
    """
    hou.findFiles
    
    Search the Houdini path for the specified file, returning a tuple of all
    the matches. The filename specified should be relative to the Houdini
    directory.
    
    USAGE
    findFiles(file_name) -> tuple of strings
    
    If the file cannot be found on the Houdini path, OperationFailed is
    raised. Directories are not found, for directories use
    hou.findDirectories instead.
    
    RELATED
    
    * hou.findFile
    
    * hou.findDirectory
    
    * hou.findDirectories
    
    * hou.houdiniPath
    
    REPLACES
    
    * findfiles()
    
    
    """
    pass
    

def findFilesWithExtension(file_extension, subdirectory, =, None):
    """
    hou.findFilesWithExtension
    
    Search the Houdini path for files with a particular extension, returning
    a tuple of all the matches. A subdirectory can also be optionally
    provided which is appended to each entry in the Houdini path before
    looking for files.
    
    USAGE
    findFilesWithExtension(file_extension, subdirectory = None) -> tuple
    of strings
    
    Directories are not returned by this method.
    
    RELATED
    
    * hou.findFile
    
    * hou.findDirectory
    
    * hou.findDirectories
    
    * hou.houdiniPath
    
    REPLACES
    
    * findfiles()
    
    
    """
    pass
    

class flipbookAntialias(object):
    """
    hou.flipbookAntialias
    
    Enum values for flipbook antialiasing settings.
    
    See hou.FlipbookSettings.antialias.
    
    VALUES
    
    
    UseViewportSetting
    Use the current viewport's antialiasing setting.
    
    Off
    No antialiasing.
    
    Fast
    Fast 2-sample antialiasing.
    
    Good
    4-sample antialiasing.
    
    HighQuality
    High-quality 8-sample antialiasing.
    
    
    """

def flipbookAntialias_swigregister():
    """None"""
    pass
    

class flipbookMotionBlurBias(object):
    """
    hou.flipbookMotionBlurBias
    
    Enum values used to specify the motion blur subframe range.
    
    See hou.FlipbookSettings.motionBlurFrameRange.
    
    VALUES
    
    
    Centered
    Subframe range is centered around the currently rendering frame.
    
    Forward
    Subframe range begins at the currently rendering frame.
    
    Previous
    Subframe range ends at the currently rendering frame.
    
    
    """

def flipbookMotionBlurBias_swigregister():
    """None"""
    pass
    

class flipbookObjectType(object):
    """
    hou.flipbookObjectType
    
    Enum values for setting the flipbook's visible object types.
    
    Used by FlipbookSettings.visibleTypes() to set the visible object types
    when doing a flipbook.
    
    VALUES
    
    
    hou.flipbookObjectType.Visible
    All object types that are currently visible will be rendered.
    
    hou.flipbookObjectType.GeoOnly
    Only geometry objects will be rendered, which excludes bone,
    muscle, null, camera, light, and blend objects.
    
    hou.flipbookObjectType.GeoExcluded
    All object types other than Geometry that are currently visible
    will be rendered.
    
    hou.flipbookObjectType.AllObjects
    All object types will be rendered, even if their type is not
    currently visible.
    
    
    """

def flipbookObjectType_swigregister():
    """None"""
    pass
    

class folderType(object):
    """
    hou.folderType
    
    Enumeration of folder types for FolderParmTemplates.
    
    See also hou.FolderParmTemplate.
    
    VALUES
    
    
    Collapsible
    A folder that expands and collapses to show and hide its
    contents respectively.
    
    Simple
    A simple folder for organizing parameters in the form of a group
    box.
    
    Tabs
    A normal folder represented by a tab.
    
    RadioButtons
    A folder with a radio button. The open folder is the selected
    radio button in the set of buttons.
    
    MultiparmBlock
    A block of multiparms. The user can add or remove instances of
    this parameter block.
    
    ScrollingMultiparmBlock
    A multiparm block inside a smaller region with scroll bars.
    
    TabbedMultiparmBlock
    A multiparm block where each instance of the parameters in the
    block appears in its own tab.
    
    ImportBlock
    A block containing parameters imported from another node.
    
    
    """

def folderType_swigregister():
    """None"""
    pass
    

def fps():
    """
    hou.fps
    
    Return the number of frames per second.
    
    USAGE
    fps() -> float
    
    This value is used when converting between frames and time.
    
    RELATED
    
    * hou.setFps
    
    * hou.frame
    
    * hou.time
    
    REPLACES
    
    * fps
    
    
    """
    pass
    

def frame():
    """
    hou.frame
    
    Return the playbar's current frame. Note that Houdini can be on a
    fractional frame if fractional frames are enabled.
    
    USAGE
    frame() -> float
    
    Note that this function is equivalent to Hscript's $FF variable. If you
    want hscript's $F variable, use hou.intFrame, which rounds the frame to
    the nearest integer.
    
    To enable fractional frames, turn off the Integer Frame Values in the
    Global Animation Options dialog.
    
    This function rounds its output to 3 decimal places, just like Hscript's
    $FF variable does. Note, though, that because a Python float may not be
    able to precisely represent a floating point value, and because Python
    does not round numbers when it displays them, the frame number might end
    with 9999999999999 or 0000000000001 when you print it to the Python
    shell. When you convert the number to a string, though, Python will
    round the value, so it will contain at most 3 decimal places.
    
    > >>> 2.759
    > 2.7589999999999999
    > >>> 2.757
    > 2.7570000000000001
    > >>> str(2.759)
    > '2.759'
    
    If Houdini is on a fractional frame and you do not want the rounded
    value, use hou.timeToFrame(hou.time()).
    
    > >>> hou.setFrame(13.193)
    > >>> hou.frame()
    > 13.193
    > >>> hou.timeToFrame(hou.time())
    > 13.192999839782715
    > >>> hou.setFrame(2.759)
    > >>> hou.frame()
    > 2.7589999999999999
    > >>> int(hou.frame())
    > 2
    > >>> hou.intFrame()
    > 3
    
    RELATED
    
    * hou.intFrame
    
    * hou.setFrame
    
    * hou.time
    
    * hou.fps
    
    REPLACES
    
    * fcur
    
    
    """
    pass
    

def frameToTime(frame):
    """
    hou.frameToTime
    
    Convert from a given frame value to a time value.
    
    USAGE
    frameToTime(frame) -> float
    
    Calling this function is the same as evaluating (frame - 1.0) /
    hou.fps(). Unlike hou.timeToFrame(), no rounding is performed.
    
    RELATED
    
    * hou.fps
    
    * hou.time
    
    * hou.frame
    
    REPLACES
    
    * fps
    
    
    """
    pass
    

def galleries_swigregister():
    """None"""
    pass
    

class geometryType(object):
    """
    hou.geometryType
    
    Enumeration of geometry component types.
    
    VALUES
    
    
    Points
    Vertices
    Edges
    Breakpoints
    Primitives
    
    
    """

def geometryType_swigregister():
    """None"""
    pass
    

class geometryViewportEvent(object):
    """
    hou.geometryViewportEvent
    
    Enumeration of the geometry viewport events that can be handled by
    callback functions.
    
    See hou.GeometryViewport.addEventCallback.
    
    VALUES
    
    
    CameraSwitched
    This event is triggered when the viewport camera has been
    switched to a different one.
    
    
    """

def geometryViewportEvent_swigregister():
    """None"""
    pass
    

class geometryViewportLayout(object):
    """
    hou.geometryViewportLayout
    
    Enumeration of viewport layouts.
    
    > # Get a reference to the 3D viewer pane tab
    > desktop = hou.ui.curDesktop()
    > viewer = desktop.paneTabOfType(hou.paneTabType.SceneViewer)
    >
    > # Get the current layout
    > current_layout = viewer.viewportLayout()
    > # Change the layout to "quad view"
    > viewer.setViewportLayout(hou.geometryViewportLayout.)
    
    See the viewport methods on the SceneViewer object.
    
    VALUES
    
    
    DoubleSide
    
    DoubleStack
    
    Quad
    
    QuadBottomSplit
    
    QuadLeftSplit
    
    Single
    
    TripleBottomSplit
    
    TripleLeftSplit
    
    
    """

def geometryViewportLayout_swigregister():
    """None"""
    pass
    

class geometryViewportType(object):
    """
    hou.geometryViewportType
    
    Enumeration of scene viewer viewport types.
    
    VALUES
    
    
    Perspective
    Top
    Bottom
    Front
    Back
    Right
    Left
    UV
    
    
    """

def geometryViewportType_swigregister():
    """None"""
    pass
    

def getPreference(name):
    """
    hou.getPreference
    
    Return a preference value.
    
    USAGE
    getPreference(name) -> string
    
    RELATED
    
    * hou.getPreferenceNames
    
    * hou.setPreference
    
    
    """
    pass
    

def getPreferenceNames():
    """
    hou.getPreferenceNames
    
    Return all the preference names.
    
    USAGE
    getPreferenceNames() -> tuple of strings
    
    RELATED
    
    * hou.getPreference
    
    * hou.setPreference
    
    
    """
    pass
    

def getenv(name, default_value=None):
    """
    hou.getenv
    
    Return the value of the specified Houdini environment variable.
    
    USAGE
    getenv(name, default_value=None) -> str
    
    Return the value of the specified Houdini environment variable. Return
    default_value if the environment variable does not exist.
    
    RELATED
    
    * hou.putenv
    
    * hou.unsetenv
    
    
    """
    pass
    

class glShadingType(object):
    """
    hou.glShadingType
    
    Enum for viewport shading modes
    
    VALUES
    
    
    hou.glShadingType.WireBoundingBox
    Objects displayed as wireframe bounding boxes.
    
    hou.glShadingType.ShadedBoundingBox
    Objects displayed as solid bounding boxes.
    
    hou.glShadingType.Wire
    Geometry displayed as regular wireframe.
    
    hou.glShadingType.WireGhost
    Geometry displayed as wireframe with occluded wires dimmed.
    
    hou.glShadingType.HiddenLineGhost
    Geometry displayed as wireframe with constant filled polygons.
    
    hou.glShadingType.HiddenLineInvisible
    Geometry displayed as wireframe hidden occluded wires.
    
    hou.glShadingType.Flat
    Geometry displayed as lit, but with flat shaded polygons.
    
    hou.glShadingType.FlatWire
    Geometry displayed as lit, but with flat shaded, outlined
    polygons.
    
    hou.glShadingType.Smooth
    Geometry displayed as shaded and lit.
    
    hou.glShadingType.SmoothWire
    Geometry displayed as shaded and lit with outlined polygons.
    
    
    """

def glShadingType_swigregister():
    """None"""
    pass
    

class groupListType(object):
    """
    hou.groupListType
    
    Enumeration of group list types.
    
    VALUES
    
    
    Points
    Vertices
    Edges
    Breakpoints
    Primitives
    MatchPickType
    
    
    """

def groupListType_swigregister():
    """None"""
    pass
    

class handleOrientToNormalAxis(object):
    """
    hou.handleOrientToNormalAxis
    
    Enumeration of handle axes that can be aligned to a geometry normal.
    
    See hou.ui.handleOrientToNormalAxis for more information.
    
    VALUES
    
    
    Y
    Z
    
    
    """

def handleOrientToNormalAxis_swigregister():
    """None"""
    pass
    

def hasContextOption(option):
    """
    hou.hasContextOption
    
    Returns True if the specified option exists in the current cook context.
    
    USAGE
    hasContextOption(option) -> bool
    
    This method tests for options that may have been set by a node
    requesting data from another node, or that are set in the default cook
    context options stored with the hip file.
    
    RELATED
    
    * hou.contextOption
    
    * hou.contextOptionNames
    
    * hou.setDefaultContextOption
    
    
    """
    pass
    

def hdaDefinition(node_type_category, name, lib_path):
    """
    hou.hdaDefinition
    
    Given a node type category, operator name and digital asset library
    path, return an HDADefinition object. Return None if no such digital
    asset definition matches the arguments.
    
    USAGE
    hdaDefinition(node_type_category, name, lib_path) -> hou.HDADefinition
    or None
    
    Be careful not to confuse this function with the class
    hou.HDADefinition.
    
    Example:
    
    > # Return the HDA definition for a SOP digital asset named 'foo'
    > # that is located in the '/tmp/bar.hda' library.
    > hou.hdaDefinition(hou.sopNodeTypeCategory(), 'foo', '/tmp/bar.hda')
    
    RELATED
    
    * hou.hda
    
    
    """
    pass
    

class hdaEventType(object):
    """
    hou.hdaEventType
    
    Enumeration of types of events that can happen for digital asset
    libraries.
    
    See hou.hda.addEventCallback.
    
    
    NOTE
    The AssetCreated and AssetDeleted events do not fire when a library
    file is installed or uninstalled.
    
    VALUES
    
    
    AssetCreated
    A new asset was created (using the Create Digital Asset context
    menu item in the network editor or through HOM).
    
    The callback function is called with this event type and the
    following additional argument:
    
    
    asset_definition
    An hou.HDADefinition object representing the newly created
    asset.
    
    AssetDeleted
    An asset was deleted (using the Asset Manager UI or through
    HOM). Note that the asset no longer exists by the time the
    function is called.
    
    The callback function is called with this event type and the
    following additional arguments:
    
    
    asset_name
    A string containing the name of the deleted asset.
    
    library_path
    A string containing the file path of the asset library
    (.hda) file that contained the asset.
    
    node_type_category
    A hou.NodeTypeCategory representing the type category (for
    example, Object, SOP, DOP) of the deleted asset.
    
    AssetSaved
    An asset was saved.
    
    The callback function is called with this event type and the
    following additional argument:
    
    
    asset_definition
    An hou.HDADefinition object representing the saved asset.
    
    LibraryInstalled
    A digital asset library has been installed into the current
    Houdini session.
    
    The callback function is called with this event type and the
    following additional argument:
    
    
    library_path
    The file path to the installed asset library (.hda) file.
    
    LibraryUninstalled
    A digital asset library has been uninstalled from the current
    Houdini session.
    
    The callback function is called with this event type and the
    following additional argument:
    
    
    library_path
    The file path to the uninstalled asset library (.hda) file.
    
    
    """

def hdaEventType_swigregister():
    """None"""
    pass
    

class hdaLicenseType(object):
    """
    hou.hdaLicenseType
    
    Enumeration of digital asset license permission levels.
    
    VALUES
    
    
    Execute
    Read
    Full
    
    
    """

def hdaLicenseType_swigregister():
    """None"""
    pass
    

def hda_swigregister():
    """None"""
    pass
    

def helpServerUrl():
    """
    hou.helpServerUrl
    
    Return the base URL for all Houdini help pages.
    
    USAGE
    helpServerUrl() -> string
    
    
    """
    pass
    

class hipFileEventType(object):
    """
    hou.hipFileEventType
    
    Enumeration of the hip file event types that can be handled by callback
    functions.
    
    See hou.hipFile.addEventCallback.
    
    VALUES
    
    
    BeforeClear
    This event is triggered immediately before the current .hip file
    is cleared. For example, when selecting File -> New in the main
    menu bar.
    
    AfterClear
    This event is triggered immediately after the current .hip file
    is cleared. For example, when selecting File -> New in the main
    menu bar.
    
    BeforeLoad
    This event is triggered immediately before a .hip file is loaded
    into Houdini.
    
    AfterLoad
    This event is triggered immediately after a .hip file is loaded
    into Houdini.
    
    BeforeMerge
    This event is triggered immediately before a .hip file is merged
    into the current Houdini session.
    
    AfterMerge
    This event is triggered immediately after a .hip file is merged
    into the current Houdini session.
    
    BeforeSave
    This event is triggered immediately before the current .hip file
    is saved.
    
    AfterSave
    This event is triggered immediately after the current .hip file
    is saved.
    
    
    """

def hipFileEventType_swigregister():
    """None"""
    pass
    

def hipFile_swigregister():
    """None"""
    pass
    

def hmath_swigregister():
    """None"""
    pass
    

def homeHoudiniDirectory():
    """
    hou.homeHoudiniDirectory
    
    Return the path to the Houdini directory in your $HOME directory.
    
    USAGE
    homeHoudiniDirectory() -> str
    
    Return the directory in your $HOME directory where Houdini stores user-
    specific settings. On many platforms, this directory is
    $HOME/houdiniX.Y, where X is the Houdini major version and Y is the
    minor version. Note that on the Mac, though, this directory might be in
    a different location.
    
    See hou.houdiniPath for more information about how Houdini searches for
    files.
    
    RELATED
    
    * hou.houdiniPath
    
    * hou.applicationVersion
    
    * hou.findFile
    
    * hou.findFiles
    
    * hou.findDirectory
    
    * hou.findDirectories
    
    
    """
    pass
    

def hotkeys_swigregister():
    """None"""
    pass
    

def houdiniPath(path_variable, =, None):
    """
    hou.houdiniPath
    
    Return the contents of the Houdini path as a tuple of strings.
    
    USAGE
    houdiniPath(path_variable = None) -> tuple of strings
    
    This method returns an ordered list of path components of the Houdini
    Path. The Houdini Path is used when searching for various files like
    otls, shelf tools, preferences, desktops, icons, etc. By adjusting the
    HOUDINI_PATH environment variable, you can add entries to the path that
    are specific to the current user, job, or studio.
    
    By default the components of the HOUDINI_PATH variable are returned. If
    the path_variable passed in refers to another well-known Houdini path,
    the components of that search path are returned instead. For example
    houdiniPath("HOUDINI_OTLSCAN_PATH")
    
    See the output of hconfig -ap for more information on the current paths
    and their values.
    
    RELATED
    
    * hou.findFile
    
    * hou.findFiles
    
    * hou.findDirectory
    
    * hou.findDirectories
    
    
    """
    pass
    

def hscript(command):
    """
    hou.hscript
    
    Executes the given hscript command and returns a 2-tuple of strings
    where the first string contains the regular output of the executed
    command and the second string contains the error output. You can specify
    multiple commands by using ';' or the newline character as the
    separator.
    
    USAGE
    hscript(command) -> tuple of strings
    
    REPLACES
    
    * execute()
    
    
    """
    pass
    

def hscriptCommandHelp(command_name):
    """
    hou.hscriptCommandHelp
    
    Return the text help of an hscript command. This function is used to
    help re-implement hscript commands in Python.
    
    USAGE
    hscriptCommandHelp(command_name) -> string
    
    
    """
    pass
    

def hscriptExpandString(str):
    """
    hou.hscriptExpandString
    
    Deprecated: Use expandString.
    
    USAGE
    hscriptExpandString(str) -> string
    
    
    WARNING
    This is deprecated. Use hou.expandString instead.
    
    RELATED
    
    * hou.expandString
    
    
    """
    pass
    

def hscriptExpression(expression_string):
    """
    hou.hscriptExpression
    
    Evaluate an Hscript expression.
    
    USAGE
    hscriptExpression(expression_string) -> float, str, or tuple
    
    Given an expression string, this function evaluates it as though it was
    an HScript expression on a parameter. The return type depends on the
    expression.
    
    Raises hou.OperationFailed if the expression is invalid or generates an
    error occur during evaluation.
    
    > >>> hou.hscriptExpression("$HIP")
    > '/path/to/hip/directory'
    > >>> hou.hscriptExpression("$F")
    > 1.0
    > >>> hou.hscriptExpression('vector("[1, 2, 3]")')
    > (1.0, 2.0, 3.0)
    > >>> hou.hscriptExpression('matrix("[[1, 2][3, 4]]")')
    > ((1.0, 2.0), (3.0, 4.0))
    > >>> hou.hscriptExpression("hello")
    > 'hello'
    > >>> hou.hscriptExpression("'hello'")
    > 'hello'
    > >>> hou.hscriptExpression("'hello' + ' world'")
    > 'hello world'
    > >>> hou.hscriptExpression('"$F"')
    > '1'
    > >>> hou.hscriptExpression("'$F'")
    > '$F'
    
    This function is somewhat similar to hou.expandString, however,
    expandString will replace the portions of the string containing
    variables, leaving the rest of the string unchanged. If the variable is
    unknown, it will not do any expansion.
    
    > >>> hou.expandString("$HOME")
    > '/home/me'
    > >>> hou.expandString("HOME is $HOME")
    > 'HOME is /home/me'
    > >>> hou.hscriptExpression("HOME is $HOME")
    > Traceback (most recent call last):
    >   File "<console>", line 1, in <module>
    >   File "/opt/hfs10.5/houdini/python2.5libs/hou.py", line 19331, in hscriptExpression
    >     return _hou.hscriptExpression(*args)
    > OperationFailed: The attempted operation failed.
    > Syntax error - extra tokens detected in expression
    > >>> hou.expandString("$F")
    > '1'
    > >>> hou.expandString('"$F"')
    > '"1"'
    > >>> hou.hscriptExpression("$GARBAGE")
    > Traceback (most recent call last):
    >   File "<console>", line 1, in <module>
    >   File "/opt/hfs10.5/houdini/python2.5libs/hou.py", line 19331, in hscriptExpression
    >     return _hou.hscriptExpression(*args)
    > OperationFailed: The attempted operation failed.
    > Undefined variable
    > >>> hou.expandString("$GARBAGE")
    > '$GARBAGE'
    > >>> hou.hscript("echo -n $GARBAGE")[0]
    > ''
    > >>> hou.expandString("")
    > ''
    > >>> hou.hscriptExpression("")
    > Traceback (most recent call last):
    >   File "<console>", line 1, in <module>
    >   File "/opt/hfs10.5/houdini/python2.5libs/hou.py", line 19331, in hscriptExpression
    >     return _hou.hscriptExpression(*args)
    > OperationFailed: The attempted operation failed.
    > Invalid expression
    
    RELATED
    
    * hou.hscriptFloatExpression
    
    * hou.hscriptStringExpression
    
    * hou.hscriptVectorExpression
    
    * hou.hscriptMatrixExpression
    
    * hou.expandString
    
    * hou.expandStringAtFrame
    
    
    """
    pass
    

def hscriptFloatExpression(expression):
    """
    hou.hscriptFloatExpression
    
    Evaluate an Hscript expression as a float.
    
    USAGE
    hscriptFloatExpression(expression) -> float
    
    This function will force the return type to be a float.
    
    Most of the time, you want to use hou.hscriptExpression over this
    function. See it for more examples.
    
    Raises hou.OperationFailed if the expression is invalid or generates an
    error occur during evaluation.
    
    If the expression contains variables, Houdini will attempt to evaluate
    them as floats, and use the value 0.0 if they cannot be converted to
    floats. However, if the expression definitely evaluates to a string that
    does not start with a number, this function raises hou.OperationFailed.
    
    > >>> hou.hscriptFloatExpression("3")
    > 3.0
    > >>> hou.hscriptFloatExpression("'3'")
    > 3.0
    > >>> hou.hscriptFloatExpression("'3X'")
    > 3.0
    > >>> hou.hscriptFloatExpression("'X3'")
    > Traceback (most recent call last):
    >   File "<console>", line 1, in <module>
    >   File "/opt/hfs10.5/houdini/python2.5libs/hou.py", line 9359, in hscriptFloatExpression
    >     return _hou.hscriptFloatExpression(*args)
    > OperationFailed: The attempted operation failed.
    > Bad data type for function or operation
    > >>> hou.hscriptFloatExpression("3X")
    > Traceback (most recent call last):
    >   File "<console>", line 1, in <module>
    >   File "/opt/hfs10.5/houdini/python2.5libs/hou.py", line 9359, in hscriptFloatExpression
    >     return _hou.hscriptFloatExpression(*args)
    > OperationFailed: The attempted operation failed.
    > Syntax error - extra tokens detected in expression
    > >>> hou.hscriptFloatExpression("$F")
    > 1.0
    > >>> hou.hscriptFloatExpression('"$F"')
    > 1.0
    > >>> hou.hscriptFloatExpression("$HOME")
    > 0.0
    > >>> hou.hscriptFloatExpression('"$HOME"')
    > Traceback (most recent call last):
    >   File "<console>", line 1, in <module>
    >   File "/opt/hfs10.5/houdini/python2.5libs/hou.py", line 9359, in hscriptFloatExpression
    >     return _hou.hscriptFloatExpression(*args)
    > OperationFailed: The attempted operation failed.
    > Bad data type for function or operation
    > >>> hou.hscriptFloatExpression("'$F'")
    > Traceback (most recent call last):
    >   File "<console>", line 1, in <module>
    >   File "/opt/hfs10.5/houdini/python2.5libs/hou.py", line 9359, in hscriptFloatExpression
    >     return _hou.hscriptFloatExpression(*args)
    > OperationFailed: The attempted operation failed.
    > Bad data type for function or operation
    
    RELATED
    
    * hou.hscriptExpression
    
    * hou.hscriptStringExpression
    
    * hou.hscriptVectorExpression
    
    * hou.hscriptMatrixExpression
    
    
    """
    pass
    

def hscriptMatrixExpression(expression):
    """
    hou.hscriptMatrixExpression
    
    Evaluate an Hscript expression as a vector.
    
    USAGE
    hscriptMatrixExpression(expression) -> tuple of tuple of floats
    
    This function will force the return type to be an Hscript matrix.
    Because Hscript matrices can be be of different sizes, the value is
    returned as a tuple of tuples of floats. If you know the matrix is a
    particular size, you can construct a Matrix3/Matrix4 out of the return
    value.
    
    Most of the time, you want to use hou.hscriptExpression over this
    function.
    
    > xform = hou.Matrix4(hou.hscriptMatrixExpression('doptransform("/obj/dopnet1", "obj0", "Geometry")'))
    
    Raises hou.OperationFailed if the expression is invalid or generates an
    error during evaluation.
    
    RELATED
    
    * hou.hscriptExpression
    
    * hou.hscriptFloatExpression
    
    * hou.hscriptStringExpression
    
    * hou.hscriptVectorExpression
    
    * hou.Matrix3
    
    * hou.Matrix4
    
    
    """
    pass
    

def hscriptStringExpression(expression):
    """
    hou.hscriptStringExpression
    
    Evaluate an Hscript expression as a float.
    
    USAGE
    hscriptStringExpression(expression) -> string
    
    This function will force the return type to be a string. If the
    expression does not evaluate to a string, this function returns its
    string representation.
    
    Most of the time, you want to use hou.hscriptExpression over this
    function. See it for more examples.
    
    Raises hou.OperationFailed if the expression is invalid or generates an
    error occur during evaluation.
    
    > >>> hou.hscriptStringExpression("3")
    > '3'
    > >>> hou.hscriptStringExpression('"3"')
    > '3'
    > >>> hou.hscriptStringExpression("$F")
    > '1'
    > >>> hou.hscriptStringExpression('vector("[1, 2, 3]")')
    > '[1,2,3]'
    
    RELATED
    
    * hou.hscriptExpression
    
    * hou.hscriptFloatExpression
    
    * hou.hscriptVectorExpression
    
    * hou.hscriptMatrixExpression
    
    
    """
    pass
    

def hscriptVectorExpression(expression):
    """
    hou.hscriptVectorExpression
    
    Evaluate an Hscript expression as a vector.
    
    USAGE
    hscriptVectorExpression(expression) -> tuple of floats
    
    This function will force the return type to be an Hscript vector.
    Because Hscript vectors can be be of different lengths, the value is
    returned as a tuple of floats. If you know the vector is a particular
    length, you can construct a Vector2/Vector3/Vector4 out of the return
    value.
    
    Most of the time, you want to use hou.hscriptExpression over this
    function.
    
    > vector = hou.Vector3(hou.hscriptVectorExpression('vtorigin("/obj/geo1", "/obj/geo2")'))
    > print vector.length()
    
    Raises hou.OperationFailed if the expression is invalid or generates an
    error occur during evaluation.
    
    RELATED
    
    * hou.hscriptExpression
    
    * hou.hscriptFloatExpression
    
    * hou.hscriptStringExpression
    
    * hou.hscriptMatrixExpression
    
    * hou.Vector2
    
    * hou.Vector3
    
    * hou.Vector4
    
    
    """
    pass
    

class imageDepth(object):
    """
    hou.imageDepth
    
    Enumeration of image depths (data formats) for representing the pixels
    in an image plane.
    
    See hou.CopNode.depth.
    
    VALUES
    
    
    Int8
    Int16
    Int32
    Float16
    Float32
    
    
    """

def imageDepth_swigregister():
    """None"""
    pass
    

def imageResolution(image_file_name):
    """
    hou.imageResolution
    
    Return the resolution of an image in a file.
    
    USAGE
    imageResolution(image_file_name) -> tuple of int
    
    Returns the width and height of an image stored in a file.
    
    Another way to get the resolution of an image is to load it into a file
    cop and retrieve it. For example, this method could be approximately
    implemented as follows:
    
    > def imageResolution(image_file_name):
    >     file_cop = hou.node("/img/comp1").createNode("file")
    >     file_cop.setParm("filename1", image_file_name)
    >     resolution = (file_cop.xRes(), file_cop.yRes())
    >     file_cop.destroy()
    >     return resolution
    
    Note, however, that this method is faster than loading the image into
    Houdini and retrieving the resolution because it is much less disk
    intensive. It does not load the image data from disk, and instead only
    loads as much as necessary to retrieve the resolution.
    
    Raises hou.OperationFailed if the image file does not exist or if it's
    not an image file type supported by Houdini.
    
    The following example retrieves the resolution of the default.pic file
    that ships with Houdini.
    
    > >>> hou.imageResolution(hou.findFile("pic/default.pic"))
    > (512, 512)
    
    RELATED
    
    * hou.CopNode.xRes
    
    * hou.CopNode.yRes
    
    
    """
    pass
    

def incrementNumberedString(str):
    """
    hou.incrementNumberedString
    
    Increments the number in a string, or appends a number to the string.
    
    USAGE
    incrementNumberedString(str) -> str
    
    If the string ends with a number, that number is incremented, and the
    resulting new string is returned. If the string does not end with a
    number, a number is appended to the string. This is the algorithm used
    by Houdini to generate uniquely named child nodes inside a network.
    
    > >>> hou.incrementNumberedString('name1')
    > 'name2'
    > >>> hou.incrementNumberedString('name199')
    > 'name200'
    > >>> hou.incrementNumberedString('name')
    > 'name2'
    > >>> hou.incrementNumberedString('')
    > '2'
    
    """
    pass
    

def intFrame():
    """
    hou.intFrame
    
    Return the playbar's current frame, rounded to the nearest integer.
    
    USAGE
    intFrame() -> int
    
    Note that this function is equivalent to Hscript's $F variable. If you
    want Hscript's $FF variable, use hou.frame.
    
    RELATED
    
    * hou.frame
    
    * hou.setFrame
    
    * hou.time
    
    * hou.fps
    
    REPLACES
    
    * fcur
    
    
    """
    pass
    

def isApprentice(non-commercial):
    """
    hou.isApprentice
    
    Return whether the application is an apprentice (non-commercial)
    version.
    
    USAGE
    isApprentice() -> bool
    
    Return whether the hou module is using an Apprentice license. Note that
    this function returns True for both Apprentice and Apprentice HD.
    
    REPLACES
    
    * version
    
    RELATED
    
    * hou.licenseCategory
    
    * hou.applicationCompilationDate
    
    * hou.applicationName
    
    * hou.applicationVersion
    
    * hou.applicationVersionString
    
    
    """
    pass
    

def isUIAvailable():
    """
    hou.isUIAvailable
    
    Return whether or not the hou.ui module is available.
    
    USAGE
    isUIAvailable() -> bool
    
    The hou.ui module is not available in the command-line interpreter or in
    MPlay, and this function helps you to write scripts that will run in
    Houdini and command-line and/or MPlay.
    
    RELATED
    
    * hou.ui
    
    
    """
    pass
    

def item(path):
    """
    hou.item
    
    Given a path string, return a NetworkMovableItem object. Return None if
    the path does not refer to an item.
    
    USAGE
    item(path) -> hou.NetworkMovableItem or None
    
    If the path starts with a /, Houdini will look for an item with that
    exact path. Otherwise, the Houdini searches relative to the current
    path. See hou.pwd for more information about Houdini's current path. For
    each occurrence of .. in the path, Houdini will move up one item from
    the current location.
    
    This method is a more general form of the hou.node_ method, which will
    only return hou.Node objects. But some network item types
    (hou.SubnetIndirectInput and hou.NetworkDot) do not have names, and so
    will never be returned by this method.
    
    Raises hou.NotAvailable if you call it from MPlay.
    
    > >>> hou.item("/obj")
    > <hou.Node at /obj>
    > >>> hou.item("/obj").createNetworkBox()
    > <hou.NetworkBox at /obj/__netbox1>
    > >>> hou.item("/obj/__netbox1")
    > <hou.NetworkBox at /obj/__netbox1>
    > >>> hou.cd("/obj")
    > >>> hou.item("__netbox1")
    > <hou.NetworkBox at /obj/__netbox1>
    > >>> print hou.item("__netbox2")
    > None
    
    RELATED
    
    * hou.node_
    
    * hou.nodes
    
    * hou.items
    
    * hou.pwd
    
    * hou.parent
    
    * hou.root
    
    
    """
    pass
    

def itemBySessionId(item_type, session_id):
    """
    hou.itemBySessionId
    
    Given an item's session id and an item type, return a NetworkMovableItem
    object. Return None if the id does not correspond to a valid item.
    
    This function is equivalent to a series of if statements checking the
    item_type enum value, and calling the more specific session id functions
    such as hou.nodeBySessionId. It allows network items to be treated in a
    uniform manner by code that is expected to handle a variety of network
    item types.
    
    The item_type parameter should be one of the hou.networkItemType enum
    values, except hou.networkItemType.Connection, which doesn't support
    lookup using a single session id value.
    
    USAGE
    itemBySessionId(item_type, session_id) -> hou.NetworkMovableItem or
    None
    
    See hou.NetworkMovableItem.sessionId for more information.
    
    Raises hou.NotAvailable if you call it from MPlay.
    
    RELATED
    
    * hou.item
    
    * hou.networkBoxBySessionId
    
    * hou.networkDotBySessionId
    
    * hou.nodeBySessionId
    
    * hou.stickyNoteBySessionId
    
    * hou.subnetIndirectInputBySessionId
    
    * hou.NetworkMovableItem.sessionId
    
    
    """
    pass
    

def items(path_tuple):
    """
    hou.items
    
    Takes a sequence of node path strings and returns a tuple of
    NetworkMovableItem objects.
    
    USAGE
    item(path_tuple) -> tuple of hou.NetworkMovableItem or None
    
    This is like hou.items but takes multiple paths and returns multiple
    item objects. See hou.item for more information.
    
    > paths = ["/obj/geo1", "/obj/geo2", "/obj/geo3"]
    > items = hou.items(paths)
    
    This is the equivalent of:
    
    > items = [hou.item(path) for path in paths]
    
    Raises hou.NotAvailable if you call it from MPlay.
    
    RELATED
    
    * hou.node_
    
    * hou.nodes
    
    * hou.item
    
    * hou.pwd
    
    * hou.parent
    
    * hou.root
    
    
    """
    pass
    

def licenseCategory(Commercial, Apprentice, ApprenticeHD, etc.):
    """
    hou.licenseCategory
    
    Return the category of license (Commercial, Apprentice, ApprenticeHD,
    etc.) in use.
    
    USAGE
    licenseCategory() -> hou.licenseCategoryType enum value
    
    REPLACES
    
    * version
    
    RELATED
    
    * hou.licenseCategoryType
    
    * hou.applicationCompilationDate
    
    * hou.applicationName
    
    * hou.applicationVersion
    
    * hou.applicationVersionString
    
    * hou.isApprentice
    
    
    """
    pass
    

class licenseCategoryType(object):
    """
    hou.licenseCategoryType
    
    Enumeration of license category values.
    
    VALUES
    
    
    Commercial
    Education
    ApprenticeHD
    Apprentice
    
    
    """

def licenseCategoryType_swigregister():
    """None"""
    pass
    

def linear():
    """
    hou.linear
    
    Linearly interpolates between the left keyframe's outgoing value and the
    right keyframe's incoming value.
    
    USAGE
    linear() -> float
    
    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.
    
    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.
    
    RELATED
    
    * hou.bezier
    
    * hou.constant
    
    * hou.cubic
    
    * hou.cycle
    
    * hou.cyclet
    
    * hou.ease
    
    * hou.easein
    
    * hou.easeinp
    
    * hou.easeout
    
    * hou.easeoutp
    
    * hou.easep
    
    * hou.match
    
    * hou.matchin
    
    * hou.matchout
    
    * hou.qlinear
    
    * hou.quintic
    
    * hou.repeat
    
    * hou.repeatt
    
    * hou.spline
    
    * hou.vmatch
    
    * hou.vmatchin
    
    * hou.vmatchout @replaces
    
    * linear()
    
    
    """
    pass
    

def loadCPIODataFromString(name, value):
    """
    hou.loadCPIODataFromString
    
    Given a string containing data in CPIO data format, decode the data and
    return a sequence of (name, value) pairs representing the data.
    
    USAGE
    loadCPIODataFromString(data) -> tuple of (str, str)
    
    CPIO data format stores an ordered sequence of (name, value) pairs. The
    same name may occur multiple times. Is most commonly used to store hip
    files and contents sections inside assets. The other common file format
    used in Houdini is index file format.
    
    If the data is not in CPIO data format, this function returns an empty
    tuple.
    
    The inverse of this function is hou.saveCPIODataToString.
    
    RELATED
    
    * hou.saveCPIODataToString
    
    * hou.loadIndexDataFromString
    
    * hou.saveIndexDataToString
    
    
    """
    pass
    

def loadImageDataFromFile():
    """None"""
    pass
    

def loadIndexDataFromFile(file_path):
    """
    hou.loadIndexDataFromFile
    
    Given a file containing data in index data format, decode the data and
    return a dictionary representing the data.
    
    USAGE
    loadIndexDataFromFile(file_path) -> dict
    
    This function could be implemented as follows:
    
    > def loadIndexDataFromFile(file_path):
    >     hou.loadIndexDataFromString(hou.readFile(file_path))
    
    See hou.loadIndexDataFromString for more details.
    
    RELATED
    
    * hou.saveIndexDataToFile
    
    * hou.loadIndexDataFromString
    
    * hou.saveIndexDataToString
    
    
    """
    pass
    

def loadIndexDataFromString(data):
    """
    hou.loadIndexDataFromString
    
    Given a string containing data in index data format, decode the data and
    return a dictionary representing the data.
    
    USAGE
    loadIndexDataFromString(data) -> dict
    
    Index data format stores an unordered mapping of (key, value) pairs. Is
    used to store otl files and asset definition sections, preset files,
    icon archives, and other files in Houdini. The other common file format
    used in Houdini is CPIO.
    
    If the data is not in index data format, this function returns an empty
    dictionary.
    
    The inverse of this function is hou.saveIndexDataToString.
    
    RELATED
    
    * hou.saveIndexDataToString
    
    * hou.loadIndexDataFromFile
    
    * hou.saveIndexDataToFile
    
    * hou.loadCPIODataFromString
    
    * hou.saveCPIODataToString
    
    
    """
    pass
    

def lopNodeTypeCategory(lop):
    """
    hou.lopNodeTypeCategory
    
    Return the NodeTypeCategory instance for Houdini lighting (lop) nodes.
    
    USAGE
    lopNodeTypeCategory() -> NodeTypeCategory
    
    
    """
    pass
    

def lvar(name):
    """
    hou.lvar
    
    Return the value of a node's local variable. Call this function from
    expressions inside node parameters.
    
    USAGE
    lvar(name) -> float or string
    
    Many node algorithms involve iterating over a series of points (or
    primitives or vertices, but we'll use points for the examples). These
    nodes evaluate their parameters for each point, setting a variable that
    you can access from an expression in that parameter to a value specific
    to that point. For example, the TX variable is set to evaluate to the X
    value of the position of the current point. These variables are called
    local variables because they are local to the expressions inside
    parameters in the node.
    
    In the Hscript expression language, you use $ to evaluate local
    variables, just like how you evaluate global variables. In Python, you
    use the lvar function. So, the Python equivalent of $TX is lvar("TX").
    
    
    TIP
    Inside a parameter expression you can drop the hou. prefix from the
    call to lvar, since Houdini implicitly runs from hou import * when
    it evaluates expressions.
    
    If you call this function from outside a parameter expression it will
    raise hou.NotAvailable. If you call it with an invalid variable name, it
    will raise hou.OperationFailed. Note that you cannot use this function
    to evaluate Houdini global variables; instead use hou.expandString.
    
    Note that hou.SopNode.curPoint and similar methods on the hou.SopNode
    and hou.PopNode classes return the current point that the node is
    iterating over. Using the point, you can evaluate attributes, etc, to
    perform the equivalent of a local variable. You can also access
    information that may not be accessible through local variables.
    
    RELATED
    
    * hou.SopNode.curPoint
    
    * hou.SopNode.curPoint2
    
    * hou.SopNode.curPrim
    
    * hou.SopNode.curPrim2
    
    * hou.SopNode.curVertex
    
    * hou.SopNode.curVertex2
    
    * hou.PopNode.curPoint
    
    * hou.expandString
    
    
    """
    pass
    

def managerNodeTypeCategory():
    """
    hou.managerNodeTypeCategory
    
    Return the NodeTypeCategory instance for Houdini manager nodes. The
    manager nodes are /obj, /out, /part, /ch, /shop, /img, and /vex.
    
    USAGE
    managerNodeTypeCategory() -> NodeTypeCategory
    
    Note that some container node types, like the shop network node type,
    are called managers in Houdini. The node type category for an instance
    of those nodes will be the same as other nodes in that same network. For
    example, a shop network in objects will be in the objects node type
    category, while a shop network in a sop network will be in the geometry
    node type category.
    
    
    """
    pass
    

class markerVisibility(object):
    """
    hou.markerVisibility
    
    Enum of visibility options for marker visualizers.
    
    VALUES
    
    
    hou.markerVisibility.Always
    Display the markers without restriction.
    
    hou.markerVisibility.Selected
    Only display the marker if its component is selected.
    
    hou.markerVisibility.AroundPointer
    Display markers around the mouse pointer in 3D space.
    
    hou.markerVisibility.UnderPointer
    Display markers under the mouse pointer in screen space.
    
    
    """

def markerVisibility_swigregister():
    """None"""
    pass
    

def match():
    """
    hou.match
    
    Creates a smooth curve between the left keyframe's incoming slope and
    the right keyframe's outgoing slope.
    
    USAGE
    match() -> float
    
    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.
    
    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.
    
    RELATED
    
    * hou.bezier
    
    * hou.constant
    
    * hou.cubic
    
    * hou.cycle
    
    * hou.cyclet
    
    * hou.ease
    
    * hou.easein
    
    * hou.easeinp
    
    * hou.easeout
    
    * hou.easeoutp
    
    * hou.easep
    
    * hou.linear
    
    * hou.matchin
    
    * hou.matchout
    
    * hou.qlinear
    
    * hou.quintic
    
    * hou.repeat
    
    * hou.repeatt
    
    * hou.spline
    
    * hou.vmatch
    
    * hou.vmatchin
    
    * hou.vmatchout @replaces
    
    * match()
    
    
    """
    pass
    

def matchin():
    """
    hou.matchin
    
    Creates a straight line from the left keyframe's incoming value,
    matching the left keyframe's incoming slope.
    
    USAGE
    matchin() -> float
    
    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.
    
    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.
    
    RELATED
    
    * hou.bezier
    
    * hou.constant
    
    * hou.cubic
    
    * hou.cycle
    
    * hou.cyclet
    
    * hou.ease
    
    * hou.easein
    
    * hou.easeinp
    
    * hou.easeout
    
    * hou.easeoutp
    
    * hou.easep
    
    * hou.linear
    
    * hou.match
    
    * hou.matchout
    
    * hou.qlinear
    
    * hou.quintic
    
    * hou.repeat
    
    * hou.repeatt
    
    * hou.spline
    
    * hou.vmatch
    
    * hou.vmatchin
    
    * hou.vmatchout
    
    REPLACES
    
    * matchin()
    
    
    """
    pass
    

def matchout():
    """
    hou.matchout
    
    Creates a straight line from the right keyframe's outgoing value,
    matching the right keyframe's outgoing slope.
    
    USAGE
    matchout() -> float
    
    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.
    
    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.
    
    RELATED
    
    * hou.bezier
    
    * hou.constant
    
    * hou.cubic
    
    * hou.cycle
    
    * hou.cyclet
    
    * hou.ease
    
    * hou.easein
    
    * hou.easeinp
    
    * hou.easeout
    
    * hou.easeoutp
    
    * hou.easep
    
    * hou.linear
    
    * hou.match
    
    * hou.matchin
    
    * hou.qlinear
    
    * hou.quintic
    
    * hou.repeat
    
    * hou.repeatt
    
    * hou.spline
    
    * hou.vmatch
    
    * hou.vmatchin
    
    * hou.vmatchout
    
    REPLACES
    
    * matchout()
    
    
    """
    pass
    

def maxThreads():
    """
    hou.maxThreads
    
    Returns the number of threads used for processing.
    
    USAGE
    maxThreads() -> int
    
    When Houdini/hython is started, it uses all available processors on the
    machine for multi-threaded processing, unless overridden by the -j
    command line option or the hou.setMaxThreads function.
    
    This function returns that maximum number of threads that Houdini/hython
    will use.
    
    RELATED
    
    * hou.setMaxThreads
    
    
    """
    pass
    

class menuType(object):
    """
    hou.menuType
    
    Enumeration of parameter menu types.
    
    See also hou.MenuParmTemplate and hou.StringParmTemplate.
    
    VALUES
    
    
    Normal
    A standard menu that displays the currently selected menu item.
    
    Mini
    A condensed menu that only displays a dropdown arrow. Houdini
    lets you choose a menu entry when you click on this arrow.
    
    ControlNextParameter
    A standard menu that displays the currently selected menu item.
    This menu always joins horizontally to the next parameter and is
    displayed without a label. However unlike simply turning off the
    label and joining to the next parameter, the layout of the next
    parameter is such that a series of parameters preceded by menus
    of this type will align in a much more appealing way.
    
    StringReplace
    A menu that also displays an input field. Selecting an entry
    from this menu will replace the contents of the field with the
    menu item. This type of menu only has meaning for string
    parameters.
    
    StringToggle
    A menu that also displays an input field. Selecting an entry
    from this menu will add the menu item to the field if it was not
    already there, and will remove it from the field it if was. This
    type of menu only has meaning for string parameters.
    
    
    """

def menuType_swigregister():
    """None"""
    pass
    

def moveNodesTo(nodes, destination_node):
    """
    hou.moveNodesTo
    
    Move all given nodes to a new place in node hierarchy.
    
    USAGE
    moveNodesTo(nodes, destination_node) -> tuple of Nodes
    
    The nodes to be moved should be a sequence of hou.Node objects. The
    destination node will be the parent of new copied nodes. The type of all
    source nodes should match the destination node child type.
    
    This function returns a tuple of hou.Node objects corresponding to the
    nodes at their new locations. If you attempt to access the original
    hou.Node objects in the sequence you passed into this function, you will
    receive hou.ObjectWasDeleted exceptions.
    
    For every moved node, if a node with the same name already exists at the
    destination, the node will be renamed to a unique name.
    
    This function will raise a hou.OperationFailed exception if any of the
    nodes to be moved are of invalid type, the destination node cannot be
    copied into, or source node type does not match the destination node's
    child type.
    
    This function will raise hou.ObjectWasDeleted if any of source nodes or
    the destination node no longer exist in Houdini.
    
    All of the above issues with source and destination nodes will be
    reported before moving starts to avoid a partial move.
    
    After the function finishes execution, all the moved nodes by it will be
    selected.
    
    
    """
    pass
    

def networkBoxBySessionId(session_id):
    """
    hou.networkBoxBySessionId
    
    Given a network box's session id, return a NetworkBox object. Return
    None if the id does not correspond to a valid network box.
    
    USAGE
    networkBoxBySessionId(session_id) -> hou.NetworkBox or None
    
    See hou.NetworkBox.sessionId for more information.
    
    Raises hou.NotAvailable if you call it from MPlay.
    
    RELATED
    
    * hou.item
    
    * hou.NetworkBox.sessionId
    
    
    """
    pass
    

def networkDotBySessionId(e.g., if, the, dot, was, deleted):
    """
    hou.networkDotBySessionId
    
    Given a dot's session id, return a NetworkDot object. Return None if the
    id does not correspond to a valid dot (e.g. if the dot was deleted).
    
    USAGE
    networkDotBySessionId(session_id) -> hou.NetworkDot or None
    
    See hou.NetworkDot.sessionId for more information.
    
    Raises hou.NotAvailable if you call it from MPlay.
    
    RELATED
    
    * hou.item
    
    * hou.NetworkDot.sessionId
    
    
    """
    pass
    

class networkItemType(object):
    """
    hou.networkItemType
    
    <Summary>
    
    <Description>
    
    VALUES
    
    
    Connection
    NetworkBox
    NetworkDot
    Node
    StickyNote
    SubnetIndirectInput
    
    
    """

def networkItemType_swigregister():
    """None"""
    pass
    

class instancemethod(object):
    """instancemethod(function, instance, class)
    
    Create an instance method object."""

def node(path):
    """
    hou.node
    
    Given a path string, return a Node object. Return None if the path does
    not refer to a node.
    
    USAGE
    node(path) -> hou.Node or None
    
    If the path starts with a /, Houdini will look for a node with that
    exact path. Otherwise, the Houdini searches relative to the current
    path. See hou.pwd for more information about Houdini's current path. For
    each occurrence of .. in the path, Houdini will move up one node from
    the current location.
    
    Raises hou.NotAvailable if you call it from MPlay.
    
    Be careful not to confuse this function with the class hou.Node.
    
    > >>> hou.node("/obj")
    > <hou.Node at /obj>
    > >>> hou.node("/obj").createNode("geo")
    > <hou.ObjNode of type geo at /obj/geo1>
    > >>> hou.node("/obj").createNode("geo")
    > <hou.ObjNode of type geo at /obj/geo2>
    > >>> hou.node("/obj/geo1")
    > <hou.ObjNode of type geo at /obj/geo1>
    > >>> hou.cd("/obj")
    > >>> hou.node("geo1")
    > <hou.ObjNode of type geo at /obj/geo1>
    > >>> hou.cd("/obj/geo2")
    > >>> hou.node("../geo1")
    > <hou.ObjNode of type geo at /obj/geo1>
    > >>> print hou.node("../geo3")
    > None
    
    RELATED
    
    * hou.item
    
    * hou.items
    
    * hou.nodes
    
    * hou.pwd
    
    * hou.parent
    
    * hou.root
    
    REPLACES
    
    * opfind
    
    * ch()
    
    * chs()
    
    * chsop()
    
    * opexist()
    
    
    """
    pass
    

def nodeBundle(name):
    """
    hou.nodeBundle
    
    Given a node bundle name, return the corresponding NodeBundle object, or
    None if there is not one with that name.
    
    USAGE
    nodeBundle(name) -> hou.NodeBundle or None
    
    See hou.NodeBundle for more information.
    
    REPLACES
    
    * opbls
    
    * opglob
    
    
    """
    pass
    

def nodeBundles():
    """
    hou.nodeBundles
    
    Return a tuple containing all the node bundles in the current session.
    
    USAGE
    nodeBundles() -> tuple of hou.NodeBundle
    
    See hou.NodeBundle for more information.
    
    REPLACES
    
    * opbls
    
    
    """
    pass
    

def nodeBySessionId(e.g., if, the, node, was, deleted):
    """
    hou.nodeBySessionId
    
    Given a node's session id, return a Node object. Return None if the id
    does not correspond to a valid node (e.g. if the node was deleted).
    
    USAGE
    nodeBySessionId(session_id) -> hou.Node or None
    
    See hou.Node.sessionId for more information.
    
    Raises hou.NotAvailable if you call it from MPlay.
    
    REPLACES
    
    * opfind
    
    * ch()
    
    * chs()
    
    * chsop()
    
    * chsoplist()
    
    * opexist()
    
    RELATED
    
    * hou.item
    
    * hou.node_
    
    * hou.Node.sessionId
    
    
    """
    pass
    

def nodeConnectionBySessionId(e.g., if, the, node, was, deleted):
    """
    hou.nodeConnectionBySessionId
    
    Given a node's session id and an input index, return a NodeConnection
    object. Return None if the id does not correspond to a valid node (e.g.
    if the node was deleted), or the specified input index is not connected.
    
    USAGE
    nodeConnectionBySessionId(session_id, input_index) ->
    hou.NodeConnection or None
    
    Raises hou.NotAvailable if you call it from MPlay.
    
    RELATED
    
    * hou.nodeBySessionId
    
    * hou.Node.sessionId
    
    
    """
    pass
    

class nodeEventType(object):
    """
    hou.nodeEventType
    
    Enumeration of types of events that can happen to nodes.
    
    Node event callbacks let you run code when events occur on an individual
    node instance. See hou.Node.addEventCallback.
    
    For all event types, the callback is called with a node keyword argument
    (containing a hou.Node reference to the node) and an event_type argument
    (containing one of the values below, indicating the type of event that
    occurred).
    
    Some event types pass additional keyword arguments to the callback
    function, as noted below.
    
    VALUES
    
    
    BeingDeleted
    Runs before a node is deleted. You cannot cancel the deletion.
    
    NameChanged
    Runs after a node was renamed. You can get the new name using
    hou.Node.name.
    
    FlagChanged
    Runs after one of the node's flags was turned on or off.
    
    AppearanceChanged
    Runs after the an event occurs that changes what the node looks
    like in the network editor. This includes but is not limited to:
    
    * Color or shape changed
    
    * Error triggered or cleared
    
    * Selected or deselected
    
    * Asset locked or unlocked
    
    *Extra keyword argument*: change_type (hou.appearanceChangeType)
    
    PositionChanged
    Runs after the node is moved in the network editor. You can get
    the node's new position using hou.Node.position.
    
    InputRewired
    Runs after one of the node's inputs are connected or
    disconnected.
    
    *Extra keyword argument*: input_index (int) -- the input number
    (starting at 0) that changed.
    
    InputDataChanged
    The data on changed on a node this node depends on. For example,
    if this node references another node in an expression. Houdini
    _does not_ trigger this event when a parameter changes.
    
    ParmTupleChanged
    Runs after a parameter value changes. You can get the new value
    using hou.ParmTuple.eval.
    
    *Extra keyword argument*: parm_tuple (hou.ParmTuple).
    
    
    NOTE
    If many/all parameters on the node change at the same time,
    instead of calling the handler for each one, Houdini will
    call the handler once with a parm_tuple argument of None.
    Your callback code should be handle this possibility.
    
    ChildCreated
    For a subnet node (for example, a Geometry object), runs after a
    new node is created inside.
    
    *Extra keyword argument*: child_node (hou.Node)
    
    ChildDeleted
    For a subnet node (for example, a Geometry object), runs
    _before_ a node is deleted inside. You cannot cancel the
    deletion.
    
    *Extra keyword argument*: child_node (hou.Node)
    
    ChildSwitched
    For a subnet node (for example, a Geometry object), runs after
    the current node, display flag, or render flag changes inside
    (meaning the 3D view will change).
    
    *Extra keyword argument*: child_node (hou.Node) -- the newly
    selected child node.
    
    ChildSelectionChanged
    For a subnet node (for example, a Geometry object), runs after
    the selection changes inside. You can get the new selection with
    hou.Node.selectedChildren.
    
    SpareParmTemplatesChanged
    Runs after a spare parameter is modified on, added to, or
    removed from the node.
    
    
    NOTE
    If the node has spare parameters, this event triggers when
    _any_ parameter is modified, not just a spare parameter.
    
    SelectionChanged
    Runs after the selection associated with a node changes. This
    only applies to the geometry selected on a SOP node, or the
    scene graph primitives selected in a LOP Network.
    
    CustomDataChanged
    Runs after some custom data on a node is changed. The custom
    data available, and the methods for accessing it, will depend on
    the hou.NodeType of the node that is changing. One example of
    custom node data is the viewport scene overrides that can be
    applied to a LOP Network.
    
    
    """

def nodeEventType_swigregister():
    """None"""
    pass
    

class nodeFlag(object):
    """
    hou.nodeFlag
    
    Enumeration of the different node flags.
    
    VALUES
    
    
    Audio
    Bypass
    ColorDefault
    Compress
    Current
    Debug
    Display
    DisplayComment
    DisplayDescriptiveName
    Export
    Expose
    Footprint
    Highlight
    InOutDetailLow
    InOutDetailMedium
    InOutDetailHigh
    Material
    Lock
    SoftLock
    Origin
    OutputForDisplay
    Pick
    Render
    Selectable
    Template
    Unload
    Visible
    XRay
    
    
    """

def nodeFlag_swigregister():
    """None"""
    pass
    

def nodeType():
    """
    hou.nodeType
    
    Given a node type category object and a name, or possibly just a node
    type name that includes the category, return the corresponding NodeType
    object. The exact name is assumed so node type aliases are not
    evaluated. To check aliases use hou.preferredNodeType() instead. Return
    None if there is no such type with that name.
    
    USAGE
    nodeType(category, name) -> NodeType or None
    
    
    category
    A hou.NodeTypeCategory object (_not_ a string). You can use the
    hou.nodeTypeCategories() function to get a dict of category name
    strings to NodeTypeCategory objects. You can also use the helper
    functions hou.sopNodeTypeCategory, hou.objNodeTypeCategory, etc.
    
    Note that this parameter is optional. If omitted, the name parameter
    must contain the node type category.
    
    name
    The internal name of a node type. To get the internal name of any
    node type in Houdini, right-click a node of that type and choose
    Type properties. The internal name is listed at the top of the type
    properties window beside *Operator type*. For example, the internal
    name of the Geometry object is geo.
    
    If the category parameter is omitted, the name must include the
    category name. For example, you can pass Object/geo to get the
    Geometry object's node type.
    
    EXAMPLES
    
    > # The following four ways of looking up the copy SOP's node type are equivalent:
    > >>> hou.nodeType("Sop/copy")
    > <hou.SopNodeType for Sop copy>
    >
    > >>> hou.nodeType(hou.sopNodeTypeCategory(), "copy")
    > <hou.SopNodeType for Sop copy>
    >
    > >>> hou.sopNodeTypeCategory().nodeTypes()["copy"]
    > <hou.SopNodeType for Sop copy>
    >
    > >>> hou.nodeType(hou.nodeTypeCategories()["Sop"], "copy")
    > <hou.SopNodeType for Sop copy>
    
    REPLACES
    
    * optype
    
    * optype()
    
    * optypeinfo()
    
    RELATED
    
    * hou.NodeType
    
    * hou.NodeTypeCategory
    
    * hou.NodeTypeCategory.nodeTypes
    
    * hou.nodeTypeCategories
    
    * hou.preferredNodeType
    
    
    """
    pass
    

def nodeTypeCategories(e.g., "Object", "Sop"):
    """
    hou.nodeTypeCategories
    
    Return a dictionary where the keys are the category names (e.g.
    "Object", "Sop") and the values are hou.NodeTypeCategory objects.
    
    USAGE
    nodeTypeCategories() -> dict of str to hou.NodeTypeCategory
    
    
    """
    pass
    

class nodeTypeFilter(object):
    """
    hou.nodeTypeFilter
    
    Enumeration of available node type filters.
    
    These filters are used by node bundles to limit the nodes in the bundle
    based on type.
    
    VALUES
    
    
    NoFilter
    Any node
    
    Sop
    Any SOP
    
    Dop
    Any DOP
    
    Chop
    Any CHOP
    
    Chopnet
    Any CHOP Network
    
    Cop
    Any COP
    
    Copnet
    Any COP Network
    
    Vop
    Any VOP
    
    Vopnet
    Any VOP Network
    
    Rop
    Any ROP
    
    Lop
    Any LOP
    
    Shop
    Any SHOP
    
    Obj
    Any Object
    
    ObjBone
    Object: Bone Only
    
    ObjCamera
    Object: Camera Only
    
    ObjFog
    Object: Fog Only
    
    ObjGeometry
    Object: Geometry Only
    
    ObjGeometryOrFog
    Object: Geometry and Fog Only
    
    ObjLight
    Object: Light Only
    
    ObjMuscle
    Object: Muscle Only
    
    ObjSubnet
    Object: Muscle Only
    
    ShopAtmosphere
    Shop: Atmosphere Only
    
    ShopCVEX
    Shop: CVEX Only
    
    ShopDisplacement
    Shop: Displacement Only
    
    ShopImage3D
    Shop: Image3D Only
    
    ShopInterior
    Shop: Interior Only
    
    ShopLight
    Shop: Light Only
    
    ShopLightShadow
    Shop: Light Shadow Only
    
    ShopShopMaterial
    Shop: Material Only
    
    ShopPhoton
    Shop: Photon Only
    
    ShopProperties
    Shop: Properties Only
    
    ShopSurface
    Shop: Surface Only
    
    
    """

def nodeTypeFilter_swigregister():
    """None"""
    pass
    

class nodeTypeSource(object):
    """
    hou.nodeTypeSource
    
    Enumeration of node type sources.
    
    VALUES
    
    
    Internal
    CompiledCode
    VexCode
    RslCode
    Subnet
    
    
    """

def nodeTypeSource_swigregister():
    """None"""
    pass
    

def nodes(path_tuple):
    """
    hou.nodes
    
    Takes a sequence of node path strings and returns a tuple of Node
    objects.
    
    USAGE
    nodes(path_tuple) -> tuple of hou.Node
    
    This is like hou.node_ but takes multiple paths and returns multiple
    node objects. See hou.node_ for more information.
    
    > paths = ["/obj/geo1", "/obj/geo2", "/obj/geo3"]
    > nodes = hou.nodes(paths)
    
    This is the equivalent of:
    
    > nodes = [hou.node(path) for path in paths]
    
    RELATED
    
    * hou.item
    
    * hou.items
    
    * hou.node
    
    * hou.pwd
    
    * hou.parent
    
    * hou.root
    
    REPLACES
    
    * opfind
    
    * ch()
    
    * chs()
    
    * chsop()
    
    * opexist()
    
    
    """
    pass
    

class numericData(object):
    """None"""

def numericData_swigregister():
    """None"""
    pass
    

def objNodeTypeCategory("/obj/model"):
    """
    hou.objNodeTypeCategory
    
    Return the NodeTypeCategory instance for Houdini object nodes. For
    example, if /obj/model is an object then
    hou.node("/obj/model").type().category() is
    hou.objectNodeTypeCategory().
    
    USAGE
    objNodeTypeCategory() -> NodeTypeCategory
    
    
    """
    pass
    

def orboltURLHandler():
    """None"""
    pass
    

class orientUpAxis(object):
    """
    hou.orientUpAxis
    
    Enumeration of global orientation mode.
    
    See hou.ui.orientationUpAxis for more information.
    
    VALUES
    
    
    Y
    Z
    
    
    """

def orientUpAxis_swigregister():
    """None"""
    pass
    

class paneLinkType(object):
    """
    hou.paneLinkType
    
    Enumeration of possible pane link values.
    
    VALUES
    
    
    Pinned
    Group1
    Group2
    Group3
    Group4
    Group5
    Group6
    Group7
    Group8
    FollowSelection
    
    
    """

def paneLinkType_swigregister():
    """None"""
    pass
    

class paneTabType(object):
    """
    hou.paneTabType
    
    Enumeration of pane tab types.
    
    VALUES
    
    
    SceneViewer
    ChannelViewer
    CompositorViewer
    OutputViewer
    MaterialPalette
    IPRViewer
    NetworkEditor
    Parm
    DetailsView
    ChannelEditor
    ChannelList
    Textport
    HandleList
    BundleList
    TakeList
    TreeView
    HelpBrowser
    PythonPanel
    ParmSpreadsheet
    LightLinker
    AssetBrowser
    
    
    """

def paneTabType_swigregister():
    """None"""
    pass
    

def parent():
    """
    hou.parent
    
    Return the parent of the current node.
    
    USAGE
    parent() -> hou.Node or None
    
    This function is a shortcut for writing hou.node(".."). It returns the
    parent of the current node (i.e. the node returned by hou.pwd).
    
    This function will raise hou.NotAvailable if you call it from MPlay.
    
    RELATED
    
    * hou.node_
    
    
    """
    pass
    

def parm(path):
    """
    hou.parm
    
    Given a path string, return a Parm object. Return None if the path does
    not refer to a parameter.
    
    USAGE
    parm(path) -> hou.Parm or None
    
    If the path starts with a /, Houdini will look for a parameter with that
    exact path. Otherwise, the Houdini searches relative to the current node
    path. For each occurrence of .. in the path, Houdini will move up one
    node from the current node location.
    
    > >>> node = hou.node("/obj").createNode("geo")
    > >>> node.path()
    > '/obj/geo1'
    > >>> hou.parmTuple("/obj/geo1/t")
    > <hou.ParmTuple t in /obj/geo1>
    > >>> hou.parmTuple("/obj/geo1/t")[0]
    > <hou.Parm tx in /obj/geo1>
    > >>> hou.parm("/obj/geo1/tx")
    > <hou.Parm tx in /obj/geo1>
    > >>> hou.setPwd(node)
    > >>> hou.parm("t")
    > <hou.Parm tx in /obj/geo1>
    
    Raises hou.NotAvailable if you call it from MPlay.
    
    RELATED
    
    * hou.Parm
    
    * hou.evalParm
    
    * hou.parmTuple_
    
    REPLACES
    
    * ch()
    
    * chs()
    
    * chexist()
    
    
    """
    pass
    

class parmBakeChop(object):
    """
    hou.parmBakeChop
    
    Enumeration of Bake Chop modes.
    
    See hou.Parm.keyframesRefit.
    
    VALUES
    
    
    Off
    KeepExportFlag
    DisableExportFlag
    CreateDeleteChop
    
    
    """

def parmBakeChop_swigregister():
    """None"""
    pass
    

def parmClipboardContents():
    """
    hou.parmClipboardContents
    
    Returns the contents of the parameter clipboard as a tuple of copied
    parameter dictionaries.
    
    USAGE
    parmClipboardContents() -> tuple of dictionaries
    
    Returns a tuple of dictionaries, one per copied hou.Parm. Each
    dictionary has the following keys.
    
    
    path
    The path of hou.Parm parameter when it was copied.
    
    value
    The evaluated value of the parameter when it was copied as a string.
    
    expression
    The expression of the parameter when it was copied as a string.
    
    expressionLanguage
    The expression language of the parameter when it was copied. This is
    a string. To convert to a hou.exprLanguage object, use
    getattr(hou.exprLanguage, expr_language_str).
    
    RELATED
    
    * hou.Parm.copyToParmClipboard
    
    * hou.ParmTuple.copyToParmClipboard
    
    
    """
    pass
    

class parmCondType(object):
    """
    hou.parmCondType
    
    Enumeration of available parameter conditional types.
    
    VALUES
    
    
    DisableWhen
    HideWhen
    NoCookWhen
    
    
    """

def parmCondType_swigregister():
    """None"""
    pass
    

class parmData(object):
    """
    hou.parmData
    
    Enumeration of parameter data types.
    
    VALUES
    
    
    Int
    Float
    String
    Ramp
    
    
    """

def parmData_swigregister():
    """None"""
    pass
    

class parmExtrapolate(object):
    """
    hou.parmExtrapolate
    
    Enumeration of Extrapolation methods when evaluating value outside the
    keyframe range.
    
    VALUES
    
    
    Default
    Hold
    Cycle
    Extend
    Slope
    CycleOffset
    Oscillate
    
    
    """

def parmExtrapolate_swigregister():
    """None"""
    pass
    

class parmLook(object):
    """
    hou.parmLook
    
    Enumeration of available looks for a parameter
    
    These looks are used by hou.ParmTemplate objects and control the user
    interface of the parameter in parameter editors.
    
    VALUES
    
    
    Regular
    The default parameter look.
    
    Logarithmic
    The parameter displays a slider that changes the value on a
    logarithmic scale.
    
    Angle
    The parameter has an arc control to enter an angle.
    
    If you use this look, set your parameter's naming scheme to
    hou.parmNamingScheme.Base1.
    
    Vector
    The parameter has a handle beside the label to edit the vector
    direction.
    
    If you use this look, set your parameter's naming scheme to
    hou.parmNamingScheme.XYZW.
    
    ColorSquare
    The parameter has a square button beside the label to display
    the current color. You can click on the square to edit the
    color.
    
    If you use this look, set your parameter's naming scheme to
    hou.parmNamingScheme.RGBA.
    
    HueCircle
    The parameter has a hue circle with a pie-shaped region, like
    the keying nodes in COPs have.
    
    CRGBAPlaneChooser
    The parameter has an RGBA mask, with buttons to toggle the red,
    green, blue, and alpha planes.
    
    
    """

def parmLook_swigregister():
    """None"""
    pass
    

class parmNamingScheme(object):
    """
    hou.parmNamingScheme
    
    Enumeration of available naming schemes for a parameter.
    
    These naming schemes are stored inside hou.ParmTemplate objects and
    determine the names of hou.Parm objects inside hou.ParmTuple objects.
    
    The number of components in the parm template determines the number of
    parms inside the parm tuple. If this number is 1, the parm name is the
    same as the parm tuple name. If the naming scheme is Base1, the number
    of components may be more than 4. Otherwise, the component may have from
    2 components up to the maximum number allowed by the naming scheme.
    
    The following restrictions exist on naming schemes:
    
    * You cannot use the following naming schemes when editing the
    parameter interface on a node or a digital asset: MinMax, MaxMin,
    StartEnd, BeginEnd, XYWH. However, some built-in node types use
    parameters with these naming schemes, so asking these node types for
    their parm templates may return ones using these naming schemes.
    
    * String and toggle parameters only support the Base1 naming scheme.
    
    * Parameters with the hou.parmLook.Vector look must use the XYZW
    naming scheme.
    
    * Parameters with the hou.parmLook.Angle look must use the Base1
    naming scheme.
    
    * Parameters with the hou.parmLook.ColorSquare look must use an RGBA
    naming scheme.
    
    The example names below are for a parm template named "foo":
    
    VALUES
    
    
    Base1
    "foo1", "foo2", "foo3", ...
    
    XYZW
    "foox", "fooy", "fooz", "foow"
    
    XYWH
    "foox", "fooy", "foow", "fooh"
    
    UVW
    "foou", "foov", "foow"
    
    RGBA
    "foor", "foog", "foob", "fooa"
    
    MinMax
    "foomin", "foomax"
    
    MaxMin
    "foomax", "foomin"
    
    StartEnd
    "foostart", "fooend"
    
    BeginEnd
    "foobegin", "fooend"
    
    
    """

def parmNamingScheme_swigregister():
    """None"""
    pass
    

class parmTemplateType(object):
    """
    hou.parmTemplateType
    
    Enumeration of parameter template types.
    
    VALUES
    
    
    Int
    Float
    String
    Toggle
    Menu
    Button
    FolderSet
    Separator
    Label
    Ramp
    
    
    """

def parmTemplateType_swigregister():
    """None"""
    pass
    

def parmTuple(path):
    """
    hou.parmTuple
    
    Given a path string, return a ParmTuple object. Return None if the path
    does not refer to a parameter tuple.
    
    USAGE
    parmTuple(path) -> hou.ParmTuple or None
    
    If the path starts with a /, Houdini will look for a parameter tuple
    with that exact path. Otherwise, the Houdini searches relative to the
    current node path. For each occurrence of .. in the path, Houdini will
    move up one node from the current node location.
    
    When a parameter is evaluating, hou.pwd returns the node containing that
    parameter, so hou.parmTuple() can be used inside expressions to perform
    relative parameter references.
    
    > >>> node = hou.node("/obj").createNode("geo")
    > >>> node.path()
    > '/obj/geo1'
    > >>> hou.parmTuple("/obj/geo1/t")
    > <hou.ParmTuple t in /obj/geo1>
    > >>> hou.setPwd(node)
    > >>> hou.parmTuple("tx")
    > <hou.ParmTuple t in /obj/geo1>
    
    Raises hou.NotAvailable if you call it from MPlay.
    
    RELATED
    
    * hou.ParmTuple
    
    * hou.evalParmTuple
    
    * hou.parm_
    
    REPLACES
    
    * ch()
    
    * chexist()
    
    * chramp()
    
    * chs()
    
    
    """
    pass
    

def pasteNodesFromClipboard(destination_node):
    """
    hou.pasteNodesFromClipboard
    
    Paste previously copied nodes to a given network.
    
    USAGE
    pasteNodesFromClipboard(destination_node)
    
    This function pastes nodes from clipboard into the destination network.
    
    RELATED
    
    * hou.copyNodesToClipboard
    
    REPLACES
    
    * oppaste
    
    
    """
    pass
    

def patternMatch(pattern_string, input_string, ignore_case, =, False, path_match, =, False):
    """
    hou.patternMatch
    
    Matches a pattern in a string.
    
    USAGE
    patternMatch(pattern_string, input_string, ignore_case = False,
    path_match = False) -> int
    
    This function is case-sensitive. Set ignore_case to True for case-
    insensitive pattern matching.
    
    This function does not treat path separator characters specially. Set
    path_match to True for path-aware matching, where the multi-level
    wildcard (**) is required to cover multiple path components.
    
    Returns 1 if any patterns in the pattern string matches the input
    string, or 0 if no patterns match.
    
    In order to match, a pattern must match the input string from beginning
    to end. Use wildcards (*) to match substrings, e.g.
    
    > >>> hou.patternMatch("bar", "foobarbaz")
    > 0
    > >>> hou.patternMatch("*bar*", "foobarbaz")
    > 1
    
    pattern is a space-separated list of one or more patterns. This can
    cause unintuitive behavior of this function. For example:
    
    > >>> hou.patternMatch("foo bar", "foo bar")
    > 0
    
    ...will return 0, because the first argument consists of two patterns,
    foo and bar, and neither of those patterns match foo bar (since the
    pattern must match from beginning to end).
    
    Similarly,
    
    > >>> hou.patternMatch("foo bar", "foo")
    > 1
    
    ...will return 1, because the string matches the first of the two
    arguments in the pattern (foo and bar).
    
    > >>> hou.patternMatch("/foo/*", "/foo/bar/blah", path_match = True)
    > 0
    
    ...will return 0, because the wildcard only matches against the first
    path component (/bar), leaving the last path component (/blah)
    unmatched.
    
    > >>> hou.patternMatch("/foo/**", "/foo/bar/blah", path_match = True)
    > 1
    
    ...will return 1, because the multi-level wildcard will matches against
    any number of path components.
    
    
    """
    pass
    

class perfMonObjectView(object):
    """
    hou.perfMonObjectView
    
    Enumeration of the different structures that are used to view objects in
    the Performance Monitor panetab.
    
    VALUES
    
    
    List
    Tree
    EventLog
    
    
    """

def perfMonObjectView_swigregister():
    """None"""
    pass
    

class perfMonTimeFormat(object):
    """
    hou.perfMonTimeFormat
    
    Enumeration of the different formats used when viewing times in the
    Performance Monitor panetab.
    
    VALUES
    
    
    Absolute
    Percent
    
    
    """

def perfMonTimeFormat_swigregister():
    """None"""
    pass
    

def perfMon_swigregister():
    """None"""
    pass
    

def phm():
    """
    hou.phm
    
    A shortcut for hou.pwd().hdaModule().
    
    USAGE
    phm() -> hou.HDAModule
    
    This shortcut lets you write hou.phm() instead of hou.pwd().hdaModule().
    You are most likely to use this shortcut from event handlers, button
    callbacks, and menu generation scripts in digital assets.
    
    See hou.pwd and hou.Node.hdaModule for more information.
    
    
    """
    pass
    

class pickFacing(object):
    """
    hou.pickFacing
    
    Enumeration for describing the facing direction of pickable components.
    
    VALUES
    
    
    Front
    Back
    FrontAndBack
    
    
    """

def pickFacing_swigregister():
    """None"""
    pass
    

class pickModifier(object):
    """
    hou.pickModifier
    
    Enumeration of methods for modifying selections with new components.
    
    VALUES
    
    
    Add
    Toggle
    Remove
    Replace
    Intersect
    
    
    """

def pickModifier_swigregister():
    """None"""
    pass
    

class pickStyle(object):
    """
    hou.pickStyle
    
    Enumeration of pick styles.
    
    VALUES
    
    
    Box
    Lasso
    Brush
    Laser
    
    
    """

def pickStyle_swigregister():
    """None"""
    pass
    

class playMode(object):
    """
    hou.playMode
    
    Enumeration of play modes for the main playbar in Houdini.
    
    VALUES
    
    
    Loop
    Play through the frame range and when reaching the end of the
    range loop back to the beginning and continue the playback.
    
    Once
    Play through the frame range and when reaching the end of the
    range stop the playback.
    
    Zigzag
    Play through the frame range and when reaching the end of the
    range reverse the playback. When the reverse playback reaches
    the beginning of the range, then continue playback in the
    forward direction, etc.
    
    
    """

def playMode_swigregister():
    """None"""
    pass
    

class playbarEvent(object):
    """
    hou.playbarEvent
    
    Enumeration of the playbar events that can be handled by callback
    functions.
    
    See hou.playbar.addEventCallback.
    
    VALUES
    
    
    Started
    This event is triggered when the playbar has started playback
    either in the forward or reverse direction.
    
    Stopped
    This event is triggered when running playback has stopped.
    
    FrameChanged
    This event is triggered when the playbar has changed to another
    frame and after the scene has been cooked for the new frame.
    
    
    """

def playbarEvent_swigregister():
    """None"""
    pass
    

def playbar_swigregister():
    """None"""
    pass
    

class positionType(object):
    """
    hou.positionType
    
    Enumeration of spaces.
    
    VALUES
    
    
    WorldSpace
    ViewportXY
    ViewportUV
    
    
    """

def positionType_swigregister():
    """None"""
    pass
    

def preferredNodeType(name, parent_node=None):
    """
    hou.preferredNodeType
    
    Given a node type name that includes the category and optionally a
    parent node, return the corresponding NodeType object after evaluating
    aliases. Return None if there is no such type with that name.
    
    USAGE
    preferredNodeType(name, parent_node=None) -> NodeType or None
    
    
    name
    The internal name of a node type including the category. To get the
    internal name of any node type in Houdini, right-click a node of
    that type and choose Type properties. The internal name is listed at
    the top of the type properties window beside *Operator type*. For
    example, the internal name of the Geometry object is geo.
    
    parent_node
    Optional. The node that will be the parent for this node type.
    
    EXAMPLES
    
    > >>> hou.preferredNodeType("Shop/pyro")
    > <hou.ShopNodeType for Shop pyro::3.0>
    >
    > >>> hou.preferredNodeType("Shop/pyro", hou.node("/shop"))
    > <hou.ShopNodeType for Shop pyro::3.0>
    
    RELATED
    
    * hou.NodeType
    
    * hou.nodeType
    
    * hou.nodeTypeCategories
    
    
    """
    pass
    

class primType(object):
    """
    hou.primType
    
    Enumeration of primitive types.
    
    VALUES
    
    
    Agent
    AlembicRef
    BezierCurve
    BezierSurface
    Circle
    Custom
    Catch-all for all HDK-defined primitives types.
    
    Mesh
    Metaball
    NURBSCurve
    NURBSSurface
    PackedFragment
    PackedGeometry
    PackedPrim
    ParticleSystem
    PastedSurface
    Polygon
    PolySoup
    Sphere
    Tetrahedron
    TriangleBezier
    TriangleFan
    TriangleStrip
    Tube
    Unknown
    VDB
    Volume
    
    
    """

def primType_swigregister():
    """None"""
    pass
    

class promptMessageType(object):
    """
    hou.promptMessageType
    
    Viewport Prompt Message Type
    
    Defines the type of messages that can be used with
    hou.SceneViewer.setPromptMessage.
    
    VALUES
    
    
    hou.promptMessageType.Error
    Specifies an error message displayed in bold red.
    
    hou.promptMessageType.Message
    Specifies a regular message displayed in black.
    
    hou.promptMessageType.Prompt
    Specifies a prompt message displayed in bold blue.
    
    hou.promptMessageType.Warning
    Specifies a warning message displayed in bold yellow.
    
    
    """

def promptMessageType_swigregister():
    """None"""
    pass
    

def properties_swigregister():
    """None"""
    pass
    

def putenv(name, value):
    """
    hou.putenv
    
    Set the value of the specified Houdini environment variable.
    
    USAGE
    putenv(name, value)
    
    Set the value of the specified Houdini environment variable.
    
    RELATED
    
    * hou.getenv
    
    * hou.unsetenv
    
    
    """
    pass
    

def pwd():
    """
    hou.pwd
    
    If called from an evaluating parm, return the node containing the parm.
    Otherwise, return Houdini's global current node. You can change this
    current node with hou.cd
    
    USAGE
    pwd() -> hou.Node
    
    This function is a shortcut for writing hou.node(".").
    
    Note that Python and hscript both share the same global current node.
    So, if you change that node in hscript, the return value of pwd() will
    reflect that change, and vice versa.
    
    Note that if this function is called from an expression inside a node's
    parameter, Houdini will return the node containing the expression, not
    Houdini's current node. This behavior permits relative parameter and
    node references from both Hscript and Python parameter expressions,
    since functions like hou.ch, ch(), hou.evalParm, hou.parm_, and
    hou.node_ are relative to the result of hou.pwd().
    
    This function will raise hou.NotAvailable if you call it from MPlay.
    
    RELATED
    
    * hou.cd
    
    * hou.parent
    
    REPLACES
    
    * oppwf
    
    * oppwf()
    
    * oppwd()
    
    * opfullpath()
    
    
    """
    pass
    

def pypanel_swigregister():
    """None"""
    pass
    

def qlinear():
    """
    hou.qlinear
    
    Linearly interpolates between keyframes using quaternions.
    
    USAGE
    qlinear() -> float
    
    The neighboring parameters must also be animated; for example, if "rx"
    uses qlinear(), "ry" and "rz" should also use qlinear().
    
    Because the interpolation is done in quaternion spaces, the orientations
    will blend smoothly with no gimbal lock or unexpected spins. The Euler
    rotation values may appear to jump suddenly, but that's simply because
    different rotation values can represent the same orientation.
    
    Note that the graph editor will display a qlinear() segment as a dashed
    straight line. This line does not represent the actual intermediate
    channel values, but it does give an accurate visual feel for the
    behavior of the interpolation.
    
    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.
    
    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.
    
    RELATED
    
    * hou.bezier
    
    * hou.constant
    
    * hou.cubic
    
    * hou.cycle
    
    * hou.cyclet
    
    * hou.ease
    
    * hou.easein
    
    * hou.easeinp
    
    * hou.easeout
    
    * hou.easeoutp
    
    * hou.easep
    
    * hou.linear
    
    * hou.match
    
    * hou.matchin
    
    * hou.matchout
    
    * hou.quintic
    
    * hou.repeat
    
    * hou.repeatt
    
    * hou.spline
    
    * hou.vmatch
    
    * hou.vmatchin
    
    * hou.vmatchout
    
    REPLACES
    
    * qlinear()
    
    
    """
    pass
    

def qt_swigregister():
    """None"""
    pass
    

def quintic():
    """
    hou.quintic
    
    Evaluate an interpolation function for an animated parameter that gives
    a smooth curve between the left keyframe's outgoing value and the right
    keyframe's incoming value, using the left's outgoing slope and
    acceleration and the right's incoming slope and acceleration.
    
    USAGE
    quintic() -> float
    
    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.
    
    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.
    
    RELATED
    
    * hou.bezier
    
    * hou.constant
    
    * hou.cubic
    
    * hou.cycle
    
    * hou.cyclet
    
    * hou.ease
    
    * hou.easein
    
    * hou.easeinp
    
    * hou.easeout
    
    * hou.easeoutp
    
    * hou.easep
    
    * hou.linear
    
    * hou.match
    
    * hou.matchin
    
    * hou.matchout
    
    * hou.qlinear
    
    * hou.repeat
    
    * hou.repeatt
    
    * hou.spline
    
    * hou.vmatch
    
    * hou.vmatchin
    
    * hou.vmatchout
    
    REPLACES
    
    * quintic()
    
    
    """
    pass
    

class radialItemLocation(object):
    """
    hou.radialItemLocation
    
    Enumeration of locations for radial menu items in Houdini.
    
    VALUES
    
    
    Top
    Specifies top location of a radial menu item.
    
    TopLeft
    Specifies top left location of a radial menu item.
    
    Left
    Specifies left location of a radial menu item.
    
    BottomLeft
    Specifies bottom left location of a radial menu item.
    
    Bottom
    Specifies bottom location of a radial menu item.
    
    BottomRight
    Specifies bottom right location of a radial menu item.
    
    Right
    Specifies right location of a radial menu item.
    
    TopRight
    Specifies top right location of a radial menu item.
    
    
    """

def radialItemLocation_swigregister():
    """None"""
    pass
    

class radialItemType(object):
    """
    hou.radialItemType
    
    Enumeration of types for radial menu items in Houdini.
    
    VALUES
    
    
    Script
    Specifies a script radial menu item.
    
    Submenu
    Specifies a submenu radial menu item.
    
    Menu
    Specifies a radial menu.
    
    
    """

def radialItemType_swigregister():
    """None"""
    pass
    

class rampBasis(object):
    """
    hou.rampBasis
    
    Enumeration of ramp interpolation types.
    
    These interpolation types specify how Houdini interpolates between
    keyframed values in a hou.Ramp. See hou.Ramp.basis and hou.Ramp.__init__
    for more information about how to get and set ramp interpolation types.
    
    VALUES
    
    
    Linear
    Does a linear (straight line) interpolation between keys.
    
    Constant
    Holds the value constant until the next key.
    
    CatmullRom
    Interpolates smoothly between the keys. See Catmull-Rom_spline.
    
    MonotoneCubic
    Another smooth interpolation that ensures that there is no
    overshoot. For example, if a key's value is smaller than the
    values in the adjacent keys, this type ensures that the
    interpolated value is never less than the key's value.
    
    Bezier
    Cubic Bezier curve that interpolates every third control point
    and uses the other points to shape the curve. See Bezier curve.
    
    BSpline
    Cubic curve where the control points influence the shape of the
    curve locally (that is, they influence only a section of the
    curve). See B-Spline.
    
    Hermite
    Cubic Hermite curve that interpolates the odd control points,
    while even control points control the tangent at the previous
    interpolation point. See Hermite spline.
    
    
    """

def rampBasis_swigregister():
    """None"""
    pass
    

class rampParmType(object):
    """
    hou.rampParmType
    
    Enumeration of ramp types.
    
    VALUES
    
    
    Color
    Float
    
    :
    
    * hou.RampParmTemplate
    
    
    """

def rampParmType_swigregister():
    """None"""
    pass
    

def readFile(file_path):
    """
    hou.readFile
    
    Read a file, returning the contents in a string. Supports regular files,
    opdef: and oplib: paths, and http URLs.
    
    USAGE
    readFile(file_path) -> string
    
    Opdef paths can be specified with the string opdef:/node?section (e.g.
    opdef:/Object/subnet1?my_section). Oplib paths can be specified with
    oplib:/operator?operator (e.g. oplib:/Cop2/grain?Cop2/grain).
    
    If the file does not exist or an error occurs while reading, this
    function raises hou.OperationFailed.
    
    
    """
    pass
    

def releaseLicense():
    """
    hou.releaseLicense
    
    Release the currently held Houdini license.
    
    USAGE
    releaseLicense()
    
    When you import the hou module into a Python shell, it will acquire a
    Houdini license. This function exists so you can release that license
    when you're done using the hou module. This way, you can have a long
    running Python script that periodically uses Houdini without having to
    hold a Houdini license for the entire duration of the script.
    
    After you release the license, it will automatically be reacquired when
    you access functions and objects from the hou module.
    
    
    """
    pass
    

class renderMethod(object):
    """
    hou.renderMethod
    
    Enumeration of dependency rendering methods.
    
    VALUES
    
    
    RopByRop
    FrameByFrame
    
    
    """

def renderMethod_swigregister():
    """None"""
    pass
    

def repeat(start_frame, end_frame):
    """
    hou.repeat
    
    Repeats the motion between two times.
    
    USAGE
    repeat(start_frame, end_frame) -> float
    
    The repeated values are repeated exactly. If you want to line up the
    values with the value of the previous keyframe, use hou.cycle() instead.
    
    This function is the same as hou.repeatt() except hou.repeatt() accepts
    times instead of frames.
    
    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.
    
    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.
    
    RELATED
    
    * hou.bezier
    
    * hou.constant
    
    * hou.cubic
    
    * hou.cycle
    
    * hou.cyclet
    
    * hou.ease
    
    * hou.easein
    
    * hou.easeinp
    
    * hou.easeout
    
    * hou.easeoutp
    
    * hou.easep
    
    * hou.linear
    
    * hou.match
    
    * hou.matchin
    
    * hou.matchout
    
    * hou.qlinear
    
    * hou.quintic
    
    * hou.repeatt
    
    * hou.spline
    
    * hou.vmatch
    
    * hou.vmatchin
    
    * hou.vmatchout
    
    REPLACES
    
    * repeat()
    
    
    """
    pass
    

def repeatt(start_time, end_time):
    """
    hou.repeatt
    
    Repeats the motion between two times.
    
    USAGE
    repeatt(start_time, end_time) -> float
    
    The repeated values are repeated exactly. If you want to line up the
    values with the value of the previous keyframe, use hou.cyclet()
    instead.
    
    This function is the same as hou.repeat() except hou.repeat() it accepts
    frames instead of times.
    
    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.
    
    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.
    
    RELATED
    
    * hou.bezier
    
    * hou.constant
    
    * hou.cubic
    
    * hou.cycle
    
    * hou.cycleoffset
    
    * hou.cyclet
    
    * hou.ease
    
    * hou.easein
    
    * hou.easeinp
    
    * hou.easeout
    
    * hou.easeoutp
    
    * hou.easep
    
    * hou.linear
    
    * hou.match
    
    * hou.matchin
    
    * hou.matchout
    
    * hou.qlinear
    
    * hou.quintic
    
    * hou.spline
    
    * hou.vmatch
    
    * hou.vmatchin
    
    * hou.vmatchout
    
    REPLACES
    
    * repeatt()
    
    
    """
    pass
    

def root(i.e., /):
    """
    hou.root
    
    Return the root node (i.e. /).
    
    USAGE
    root() -> hou.Node
    
    This function is a shortcut for writing hou.node("/").
    
    This function will raise hou.NotAvailable if you call it from MPlay.
    
    RELATED
    
    * hou.node_
    
    
    """
    pass
    

def rootNodeTypeCategory(/):
    """
    hou.rootNodeTypeCategory
    
    Return the NodeTypeCategory instance for Houdini root (/) node. There is
    only one instance of the root node, and it has its own node type
    category.
    
    USAGE
    rootNodeTypeCategory() -> NodeTypeCategory
    
    
    """
    pass
    

def ropNodeTypeCategory(rop):
    """
    hou.ropNodeTypeCategory
    
    Return the NodeTypeCategory instance for Houdini output (rop) nodes.
    
    USAGE
    ropNodeTypeCategory() -> NodeTypeCategory
    
    
    """
    pass
    

def runCallbackAndCatchCrashes():
    """None"""
    pass
    

def runVex(vex_file, inputs, precision="32"):
    """
    hou.runVex
    
    Invokes the main function in a compiled VEX file, returning the exported
    values.
    
    USAGE
    runVex(vex_file, inputs, precision="32") -> dict of str to values
    
    ARGUMENTS
    
    
    vex_file
    A string containing the path to a _compiled_ VEX object file
    (.vex) on disk. This function does not accept VEX source code
    (.vfl), you must compile the source code first.
    
    Currently this function only works with functions in the cvex
    context.
    
    runVex currently raises an exception if the file path does not
    end with .vex.
    
    
    NOTE
    runVex _always_ calls the "main function" in the compiled
    file (the function whose return type is the context type,
    cvex). It is not currently possible to call another function
    in the compiled file by name.
    
    inputs
    A dictionary mapping VEX input names to values.
    
    * If a value is a single number, string, hou.Vector3, hou.Vector4,
    hou.Matrix3, or hou.Matrix4, it is treated as a "static" value.
    
    * If a value is a sequence of values, it is treated as _varying
    data_ the function will "iterate over" (possibly in parallel)
    automatically. This is the same as when, for example, a VEX
    snippet runs over all the points in a geometry. It is more
    efficient to call the function once with varying data than to
    call it separately for each of a list of different values.
    
    * If you supply multiple "varying" inputs, *they must all be the
    same length* and all values must be the same type. Houdini
    iterates over the corresponding values at each index of the
    varying sequences.
    
    For example, you might have two arguments corresponding to a
    point's color (Cd) and position (P) attributes:
    
    > runVex("test.vex", {
    >     "Cd": [hou.Vector3(1.0, 0, 0), hou.Vector3(0, 1.0, 0), hou.Vector3(0, 0, 1.0)],
    >     "P": [hou.Vector3(1.0, 1.0, 1.0), hou.Vector3(2.0, 2.0, 2.0), hou.Vector3(3.0, 3.0, 3.0)]
    > })
    
    Houdini would "zip" the two lists together and iterate using
    the following values:
    
    1
    Vector3(1.0, 0, 0)
    
    Vector3(1.0, 1.0, 1.0)
    
    2
    Vector3(0, 1.0, 0)
    
    Vector3(2.0, 2.0, 2.0)
    
    3
    Vector3(0, 0, 1.0)
    
    Vector3(3.0, 3.0, 3.0)
    
    
    NOTE
    Because this function interprets a sequence as varying data,
    it is *not currently possible* for this function to call VEX
    with array arguments.
    
    precision
    Either "32" or "64". If you specify "64" Houdini will run the
    VEX snippet in 64-bit mode.
    
    RETURNS
    
    runVex() returns a dictionary mapping VEX output names to values.
    
    The "main" VEX function does not directly return values, it can only
    write to arguments marked export. This dictionary contains the
    output value of the exported arguments.
    
    If the input to the argument was static, the output will be a single
    value. If the input to the argument was "varying", the output will
    be a tuple of values. If multiple arguments were varying, the output
    tuples will all be the same length.
    
    EXAMPLE
    
    For example, if you have the following code.vfl file and compile it
    to code.vex using vcc:
    
    > cvex add(float x=0; float y=0; export float out=0)
    > {
    >     out = x + y;
    > }
    
    You can then invoke it from Python using the following:
    
    > >>> hou.runVex("code.vex", {"x":(1.0, 2.0, 3.0), "y":(7.1, 8.1, 9.1)})
    > {"out": (8.1, 10.1, 12.1)}
    > >>> hou.runVex("code.vex", {"x":(1.0, 2.0, 3.0), "y":0.5})
    > {"out": (1.5, 2.5, 3.5)}
    > >>> hou.runVex("code.vex", {"x":1.0, "y":0.5})
    > {"out": 1.5}
    > >>> hou.runVex("code.vex", {"x":1.0, "y":0.5}, precision="64")
    > {"out": 1.5}
    
    USING A VOP NETWORK
    
    The following code shows how you can write the VEX code created by a
    VOP network node (such as a CVEX VOP) to a file, for use with
    runVex:
    
    > import os
    > import tempfile
    >
    > def runVexFromNode(vop_node, input_dict):
    >     handle, path = tempfile.mkstemp(prefix=vop_node.name(), suffix=".vex")
    >     vop_node.saveCompiledCookCodeToFile(path)
    >     os.close(handle)
    >     output_dict = hou.runVex(path, input_dict)
    >     os.remove(path)
    >     return output_dict
    
    
    """
    pass
    

def saveCPIODataToString(name, value):
    """
    hou.saveCPIODataToString
    
    Given a sequence of (name, value) string tuples, encode that data into a
    string in CPIO format.
    
    USAGE
    saveCPIODataToString(data_tuples) -> str
    
    The inverse of this function is hou.loadCPIODataFromString. See it for
    more information about CPIO data format.
    
    RELATED
    
    * hou.loadCPIODataFromString
    
    
    """
    pass
    

def saveImageDataToFile(color_and_alpha_data, width, height, file_name):
    """
    hou.saveImageDataToFile
    
    Create an image file from color and alpha pixel data.
    
    USAGE
    saveImageDataToFile(color_and_alpha_data, width, height, file_name)
    
    
    color_and_alpha_data
    Either a sequence of floats or a string containing the image data.
    The data must be in interleaved format, meaning that the first 4
    values are the red, green, blue, and alpha (RGBA) values for the
    first pixel, the next 4 are for the second pixel, and so on. The
    first row of pixels in the data corresponds to the top scanline in
    the image.
    
    The length of this sequence must be width * height * 4.
    
    If you are writing a .pic file, the file will store 32-bit float
    data if you pass in a sequence of floats and 8-bit unsigned data if
    you pass in a string.
    
    width, height
    The width and height of the image to be written.
    
    file_name
    The name of the output image file to create. Houdini will
    automatically determine which type of file to create based on this
    file's extension.
    
    This function provides two features not provided by other imaging
    libraries:
    
    * It lets you create files in Houdini's .pic format.
    
    * It lets you save images with 32-bit float data.
    
    Raises hou.OperationFailed if the data is not the correct size, the
    output file could not be created, or the output file format is not
    supported by Houdini.
    
    The following example uses the Python imaging library (PIL) to read in a
    file and calls this function to write it out. Using the convertImage
    function below, you can convert any image that can be read by PIL into
    Houdini's .pic format.
    
    > import Image
    >
    > def convertImage(input_image, output_image):
    >     im = Image.open(input_image)
    >     im.mode != "RGBA":
    >         raise ValueError("The image must contain alpha information")
    >     hou.saveImageDataToFile(im.tostring(), im.size[0], im.size[1], output_image)
    >
    > convertImage("image.png", "image.pic")
    
    See also Writing a COP in Python.
    
    
    """
    pass
    

def saveIndexDataToFile(file_path, index_data):
    """
    hou.saveIndexDataToFile
    
    Given a dictionary mapping strings to strings, encode that data in index
    data format and save it into a file.
    
    USAGE
    saveIndexDataToFile(file_path, index_data)
    
    This function could be implemented as follows:
    
    > def saveIndexDataToFile(file_path, index_data):
    >     with open(file_path, "wb") as open_file:
    >         open_file.write(hou.saveIndexDataToString(index_data))
    
    See hou.loadIndexDataFromString for more details.
    
    RELATED
    
    * hou.loadIndexDataFromFile
    
    * hou.loadIndexDataFromString
    
    * hou.saveIndexDataToString
    
    
    """
    pass
    

def saveIndexDataToString(data_dict):
    """
    hou.saveIndexDataToString
    
    Given a dictionary mapping strings to strings, encode that data into a
    string in index data format.
    
    USAGE
    saveIndexDataToString(data_dict) -> str
    
    The inverse of this function is hou.loadIndexDataFromString. See it for
    more information about index data format.
    
    RELATED
    
    * hou.loadIndexDataFromString
    
    * hou.loadIndexDataFromFile
    
    * hou.saveIndexDataToFile
    
    
    """
    pass
    

class saveMode(object):
    """
    hou.saveMode
    
    Enumeration of hip file save modes.
    
    VALUES
    
    
    Text
    Save in an ASCII format that is friendly to version control and
    can be viewed and edited as plain text. This format is
    compatible with Houdini 16 and above only and is only available
    with a full commercial license.
    
    Binary
    Traditional binary hip file format. This is both smaller and
    more performant than the text format.
    
    
    """

def saveMode_swigregister():
    """None"""
    pass
    

def scaleFromMKS():
    """None"""
    pass
    

def scaleToMKS():
    """None"""
    pass
    

class scenePrimMask(object):
    """
    hou.scenePrimMask
    
    Scene Graph Selection Mask
    
    Defines the primitive types that can be selected by
    SceneViewer.selectSceneGraph() if the caller wishes to override the
    current scene viewer selection mask.
    
    VALUES
    
    
    hou.scenePrimMask.All
    All primitive types can be selected.
    
    hou.scenePrimMask.Camera
    Only camera primitive types can be selected.
    
    hou.scenePrimMask.Geometry
    Only geometry primitive types can be selected.
    
    hou.scenePrimMask.Light
    Only light primitive types can be selected.
    
    hou.scenePrimMask.LightAndCamera
    Only light and camera primitive types can be selected.
    
    hou.scenePrimMask.ViewerSetting
    Use the viewer setting for the primitive selection mask
    (default).
    
    
    """

def scenePrimMask_swigregister():
    """None"""
    pass
    

class scriptLanguage(object):
    """
    hou.scriptLanguage
    
    Enumeration of available script languages.
    
    VALUES
    
    
    Python
    Hscript
    
    
    """

def scriptLanguage_swigregister():
    """None"""
    pass
    

def selectedConnections():
    """
    hou.selectedConnections
    
    Return a list of all selected node connections.
    
    
    selectedConnections() -> tuple of hou.NodeConnection
    
    The following example will print the name of the input node for all
    selected connections:
    
    > for conn in hou.selectedConnections():
    >     print conn.inputNode().name()
    
    """
    pass
    

def selectedItems(include_hidden=False):
    """
    hou.selectedItems
    
    Return a list of all selected nodes, network boxes, sticky notes, subnet
    indirect inputs, and network dots.
    
    
    selectedItems(include_hidden=False) -> tuple of hou.NetworkMovableItem
    
    If include_hidden is False, hidden nodes will not in the result, even if
    they are selected. See hou.Node.isHidden for more information about
    hidden nodes. Other item types do not support hiding and so are
    unaffected by the value of this parameter.
    
    The following example will print the positions of all selected items:
    
    > for n in hou.selectedItems():
    >     print n.position()
    
    """
    pass
    

def selectedNodeBundles():
    """
    hou.selectedNodeBundles
    
    Return a tuple containing all the node bundles that are selected in the
    bundle list pane.
    
    USAGE
    selectedNodeBundles() -> tuple of hou.NodeBundle
    
    This function is a shortcut for [bundle for bundle in hou.nodeBundles()
    if bundle.isSelected].
    
    See hou.NodeBundle for more information about bundles.
    
    REPLACES
    
    * opbls
    
    
    """
    pass
    

def selectedNodes(include_hidden=False):
    """
    hou.selectedNodes
    
    Return a list of all selected nodes.
    
    USAGE
    selectedNodes(include_hidden=False) -> tuple of hou.Node
    
    Returns a sequence of hou.Node objects representing the nodes that are
    currently selected.
    
    > print("The following nodes are currently selected:")
    > for node in hou.selectedNodes():
    >     print(node.path())
    
    The last selected item has special meaning in Houdini: it controls what
    network unpinned panes focus on.
    
    > selected = hou.selectedNodes()
    > # In Python, a negative index counts from the end
    > print("Following:", selected[-1])
    
    include_hidden
    Normally, hidden nodes will not be included in the results, even if
    they are selected. Use include_hidden=True to get the selected
    hidden nodes as well. See hou.Node.isHidden for more information
    about hidden nodes.
    
    REPLACES
    
    * opselectrecurse()
    
    
    """
    pass
    

class selectionMode(object):
    """
    hou.selectionMode
    
    Enumeration of selection modes.
    
    See hou.SceneViewer.selectionMode.
    
    VALUES
    
    
    Object
    Geometry
    Dynamics
    
    
    """

def selectionMode_swigregister():
    """None"""
    pass
    

def sessionModuleSource():
    """
    hou.sessionModuleSource
    
    Returns the contents of the hou.session module.
    
    USAGE
    sessionModuleSource() -> string
    
    RELATED
    
    * hou.appendSessionModuleSource
    
    * hou.session
    
    * hou.setSessionModuleSource
    
    
    """
    pass
    

def setChopExportConflictResolutionPattern(string, pattern):
    """
    hou.setChopExportConflictResolutionPattern
    
    Sets a CHOP node path pattern to take precedence when exporting to the
    same channel.
    
    USAGE
    setChopExportConflictResolutionPattern(string pattern) -> None
    
    Sets a pattern for matching CHOP node paths that should take precedence
    when there are other CHOPs that override the same channels thus leading
    to conflicts.
    
    
    """
    pass
    

def setCurrentDopNet(dopnet):
    """
    hou.setCurrentDopNet
    
    USAGE
    setCurrentDopNet(dopnet)
    
    The "current" DOP network is the network the shelf tools put new nodes
    into. The user can change this using the simulation menu in the bottom
    right corner of the main window. This method lets you programmatically
    set the current simulation network.
    
    Call hou.currentDopNet to get a hou.Node object representing the current
    DOP Network node.
    
    RELATED
    
    * hou.currentDopNet
    
    
    """
    pass
    

def setDefaultColor(color_item, color):
    """
    hou.setDefaultColor
    
    Return the setDefault color for a particular network element.
    
    USAGE
    setDefaultColor(color_item, color)
    
    Sets the default color that will be used for new network elements such
    as network boxes and sticky notes. Node default colors are controlled
    with methods on the hou.NodeType for each node type.
    
    The color parameter can either be a hou.Color or None, in which case the
    default color is cleared, and the standard default colors are used.
    
    RELATED
    
    * hou.colorItemType
    
    * hou.defaultColor
    
    * hou.NodeType.setDefaultColor
    
    
    """
    pass
    

def setDefaultContextOption(option, value):
    """
    hou.setDefaultContextOption
    
    Sets the default value for a cook context option.
    
    USAGE
    setDefaultContextOption(option, value)
    
    If the named context option doesn't already exist, it is created as part
    of the set of default cook context options that are stored with the hip
    file. Passing a value of None will remove the named context option from
    the set of default options. The value may be either a string or a
    number.
    
    RELATED
    
    * hou.contextOption
    
    * hou.contextOptionNames
    
    * hou.hasContextOption
    
    
    """
    pass
    

def setFps(fps):
    """
    hou.setFps
    
    Set the number of frames per second.
    
    USAGE
    setFps(fps)
    
    RELATED
    
    * hou.fps
    
    REPLACES
    
    * fps
    
    
    """
    pass
    

def setFrame(frame):
    """
    hou.setFrame
    
    Set the playbar's current frame. Note that the frame may be a fractional
    value.
    
    USAGE
    setFrame(frame)
    
    RELATED
    
    * hou.time
    
    * hou.setFrame
    
    REPLACES
    
    * tcur
    
    
    """
    pass
    

def setMaxThreads(max_threads):
    """
    hou.setMaxThreads
    
    Sets the maximum number of threads to use for multi-processing.
    
    USAGE
    setMaxThreads(max_threads)
    
    When Houdini/hython is started, it uses all available processors on the
    machine for multi-threaded processing, unless overridden by the -j
    command line option.
    
    This function allows dynamically adjusting this setting at run-time.
    
    Note that this function may only be called from the main thread. If
    called from an expression that gets evaluated in a multi-threaded
    context, or during other processing, it will throw an exception.
    
    RELATED
    
    * hou.maxThreads
    
    
    """
    pass
    

def setPreference(name, value):
    """
    hou.setPreference
    
    Sets a preference given a name and returns true on success.
    
    USAGE
    setPreference(name, value) -> bool
    
    RELATED
    
    * hou.getPreference
    
    * hou.getPreferenceNames
    
    
    """
    pass
    

def setPwd(node.path():
    """
    hou.setPwd
    
    Make the given node Houdini's current node. This function is equivalent
    to hou.cd(node.path()).
    
    USAGE
    setPwd(node)
    
    This function will raise hou.ObjectWasDeleted if the parameter refers to
    a node that no longer exists in Houdini.
    
    This function will raise hou.NotAvailable if you call it from mplay.
    
    RELATED
    
    * hou.pwd
    
    * hou.cd
    
    * hou.ScriptEvalContext
    
    REPLACES
    
    * opcf
    
    
    """
    pass
    

def setSessionModuleSource(source):
    """
    hou.setSessionModuleSource
    
    Sets the contents of the hou.session module. The new contents is made
    available immediately. You do not have to re-import hou.session.
    
    USAGE
    setSessionModuleSource(source)
    
    This function throws a hou.OperationFailed exception if it fails to
    update the hou.session module. This can happen if the new contents has
    syntax errors.
    
    RELATED
    
    * hou.appendSessionModuleSource
    
    * hou.session
    
    * hou.setSessionModuleSource
    
    
    """
    pass
    

def setSimulationEnabled(enabled):
    """
    hou.setSimulationEnabled
    
    USAGE
    setSimulationEnabled(enabled)
    
    Call hou.setSimulationEnabled(True) to enable simulation updates or
    hou.setSimulationEnabled(False) to disable them. The user can choose to
    disable simulation updates to improve interactivity using the simulation
    menu in the bottom right corner of the main window. This function lets
    you set the state of that menu item programmatically. Use
    hou.simulationEnabled to check whether simulation updates are currently
    enabled.
    
    RELATED
    
    * hou.simulationEnabled
    
    
    """
    pass
    

def setTime(time):
    """
    hou.setTime
    
    Set the playbar's time.
    
    USAGE
    setTime(time)
    
    RELATED
    
    * hou.time
    
    * hou.setFrame
    
    REPLACES
    
    * tcur
    
    
    """
    pass
    

def setUpdateMode(Auto, Update/On, Mouse, Up/Manual):
    """
    hou.setUpdateMode
    
    Return Houdini's cook update mode (Auto Update/On Mouse Up/Manual) that
    is displayed in the status bar.
    
    USAGE
    updateModeSetting() -> hou.updateMode enum value
    
    Set Houdini's cook update mode to a hou.updateMode enumerated value. See
    hou.updateModeSetting for more information.
    
    
    """
    pass
    

class severityType(object):
    """
    hou.severityType
    
    Enumeration of dialog message severities.
    
    VALUES
    
    
    Message
    ImportantMessage
    Warning
    Error
    Fatal
    
    
    """

def severityType_swigregister():
    """None"""
    pass
    

class shaderType(object):
    """
    hou.shaderType
    
    Enumeration of SHOP shader types.
    
    Each SHOP type defines a particular type of shader. For example, it
    might be a surface shader or a displacement shader. This enumeration
    contains all the possible shader types.
    
    Use hou.ShopNodeType.shaderType to determine what type of shader a
    particular SHOP type is.
    
    VALUES
    
    
    Invalid
    Surface
    SurfaceShadow
    Displacement
    Geometry
    Interior
    Light
    LightShadow
    Atmosphere
    Lens
    Output
    Background
    Photon
    Image3D
    BSDF
    CVEX
    Mutable
    Properties
    Material
    VopMaterial
    ShaderClass
    
    
    """

def shaderType_swigregister():
    """None"""
    pass
    

def shelves_swigregister():
    """None"""
    pass
    

def shopNodeTypeCategory(SHOP):
    """
    hou.shopNodeTypeCategory
    
    Return the NodeTypeCategory object corresponding to shader (SHOP) nodes.
    
    USAGE
    shopNodeTypeCategory() -> hou.NodeTypeCategory
    
    Be careful not to confuse this function with the class
    hou.ShopNodeTypeCategory.
    
    
    """
    pass
    

def simulationEnabled():
    """
    hou.simulationEnabled
    
    USAGE
    simulationEnabled() -> bool
    
    Returns True if Houdini is currently set to update simulations. The user
    can choose to disable simulation updates to improve interactivity using
    the simulation menu in the bottom right corner of the main window. Use
    hou.setSimulationEnabled to enable or disable simulation updates
    programmatically.
    
    RELATED
    
    * hou.setSimulationEnabled
    
    
    """
    pass
    

class snappingMode(object):
    """
    hou.snappingMode
    
    Enumeration of snapping modes.
    
    See hou.SceneViewer.snappingMode.
    
    VALUES
    
    
    Off
    Grid
    Prim
    Point
    Multi
    
    
    """

def snappingMode_swigregister():
    """None"""
    pass
    

class snappingPriority(object):
    """
    hou.snappingPriority
    
    Enumeration of snapping priority.
    
    See hou.SceneViewer.snappingPriority.
    
    VALUES
    
    
    GeoEdge
    Edge between two GeoPoints
    
    GeoPoint
    Point on a geometry
    
    Midpoint
    Midpoint of a GeoEdge
    
    GeoPrim
    Primitive on a geometry
    
    
    """

def snappingPriority_swigregister():
    """None"""
    pass
    

def sopNodeTypeCategory(sop):
    """
    hou.sopNodeTypeCategory
    
    Return the NodeTypeCategory instance for Houdini geometry (sop) nodes.
    
    USAGE
    sopNodeTypeCategory() -> NodeTypeCategory
    
    
    """
    pass
    

def sortedNodePaths(path_tuple):
    """
    hou.sortedNodePaths
    
    Given a tuple of path strings, return a tuple of path strings sorted in
    input/outputs order. Invalid node paths won't be part of the sorted
    list.
    
    USAGE
    sortedNodePaths(path_tuple) -> tuple of string
    
    Sorts nodes following the network traversal order. Root nodes appear
    first and leaf nodes come last.
    
    > >>> hou.node('/obj').createNode('simplefemale')
    > <hou.ObjNode of type simplefemale at /obj/simplefemale1>
    > >>> paths = ["/obj/simplefemale1/ctrl_master","/obj/simplefemale1/ctrl_IK_wrist_right","/obj/simplefemale1/ctrl_cog","/obj/simplefemale1/ctrl_neck","/obj/simplefemale1/ctrl_head","/obj/simplefemale1/ctrl_FK_hand_right"]
    > >>> hou.sortedNodePaths(paths)
    > ('/obj/simplefemale1/ctrl_master', '/obj/simplefemale1/ctrl_cog', '/obj/simplefemale1/ctrl_IK_wrist_right', '/obj/simplefemale1/ctrl_neck', '/obj/simplefemale1/ctrl
    > _head', '/obj/simplefemale1/ctrl_FK_hand_right')
    
    RELATED
    
    * hou.node
    
    * hou.nodes
    
    * hou.Node
    
    * hou.sortedNodes
    
    REPLACES
    
    * oplistsort()
    
    
    """
    pass
    

def sortedNodes(node_tuple):
    """
    hou.sortedNodes
    
    Given a tuple of hou.Node, return a tuple of hou.Node sorted in
    input/outputs order.
    
    USAGE
    sortedNodePaths(node_tuple) -> tuple of hou.Node
    
    Sorts nodes following the network traversal order. Root nodes appear
    first and leaf nodes come last.
    
    > >>> hou.node('/obj').createNode('simplefemale')
    > <hou.ObjNode of type simplefemale at /obj/simplefemale1>
    > >>> nodes = hou.nodes( ["/obj/simplefemale1/ctrl_master","/obj/simplefemale1/ctrl_IK_wrist_right","/obj/simplefemale1/ctrl_cog","/obj/simplefemale1/ctrl_neck","/obj/simplefemale1/ctrl_head","/obj/simplefemale1/ctrl_FK_hand_right"] )
    > >>> hou.sortedNodes(nodes)
    > ('/obj/simplefemale1/ctrl_master', '/obj/simplefemale1/ctrl_cog', '/obj/simplefemale1/ctrl_IK_wrist_right', '/obj/simplefemale1/ctrl_neck', '/obj/simplefemale1/ctrl
    > _head', '/obj/simplefemale1/ctrl_FK_hand_right')
    
    RELATED
    
    * hou.node
    
    * hou.nodes
    
    * hou.Node
    
    * hou.sortedNodePaths
    
    REPLACES
    
    * oplistsort()
    
    
    """
    pass
    

def spline():
    """
    hou.spline
    
    Fits a spline through consecutive keyframe values.
    
    USAGE
    spline() -> float
    
    The resulting spline interpolates the channel values at the keyframes,
    and slope values are not used.
    
    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.
    
    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.
    
    RELATED
    
    * hou.bezier
    
    * hou.constant
    
    * hou.cubic
    
    * hou.cycle
    
    * hou.cyclet
    
    * hou.ease
    
    * hou.easein
    
    * hou.easeinp
    
    * hou.easeout
    
    * hou.easeoutp
    
    * hou.easep
    
    * hou.linear
    
    * hou.match
    
    * hou.matchin
    
    * hou.matchout
    
    * hou.qlinear
    
    * hou.quintic
    
    * hou.repeat
    
    * hou.repeatt
    
    * hou.vmatch
    
    * hou.vmatchin
    
    * hou.vmatchout
    
    REPLACES
    
    * spline()
    
    
    """
    pass
    

def startHoudiniEngineDebugger(port):
    """
    hou.startHoudiniEngineDebugger
    
    Starts a Houdini Engine debugging session in Houdini if no session is
    currently active
    
    USAGE
    startHoudiniEngineDebugger(port) startHoudiniEngineDebugger(pipeName)
    
    
    port
    The port number that the debugging server should use
    
    pipeName
    The pipe name that the debugging server should use
    
    EXAMPLES
    
    > >hou.startHoudiniEngineDebugger(9090)
    > >hou.startHoudiniEngineDebugger("hapi_debug_session")
    
    
    """
    pass
    

class stateGenerateMode(object):
    """
    hou.stateGenerateMode
    
    Enumeration of possible node generation modes by states.
    
    See hou.SceneViewer.setCurrentState for more information.
    
    VALUES
    
    
    Insert
    Branch
    
    
    """

def stateGenerateMode_swigregister():
    """None"""
    pass
    

class stateViewerType(object):
    """
    hou.stateViewerType
    
    Enumeration of state viewer types.
    
    VALUES
    
    
    Scene
    Compositor
    
    
    """

def stateViewerType_swigregister():
    """None"""
    pass
    

def stickyNoteBySessionId(session_id):
    """
    hou.stickyNoteBySessionId
    
    Given a sticky note's session id, return a StickyNote object. Return
    None if the id does not correspond to a valid sticky note.
    
    USAGE
    stickyNoteBySessionId(session_id) -> hou.StickyNote or None
    
    See hou.StickyNote.sessionId for more information.
    
    Raises hou.NotAvailable if you call it from MPlay.
    
    RELATED
    
    * hou.item
    
    * hou.StickyNote.sessionId
    
    
    """
    pass
    

class stringParmType(object):
    """
    hou.stringParmType
    
    Enumeration of string parameter types.
    
    A hou.StringParmTemplate is set to one of these types to specify whether
    a string parameter will hold an arbitrary string, a reference to a file,
    a reference to a node, or a reference to multiple nodes.
    
    VALUES
    
    
    Regular
    FileReference
    NodeReference
    NodeReferenceList
    
    
    """

def stringParmType_swigregister():
    """None"""
    pass
    

def styles_swigregister():
    """None"""
    pass
    

def subnetIndirectInputBySessionId(e.g., if, the, subnet, containing, the, input, was, deleted):
    """
    hou.subnetIndirectInputBySessionId
    
    Given a subnet input's session id, return a SubnetIndirectInput object.
    Return None if the id does not correspond to a valid subnet input (e.g.
    if the subnet containing the input was deleted).
    
    USAGE
    subnetIndirectInputBySessionId(session_id) -> hou.SubnetIndirectInput
    or None
    
    See hou.SubnetIndirectInput.sessionId for more information.
    
    Raises hou.NotAvailable if you call it from MPlay.
    
    RELATED
    
    * hou.item
    
    * hou.SubnetIndirectInput.sessionId
    
    
    """
    pass
    

def takes_swigregister():
    """None"""
    pass
    

def time():
    """
    hou.time
    
    Return the playbar's current time, in seconds of playback.
    
    USAGE
    time() -> float
    
    Note that the time at frame 1 is 0s.
    
    RELATED
    
    * hou.setTime
    
    * hou.frame
    
    * hou.fps
    
    REPLACES
    
    * tcur
    
    
    """
    pass
    

def timeToFrame(time):
    """
    hou.timeToFrame
    
    Convert from a given time value to a frame value, rounding the result to
    a integer if it is close to an integer.
    
    USAGE
    timeToFrame(time) -> float
    
    Calling this function is roughly equivalent to evaluating time *
    hou.fps() + 1.0, but the result is rounded to 6 digits of precision.
    
    RELATED
    
    * hou.fps
    
    * hou.frame
    
    * hou.time
    
    REPLACES
    
    * fps
    
    
    """
    pass
    

class topCookState(object):
    """
    hou.topCookState
    
    Enumeration of TOP Node cook states.
    
    VALUES
    
    
    Uncooked
    The node is uncooked. This occurs when it has no work items
    because it has never cooked before, or if it was dirtied.
    
    Cooking
    The node has work items that are currently cooking.
    
    Cooked
    All work items in the node are cooked.
    
    Failed
    One or more work items in the node has failed to cook.
    
    Warning
    One or more work items in the node have been canceled or issued
    a warning during the cook
    
    Waiting
    The node has no cooking work items, but may still generate new
    work from an input node.
    
    Incomplete
    The node has cooked work items, but one or more work items are
    in an uncooked state.
    
    
    """

def topCookState_swigregister():
    """None"""
    pass
    

def topNodeTypeCategory(top):
    """
    hou.topNodeTypeCategory
    
    Return the NodeTypeCategory instance for Houdini task (top) nodes.
    
    USAGE
    topNodeTypeCategory() -> NodeTypeCategory
    
    
    """
    pass
    

class triggerSelectorAction(object):
    """
    hou.triggerSelectorAction
    
    Enumerator representing the type of action a state selector can perform
    if triggered with hou.SceneViewer.triggerStateSelector.
    
    VALUES
    
    
    Start
    Activate a selector.
    
    Stop
    Deactivate a selector.
    
    Toggle
    Start or stop a selector depending of the current selector
    state. If currently stopped, the selector is started otherwise
    it is stopped.
    
    
    """

def triggerSelectorAction_swigregister():
    """None"""
    pass
    

class uiEventReason(object):
    """
    hou.uiEventReason
    
    Values representing reasons Houdini generated a particular UI event.
    
    Calling hou.UIEvent.reason returns one of the following values.
    
    VALUES
    
    
    Picked
    Quick mouse click without dragging.
    
    Start
    Left mouse button pressed (mouse down)
    
    Active
    Mouse dragged with the left mouse button down.
    
    Changed
    Left mouse button released (mouse up).
    
    Located
    Mouse pointer hovered over something in the interface. In a
    viewer state, this is the reason associated with mouse moves.
    
    ItemsChanged
    Event generated as a change of values in hou.UIEvent
    
    New
    Event generated when a UI element was assigned a different
    value.
    
    RangeChanged
    Event generated when a slider or scrollbar has changed.
    
    NoReason
    Event was likely explicitly generated.
    
    RELATED
    
    hou.UIEvent.reason
    
    
    """

def uiEventReason_swigregister():
    """None"""
    pass
    

class uiEventValueType(object):
    """
    hou.uiEventValueType
    
    Enumerator for UI event value types.
    
    Represents the type of value stored in a hou.UIEvent object.
    
    VALUES
    
    
    hou.uiEventValueType.Float
    float value type.
    
    hou.uiEventValueType.FloatArray
    Array of float values.
    
    hou.uiEventValueType.IntArray
    Array of int values.
    
    hou.uiEventValueType.Integer
    int value type.
    
    hou.uiEventValueType.NoType
    invalid value type.
    
    hou.uiEventValueType.String
    string value type.
    
    hou.uiEventValueType.StringArray
    Array of string values.
    
    RELATED
    
    hou.UIEvent.valueType
    
    
    """

def uiEventValueType_swigregister():
    """None"""
    pass
    

def ui_swigregister():
    """None"""
    pass
    

def undos_swigregister():
    """None"""
    pass
    

def unsetenv(name):
    """
    hou.unsetenv
    
    Unset the specified Houdini environment variable.
    
    USAGE
    unsetenv(name)
    
    Unset the specified Houdini environment variable.
    
    RELATED
    
    * hou.getenv
    
    * hou.putenv
    
    
    """
    pass
    

class updateMode(object):
    """
    hou.updateMode
    
    Enumeration of interface update modes.
    
    See hou.updateModeSetting.
    
    VALUES
    
    
    AutoUpdate
    OnMouseUp
    Manual
    
    
    """

def updateModeSetting(Auto, Update/On, Mouse, Up/Manual):
    """
    hou.updateModeSetting
    
    Return Houdini's cook update mode (Auto Update/On Mouse Up/Manual) that
    is displayed in the status bar.
    
    USAGE
    updateModeSetting() -> hou.updateMode enum value
    
    Houdini's update mode determines when it will recook its nodes after you
    make parameter changes. When it is Auto Update, it will recook whenever
    any parameter changes. When it is On Mouse Up, it will not recook while
    you are tuning a parameter with a viewport or ladder handle until you
    release the mouse. When it is Manual, it will only recook when you press
    the update button in the status bar.
    
    Note that this function is named updateModeSetting because
    hou.updateMode refers to the submodule containing enumeration values.
    This function used to be in the hou.ui submodule, but it was moved into
    the main hou module because it also applies to a non-graphical Houdini.
    
    > >>> # Prevent Houdini from cooking any nodes.
    > >>> hou.setUpdateMode(hou.updateMode.Manual)
    > >>> hou.updateModeSetting()
    > hou.updateMode.Manual
    
    RELATED
    
    * hou.setUpdateMode
    
    * hou.ui.triggerUpdate.
    
    
    """
    pass
    

def updateMode_swigregister():
    """None"""
    pass
    

def updateProgressAndCheckForInterrupt(percentage=-1):
    """
    hou.updateProgressAndCheckForInterrupt
    
    Deprecated: Use InterruptableOperation.
    
    Check if the user pressed Escape to interrupt the current operation, and
    optionally update the completion progress.
    
    USAGE
    updateProgressAndCheckForInterrupt(percentage=-1) -> bool
    
    
    WARNING
    This is deprecated. Use hou.InterruptableOperation instead.
    
    Return True if the user pressed Escape and False otherwise.
    
    
    percentage
    An integer value containing the percentage complete to display in
    the taskbar. If the percentage is -1, the taskbar will not display
    the completion percentage.
    
    You would typically call this function from inside a Python SOP, to let
    the user of the SOP press escape to interrupt a long cook.
    
    See Define a new SOP type using Python for an example.
    
    
    """
    pass
    

class valueLadderDataType(object):
    """
    hou.valueLadderDataType
    
    Enumeration of the different data types that may be manipulated by a
    value ladder.
    
    See hou.ui.openValueLadder.
    
    VALUES
    
    
    Float
    The ladder is being used to manipulate a single floating point
    value.
    
    Int
    The ladder is being used to manipulate a single integer value.
    
    FloatArray
    The ladder is being used to manipulate an array of floating
    point values.
    
    IntArray
    The ladder is being used to manipulate an array of integer
    values.
    
    
    """

def valueLadderDataType_swigregister():
    """None"""
    pass
    

class valueLadderType(object):
    """
    hou.valueLadderType
    
    Enumeration of the different value ladder types.
    
    See hou.ui.openValueLadder.
    
    VALUES
    
    
    Generic
    The ladder is being used to manipulate a generic numeric value.
    The step sizes for this ladder type range from 0.0001 to 100.0.
    
    Angle
    The ladder is being used to manipulate a value representing an
    angle. The step sizes for this ladder type range from 1.0 to
    45.0.
    
    
    """

def valueLadderType_swigregister():
    """None"""
    pass
    

class vdbData(object):
    """
    hou.vdbData
    
    Enumeration of voxel data types.
    
    See hou.VDB.
    
    VALUES
    
    
    Boolean
    Float
    Int
    Vector3
    
    
    """

def vdbData_swigregister():
    """None"""
    pass
    

def vexContextForNodeTypeCategory(node_type_category):
    """
    hou.vexContextForNodeTypeCategory
    
    Takes a NodeTypeCategory object and returns a VexContext object
    representing the context of VOP networks the node would contain.
    
    
    NOTE
    This function is for internal use by Houdini and isn't usually
    necessary for scripting Houdini or creating tools.
    
    USAGE
    vexContextForNodeTypeCategory(node_type_category) -> hou.VexContext or
    None
    
    > >>> # Get a reference to a SOP node
    > >>> n = hou.node("/obj/geo1/pointvop1")
    > >>> # Get its type category (SOPs)
    > >>> sops = n.type().category()
    > >>> # If a SOP contains a VOP network, what is its context?
    > >>> hou.vexContextForNodeTypeCategory(sops)
    > <hou.VexContext Sop>
    > >>> hou.vexContextForNodeTypeCategory(sops).name()
    > 'Sop'
    See hou.VexContext.
    
    RELATED
    
    * VEX contexts
    
    * hou.vexContextForShaderType
    
    
    """
    pass
    

def vexContextForShaderType(shader_type):
    """
    hou.vexContextForShaderType
    
    NOTE
    This function is for internal use by Houdini and isn't usually
    necessary for scripting Houdini or creating tools.
    
    USAGE
    vexContextForShaderType(shader_type) -> hou.VexContext or None
    
    RELATED
    
    * VEX contexts
    
    * hou.vexContextForNodeTypeCategory
    
    
    """
    pass
    

def vexContexts():
    """
    hou.vexContexts
    
    USAGE
    vexContexts() -> tuple of VexContexts
    
    
    """
    pass
    

class viewerStateEventMessage(object):
    """
    hou.viewerStateEventMessage
    
    Enumeration of the Viewer state events that can be handled by callback
    functions.
    
    See hou.ui.addViewerStateEventCallback.
    
    VALUES
    
    
    OnCustomEvent
    Event triggered when hou.ui.fireViewerStateCustomEvent is
    called.
    
    OnEnter
    Event triggered after a viewer state begins.
    
    OnExit
    Event triggered after a viewer state ends.
    
    OnGenerate
    Event triggered after a nodeless viewer state begins.
    
    OnInterrupt
    Event triggered after a viewer state has been interrupted.
    
    OnPreEnter
    Event triggered before a viewer state begins.
    
    OnPrintMessage
    Event triggered when hou.ui.printViewerStateMessage is called.
    
    OnReload
    Event triggered after a viewer state has been successsfully
    reloaded.
    
    OnResume
    Event triggered after a viewer state has resumed after an
    interruption.
    
    OnRegister
    Event triggered after a viewer state has been successfully
    registered.
    
    OnUnregister
    Event triggered after a viewer state has been successfully un-
    registered.
    
    OnRuntimeError
    Event triggered when a runtime error occurs during a viewer
    state operation.
    
    NoEventType
    An invalid viewer state event type.
    
    
    """

def viewerStateEventMessage_swigregister():
    """None"""
    pass
    

class viewportAgentBoneDeform(object):
    """
    hou.viewportAgentBoneDeform
    
    Enum for deforming agent quality
    
    Defines the quality vs. performance tradeoff for deforming agent
    geometry.
    
    VALUES
    
    
    hou.viewportAgentBoneDeform.Always
    Only use 1 bone to deform on all agent instances (the one with
    the most influence).
    
    hou.viewportAgentBoneDeform.Disabled
    Use up to 4 bones to deform the highest LOD agent instances, and
    1 bone on all the reduced LOD instances.
    
    hou.viewportAgentBoneDeform.ReducedLOD
    Use up to 4 bones to deform on all agent instances.
    
    
    """

def viewportAgentBoneDeform_swigregister():
    """None"""
    pass
    

class viewportAgentWireframe(object):
    """
    hou.viewportAgentWireframe
    
    Enum for agent wireframe mode display
    
    The look of agents in wireframe mode.
    
    VALUES
    
    
    hou.viewportAgentWireframe.Bone
    Agents are rendered as bone-based skeletons.
    
    hou.viewportAgentWireframe.Line
    Agents are rendered as line-based skeletons.
    
    
    """

def viewportAgentWireframe_swigregister():
    """None"""
    pass
    

class viewportBGImageView(object):
    """
    hou.viewportBGImageView
    
    Background image view target for the viewport display options
    
    Selects a view target when choosing which background image to edit in
    GeometryViewportSettings.
    
    VALUES
    
    
    hou.viewportBGImageView.Perspective
    The 3D view not attached to a camera ("No cam").
    
    hou.viewportBGImageView.Camera
    The 3D view looking through a camera.
    
    hou.viewportBGImageView.Top
    The orthographic top view.
    
    hou.viewportBGImageView.Front
    The orthographic front view.
    
    hou.viewportBGImageView.Right
    The orthographic right view.
    
    hou.viewportBGImageView.Bottom
    The orthographic bottom view.
    
    hou.viewportBGImageView.Back
    The orthographic back view.
    
    hou.viewportBGImageView.Left
    The orthographic left view.
    
    hou.viewportBGImageView.UV
    The UV texture viewport.
    
    
    """

def viewportBGImageView_swigregister():
    """None"""
    pass
    

class viewportClosureSelection(object):
    """
    hou.viewportClosureSelection
    
    Viewport highlight of primitives with selected components
    
    When components of a primitive are selected (points, vertices, edges),
    the primitive can be highlighted as well to indicate which primitives
    will be affected by the current selection.
    
    VALUES
    
    
    hou.viewportClosureSelection.Hide
    Primitives are not highlighted.
    
    hou.viewportClosureSelection.HullPrimitives
    Only primitives whose points and edges reside on separate hull
    geometry will be highlighted when those are selected (NURBS
    surfaces, Bezier surfaces).
    
    hou.viewportClosureSelection.Show
    Highlight all primitives whose points, edges, or vertices belong
    to the current selection.
    
    
    """

def viewportClosureSelection_swigregister():
    """None"""
    pass
    

class viewportColorScheme(object):
    """
    hou.viewportColorScheme
    
    Viewport Color Schemes
    
    List of available color schemes for the viewport.
    
    VALUES
    
    
    hou.viewportColorScheme.Dark
    Solid black backaground.
    
    hou.viewportColorScheme.Grey
    Solid grey background.
    
    hou.viewportColorScheme.Light
    Light blue gradient background.
    
    
    """

def viewportColorScheme_swigregister():
    """None"""
    pass
    

class viewportGeometryInfo(object):
    """
    hou.viewportGeometryInfo
    
    Geometry information display state
    
    The state of the geometry information displayed in the lower right
    corner of the viewport. This information takes additional time to
    generate.
    
    VALUES
    
    
    hou.viewportGeometryInfo.Off
    Do not show geometry information.
    
    hou.viewportGeometryInfo.SelectedOnly
    Only show information when a selection is present.
    
    hou.viewportGeometryInfo.AlwaysOn
    Always show information on the displayed geometry.
    
    
    """

def viewportGeometryInfo_swigregister():
    """None"""
    pass
    

class viewportGridRuler(object):
    """
    hou.viewportGridRuler
    
    Enum for grid numbering on viewport grids.
    
    Specifies where the grid numbering occurs on viewport grids.
    
    VALUES
    
    
    hou.viewportGridRuler.Hide
    No grid numbers are displayed.
    
    hou.viewportGridRuler.MainAxis
    Numbers appear along the max axes at grid line intersections.
    
    hou.viewportGridRuler.GridPoints
    Numbers appear at grid line intersections.
    
    
    """

def viewportGridRuler_swigregister():
    """None"""
    pass
    

class viewportGuide(object):
    """
    hou.viewportGuide
    
    Viewport guides
    
    List of viewport guides that can be queried, enabled or disabled.
    
    VALUES
    
    
    hou.viewportGuide.CameraMask
    The mask which dims out areas outside the camera aspect ratio.
    
    hou.viewportGuide.CurrentGeometry
    Geometry from the current modelling operator (SOP)
    
    hou.viewportGuide.DisplayNodes
    Geometry from the currently displayed modelling operator (SOP)
    
    hou.viewportGuide.FieldGuide
    hou.viewportGuide.FillSelections
    Polygon selections are highlighted with a solid color rather
    than just an outline when in Wire-Over shading modes.
    
    hou.viewportGuide.FloatingGnomon
    Show the orientation axes in the lower left corner of the
    viewport.
    
    hou.viewportGuide.FollowSelection
    Show point or vertex markers when point or selection is active.
    
    hou.viewportGuide.GroupList
    Show the group list in the top right corner of the viewport.
    
    hou.viewportGuide.IKCriticalZone
    Show the critical zone for IK bones.
    
    hou.viewportGuide.NodeGuides
    Show any node guides that are available.
    
    hou.viewportGuide.NodeHandles
    Show any handles that are available.
    
    hou.viewportGuide.ObjectNames
    Show object names for visible objects.
    
    hou.viewportGuide.ObjectPaths
    Show full objects paths for visible objects. Object names must
    be displayed.
    
    hou.viewportGuide.ObjectSelection
    Show object selections.
    
    hou.viewportGuide.OriginGnomon
    Show the axes at the world origin.
    
    hou.viewportGuide.ParticleGnomon
    Show axes per particle.
    
    hou.viewportGuide.SafeArea
    Show the safe area overlay for broadcast.
    
    hou.viewportGuide.SelectableTemplates
    Show geometry from modelling operators with their selectable
    template flags set.
    
    hou.viewportGuide.ShowDrawTime
    Show the time to update and render the viewport.
    
    hou.viewportGuide.TemplateGeometry
    Show geometry from modelling operators with their template flags
    set.
    
    hou.viewportGuide.ViewPivot
    Show the camera pivot where tumbling will rotate about.
    
    hou.viewportGuide.XYPlane
    Show a grid along the XY plane.
    
    hou.viewportGuide.XZPlane
    Show a grid along the XZ plane.
    
    hou.viewportGuide.YZPlane
    Show a grid along the YZ plane.
    
    
    """

class viewportGuideFont(object):
    """
    hou.viewportGuideFont
    
    Viewport font sizes for visualizer text
    
    Font sizes for displaying text-based visualizers.
    
    VALUES
    
    
    hou.viewportGuideFont.Tiny
    Tiny font.
    
    hou.viewportGuideFont.Small
    Small font.
    
    hou.viewportGuideFont.Medium
    The just right font.
    
    hou.viewportGuideFont.Large
    Largest font.
    
    
    """

def viewportGuideFont_swigregister():
    """None"""
    pass
    

def viewportGuide_swigregister():
    """None"""
    pass
    

class viewportHandleHighlight(object):
    """
    hou.viewportHandleHighlight
    
    Handle highlight size
    
    Highlight size when moving the mouse over a handle.
    
    VALUES
    
    
    hou.viewportHandleHighlight.Off
    Don't display any highlights.
    
    hou.viewportHandleHighlight.Small
    Show a half-width highlight.
    
    hou.viewportHandleHighlight.Normal
    Show a full highlight.
    
    
    """

def viewportHandleHighlight_swigregister():
    """None"""
    pass
    

class viewportHomeClipMode(object):
    """
    hou.viewportHomeClipMode
    
    Automatic viewport clip plane adjustment during homing
    
    Homing the viewport can adjust the viewport's near and far clip planes
    to adapt to what is being homed onto, so that geometry is fully visible
    in the viewport.
    
    VALUES
    
    
    hou.viewportHomeClipMode.Neither
    No clip planes are adjusted.
    
    hou.viewportHomeClipMode.NearOnly
    Only the near clip plane is adjusted. Far is left as is.
    
    hou.viewportHomeClipMode.FarOnly
    Only the far clip plane is adjusted. Near is left as is.
    
    hou.viewportHomeClipMode.NearAndFar
    Both clip planes are adjusted.
    
    
    """

def viewportHomeClipMode_swigregister():
    """None"""
    pass
    

class viewportLighting(object):
    """
    hou.viewportLighting
    
    Lighting modes for the viewport
    
    The viewport renderer supports several global lighting modes, from no
    lighting whatsoever to full lighting with shadows.
    
    VALUES
    
    
    hou.viewportLighting.Off
    No lighting, constant shaded.
    
    hou.viewportLighting.Headlight
    Basic lighting from a single directional light defined in the
    display options.
    
    hou.viewportLighting.Normal
    Good quality lighting from up to 10 basic lights (area lights
    modeled as point lights, limited environment lights).
    
    hou.viewportLighting.HighQuality
    High quality lighting from an unlimited number of lights
    including area, geometry, environment and ambient occlusion.
    
    hou.viewportLighting.HighQualityWithShadows
    High quality lighting with shadows.
    
    
    """

def viewportLighting_swigregister():
    """None"""
    pass
    

class viewportMaterialUpdate(object):
    """
    hou.viewportMaterialUpdate
    
    Enum for the update frequency of viewport material assignments
    
    When material assignments are re-evaluated for a displayed object.
    
    VALUES
    
    
    hou.viewportMaterialUpdate.Always
    Update assignments whenever needeed.
    
    hou.viewportMaterialUpdate.Manual
    Only update assignments when Update Materials is pressed.
    
    hou.viewportMaterialUpdate.OffForPlayback
    Update assignments whenever needed, but not during playback.
    
    
    """

def viewportMaterialUpdate_swigregister():
    """None"""
    pass
    

class viewportPackedBoxMode(object):
    """
    hou.viewportPackedBoxMode
    
    Enum for the culled packed geometry display mode.
    
    Defines how culled packed primitives are displayed in the viewport.
    
    VALUES
    
    
    hou.viewportPackedBoxMode.NoDisplay
    Culled packed primitives are not displayed at all.
    
    hou.viewportPackedBoxMode.Wireframe
    A wireframe bounding box replaces the packed primitive.
    
    hou.viewportPackedBoxMode.Shaded
    A shaded bounding box replaces the packed primitive.
    
    hou.viewportPackedBoxMode.CurrentShadingMode
    A bounding box replaces the packed primitive, drawn wireframe in
    wireframe shading modes and shaded otherwise.
    
    
    """

def viewportPackedBoxMode_swigregister():
    """None"""
    pass
    

class viewportParticleDisplay(object):
    """
    hou.viewportParticleDisplay
    
    Viewport display option for particle display visualization.
    
    Specifies the visualization for particles and points in the viewport.
    
    VALUES
    
    
    Points
    Fixed size points in screen space.
    
    Lines
    Points with streaks indicating velocity.
    
    Pixels
    Single pixel particle (fixed size)
    
    Discs
    Circular disc, variable world size.
    
    
    """

def viewportParticleDisplay_swigregister():
    """None"""
    pass
    

class viewportShadowQuality(object):
    """
    hou.viewportShadowQuality
    
    The quality of shadows produced in the viewport
    
    The viewport renderer can do various amounts of shadowmap sampling to
    produce a higher quality result.
    
    VALUES
    
    
    hou.viewportShadowQuality.Point
    Area lights are treated as point lights when generating and
    sampling shadow maps. This is the fastest option.
    
    hou.viewportShadowQuality.PointAA
    Do some antialiasing of shadow edges. Treat area lights as point
    lights when generating and sampling shadow maps.
    
    hou.viewportShadowQuality.Area
    Area lights generate multiple shadow maps which are sampled to
    generate an approximation of a blurred shadow from an area
    source.
    
    hou.viewportShadowQuality.AreaAA
    Area lights generate multiple maps and antialias the shadow
    lookups.
    
    
    """

def viewportShadowQuality_swigregister():
    """None"""
    pass
    

class viewportStandInGeometry(object):
    """
    hou.viewportStandInGeometry
    
    Replacement geometry for instances culled in the viewport.
    
    When using point instancing, instances can be culled because of the
    Point Instancing Percent, or the Instancing Limit display options.
    Culled instances can be replaced by a marker or bounding box, or
    completely hidden.
    
    VALUES
    
    
    DisplayOff
    Don't show anything for culled instances.
    
    LocationMarker
    Show a point marker at the local space origin of the instance.
    
    BoundingBox
    Show the bounding box of the culled instance.
    
    
    """

def viewportStandInGeometry_swigregister():
    """None"""
    pass
    

class viewportStereoMode(object):
    """
    hou.viewportStereoMode
    
    Stereoscopic viewport display modes
    
    The stereoscopic viewport display modes available when viewing through a
    stereo camera rig.
    
    VALUES
    
    
    hou.viewportStereoMode.Anaglyph
    Anaglyph display of left/right as red/cyan.
    
    hou.viewportStereoMode.HorizontalInterlace
    Interlace left and right on alternating scanlines. Only useful
    for 3D monitors which support this.
    
    hou.viewportStereoMode.HorizontalInterlaceReverse
    Interlace left and right on alternating scanlines, swapping
    which scanlines are used for left and right.
    
    hou.viewportStereoMode.QuadBufferGL
    Use OpenGL quad buffer stereo, generally only available on
    professional cards.
    
    
    """

def viewportStereoMode_swigregister():
    """None"""
    pass
    

class viewportTextureDepth(object):
    """
    hou.viewportTextureDepth
    
    Enum for the viewport texture bit depth limit
    
    Specifies the maximum bit depth that can be used for textures in the
    viewport.
    
    VALUES
    
    
    hou.viewportTextureDepth.Compressed8
    Compressed, 8b SDR texture format. Smallest memory use.
    
    hou.viewportTextureDepth.Fixed8
    8b SDR texture format. Good balance between memory and quality.
    
    hou.viewportTextureDepth.FullHDR
    16b HDR texture format. Excellent dynamic range, but more memory
    use and slower texturing performance.
    
    hou.viewportTextureDepth.HDR16
    32b HDR texture format. Extreme dynamic range, but very high
    memory use and slow texturing performance. Use with care.
    
    
    """

def viewportTextureDepth_swigregister():
    """None"""
    pass
    

class viewportTransparency(object):
    """
    hou.viewportTransparency
    
    Transparency rendering quality for the viewport
    
    Quality levels for rendering objects with transparency in the viewport.
    
    VALUES
    
    
    hou.viewportTransparency.Cutout
    Fast test to render the transparent pixel as opaque (>0) or to
    discard it (0). This can be used for texture cards such as
    leaves. This doesn't require an additional pass for
    transparency.
    
    hou.viewportTransparency.Low
    Render transparent pixels in a separate pass. Only the front-
    most transparent pixel is rendered.
    
    hou.viewportTransparency.Medium
    Render transparent pixels in an Order-Independent buffer of 8
    samples, which is then sorted and composited together to do
    multi-layer transparency for up to 8 layers of overlapping
    transparency.
    
    hou.viewportTransparency.High
    Render transparent pixels in an Order-Independent buffer of 16
    samples, which is then sorted and composited together to do
    multi-layer transparency for up to 16 layers of overlapping
    transparency.
    
    
    """

def viewportTransparency_swigregister():
    """None"""
    pass
    

class viewportVisualizerCategory(object):
    """
    hou.viewportVisualizerCategory
    
    Enumeration of the different categories of viewport visualizers.
    
    VALUES
    
    
    Common
    Viewport visualizers in the common category are available across
    all scene files.
    
    Scene
    Viewport visualizers in the scene category are saved to the
    scene file and are only available in the specific scene file in
    which they are created or saved.
    
    Node
    Node visualizers are installed on individual nodes in Houdini
    and have a limited scope.
    
    
    """

def viewportVisualizerCategory_swigregister():
    """None"""
    pass
    

class viewportVisualizerScope(object):
    """
    hou.viewportVisualizerScope
    
    Enumeration of the different scopes of viewport visualizers.
    
    VALUES
    
    
    NodeOnly
    The visualizer affects only the geometry produced by the node on
    which it is installed. This value only applies to visualizers in
    the hou.viewportVisualizerCategory.Node category.
    
    SameNetworkTypeDescendents
    The visualizer affects only the geometries produced by the node
    and its descendent nodes of the same network type. This value
    only applies to visualizers in the
    hou.viewportVisualizerCategory.Node category.
    
    AllDescendents
    The visualizer affects the geometries produced by the node and
    its descendent nodes regardless of the network type. This value
    only applies to visualizers in the
    hou.viewportVisualizerCategory.Node category.
    
    Global
    The visualizer affects any geometry that is displayed in the
    viewport. This value only applies to visualizers in the
    hou.viewportVisualizerCategory.Common and
    hou.viewportVisualizerCategory.Scene categories.
    
    
    """

def viewportVisualizerScope_swigregister():
    """None"""
    pass
    

def viewportVisualizers_swigregister():
    """None"""
    pass
    

class viewportVolumeQuality(object):
    """
    hou.viewportVolumeQuality
    
    Display options for viewport volume rendering quality
    
    Volume display in the viewport can be an expensive drawing operation.
    The volume quality can be adjusted to provide better viewport
    performance or better volume quality.
    
    VALUES
    
    
    VeryLow
    Quick volume preview.
    
    Low
    Minor quality loss for performance.
    
    Normal
    Balanced quality/performance setting.
    
    High
    Jittered, high quality volume with more passes.
    
    
    """

def viewportVolumeQuality_swigregister():
    """None"""
    pass
    

def vmatch():
    """
    hou.vmatch
    
    Matches the incoming and outgoing values and slopes.
    
    USAGE
    vmatch() -> float
    
    Unlike hou.match, this function will use its left keyframe's outgoing
    value and the right keyframe's incoming value, so hou.vmatch() can
    produce curves that are discontinuous with the previous segment.
    
    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.
    
    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.
    
    RELATED
    
    * hou.bezier
    
    * hou.constant
    
    * hou.cubic
    
    * hou.cycle
    
    * hou.cyclet
    
    * hou.ease
    
    * hou.easein
    
    * hou.easeinp
    
    * hou.easeout
    
    * hou.easeoutp
    
    * hou.easep
    
    * hou.linear
    
    * hou.match
    
    * hou.matchin
    
    * hou.matchout
    
    * hou.qlinear
    
    * hou.quintic
    
    * hou.repeat
    
    * hou.repeatt
    
    * hou.spline
    
    * hou.vmatchin
    
    * hou.vmatchout
    
    REPLACES
    
    * vmatch()
    
    
    """
    pass
    

def vmatchin():
    """
    hou.vmatchin
    
    Matches the left keyframe's incoming slope.
    
    USAGE
    vmatchin() -> float
    
    The curve will be a straight line from the left keyframe's outgoing
    value, and will not match the right keyframe's outgoing value. Unlike
    the hou.matchin() function, the left keyframe's outgoing value can
    differ from its incoming value, so so hou.vmatchin() can produce curves
    whose left tangent matches the left keyframe but whose left values do
    not line up.
    
    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.
    
    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.
    
    RELATED
    
    * hou.bezier
    
    * hou.constant
    
    * hou.cubic
    
    * hou.cycle
    
    * hou.cyclet
    
    * hou.ease
    
    * hou.easein
    
    * hou.easeinp
    
    * hou.easeout
    
    * hou.easeoutp
    
    * hou.easep
    
    * hou.linear
    
    * hou.match
    
    * hou.matchin
    
    * hou.matchout
    
    * hou.qlinear
    
    * hou.quintic
    
    * hou.repeat
    
    * hou.repeatt
    
    * hou.spline
    
    * hou.vmatch
    
    * hou.vmatchout
    
    REPLACES
    
    * vmatchin()
    
    
    """
    pass
    

def vmatchout():
    """
    hou.vmatchout
    
    Matches the right keyframe's outgoing slope.
    
    USAGE
    vmatchout() -> float
    
    The curve will be a straight line ending at the right keyframe's
    incoming value, and will not match the left keyframe's incoming value.
    Unlike the hou.matchout() function, the right keyframe's incoming value
    can differ from its outgoing value, so so hou.vmatchout() can produce
    curves whose right tangent matches the right keyframe but whose right
    values do not line up.
    
    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.
    
    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.
    
    RELATED
    
    * hou.bezier
    
    * hou.constant
    
    * hou.cubic
    
    * hou.cycle
    
    * hou.cyclet
    
    * hou.ease
    
    * hou.easein
    
    * hou.easeinp
    
    * hou.easeout
    
    * hou.easeoutp
    
    * hou.easep
    
    * hou.linear
    
    * hou.match
    
    * hou.matchin
    
    * hou.matchout
    
    * hou.qlinear
    
    * hou.quintic
    
    * hou.repeat
    
    * hou.repeatt
    
    * hou.spline
    
    * hou.vmatch
    
    * hou.vmatchin
    
    REPLACES
    
    * vmatchout()
    
    
    """
    pass
    

def vopNetNodeTypeCategory(vopnet):
    """
    hou.vopNetNodeTypeCategory
    
    Return the NodeTypeCategory instance for Houdini vex builder container
    (vopnet) nodes.
    
    USAGE
    vopNetNodeTypeCategory() -> NodeTypeCategory
    
    
    """
    pass
    

def vopNodeTypeCategory(VOP):
    """
    hou.vopNodeTypeCategory
    
    Return the NodeTypeCategory instance for Houdini vex builder (VOP)
    nodes.
    
    USAGE
    vopNodeTypeCategory() -> NodeTypeCategory
    
    
    """
    pass
    

class vopParmGenType(object):
    """
    hou.vopParmGenType
    
    Enumeration of the different node configurations that can be created for
    the inputs of a VOP node.
    
    See hou.VopNode.insertParmGenerator and
    hou.VopNode.insertParmGeneratorsForAllInputs.
    
    VALUES
    
    
    Constant
    Create a Constant VOP and connect it to the VOP node's input.
    
    Parameter
    Create a Parameter VOP and connect it to the VOP node's input.
    The input parameter is automatically promoted to the VOP
    network's parameter interface.
    
    SubnetInput
    Create a Parameter VOP and connect it to the VOP node's input.
    Additionally set the Parameter VOP's Scope parameter to Subnet.
    The input parameter is automatically promoted to the owning
    Subnet VOP's parameter interface.
    
    
    """

def vopParmGenType_swigregister():
    """None"""
    pass
    
